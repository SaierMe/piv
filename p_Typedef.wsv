<火山程序 类型 = "通常" 版本 = 1 />

包 PIV.类型 <注释 = "https://github.com/SaierMe/piv">

# 类型模板

类 PIV结构模板 <公开 注释 = "用作支持纯C的本地结构的基础模板类" 注释 = "注: 在官方的\"本地结构模板\"的基础上扩展" 折叠 @文档 = "category = \"类型模板\""
        @模板基础类 = 真 @别名类型 = 本地结构>
{
    方法 取尺寸 <公开 静态 类型 = 整数 注释 = "返回结构数据的尺寸" 折叠 @嵌入式方法 = "">
    {
        @ (INT)sizeof (@dt<PIV结构模板>)
    }

    方法 取地址 <公开 静态 类型 = 通用指针 注释 = "返回本结构地址对应的通用指针" 折叠 @嵌入式方法 = "">
    参数 本结构 <类型 = PIV结构模板>
    {
        @ (void*)&@<本结构>
    }

    方法 取变整数地址 <公开 静态 类型 = 变整数 注释 = "返回本结构地址指针对应的变整数" 折叠 @嵌入式方法 = "">
    参数 本结构 <类型 = PIV结构模板>
    {
        @ (INT_P)&@<本结构>
    }

    # ---

    方法 清零 <公开 静态 注释 = "将本结构数据的所有成员初始化为零" 折叠 @嵌入式方法 = "">
    参数 本结构 <类型 = PIV结构模板>
    {
        @ memset(&@<本结构>, 0, sizeof(@dt<PIV结构模板>))
    }
}

类 PIV本地类模板 <公开 注释 = "用作支持C++结构体或类的基础模板类" 注释 = "注: 所封装的类型必须有默认构造函数" 注释 = "" 折叠
        @文档 = "category = \"类型模板\"" @模板基础类 = 真 @别名类型 = 本地类>
{
    方法 取地址 <公开 静态 类型 = 通用指针 注释 = "返回本对象的通用指针" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = PIV本地类模板>
    {
        @ (void*)&@<当前对象>
    }

    方法 取变整数地址 <公开 静态 类型 = 变整数 注释 = "返回本对象指针对应的变整数" @嵌入式方法 = "">
    参数 当前对象 <类型 = PIV本地类模板>
    {
        @ (INT_P)&@<当前对象>
    }
}

类 PIV本地值模板 <公开 注释 = "用作支持非数值的基本型,或C++结构体或类的基础模板类." 注释 = "本地值类型默认按值传参,但允许定义常量."
        注释 = "注: 所封装的类型必须支持赋值和不等于比较" 折叠 @文档 = "category = \"类型模板\"" @模板基础类 = 真 @别名类型 = 本地值类型>
{
    方法 取地址 <公开 静态 类型 = 通用指针 注释 = "返回本对象的通用指针" 折叠 @嵌入式方法 = "">
    参数 当前值 <类型 = PIV本地值模板>
    {
        @ (void*)&@<当前值>
    }

    方法 取变整数地址 <公开 静态 类型 = 变整数 注释 = "返回本对象指针对应的变整数" 折叠 @嵌入式方法 = "">
    参数 当前值 <类型 = PIV本地值模板>
    {
        @ (INT_P)&@<当前值>
    }
}

类 PIV数值模板 <公开 注释 = "用作支持扩展C++基本整数值数据类型" 折叠 @文档 = "category = \"类型模板\"" @模板基础类 = 真 @别名类型 = 本地数值基本类型>
{
    方法 到变整数 <公开 静态 类型 = 变整数 注释 = "将本数据类型值转换到有符号变整数后返回" 折叠 @嵌入式方法 = "">
    参数 当前值 <类型 = PIV数值模板>
    {
        @ (INT_P)@<当前值>
    }

    方法 到整数 <公开 静态 类型 = 整数 注释 = "将本数据类型值转换到有符号整数后返回" 折叠 @嵌入式方法 = "">
    参数 当前值 <类型 = PIV数值模板>
    {
        @ (INT)@<当前值>
    }

    方法 来自 <公开 静态 类型 = PIV数值模板 注释 = "将指定整数值转换为本数据类型值后返回" 折叠 @嵌入式方法 = "">
    参数 欲转换整数值 <@匹配类型 = 通用整数型>
    {
        @ (@dt<PIV数值模板>)@<欲转换整数值>
    }

    方法 零值 <公开 静态 类型 = PIV数值模板 注释 = "将零值转换为本数据类型值后返回" 折叠 @嵌入式方法 = "">
    {
        @ 0
    }

    # ---

    方法 置值 <公开 静态 类型 = PIV数值模板 注释 = "将指定整数值转换为本数据类型值后返回" 折叠 @嵌入式方法 = "">
    参数 当前值 <类型 = PIV数值模板 @视窗.后缀文本 = "&">
    参数 欲转换整数值 <@匹配类型 = 通用整数型>
    {
        @ (@<当前值> = (@dt<PIV数值模板>)@<欲转换整数值>)
    }

    方法 到长整数 <公开 静态 类型 = 长整数 注释 = "将本数值转换到有符号长整数后返回" 折叠 @嵌入式方法 = "">
    参数 当前值 <类型 = PIV数值模板>
    {
        @ (INT64)@<当前值>
    }

    方法 到字符 <公开 静态 类型 = 字符 注释 = "将本数值转换到宽字符后返回" 折叠 @嵌入式方法 = "">
    参数 当前值 <类型 = PIV数值模板>
    {
        @ (WCHAR)@<当前值>
    }

    方法 到短整数 <公开 静态 类型 = 短整数 注释 = "将本数值转换到有符号短整数后返回" 折叠 @嵌入式方法 = "">
    参数 当前值 <类型 = PIV数值模板>
    {
        @ (SHORT)@<当前值>
    }

    方法 到字节 <公开 静态 类型 = 字节 注释 = "将本数值转换到有符号字节后返回" 折叠 @嵌入式方法 = "">
    参数 当前值 <类型 = PIV数值模板>
    {
        @ (S_BYTE)@<当前值>
    }

    方法 到逻辑型 <公开 静态 类型 = 逻辑型 注释 = "将本数值转换到逻辑型后返回" 折叠 @嵌入式方法 = "">
    参数 当前值 <类型 = PIV数值模板>
    {
        @ @<当前值> != 0
    }

    # ---

    方法 取尺寸 <公开 静态 类型 = 整数 注释 = "返回数值类型的尺寸" 折叠 @嵌入式方法 = "">
    {
        @ (INT)sizeof (@dt<PIV数值模板>)
    }

    方法 取地址 <公开 静态 类型 = 通用指针 注释 = "返回本数值对应的通用指针" 折叠 @嵌入式方法 = "">
    参数 当前值 <类型 = PIV数值模板>
    {
        @ (void*)&@<当前值>
    }

    方法 取变整数地址 <公开 静态 类型 = 变整数 注释 = "返回本数值指针对应的变整数" 折叠 @嵌入式方法 = "">
    参数 当前值 <类型 = PIV数值模板>
    {
        @ (INT_P)&@<当前值>
    }
}

类 PIV数组模板 <公开 注释 = "本模板类封装了C++标准数组\"std::vector\"" 折叠 @文档 = "category = \"类型模板\""
        @视窗.外部头文件 = "<vector>\r\n<algorithm>" @别名 = "std::vector<模板类型1>" @别名类型 = 本地类 @模板基础类 = 真>
{
    方法 创建 <公开 静态 类型 = PIV数组模板 注释 = "从一系列所提供成员值创建一个新数组" 折叠 @嵌入式方法 = "">
    参数 初始列表 <类型 = 模板类型1 注释 = "所欲初始化的成员列表,支持多参" @可扩展 = "">
    {
        @ @dt<PIV数组模板>{@<初始列表>}
    }

    # 分配器

    方法 预分配尺寸 <公开 静态 属性读 类型 = 变整数 注释 = "返回本数组已分配了空间的成员数量,此容量值会大于或等于数组成员数." 折叠 @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    {
        @ static_cast<INT_P>(@<本数组>.capacity())
    }

    方法 预分配尺寸 <公开 静态 属性写 注释 = "提前为本数组分配指定数目成员的空间,用作支持在后面快速进行成员添加." 折叠>
    参数 本数组 <类型 = PIV数组模板>
    参数 所欲设置的容量 <类型 = 变整数 注释 = "单位为数组的成员数量">
    {
        @ @<本数组>.reserve(static_cast<size_t>(@<所欲设置的容量>));
    }

    方法 释放空闲容量 <公开 静态 注释 = "释放数组中未使用的内存空间,可能会重新分配内存." 注释 = "执行后会将数组容量(\"预分配尺寸\")缩减到跟\"取成员数\"一样." 折叠
            @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    {
        @ @<本数组>.shrink_to_fit()
    }

    # 方法

    方法 枚举循环 <公开 静态 注释 = "  启动一个循环来枚举本数组中的每一个成员,在循环中可以调用" 注释 = "\"取枚举值\"方法来获取当前所枚举到的成员值,调用\"取枚举索引\""
            注释 = "方法来获取当前所枚举到成员的索引位置." 折叠 @嵌入式方法 = "name = vector_iter\r\nhas_loop_body = true">
    参数 本数组 <类型 = PIV数组模板>
    {
        @ for (size_t __piv_vector_i = 0; __piv_vector_i < @<本数组>.size(); __piv_vector_i++)
    }

    方法 逆向枚举循环 <公开 静态 注释 = "  启动一个循环来逆向枚举本数组中的每一个成员,在循环中可以调用" 注释 = "\"取枚举索引\"/\"取枚举值\"方法来获取当前所枚举索引和对应值."
            注释 = "注意: 不能嵌套使用本循环,否则编译将报错." 折叠 @嵌入式方法 = "name = vector_riter\r\nhas_loop_body = true">
    参数 本数组 <类型 = PIV数组模板>
    {
        @ for (size_t __piv_vector_i = @<本数组>.size() - 1; __piv_vector_i >= 0; __piv_vector_i--)
    }

    方法 取枚举值 <公开 静态 类型 = 模板类型1 注释 = "  只能在本类的\"枚举循环\"/\"逆向枚举循环\"语句的子语句体中使用,用作取回当前枚举到的成员值,如果有多层"
            注释 = "本类或本类继承类的\"枚举循环\"嵌套,本方法将返回所处最近层\"枚举循环\"的枚举成员值." 折叠
            @嵌入式方法 = "parent = \"vector_iter, vector_riter\"" @视窗.返回参考 = 真>
    参数 本数组 <类型 = PIV数组模板>
    {
        @ (@dt<模板类型1>&)@<本数组>[__piv_vector_i]
    }

    方法 取枚举索引 <公开 静态 类型 = 整数 注释 = "  只能在本类的\"枚举循环\"/\"逆向枚举循环\"语句的子语句体中使用,用作取回当前枚举到成员的索引位置,如果有"
            注释 = "多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回所处最近层\"枚举循环\"枚举到成员的索" 注释 = "引位置." 折叠
            @嵌入式方法 = "parent = \"vector_iter, vector_riter\"">
    参数 本数组 <类型 = PIV数组模板>
    {
        @ static_cast<INT>(__piv_vector_i)
    }

    方法 取对象自身指针 <公开 静态 类型 = 变整数 注释 = "获取数组类自身的指针(std::vector<模板类型1> *)." 折叠 @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    {
        @ reinterpret_cast<INT_P>(&@<本数组>)
    }

    方法 取数组指针 <公开 静态 类型 = 变整数 注释 = "返回当前数组内容的第一个元素的指针" 折叠 @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    {
        @ reinterpret_cast<INT_P>(@<本数组>.data())
    }

    方法 索引是否有效 <公开 静态 类型 = 逻辑型 注释 = "返回所指定的索引值是否大于等于0且小于本数组的成员数" 折叠 @禁止流程检查 = 真>
    参数 本数组 <类型 = PIV数组模板>
    参数 所欲检查的索引值 <类型 = 变整数>
    {
        @ return static_cast<size_t>(@<所欲检查的索引值>) >= 0 && static_cast<size_t>(@<所欲检查的索引值>) < @<本数组>.size();
    }

    方法 取成员数 <公开 静态 类型 = 整数 注释 = "返回数组中的当前已有成员数目" 折叠 @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    {
        @ static_cast<INT>(@<本数组>.size())
    }

    方法 取最大索引 <公开 静态 类型 = 整数 注释 = "返回数组中尾成员的索引位置,如果当前数组为空,则返回-1." 折叠 @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    {
        @ static_cast<INT>(@<本数组>.size()) - 1
    }

    方法 是否为空 <公开 静态 类型 = 逻辑型 注释 = "返回本数组是否为空" 折叠 @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    {
        @ @<本数组>.empty()
    }

    方法 删除所有成员 <公开 静态 注释 = "删除当前数组中的所有成员" 折叠 @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    {
        @ @<本数组>.clear()
    }

    方法 重置数组 <公开 静态 注释 = "重置数组中的成员数为所指定的数目,数组原有的数据将被覆盖." 折叠 @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    参数 欲重置的成员数目 <类型 = 变整数 注释 = "重置后的数组成员数">
    参数 初始值 <类型 = 模板类型1 注释 = "用于提供每个成员的初始值">
    {
        @ @<本数组>.assign(static_cast<INT_P>(@<欲重置的成员数目>), @<初始值>)
    }

    方法 重置成员数 <公开 静态 注释 = "重置当前数组的成员数量,如果新的成员数小于当前成员数,则多余的成员值会被删除." 折叠 @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    参数 新成员数 <类型 = 整数>
    {
        @ @<本数组>.resize(@<新成员数>)
    }

    方法 取成员 <公开 静态 类型 = 模板类型1 注释 = "返回所指定索引位置处的成员值" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 本数组 <类型 = PIV数组模板>
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ (@dt<模板类型1>&)@<本数组>[static_cast<size_t>(@<索引位置>)]
    }

    方法 取成员指针 <公开 静态 类型 = 变整数 注释 = "返回所指定索引位置处的成员值指针" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 本数组 <类型 = PIV数组模板>
    参数 索引 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ reinterpret_cast<INT_P>(&@<本数组>[static_cast<size_t>(@<索引>)])
    }

    方法 置成员值 <公开 静态 注释 = "设置数组中所指定索引位置处的成员值" 折叠 @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    参数 所欲设置的值 <类型 = 模板类型1 注释 = "提供所欲设置的成员值,先前的值将被覆盖.">
    {
        @ @<本数组>[static_cast<size_t>(@<索引位置>)] = @<所欲设置的值>
    }

    方法 添加数组 <公开 静态 注释 = "将另一个同类型数组的内容添加到本数组尾部" 折叠>
    参数 本数组 <类型 = PIV数组模板>
    参数 所欲添加的数组 <类型 = PIV数组模板>
    {
        @ @<本数组>.insert(@<本数组>.end(), @<所欲添加的数组>.begin(), @<所欲添加的数组>.end());
    }

    方法 添加部分数组 <公开 静态 注释 = "将另一个同类型数组内容中的一部分添加到本数组尾部" 折叠>
    参数 本数组 <类型 = PIV数组模板>
    参数 所欲添加的数组 <类型 = PIV数组模板>
    参数 起始索引位置 <类型 = 整数 注释 = "必须大于等于0且加上\"所欲添加的成员数\"后小于等于\"所欲添加的数组\"的成员数目">
    参数 所欲添加的成员数 <类型 = 整数 注释 = "必须大于等于0且加上\"起始索引位置\"后小于等于\"所欲添加的数组\"的成员数目">
    {
        @ @<本数组>.insert(@<本数组>.end(), @<所欲添加的数组>.begin() + @<起始索引位置>, @<所欲添加的数组>.begin() + @<起始索引位置> + @<所欲添加的成员数>);
    }

    方法 初始化 <公开 静态 注释 = "从一系列所提供成员值初始化当前对象" 折叠 @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    参数 欲添加成员 <类型 = 模板类型1 @可扩展 = "">
    {
        @ @<本数组> = {@<欲添加成员>}
    }

    方法 从数组复制 <公开 静态 注释 = "将另一个同类型数组的内容复制到本数组中" 折叠>
    参数 本数组 <类型 = PIV数组模板>
    参数 欲复制的数组 <类型 = PIV数组模板>
    {
        @ @<本数组>.resize(@<欲复制的数组>.size());
        @ std::move(@<欲复制的数组>.begin(), @<欲复制的数组>.end(), @<本数组>.begin());
    }

    方法 加入成员 <公开 静态 注释 = "将一个或多个所指定类型的成员值加入到本数组的尾部" 折叠 @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    参数 所欲添加成员值 <类型 = 模板类型1 @可扩展 = "">
    {
        @ piv::push_backs(@<本数组>, @<所欲添加成员值>)
    }

    方法 加入并返回成员 <公开 静态 类型 = 模板类型1 注释 = "将一个所指定类型的成员值加入到本数组的尾部,并返回所加入的成员." 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本数组 <类型 = PIV数组模板>
    参数 所欲添加成员值 <类型 = 模板类型1 注释 = "提供所欲加入的成员值">
    {
        @ @<本数组>.push_back(@<所欲添加成员值>);
        @ return (@dt<模板类型1>&)@<本数组>.back();
    }

    方法 加入新成员 <公开 静态 注释 = "原位默认构造一个成员值,并将其加入到本数组的尾部." 注释 = "注意: \"模板类型1\"必须满足可移动插入和可原位构造." 折叠 @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    {
        @ @<本数组>.emplace_back()
    }

    方法 批量加入新成员 <公开 静态 注释 = "原位默认构造一个或多个成员值,并将其加入到本数组的尾部." 注释 = "注意: \"模板类型1\"必须满足可移动插入和可原位构造." 折叠
            @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    参数 所欲加入的成员数目 <类型 = 变整数 注释 = "提供所欲加入的成员数目" @默认值 = 1>
    {
        @ for (INT_P i = 0; i < @<所欲加入的成员数目>; i++) {
        @     @<本数组>.emplace_back();
        @ }
    }

    方法 加入并返回新成员 <公开 静态 类型 = 模板类型1 注释 = "原位默认构造一个成员值并将其加入到本数组的尾部,返回所加入成员的参考."
            注释 = "注意: \"模板类型1\"必须满足可移动插入和可原位构造." 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本数组 <类型 = PIV数组模板>
    {
        @ @<本数组>.emplace_back();
        @ return (@dt<模板类型1>&)@<本数组>.back();
    }

    方法 插入成员 <公开 静态 注释 = "将所指定的成员值插入到所指定的索引位置" 折叠>
    参数 本数组 <类型 = PIV数组模板>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于数组成员数目.">
    参数 所欲插入的成员值 <类型 = 模板类型1>
    {
        @ @<本数组>.insert(@<本数组>.begin() + static_cast<size_t>(@<插入索引位置>), @<所欲插入的成员值>);
    }

    方法 插入新成员 <公开 静态 类型 = 模板类型1 注释 = "原位构造一个成员值并将其插入到本数组中的指定索引位置,返回所插入成员的参考."
            注释 = "注意: \"模板类型1\"必须满足可移动插入和可原位构造." 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本数组 <类型 = PIV数组模板>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于数组成员数目.">
    {
        @ return (@dt<模板类型1>&)*@<本数组>.emplace(@<本数组>.begin() + @<插入索引位置>);
    }

    方法 插入相同成员 <公开 静态 注释 = "将所指定的成员值插入到所指定的索引位置" 折叠>
    参数 本数组 <类型 = PIV数组模板>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于数组成员数目.">
    参数 插入数量 <类型 = 整数>
    参数 所欲插入的成员值 <类型 = 模板类型1>
    {
        @ @<本数组>.insert(@<本数组>.begin() + @<插入索引位置>, @<插入数量>, @<所欲插入的成员值>);
    }

    方法 删除尾成员 <公开 静态 注释 = "删除数组尾部的单个成员,数组不能为空." 折叠 @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    {
        @ @<本数组>.pop_back()
    }

    方法 删除成员 <公开 静态 注释 = "删除数组中所指定索引范围的单个或多个成员" 折叠>
    参数 本数组 <类型 = PIV数组模板>
    参数 删除索引位置 <类型 = 变整数 注释 = "提供所欲删除的索引位置,必须大于等于0且小于等于数组成员数目.">
    参数 所欲删除成员数目 <类型 = 变整数 注释 = "提供所欲删除成员的数目,必须大于等于0且加上\"删除索引位置\"参数值后小于等于数组成员数目." @默认值 = 1>
    {
        @ @<本数组>.erase(@<本数组>.begin() + @<删除索引位置>, @<本数组>.begin() + @<删除索引位置> + @<所欲删除成员数目>);
    }

    方法 删除到尾部 <公开 静态 注释 = "删除数组中所指定索引位置后(包括该位置)的所有成员" 折叠>
    参数 本数组 <类型 = PIV数组模板>
    参数 起始索引位置 <类型 = 变整数 注释 = "提供所欲删除起始成员的索引位置,必须大于等于0且小于等于数组成员数目.">
    {
        @ @<本数组>.erase(@<本数组>.begin() + @<起始索引位置>, @<本数组>.end());
    }

    方法 查找删除成员 <公开 静态 类型 = 逻辑型 注释 = "查找第一个等于所指定值的成员,如果找到则将其删除并返回真,否则返回假." 折叠>
    参数 本数组 <类型 = PIV数组模板>
    参数 所欲查找成员值 <类型 = 模板类型1 注释 = "提供所欲查找并删除的成员值">
    {
        变量 索引值 <类型 = 整数>
        索引值 = 本数组.查找首成员 (所欲查找成员值)
        如果 (索引值 == -1)
        {
            返回 (假)
        }
        本数组.删除成员 (索引值)
        返回 (真)
    }

    方法 去重 <公开 静态 注释 = "去除数组中的重复成员." 注释 = "注意: 本方法会先对数组进行排序,请谨慎使用." 注释 = "重点: <模板类型1>必须支持等于和小于比较." 折叠 "">
    参数 本数组 <类型 = PIV数组模板 "">
    {
        @ std::sort(@<本数组>.begin(), @<本数组>.end());
        @ @<本数组>.erase(std::unique(@<本数组>.begin(), @<本数组>.end()), @<本数组>.end());
    }

    方法 交换成员 <公开 静态 注释 = "将两个索引位置处的成员值相互交换" 折叠>
    参数 本数组 <类型 = PIV数组模板>
    参数 索引位置1 <类型 = 整数 注释 = "提供成员1的索引位置,必须大于等于0且小于数组成员数目.">
    参数 索引位置2 <类型 = 整数 注释 = "提供成员2的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ std::swap(@<本数组>[@<索引位置1>], @<本数组>[@<索引位置2>]);
    }

    方法 交换所有成员 <公开 静态 注释 = "将当前数组的成员和另外一个数组的成员进行交换" 折叠 @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    参数 欲交换的数组 <类型 = PIV数组模板>
    {
        @ std::swap(@<本数组>, @<欲交换的数组>)
    }

    方法 交换数组 <公开 静态 注释 = "交换两个动态数组的数据内容." 折叠 @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    参数 欲交换的数组 <类型 = PIV数组模板>
    {
        @ @<本数组>.swap(@<欲交换的数组>)
    }

    方法 弹出成员 <公开 静态 类型 = 模板类型1 注释 = "返回并删除数组尾部的单个成员." 注释 = "注意: 执行本方法前必须确保数组不为空" 折叠 @禁止流程检查 = 真>
    参数 本数组 <类型 = PIV数组模板>
    {
        @ @dt<模板类型1> last_element = @<本数组>.back();
        @ @<本数组>.pop_back();
        @ return last_element;
    }

    方法 取首成员 <公开 静态 类型 = 模板类型1 注释 = "取第一个成员." 注释 = "注意: 执行本方法前必须确保数组不为空" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 本数组 <类型 = PIV数组模板>
    {
        @ (@dt<模板类型1>&)@<本数组>.front()
    }

    方法 取尾成员 <公开 静态 类型 = 模板类型1 注释 = "返回数组尾部的成员值." 注释 = "注意: 执行本方法前必须确保数组不为空" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 本数组 <类型 = PIV数组模板>
    {
        @ (@dt<模板类型1>&)@<本数组>.back()
    }

    方法 查找首成员 <公开 静态 类型 = 整数 注释 = "正向查找等于所指定值的第一个成员,找到返回其索引位置,未找到返回-1." 折叠 @禁止流程检查 = 真>
    参数 本数组 <类型 = PIV数组模板>
    参数 所欲查找的成员值 <类型 = 模板类型1>
    {
        @ auto it = std::find(@<本数组>.begin(), @<本数组>.end(), @<所欲查找的成员值>);
        @ return (it != @<本数组>.end () ? std::distance(@<本数组>.begin(), it) : -1);
    }

    方法 成员是否存在 <公开 静态 类型 = 逻辑型 注释 = "返回数组中是否存在为所指定值的成员" 折叠>
    参数 本数组 <类型 = PIV数组模板>
    参数 所欲查找的成员值 <类型 = 模板类型1>
    {
        返回 (本数组.查找首成员 (所欲查找的成员值) != -1)
    }

    方法 查找尾成员 <公开 静态 类型 = 整数 注释 = "逆向查找等于所指定值的最后一个成员,找到返回其索引位置,未找到返回-1." 折叠 @禁止流程检查 = 真>
    参数 本数组 <类型 = PIV数组模板>
    参数 所欲查找的成员值 <类型 = 模板类型1>
    {
        @ auto it = std::find(@<本数组>.rbegin(), @<本数组>.rend(), @<所欲查找的成员值>);
        @ return (it != @<本数组>.rend() ? @<本数组>.size() - std::distance(@<本数组>.rbegin(), it) - 1 : -1);
    }

    方法 替换成员值 <公开 静态 注释 = "将所有等于指定值的成员替换为另一个值" 折叠>
    参数 本数组 <类型 = PIV数组模板>
    参数 所欲替换的成员值 <类型 = 模板类型1>
    参数 所替换到的成员值 <类型 = 模板类型1>
    {
        @ std::replace(@<本数组>.begin(), @<本数组>.end(), @<所欲替换的成员值>, @<所替换到的成员值>);
    }

    方法 取指定成员数量 <公开 静态 类型 = 整数 注释 = "获取指定成员值在数组内的数量" 折叠 @禁止流程检查 = 真>
    参数 本数组 <类型 = PIV数组模板>
    参数 欲检查的成员值 <类型 = 模板类型1>
    {
        @ return std::count(@<本数组>.begin(), @<本数组>.end(), @<欲检查的成员值>);
    }

    方法 排序 <公开 静态 注释 = "对数组中的所有成员进行排序." 注释 = "注意: 需要<模板类型1>支持小于和大于比较." 折叠>
    参数 本数组 <类型 = PIV数组模板 "">
    参数 从小到大排序 <类型 = 逻辑型 注释 = "为真表示从小到大进行排序,为假表示从大到小进行排序." @默认值 = 真>
    {
        @ if (@<从小到大排序>) {
        @    std::sort(@<本数组>.begin(), @<本数组>.end());
        @ } else {
        @    std::sort(@<本数组>.begin(), @<本数组>.end(), [](@dt<模板类型1>& a, @dt<模板类型1>& b) {
        @        return a > b;
        @    });
        @ }
    }

    方法 反转顺序 <公开 静态 注释 = "反转数组顺序,例如: 1,2,3 变 3,2,1" 折叠>
    参数 本数组 <类型 = PIV数组模板 "">
    {
        @ std::reverse(@<本数组>.begin(), @<本数组>.end());
    }

    方法 打乱顺序 <公开 静态 注释 = "随机地打乱数组中所有成员的顺序." 注释 = "注: 随机算法为std::mt19937,成员的每个排列都拥有相同的出现概率." 折叠
            @视窗.外部头文件 = "<random>">
    参数 本数组 <类型 = PIV数组模板 "">
    {
        @ std::shuffle(@<本数组>.begin(), @<本数组>.end(), std::mt19937{std::random_device{}()});
    }

    方法 是否相等 <公开 静态 类型 = 逻辑型 注释 = "返回所指定数组的内容是否与本数组相同" 折叠 @嵌入式方法 = "">
    参数 本数组 <类型 = PIV数组模板>
    参数 所欲比较的容器 <类型 = PIV数组模板>
    {
        @ @<本数组> == @<所欲比较的容器>
    }
}

# 指针模板

类 PIV指针模板 <公开 注释 = "用作支持C++结构体或类指针的基础模板类" 注释 = "注意: 本模板用在参数上不默认具有参考属性." 折叠 @文档 = "category = \"指针模板\""
        @模板基础类 = 真 @别名类型 = 本地参考类型>
{
    方法 创建 <公开 静态 类型 = PIV指针模板 注释 = "  创建并返回一个本类指针,注意不使用后必须调用销毁命令将其销毁."
            注释 = "  注意: 使用本模板类方法时,所对应的C++结构指针别名必须以\'*\'字符结束,或者以\"P\"/\"P_\"/\"LP\"/\"LP_\"这几类文本开头,"
            注释 = "譬如别名为 xxx 结构的指针, 可以使用\"Pxxx\" / \"LPxxx\" / \"P_xxx\" / \"LP_xxx\" / \"xxx*\"别名,否则将无法正确取得结构"
            注释 = "指针所对应的结构数据类型." 折叠 @嵌入式方法 = "">
    {
        @ new @dt<PIV指针模板, n>
    }

    方法 带参创建 <公开 静态 类型 = PIV指针模板 注释 = "  带参创建并返回一个本类指针,注意不使用后必须调用销毁命令将其销毁."
            注释 = "  注意: 使用本模板类方法时,所对应的C++结构指针别名必须以\'*\'字符结束,或者以\"P\"/\"P_\"/\"LP\"/\"LP_\"这几类文本开头,"
            注释 = "譬如别名为 xxx 结构的指针, 可以使用\"Pxxx\" / \"LPxxx\" / \"P_xxx\" / \"LP_xxx\" / \"xxx*\"别名,否则将无法正确取得结构"
            注释 = "指针所对应的结构数据类型." 折叠 @嵌入式方法 = "">
    参数 构造参数 <注释 = "C++结构体或类的带参构造参数" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ new @dt<PIV指针模板, n>()
    }

    方法 销毁 <公开 静态 注释 = "销毁先前调用\"创建\"方法所创建的本类指针" 折叠 @嵌入式方法 = "">
    参数 本结构指针 <类型 = PIV指针模板>
    {
        @ delete @<本结构指针>
    }

    方法 取数据尺寸 <公开 静态 类型 = 整数 注释 = "  返回本类指针所指向结构数据的尺寸."
            注释 = "  注意: 使用本模板类方法时,所对应的C++结构指针别名必须以\'*\'字符结束,或者以\"P\"/\"P_\"/\"LP\"/\"LP_\"这几类文本开头,"
            注释 = "譬如别名为 xxx 结构的指针, 可以使用\"Pxxx\" / \"LPxxx\" / \"P_xxx\" / \"LP_xxx\" / \"xxx*\"别名,否则将无法正确取得结构"
            注释 = "指针所对应的结构数据类型." 折叠 @嵌入式方法 = "">
    {
        @ (INT)sizeof (@dt<PIV指针模板, n>)
    }

    方法 取指针 <公开 静态 类型 = 通用指针 注释 = "取回本类指针对应的通用指针" 折叠 @嵌入式方法 = "">
    参数 本结构指针 <类型 = PIV指针模板>
    {
        @ (void*)@<本结构指针>
    }

    方法 取变整数指针 <公开 静态 类型 = 变整数 注释 = "将本数据类型值转换到变整数后返回" 折叠 @嵌入式方法 = "">
    参数 本结构指针 <类型 = PIV指针模板>
    {
        @ (INT_P)@<本结构指针>
    }

    方法 来自变整数 <公开 静态 类型 = PIV指针模板 注释 = "将指定整数值转换为本数据类型值后返回" 折叠 @嵌入式方法 = "">
    参数 欲转换整数值 <@匹配类型 = 通用整数型>
    {
        @ (@dt<PIV指针模板>)@<欲转换整数值>
    }

    方法 空指针 <公开 静态 类型 = PIV指针模板 注释 = "将NULL指针值转换为本数据类型值后返回" 折叠 @嵌入式方法 = "">
    {
        @ NULL
    }

    # ---

    方法 置空指针 <公开 静态 类型 = 逻辑型 注释 = "将指针值置空(null)." 注释 = "注意: 本方法不会销毁指针数据,请确保指针数据会被销毁." 折叠 @嵌入式方法 = "">
    参数 本结构指针 <类型 = PIV指针模板>
    {
        @ @<本结构指针> = nullptr
    }

    方法 为空指针 <公开 静态 类型 = 逻辑型 注释 = "返回本指针是否为空" 折叠 @嵌入式方法 = "">
    参数 本结构指针 <类型 = PIV指针模板>
    {
        @ @<本结构指针> == nullptr
    }
}

类 PIV参考指针模板 <公开 注释 = "用作参考其他变量,本类不会管理指针的创建和释放." 注释 = "注意:" 注释 = " 1. 所封装的类型不必拥有默认构造函数;"
        注释 = " 2. 本模板用在参数上不默认具有参考属性;" 折叠 @文档 = "category = \"指针模板\"" @模板基础类 = 真 @别名 = "模板类型1*" @别名类型 = 本地参考类型>
{
    方法 值 <公开 静态 属性写 注释 = "参考指定的变量,所参考变量的生命周期应不要短于本指针." 注释 = "注意: 本属性写方法与\"参考\"方法一样,可以混用." 折叠>
    参数 本指针 <类型 = PIV参考指针模板 @视窗.后缀文本 = "&">
    参数 欲参考的变量 <类型 = 模板类型1>
    {
        @ @<本指针> = &@<欲参考的变量>;
    }

    方法 值 <公开 静态 属性读 类型 = 模板类型1 注释 = "解引用指针,返回本指针所参考的变量." 注释 = "注意:" 注释 = " 1. 本属性读方法与\"解引用\"方法一样,可以混用;"
            注释 = " 2. 指针为空时请勿使用本属性读方法,会直接崩溃!!!" 注释 = " 3. 所参考变量不能在调用本方法前被释放,否则也会直接崩溃!!!" 折叠 @视窗.返回参考 = 真
            @禁止流程检查 = 真>
    参数 本指针 <类型 = PIV参考指针模板>
    {
        @ return *@<本指针>;
    }

    方法 参考 <公开 静态 注释 = "参考指定的变量,所参考变量的生命周期应不要短于本指针." 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = PIV参考指针模板>
    参数 欲参考的变量 <类型 = 模板类型1 @需求类型 = 可写入变量>
    {
        @ @<本指针> = &@<欲参考的变量>
    }

    方法 解引用 <公开 静态 类型 = 模板类型1 注释 = "解引用指针,返回本指针所参考的变量." 注释 = "注意:" 注释 = " 1. 指针为空时请勿使用本方法,会直接崩溃!!!"
            注释 = " 2. 所参考变量不能在调用本方法前被释放,否则也会直接崩溃!!!" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 本指针 <类型 = PIV参考指针模板>
    {
        @ *@<本指针>
    }

    方法 为空指针 <公开 静态 类型 = 逻辑型 注释 = "返回本指针是否为空,空指针时请勿解引用." 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = PIV参考指针模板>
    {
        @ @<本指针> == nullptr
    }

    方法 置指针 <公开 静态 注释 = "将本指针设置为指定的值,请自行确保提供的指针值有效." 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = PIV参考指针模板>
    参数 欲参考的地址 <类型 = 变整数>
    {
        @ @<本指针> = (@dt<PIV参考指针模板>)@<欲参考的地址>
    }

    方法 取变整数地址 <公开 静态 类型 = 变整数 注释 = "返回变整数类型的指针地址" 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = PIV参考指针模板>
    {
        @ (INT_P)@<本指针>
    }
}

类 独占智能指针模板 <公开 注释 = "独占智能指针(std::unique_ptr)将独占被管理对象的所有权," 注释 = "在智能指针被销毁的同时销毁被管理的对象."
        注释 = "独占智能指针只支持移动赋值,一个对象只能由一个智能指针管理." 注释 = "模板类型1: 所封装的类型(不能为指针)" 注释 = "注意: 请通过\"智能指针.值\"访问所封装的对象."
        注释 = "你也可以在模板实现类里写操作对象的方法." 折叠 @文档 = "category = \"指针模板\"" @视窗.外部头文件 = "<memory>"
        @别名 = "std::unique_ptr<模板类型1>" @别名类型 = 本地类 @模板基础类 = 真>
{
    方法 创建 <公开 静态 类型 = 独占智能指针模板 注释 = "创建并返回一个本类独占智能指针." 注释 = "智能指针在离开作用域后即销毁其管理的对象,无需手动销毁." 折叠 @嵌入式方法 = "">
    {
        @ @dt<独占智能指针模板>(new @dt<模板类型1>)
    }

    方法 带参创建 <公开 静态 类型 = 独占智能指针模板 注释 = "带参创建并返回一个本类独占智能指针." 注释 = "智能指针在离开作用域后即销毁其管理的对象,无需手动销毁." 折叠
            @嵌入式方法 = "">
    参数 构造参数 <注释 = "C++结构体或类的带参构造参数" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @dt<独占智能指针模板>(new @dt<模板类型1>(@<构造参数>))
    }

    方法 重置 <公开 静态 注释 = "替换智能指针的被管理对象,先前管理的对象将被销毁." @嵌入式方法 = "">
    参数 本指针 <类型 = 独占智能指针模板>
    参数 新指针 <类型 = 变整数 注释 = "欲管理的新对象指针,如果为0则将重置为空指针." @默认值 = 0>
    {
        @ @<本指针>.reset(reinterpret_cast<@dt<模板类型1>*>(@<新指针>))
    }

    方法 释放 <公开 静态 类型 = 变整数 注释 = "释放被管理对象的所有权,返回被释放对象的变整数指针." 注释 = "释放后智能指针为空,需要自行管理被释放指针的销毁." @嵌入式方法 = "">
    参数 本指针 <类型 = 独占智能指针模板>
    {
        @ reinterpret_cast<INT_P>(@<本指针>.release())
    }

    方法 交换 <公开 静态 注释 = "交换两个智能指针管理的对象" @嵌入式方法 = "">
    参数 本指针 <类型 = 独占智能指针模板>
    参数 欲交换的对象 <类型 = 独占智能指针模板 注释 = "所欲交换的另一个智能指针">
    {
        @ @<本指针>.swap(@<欲交换的对象>)
    }

    方法 值 <公开 静态 属性读 类型 = 模板类型1 注释 = "解引用智能指针,返回所管理对象的参考." 注释 = "注意: 智能指针为空时,使用本方法会造成崩溃." @禁止流程检查 = 真
            @视窗.返回参考 = 真>
    参数 本指针 <类型 = 独占智能指针模板>
    {
        @ return *@<本指针>;
    }

    方法 为空指针 <公开 静态 类型 = 逻辑型 注释 = "返回智能指针是否为空,空指针时请勿解引用." @嵌入式方法 = "">
    参数 本指针 <类型 = 独占智能指针模板>
    {
        @ (@<本指针>.get() == nullptr)
    }

    方法 取通用指针 <公开 静态 类型 = 通用指针 注释 = "返回智能指针所管理对象的无类型指针" @嵌入式方法 = "">
    参数 本指针 <类型 = 独占智能指针模板>
    {
        @ (void*)@<本指针>.get()
    }

    方法 取变整数地址 <公开 静态 类型 = 变整数 注释 = "返回智能指针所管理对象的变整数地址" @嵌入式方法 = "">
    参数 本指针 <类型 = 独占智能指针模板>
    {
        @ reinterpret_cast<INT_P>(@<本指针>.get())
    }
}

类 共享智能指针模板 <公开 注释 = "共享智能指针(std::shared_ptr)允许共享被管理对象的所有权," 注释 = "多个智能指针可以同时占有同一个对象,只有在所有智能指针被销毁后,"
        注释 = "被管理的对象才会被销毁." 注释 = "模板类型1: 所封装的类型(不能为指针)" 注释 = "注意: 请通过\"智能指针.值\"访问所封装的对象."
        注释 = "你也可以在模板实现类里写操作对象的方法." 折叠 @文档 = "category = \"指针模板\"" @视窗.外部头文件 = "<memory>"
        @别名 = "std::shared_ptr<模板类型1>" @别名类型 = 本地类 @模板基础类 = 真>
{
    方法 创建 <公开 静态 类型 = 共享智能指针模板 注释 = "创建并返回一个本类的共享智能指针." 注释 = "智能指针在离开作用域后即销毁其管理的对象,无需手动销毁." 折叠 @嵌入式方法 = "">
    {
        @ @dt<共享智能指针模板>(new @dt<模板类型1>)
    }

    方法 带参创建 <公开 静态 类型 = 共享智能指针模板 注释 = "带参创建并返回一个本类的共享智能指针." 注释 = "智能指针在离开作用域后即销毁其管理的对象,无需手动销毁." 折叠
            @嵌入式方法 = "">
    参数 构造参数 <注释 = "C++结构体或类的带参构造参数" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @dt<共享智能指针模板>(new @dt<模板类型1>{@<构造参数>})
    }

    方法 重置 <公开 静态 注释 = "替换智能指针的被管理对象,将释放先前管理对象的所有权(仅在所有共享智能指针被销毁后才会被销毁)." 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = 共享智能指针模板>
    参数 新指针 <类型 = 变整数 注释 = "欲管理的新对象指针,如果为0则将重置为空指针." @默认值 = 0>
    {
        @ @<本指针>.reset(reinterpret_cast<@dt<模板类型1>*>(@<新指针>))
    }

    方法 交换 <公开 静态 注释 = "交换两个智能指针管理的对象" 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = 共享智能指针模板>
    参数 欲交换的对象 <类型 = 共享智能指针模板 注释 = "所欲交换的另一个智能指针">
    {
        @ @<本指针>.swap(@<欲交换的对象>)
    }

    方法 值 <公开 静态 属性读 类型 = 模板类型1 注释 = "解引用智能指针,返回所管理对象的参考." 注释 = "注意: 智能指针为空时,使用本方法会造成崩溃." 折叠 @禁止流程检查 = 真
            @视窗.返回参考 = 真>
    参数 本指针 <类型 = 共享智能指针模板>
    {
        @ return *@<本指针>;
    }

    方法 引用计数 <公开 静态 属性读 类型 = 整数 注释 = "返回管理当前对象的智能指针数量,若无管理对象则返回0." 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = 共享智能指针模板>
    {
        @ @<本指针>.use_count()
    }

    方法 为空指针 <公开 静态 类型 = 逻辑型 注释 = "返回智能指针是否为空,空指针时请勿解引用." 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = 共享智能指针模板>
    {
        @ (@<本指针>.get() == nullptr)
    }

    方法 取通用指针 <公开 静态 类型 = 通用指针 注释 = "返回智能指针所管理对象的无类型指针" 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = 共享智能指针模板>
    {
        @ (void*)@<本指针>.get()
    }

    方法 取变整数地址 <公开 静态 类型 = 变整数 注释 = "返回智能指针所管理对象的变整数地址" 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = 共享智能指针模板>
    {
        @ reinterpret_cast<INT_P>(@<本指针>.get())
    }
}

# ---

类 无类型指针 <公开 基础类 = PIV指针模板 注释 = "void*" @文档 = "category = \"基本类型\"" @别名 = "void*" @模板实现类 = "无类型指针">

类 字符串指针 <公开 基础类 = PIV指针模板 注释 = "UTF-8与ANSI通用" @文档 = "category = \"基本类型\"" @别名 = "char*"
        @模板实现类 = "字符串指针">

类 常量字符串指针 <公开 基础类 = PIV指针模板 注释 = "UTF-8与ANSI通用" @文档 = "category = \"基本类型\"" @别名 = "const char*"
        @模板实现类 = "常量字符串指针">

类 "// 无符号变整数" <公开 基础类 = PIV数值模板 @文档 = "category = \"基本类型\"" @别名 = "size_t" @模板实现类 = "无符号变整数">

类 "// 无符号字节指针" <公开 基础类 = PIV指针模板 @文档 = "category = \"指针类型\"" @别名 = "BYTE*" @模板实现类 = "无符号字节指针">

# ======

类 PIV对象类 <公开 基础类 = 对象类 注释 = "等同于\"扩展对象类\",并导入了<chrono>头文件." 折叠 @文档 = "category = \"基础类\""
        "@视窗.外部头文件.全局-100" = "<malloc.h>\r\n<chrono>">
{
    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 折叠2 @虚拟方法 = 可覆盖
            @输出名 = "GetDumpString" @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        @ BaseClass::GetDumpString (@<展示内容>, @<最大展示数据尺寸>);
    }

    方法 流读入 <公开 注释 = "从所指定的流对象中读入本对象的数据. 请注意以下事项:" 注释 = "  1. 一旦定义了\"流读入\"方法,必须定义对应的\"流写出\"方法,所读入内容格式与"
            注释 = "\"流写出\"方法写出的内容格式必须完全一致;" 注释 = "  2. 任何类如果既没有定义\"流读入\"方法,也没有定义\"流写出\"方法,编译器会自动"
            注释 = "建立默认的\"流读入\"和\"流写出\"方法,默认方法就是首先调用基础类中的对应方法," 注释 = "然后将本对象中的所有非静态变量成员顺序从流中读入/写出;"
            注释 = "  3. 继承类中如果覆盖了本方法且基础类中也存在数据需要从流中读入,则必须负" 注释 = "责调用基础类中的\"流读入\"方法,调用格式如: \"父对象.流读入 (流对象)\";"
            注释 = "  4. 如果本方法中的读入操作比较复杂或耗时,在之前最好检查一下流对象当前是" 注释 = "否处于出错状态(\"流对象.是否出错\"方法返回真),如果出错则放弃后续的读入操作,"
            注释 = "以提高运行效率;" 注释 = "  5. 在读入过程中一旦发现出错,则需要将对应的错误码写入\"流对象.错误码\"属性"
            注释 = "中(流读入出错不需要,会自动写入),以禁止后续的流读入操作. 错误码可以是" 注释 = "\"流错误码\"类中的常量值,也可以是自行定义的错误码值(必须大于0);"
            注释 = "  6. 流对象一旦处于出错状态(流对象的\"错误码\"属性值不为\"流错误码.无错误\")," 注释 = "则后续所有流读入操作都会失败,如果欲再次使用此流对象,需要首先调用其"
            注释 = "\"清除错误\"方法清除掉流的出错状态或者将流关闭后再打开." 折叠 折叠2 @虚拟方法 = 可覆盖 @输出名 = "@LoadFromStream"
            @视窗.后缀文本 = "override">
    参数 流对象 <类型 = 输入流类 注释 = "提供欲从其中读入本对象数据内容的输入流">

    方法 流写出 <公开 注释 = "将本对象的数据写入所指定的流对象中. 注意:" 注释 = "  1. 一旦定义了\"流写出\"方法,必须定义对应的\"流读入\"方法,所写出内容格式与"
            注释 = "\"流读入\"方法读取的内容格式必须完全一致;" 注释 = "  2. 任何类如果既没有定义\"流读入\"方法,也没有定义\"流写出\"方法,编译器会自动"
            注释 = "建立默认的\"流读入\"和\"流写出\"方法,默认方法就是首先调用基础类中的对应方法," 注释 = "然后将本对象中的所有非静态变量成员顺序从流中读入/写出;"
            注释 = "  3. 继承类中如果覆盖了本方法且基础类中也存在数据需要写出到流中,则必须负" 注释 = "责调用基础类中的\"流写出\"方法,调用格式如: \"父对象.流写出 (流对象)\";"
            注释 = "  4. 如果本方法中的写出操作比较复杂或耗时,在之前最好检查一下流对象当前是" 注释 = "否处于出错状态(\"流对象.是否出错\"方法返回真),如果出错则放弃后续的写出操作,"
            注释 = "以提高运行效率;" 注释 = "  5. 在写出过程中一旦发现出错,则需要将对应的错误码写入\"流对象.错误码\"属性"
            注释 = "中(流写出出错不需要,会自动写入),以禁止后续的流写出操作. 错误码可以是" 注释 = "\"流错误码\"类中的常量值,也可以是自行定义的错误码值(必须大于0);"
            注释 = "  6. 流对象一旦处于出错状态(流对象的\"错误码\"属性值不为\"流错误码.无错误\")," 注释 = "则后续所有流写出操作都会失败,如果欲再次使用此流对象,需要首先调用其"
            注释 = "\"清除错误\"方法清除掉流的出错状态或者将流关闭后再打开." 折叠 折叠2 @虚拟方法 = 可覆盖 @输出名 = "@SaveIntoStream"
            @视窗.后缀文本 = "override">
    参数 流对象 <类型 = 输出流类 注释 = "提供欲将本对象数据内容写出到其中的输出流">
}

# @begin
# <> <global>
# <> <include>
# #define PIVDEBUG(format, ...) _DEBUG_STATMENT (DebugTrace (FALSE, 0, 0, _T (format), __VA_ARGS__))
# #define PIV_ARRAY_AND_SIZE(_ARR)  (_ARR), sizeof(_ARR) / sizeof(*(_ARR))
# #define PIV_MEM_PTR_AND_SIZE(_MEM)  (_MEM).GetPtr(), (_MEM).GetSize()
# #define PIV_TEXT_AND_SIZE(_STR)  (_STR).GetText(), (_STR).GetLength()
# namespace piv
# {
#     // 取基本数据封装类的值指针,空对象时返回nullptr
#     template <typename T = void*>
#     T GetBaseDataPtr(CVolBaseDataType& data) {
#         return data.IsNullObject() ? nullptr : reinterpret_cast<T>(data.GetDataPtr());
#     }
#     // 强制指针类型转换
#     template <typename dst_type, typename src_type>
#     dst_type pointer_cast(src_type src) {
#         return *static_cast<dst_type*>(static_cast<void*>(&src));
#     }
#     // std::vector 连续加入成员
#     template <typename T, typename V>
#     void push_backs(T& vector, V&& value) {
#         vector.push_back(value);
#     }
#     template <typename T, typename V, typename... Args>
#     void push_backs(T& vector, V&& value, Args&&...args) {
#         vector.push_back(value);
#         push_backs(vector, args...);
#     }
# } // namespace piv
#
# #ifndef _PIV_BUFFER_CLASS
# #define _PIV_BUFFER_CLASS
# // 基于火山内部内存池实现的缓存类
# template <typename ELEMENT_T = BYTE, typename MEM_SIZE = DWORD>
# class PivBuffer
# {
# private:
#     ELEMENT_T *p = nullptr;
#     MEM_SIZE size = 0;
# public:
#     PivBuffer() {}
#     ~PivBuffer() { Free(); }
#     PivBuffer(MEM_SIZE npSize, bool zero = true) { Alloc(npSize, zero); }
#     ELEMENT_T *Alloc(MEM_SIZE npSize, bool zero = true) {
#         size = npSize * sizeof(ELEMENT_T);
#         if (!p)
#             p = reinterpret_cast<ELEMENT_T *>(g_objVolApp.GetPoolMem()->Alloc(static_cast<INT_P>(size)));
#         else
#             p = reinterpret_cast<ELEMENT_T *>(g_objVolApp.GetPoolMem()->Realloc((void *)p, static_cast<INT_P>(size)));
#         if (zero)
#             memset(p, 0, static_cast<size_t>(size));
#         return p;
#     }
#     inline ELEMENT_T *Realloc(MEM_SIZE npNewSize, bool zero = true) {
#         size = npNewSize * sizeof(ELEMENT_T);
#         p = reinterpret_cast<ELEMENT_T *>(g_objVolApp.GetPoolMem()->Realloc((void *)p, static_cast<INT_P>(size)));
#         if (zero)
#             memset(p, 0, static_cast<size_t>(size));
#         return p;
#     }
#     inline void Free() {
#         if (p)
#             g_objVolApp.GetPoolMem()->Free((void *)p);
#         size = 0;
#     }
#     inline ELEMENT_T *GetPtr() { return p; }
#     template <typename R = ELEMENT_T>
#     inline R *Get() { return reinterpret_cast<R *>(p); }
#     inline MEM_SIZE GetSize() { return size; }
#     inline MEM_SIZE GetCount() { return size / sizeof(ELEMENT_T); }
#     ELEMENT_T &At(MEM_SIZE pos) { return p[pos]; }
#     ELEMENT_T *operator*() { return p; }
#     ELEMENT_T &operator[](MEM_SIZE pos) { return p[pos]; }
# }; // PivBuffer
# #endif // _PIV_BUFFER_CLASS
# <> </include>
# <> </global>
# @end
#
