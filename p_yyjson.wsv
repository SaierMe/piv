<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "yyjson --最快的C语言JSON库--" 注释 = "https://github.com/ibireme/yyjson"
        注释 = "版本: 0.11.1 (2025-05-14)" @视窗.外部头文件 = "src\\yyjson\\piv_yyjson.hpp"
        @视窗.外部源文件 = "src\\yyjson\\yyjson.c">

# 本yyjson库特色:
# 1. 唯一完整封装了yyjson的火山库;
# 2. 不区分对象、数组和简单值,跟原库一样以"YYJSON值/YYJSON只读值"操作所有的JSON值类型;
# 3. 支持通用型参数,比如"加入成员/置入键值"就相当于"加入文本成员"、"加入整数成员"...等等;
# 4. 支持多种文本类型,若使用UTF-8编码的文本则无需编码转换;
# 5. 默认使用火山内部的内存池作为内存分配器,比标准函数(malloc/realloc/free)更快,你也可以使用mimalloc等更高性能的内存分配库(参考《PIV模块例程》);
# 6. 部分支持链式语法;
# 7. 内部使用共享智能指针,默认为参考赋值,即多个类实例可以操作同一JSON文档;

类 YYJSON只读值 <公开 注释 = "本类仅用于解析和访问JSON内容,效率极高,如需使用构造功能请使用\"YYJSON值\"."
        注释 = " 1. 内部以智能指针管理\"YYJSON只读文档\",允许多个实例操作同一JSON文档;" 注释 = " 2. 默认为参考赋值,赋值后左值指向的数据跟右值一样;" 折叠
        隐藏值属性 = "0" @文档 = "category = \"JSON支持.YYJSON\"" @别名 = "piv_yyjson_val" @别名类型 = 火山类>
{

    # 全局方法 ---

    方法 取版本号 <公开 静态 类型 = 整数 注释 = "返回YYJSON的版本号,版本号编码方式:" 注释 = "(major << 16) | (minor << 8) | (patch)" 折叠
            @嵌入式方法 = "">
    {
        @ (INT)yyjson_version()
    }

    方法 取版本信息 <公开 静态 类型 = 文本型 注释 = "返回YYJSON的文本版本号" 折叠 @嵌入式方法 = "">
    {
        @ @an<CVolString>{YYJSON_VERSION_STRING}
    }

    # 解析/反序列化JSON文档 ---

    方法 解析 <公开 静态 类型 = 逻辑型 注释 = "解析所有支持的JSON文档数据,返回是否解析成功." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 JSON数据 <注释 = "所欲解析的JSON文本数据,支持类型(带*号表示会转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8编码)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 解析标志位 <类型 = YYJSON解析选项 注释 = "为\"YYJSON解析选项\"常量的位或组合值" @默认值 = YYJSON解析选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON文档的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    参数 错误信息 <类型 = YYJSON解析错误 注释 = "若提供非空指针,可在解析失败时返回错误信息." @默认值 = YYJSON解析错误.空指针>
    {
        @ @<当前对象>.parse(@<JSON数据>, @<解析标志位>, @<内存分配器>, @<错误信息>)
    }

    方法 解析内存 <公开 静态 类型 = 逻辑型 注释 = "解析内存中的JSON文档数据,返回是否解析成功." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 JSON数据指针 <注释 = "所欲解析的JSON数据地址,其内容必须为UTF-8编码的文本数据" @匹配类型 = 通用数值型>
    参数 JSON数据长度 <注释 = "JSON数据的字节长度" @匹配类型 = 通用数值型>
    参数 解析标志位 <类型 = YYJSON解析选项 注释 = "为\"YYJSON解析选项\"常量的位或组合值" @默认值 = YYJSON解析选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON文档的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    参数 错误信息 <类型 = YYJSON解析错误 注释 = "若提供非空指针,可在解析失败时返回错误信息." @默认值 = YYJSON解析错误.空指针>
    {
        @ @<当前对象>.parse_doc(reinterpret_cast<const char*>(@<JSON数据指针>), static_cast<size_t>(@<JSON数据长度>), @<解析标志位>, @<内存分配器>, @<错误信息>)
    }

    方法 解析文件 <公开 静态 类型 = 逻辑型 注释 = "解析指定路径的UTF-8编码JSON文件,返回是否解析成功." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 文件路径 <类型 = 文本型 注释 = "提供JSON文件的完整路径">
    参数 解析标志位 <类型 = YYJSON解析选项 注释 = "为\"YYJSON解析选项\"常量的位或组合值" @默认值 = YYJSON解析选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON文档的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    参数 错误信息 <类型 = YYJSON解析错误 注释 = "若提供非空指针,可在解析失败时返回错误信息." @默认值 = YYJSON解析错误.空指针>
    {
        @ @<当前对象>.parse_file(@<文件路径>.GetText(), @<解析标志位>, @<内存分配器>, @<错误信息>)
    }

    # 序列化JSON文档 ---

    方法 到可读文本 <公开 静态 类型 = 文本型 注释 = "将JSON文档序列化为字符串,并转换到文本型." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 序列化标志位 <类型 = YYJSON序列化选项 注释 = "为\"YYJSON序列化选项\"常量的位或组合值" @默认值 = YYJSON序列化选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON序列化时使用的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    参数 错误信息 <类型 = YYJSON序列化错误 注释 = "若提供非空指针,可在序列化失败时返回错误信息." @默认值 = YYJSON序列化错误.空指针>
    {
        @ @<当前对象>.write_vol_str(@<序列化标志位>, @<内存分配器>, @<错误信息>)
    }

    方法 到可读标准文本 <公开 静态 类型 = 标准文本类U 注释 = "将JSON文档序列化为字符串,返回到标准文本类U." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 序列化标志位 <类型 = YYJSON序列化选项 注释 = "为\"YYJSON序列化选项\"常量的位或组合值" @默认值 = YYJSON序列化选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON序列化时使用的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    参数 错误信息 <类型 = YYJSON序列化错误 注释 = "若提供非空指针,可在序列化失败时返回错误信息." @默认值 = YYJSON序列化错误.空指针>
    {
        @ @<当前对象>.write_std_str(@<序列化标志位>, @<内存分配器>, @<错误信息>)
    }

    方法 到字节集 <公开 静态 类型 = 字节集类 注释 = "将JSON文档序列化为字符串,返回到字节集类(UTF-8编码)." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 序列化标志位 <类型 = YYJSON序列化选项 注释 = "为\"YYJSON序列化选项\"常量的位或组合值" @默认值 = YYJSON序列化选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON序列化时使用的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    参数 错误信息 <类型 = YYJSON序列化错误 注释 = "若提供非空指针,可在序列化失败时返回错误信息." @默认值 = YYJSON序列化错误.空指针>
    {
        @ @<当前对象>.write_vol_mem(@<序列化标志位>, @<内存分配器>, @<错误信息>)
    }

    方法 写出文件 <公开 静态 类型 = 逻辑型 注释 = "将整个JSON文档写出到文件(UTF-8编码),返回是否成功." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 文件名称 <类型 = 文本型 注释 = "请提供完整的文件路径,路径的中间目录必须已经存在;" 注释 = "如果文件不存在将自动创建,文件已存在则覆盖原先的数据.">
    参数 序列化标志位 <类型 = YYJSON序列化选项 注释 = "为\"YYJSON序列化选项\"常量的位或组合值" @默认值 = YYJSON序列化选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON序列化时使用的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    参数 错误信息 <类型 = YYJSON序列化错误 注释 = "若提供非空指针,可在序列化失败时返回错误信息." @默认值 = YYJSON序列化错误.空指针>
    {
        @ @<当前对象>.write_file(@<文件名称>.GetText(), @<序列化标志位>, @<内存分配器>, @<错误信息>)
    }

    # 序列化JSON值 ---

    方法 到文本 <公开 静态 类型 = 文本型 注释 = "将当前JSON值序列化为字符串,并转换到文本型." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 序列化标志位 <类型 = YYJSON序列化选项 注释 = "为\"YYJSON序列化选项\"常量的位或组合值" @默认值 = YYJSON序列化选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON序列化时使用的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    {
        @ @<当前对象>.to_vol_str(@<序列化标志位>, @<内存分配器>)
    }

    方法 到标准文本 <公开 静态 类型 = 标准文本类U 注释 = "将当前JSON值序列化为字符串,返回到标准文本类U." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 序列化标志位 <类型 = YYJSON序列化选项 注释 = "为\"YYJSON序列化选项\"常量的位或组合值" @默认值 = YYJSON序列化选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON序列化时使用的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    {
        @ @<当前对象>.to_std_str(@<序列化标志位>, @<内存分配器>)
    }

    # JSON文档属性 ---

    方法 为空文档 <公开 静态 类型 = 逻辑型 注释 = "返回当前的JSON文档是否为空" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.empty()
    }

    # 转换 ---

    方法 到可变值 <公开 静态 类型 = YYJSON值 注释 = "将当前的JSON只读值转换到JSON可变值" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.to_mut_val()
    }

    # JSON值属性 ---

    方法 为根节点 <公开 静态 类型 = 逻辑型 注释 = "判断当前的JSON值是否为JSON文档的根节点" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.is_root()
    }

    方法 为同一文档 <公开 静态 类型 = 逻辑型 注释 = "判断两个JSON值是否由同一个JSON文档管理" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 欲比较的值 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.is_same_doc(@<欲比较的值>)
    }

    方法 取成员数 <公开 静态 类型 = 整数 注释 = "返回当前JSON值的内容长度." 注释 = "根据JSON值类型,可以是数组成员数、对象键值对数量、文本值长度." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ (INT)@<当前对象>.size()
    }

    方法 取类型 <公开 静态 类型 = 无符号字节 注释 = "获取当前JSON值的类型,请参考\"YYJSON类型\"的常量." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.type()
    }

    方法 取子类型 <公开 静态 类型 = 无符号字节 注释 = "获取当前JSON值的子类型,请参考\"YYJSON子类型\"的常量." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.subtype()
    }

    方法 取标签值 <公开 静态 类型 = 无符号字节 注释 = "获取当前JSON值的标签值,为\"YYJSON类型\"和\"YYJSON子类型\"的组合值."
            注释 = "如果JSON值是文本,还会组合文本长度." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.tag()
    }

    方法 取类型描述 <公开 静态 类型 = 文本型 注释 = "以文本返回当前JSON值类型的英文描述名称" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ PivU2Ws{@<当前对象>.desc()}.str
    }

    方法 是否为空 <公开 静态 类型 = 逻辑型 注释 = "返回当前的JSON值是否为空指针" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.empty_val()
    }

    方法 是否为原始值 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值的类型是否为原始值(用文本来表达数值)." 注释 = "注: 根据解析时的选项,部分或所有数字会被读取为原始文本值." 折叠
            @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.is_raw()
    }

    方法 是否为空值 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值的类型是否为\"空/null\"值." 注释 = "注: JSON空值不等于空指针." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.is_null()
    }

    方法 是否为逻辑型 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值得类型是否为逻辑值(bool)" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.is_bool()
    }

    方法 是否为数字 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值的类型是否为数字(有符号整数/无符号整数/小数)." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.is_num()
    }

    方法 是否为整数 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值得类型是否为有符号整数" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.is_sint()
    }

    方法 是否为无符号整数 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值得类型是否为无符号整数" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.is_uint()
    }

    方法 是否为小数 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值得类型是否为小数" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.is_real()
    }

    方法 是否为文本 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值得类型是否为文本" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.is_str()
    }

    方法 是否为数组 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值得类型是否为数组" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.is_arr()
    }

    方法 是否为对象 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值得类型是否为对象" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.is_obj()
    }

    方法 是否为容器 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值得类型是否为容器(数组/对象)" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.is_ctn()
    }

    # 获取JSON值 ---

    方法 取文本 <公开 静态 类型 = 文本型 注释 = "以文本型返回当前的JSON文本值." 注释 = "如果当前值为空或不是JSON文本值,将返回空文本." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ PivU2Ws{@<当前对象>.get_str()}.str
    }

    方法 取文本指针 <公开 静态 类型 = PIV.类型.字符串指针 注释 = "以字符串指针(const char*)返回当前的JSON文本值."
            注释 = "如果当前值为空或不是JSON文本值,将返回空指针." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.get_str()
    }

    方法 取标准文本 <公开 静态 类型 = 标准文本类U 注释 = "以标准文本类U返回当前的JSON文本值." 注释 = "如果当前值为空或不是JSON文本值,将返回空文本." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @dt<标准文本类U>{@<当前对象>.get_str()}
    }

    方法 取文本视图 <公开 静态 类型 = 文本视图类U 注释 = "以文本视图类U返回当前的JSON文本值." 注释 = "如果当前值为空或不是JSON文本值,将返回空视图." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @dt<文本视图类U>{@<当前对象>.get_str()}
    }

    方法 取整数 <公开 静态 类型 = 整数 注释 = "以整数返回当前的JSON数字值." 注释 = "如果当前值为空或不是JSON数字值,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.get_num<INT>()
    }

    方法 取长整数 <公开 静态 类型 = 长整数 注释 = "以长整数返回当前的JSON数字值." 注释 = "如果当前值为空或不是JSON数字值,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.get_num<INT64>()
    }

    方法 取小数 <公开 静态 类型 = 小数 注释 = "以小数返回当前的JSON数字值." 注释 = "如果当前值为空或不是JSON数字值,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.get_real()
    }

    方法 取数值 <公开 静态 注释 = "以指定的数值类型返回当前的JSON数字值." 注释 = "如果当前值为空或不是JSON数字值,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 数值类型 <注释 = "指定以何种类型返回JSON数字值,支持小数、有符号和无符号整数型." @需求类型 = 数据类型 @匹配类型 = 通用数值型 @返回值类型 = 0>
    {
        @ @<当前对象>.get_num<@<数值类型>>()
    }

    方法 取逻辑 <公开 静态 类型 = 逻辑型 注释 = "返回当前的JSON逻辑值." 注释 = "如果当前值为空或不是JSON逻辑值,将返回假." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.get_bool()
    }

    # JSON数组操作 ---

    方法 取数组成员数 <公开 静态 类型 = 整数 注释 = "返回当前JSON数组值的成员数,如果当前值类型不为数组则返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ (INT)@<当前对象>.arr_size()
    }

    方法 取首成员 <公开 静态 类型 = YYJSON只读值 注释 = "返回当前JSON数组的第一个成员值" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.arr_get_first()
    }

    方法 取尾成员 <公开 静态 类型 = YYJSON只读值 注释 = "返回当前JSON数组的最后一个成员值" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @<当前对象>.arr_get_last()
    }

    # JSON对象操作 ---

    方法 取键值数 <公开 静态 类型 = 整数 注释 = "返回当前JSON对象值的键值对数量,如果当前值类型不为对象则返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ (INT)@<当前对象>.obj_size()
    }

    方法 取所有键名 <公开 静态 类型 = 整数 注释 = "获取当前JSON对象值的所有键名,返回键名的数量." 注释 = "如果当前值类型不为对象或为空则返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 存放键名的数组 <类型 = 文本数组类 注释 = "获取的键名将存放在提供数组变量中">
    {
        @ (INT)@<当前对象>.eume_key(@<存放键名的数组>.data())
    }

    # 获取JSON成员值 ---

    方法 取成员 <公开 静态 类型 = YYJSON只读值 注释 = "访问指定索引或键名的JSON值,如果成员不存在则返回空值." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ @<当前对象>.get(@<成员位置>)
    }

    方法 取成员文本 <公开 静态 类型 = 文本型 注释 = "获取指定索引或键名的JSON文本值." 注释 = "如果找不到指定的成员或值类型不是文本,将返回空文本." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ PivU2Ws{@<当前对象>.get_str(@<成员位置>)}.str
    }

    方法 取成员文本指针 <公开 静态 类型 = PIV.类型.字符串指针 注释 = "获取指定索引或键名的JSON文本值." 注释 = "如果找不到指定的成员或值类型不是文本,将返回空指针." 折叠
            @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ @<当前对象>.get_str(@<成员位置>)
    }

    方法 取成员标准文本 <公开 静态 类型 = 标准文本类U 注释 = "获取指定索引或键名的JSON文本值." 注释 = "如果找不到指定的成员或值类型不是文本,将返回空文本." 折叠
            @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ @dt<标准文本类U>{@<当前对象>.get_str(@<成员位置>)}
    }

    方法 取成员文本视图 <公开 静态 类型 = 文本视图类U 注释 = "获取指定索引或键名的JSON文本值." 注释 = "如果找不到指定的成员或值类型不是文本,将返回空文本." 折叠
            @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ @dt<文本视图类U>{@<当前对象>.get_str(@<成员位置>)}
    }

    方法 取成员整数 <公开 静态 类型 = 整数 注释 = "获取指定索引或键名的JSON数字值,并转换到整数." 注释 = "如果找不到指定的成员或值类型不是数字,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ @<当前对象>.get_num<INT>(@<成员位置>)
    }

    方法 取成员长整数 <公开 静态 类型 = 长整数 注释 = "获取指定索引或键名的JSON数字值,并转换到长整数." 注释 = "如果找不到指定的成员或值类型不是数字,将返回0." 折叠
            @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):"
            注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8);" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ @<当前对象>.get_num<INT64>(@<成员位置>)
    }

    方法 取成员小数 <公开 静态 类型 = 小数 注释 = "获取指定索引或键名的JSON数字值,并转换到小数." 注释 = "如果找不到指定的成员或值类型不是数字,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):"
            注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8);" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ @<当前对象>.get_real(@<成员位置>)
    }

    方法 取成员数值 <公开 静态 注释 = "获取指定索引或键名的JSON数字值,并转换到指定的数值类型." 注释 = "如果找不到指定的成员或值类型不是数字,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 数值类型 <注释 = "指定以何种类型返回JSON数字值,支持小数、有符号和无符号整数型." @需求类型 = 数据类型 @匹配类型 = 通用数值型 @返回值类型 = 0>
    {
        @ @<当前对象>.get_num<@<数值类型>>(@<成员位置>)
    }

    方法 取成员逻辑 <公开 静态 类型 = 逻辑型 注释 = "获取指定索引或键名的JSON逻辑值." 注释 = "如果找不到指定的成员或值类型不是逻辑型,将返回假." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ @<当前对象>.get_bool(@<成员位置>)
    }

    # 获取JSON路径值 ---

    方法 取路径 <公开 静态 类型 = YYJSON只读值 注释 = "访问指定路径的JSON值,如果成员不存在则返回空值." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    {
        @ @<当前对象>.ptr(@<路径>, @<错误信息>)
    }

    方法 取路径文本 <公开 静态 类型 = 文本型 注释 = "获取指定路径的JSON文本值." 注释 = "如果找不到指定的成员或值类型不是文本,将返回空文本." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    {
        @ PivU2Ws{@<当前对象>.get_ptr_str(@<路径>, @<错误信息>)}.str
    }

    方法 取路径文本指针 <公开 静态 类型 = PIV.类型.字符串指针 注释 = "获取指定路径的JSON文本值." 注释 = "如果找不到指定的成员或值类型不是文本,将返回空指针." 折叠
            @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    {
        @ @<当前对象>.get_ptr_str(@<路径>, @<错误信息>)
    }

    方法 取路径标准文本 <公开 静态 类型 = 标准文本类U 注释 = "获取指定路径的JSON文本值." 注释 = "如果找不到指定的成员或值类型不是文本,将返回空文本." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    {
        @ @dt<标准文本类U>{@<当前对象>.get_ptr_str(@<路径>, @<错误信息>)}
    }

    方法 取路径文本视图 <公开 静态 类型 = 文本视图类U 注释 = "获取指定路径的JSON文本值." 注释 = "如果找不到指定的成员或值类型不是文本,将返回空文本." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    {
        @ @dt<文本视图类U>{@<当前对象>.get_ptr_str(@<路径>, @<错误信息>)}
    }

    方法 取路径整数 <公开 静态 类型 = 整数 注释 = "获取指定路径的JSON数字值,并转换到整数." 注释 = "如果找不到指定的成员或值类型不是数字,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    {
        @ @<当前对象>.get_ptr_num<INT>(@<路径>, @<错误信息>)
    }

    方法 取路径长整数 <公开 静态 类型 = 长整数 注释 = "获取指定路径的JSON数字值,并转换到长整数." 注释 = "如果找不到指定的成员或值类型不是数字,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    {
        @ @<当前对象>.get_ptr_num<INT64>(@<路径>, @<错误信息>)
    }

    方法 取路径小数 <公开 静态 类型 = 小数 注释 = "获取指定路径的JSON数字值,并转换到小数." 注释 = "如果找不到指定的成员或值类型不是数字,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    {
        @ @<当前对象>.get_ptr_real(@<路径>, @<错误信息>)
    }

    方法 取路径数值 <公开 静态 注释 = "获取指定路径的JSON数字值,并转换到指定的数值类型." 注释 = "如果找不到指定的成员或值类型不是数字,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 数值类型 <注释 = "指定以何种类型返回JSON数字值,支持小数、有符号和无符号整数型." @需求类型 = 数据类型 @匹配类型 = 通用数值型 @返回值类型 = 0>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    {
        @ @<当前对象>.get_ptr_num<@<数值类型>>(@<路径>, @<错误信息>)
    }

    方法 取路径逻辑 <公开 静态 类型 = 逻辑型 注释 = "获取指定路径的JSON逻辑值." 注释 = "如果找不到指定的成员或值类型不是逻辑型,将返回假." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON只读值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    {
        @ @<当前对象>.get_ptr_bool(@<路径>, @<错误信息>)
    }

    # 枚举循环 ---

    方法 枚举循环 <公开 静态 注释 = "启动一个循环来枚举当前JSON数组值中的每一个成员,或JSON对象值的每一个键值对." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = yyjson_iter\r\nhas_loop_body = true">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ for (auto &yyjson_iter : @<当前对象>)
    }

    方法 取枚举索引 <公开 静态 类型 = 整数 注释 = "返回当前所枚举到的JSON成员的索引." 注释 = "注: 只能在本类的\"枚举循环\"语句的子语句体中使用." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "parent = yyjson_iter">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ static_cast<INT>(yyjson_iter.idx)
    }

    方法 取枚举键 <公开 静态 类型 = YYJSON只读值 注释 = "返回当前所枚举到的JSON对象键名." 注释 = "注: 只能在本类的\"枚举循环\"语句的子语句体中使用." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "parent = yyjson_iter">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ yyjson_iter.get_key()
    }

    方法 取枚举键文本 <公开 静态 类型 = 文本型 注释 = "用\"文本型\"返回当前所枚举到的JSON对象键名." 注释 = "注: 只能在本类的\"枚举循环\"语句的子语句体中使用." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "parent = yyjson_iter">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ PivU2Ws{yyjson_iter.get_key_str()}.str
    }

    方法 取枚举键文本指针 <公开 静态 类型 = PIV.类型.字符串指针 注释 = "用字符串指针(const char*)返回当前所枚举到的JSON对象键名."
            注释 = "注: 只能在本类的\"枚举循环\"语句的子语句体中使用." 折叠 隐藏值属性 = "0" @嵌入式方法 = "parent = yyjson_iter">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ yyjson_iter.get_key_str()
    }

    方法 取枚举键标准文本 <公开 静态 类型 = 标准文本类U 注释 = "用\"标准文本类U\"返回当前所枚举到的JSON对象键名." 注释 = "注: 只能在本类的\"枚举循环\"语句的子语句体中使用."
            折叠 隐藏值属性 = "0" @嵌入式方法 = "parent = yyjson_iter">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ @dt<标准文本类U>{yyjson_iter.get_key_str()}
    }

    方法 取枚举值 <公开 静态 类型 = YYJSON只读值 注释 = "返回当前所枚举到的(JSON对象/JSON数组)成员值." 注释 = "注: 只能在本类的\"枚举循环\"语句的子语句体中使用."
            折叠 隐藏值属性 = "0" @嵌入式方法 = "parent = yyjson_iter">
    参数 当前对象 <类型 = YYJSON只读值>
    {
        @ yyjson_iter.get_val()
    }
}

类 YYJSON值 <公开 注释 = "本类同时支持解析与构造JSON内容,但比\"YYJSON只读值\"稍慢."
        注释 = " 1. 内部以智能指针管理\"YYJSON可变文档\",允许多个实例操作同一JSON文档;" 注释 = " 2. 默认为参考赋值,赋值后左值指向的数据跟右值一样;"
        注释 = " 3. 如需复制赋值(深拷贝),请在左值使用\"复制\"方法;" 折叠 隐藏值属性 = "0" @文档 = "category = \"JSON支持.YYJSON\""
        @别名 = "piv_yyjson_mut_val" @别名类型 = 火山类>
{

    # 全局方法 ---

    方法 取版本号 <公开 静态 类型 = 整数 注释 = "返回YYJSON的版本号,版本号编码方式:" 注释 = "(major << 16) | (minor << 8) | (patch)" 折叠
            @嵌入式方法 = "">
    {
        @ (INT)yyjson_version()
    }

    方法 取版本信息 <公开 静态 类型 = 文本型 注释 = "返回YYJSON的文本版本号" 折叠 @嵌入式方法 = "">
    {
        @ @an<CVolString>{YYJSON_VERSION_STRING}
    }

    # 解析/反序列化JSON文档 ---

    方法 解析 <公开 静态 类型 = 逻辑型 注释 = "解析所有支持的JSON文档数据,返回是否解析成功." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 JSON数据 <注释 = "所欲解析的JSON文本数据,支持类型(带*号表示会转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8编码)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 解析标志位 <类型 = YYJSON解析选项 注释 = "为\"YYJSON解析选项\"常量的位或组合值" @默认值 = YYJSON解析选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON文档的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    参数 错误信息 <类型 = YYJSON解析错误 注释 = "若提供非空指针,可在解析失败时返回错误信息." @默认值 = YYJSON解析错误.空指针>
    {
        @ @<当前对象>.parse(@<JSON数据>, @<解析标志位>, @<内存分配器>, @<错误信息>)
    }

    方法 解析内存 <公开 静态 类型 = 逻辑型 注释 = "解析内存中的JSON文档数据,返回是否解析成功." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 JSON数据指针 <注释 = "所欲解析的JSON数据地址,其内容必须为UTF-8编码的文本数据" @匹配类型 = 通用数值型>
    参数 JSON数据长度 <注释 = "JSON数据的字节长度" @匹配类型 = 通用数值型>
    参数 解析标志位 <类型 = YYJSON解析选项 注释 = "为\"YYJSON解析选项\"常量的位或组合值" @默认值 = YYJSON解析选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON文档的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    参数 错误信息 <类型 = YYJSON解析错误 注释 = "若提供非空指针,可在解析失败时返回错误信息." @默认值 = YYJSON解析错误.空指针>
    {
        @ @<当前对象>.parse_doc(reinterpret_cast<const char*>(@<JSON数据指针>), static_cast<size_t>(@<JSON数据长度>), @<解析标志位>, @<内存分配器>, @<错误信息>)
    }

    方法 解析文件 <公开 静态 类型 = 逻辑型 注释 = "解析指定路径的UTF-8编码JSON文件,返回是否解析成功." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 文件路径 <类型 = 文本型 注释 = "JSON文件的完整路径">
    参数 解析标志位 <类型 = YYJSON解析选项 注释 = "为\"YYJSON解析选项\"常量的位或组合值" @默认值 = YYJSON解析选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON文档的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    参数 错误信息 <类型 = YYJSON解析错误 注释 = "若提供非空指针,可在解析失败时返回错误信息." @默认值 = YYJSON解析错误.空指针>
    {
        @ @<当前对象>.parse_file(@<文件路径>.GetText(), @<解析标志位>, @<内存分配器>, @<错误信息>)
    }

    方法 复制 <公开 静态 类型 = YYJSON值 注释 = "将另一个JSON值深拷贝到当前对象,然后返回当前对象自身." 注释 = "注: 当前对象将释放原先数据的所有权." 折叠
            @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值 注释 = "左值">
    参数 欲复制对象 <类型 = YYJSON值 注释 = "右值,所欲复制的JSON值.">
    {
        @ @<当前对象>.copy(@<欲复制对象>)
    }

    # 序列化JSON文档 ---

    方法 到可读文本 <公开 静态 类型 = 文本型 注释 = "将整个JSON文档序列化为字符串,并转换到文本型." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 序列化标志位 <类型 = YYJSON序列化选项 注释 = "为\"YYJSON序列化选项\"常量的位或组合值" @默认值 = YYJSON序列化选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON序列化时使用的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    参数 错误信息 <类型 = YYJSON序列化错误 注释 = "若提供非空指针,可在序列化失败时返回错误信息." @默认值 = YYJSON序列化错误.空指针>
    {
        @ @<当前对象>.write_vol_str(@<序列化标志位>, @<内存分配器>, @<错误信息>)
    }

    方法 到可读标准文本 <公开 静态 类型 = 标准文本类U 注释 = "将整个JSON文档序列化为字符串,返回到标准文本类U." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 序列化标志位 <类型 = YYJSON序列化选项 注释 = "为\"YYJSON序列化选项\"常量的位或组合值" @默认值 = YYJSON序列化选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON序列化时使用的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    参数 错误信息 <类型 = YYJSON序列化错误 注释 = "若提供非空指针,可在序列化失败时返回错误信息." @默认值 = YYJSON序列化错误.空指针>
    {
        @ @<当前对象>.write_std_str(@<序列化标志位>, @<内存分配器>, @<错误信息>)
    }

    方法 到字节集 <公开 静态 类型 = 字节集类 注释 = "将整个JSON文档序列化为字符串,返回到字节集类(UTF-8编码)." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 序列化标志位 <类型 = YYJSON序列化选项 注释 = "为\"YYJSON序列化选项\"常量的位或组合值" @默认值 = YYJSON序列化选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON序列化时使用的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    参数 错误信息 <类型 = YYJSON序列化错误 注释 = "若提供非空指针,可在序列化失败时返回错误信息." @默认值 = YYJSON序列化错误.空指针>
    {
        @ @<当前对象>.write_vol_mem(@<序列化标志位>, @<内存分配器>, @<错误信息>)
    }

    方法 写出文件 <公开 静态 类型 = 逻辑型 注释 = "将整个JSON文档写出到文件(UTF-8编码),返回是否成功." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 文件名称 <类型 = 文本型 注释 = "请提供完整的文件路径,路径的中间目录必须已经存在;" 注释 = "如果文件不存在将自动创建,文件已存在则覆盖原先的数据.">
    参数 序列化标志位 <类型 = YYJSON序列化选项 注释 = "为\"YYJSON序列化选项\"常量的位或组合值" @默认值 = YYJSON序列化选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON序列化时使用的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    参数 错误信息 <类型 = YYJSON序列化错误 注释 = "若提供非空指针,可在序列化失败时返回错误信息." @默认值 = YYJSON序列化错误.空指针>
    {
        @ @<当前对象>.write_file(@<文件名称>.GetText(), @<序列化标志位>, @<内存分配器>, @<错误信息>)
    }

    # 序列化JSON值 ---

    方法 到文本 <公开 静态 类型 = 文本型 注释 = "将当前JSON值序列化为字符串,并转换到文本型." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 序列化标志位 <类型 = YYJSON序列化选项 注释 = "为\"YYJSON序列化选项\"常量的位或组合值" @默认值 = YYJSON序列化选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON序列化时使用的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    {
        @ @<当前对象>.to_vol_str(@<序列化标志位>, @<内存分配器>)
    }

    方法 到标准文本 <公开 静态 类型 = 标准文本类U 注释 = "将当前JSON值序列化为字符串,返回到标准文本类U." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 序列化标志位 <类型 = YYJSON序列化选项 注释 = "为\"YYJSON序列化选项\"常量的位或组合值" @默认值 = YYJSON序列化选项.默认>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON序列化时使用的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    {
        @ @<当前对象>.to_std_str(@<序列化标志位>, @<内存分配器>)
    }

    # 转换 ---

    方法 到只读文档 <公开 静态 类型 = YYJSON只读值 注释 = "将整个JSON文档转换到\"JSON只读值\"." 注释 = "注: 本方法会进行深拷贝." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON文档的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    {
        @ @<当前对象>.to_imut_doc(@<内存分配器>)
    }

    方法 到只读值 <公开 静态 类型 = YYJSON只读值 注释 = "将当前的JSON值转换到\"JSON只读值\"." 注释 = "注: 本方法会进行深拷贝." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 内存分配器 <类型 = YYJSON分配器 注释 = "提供JSON文档的内存分配器" @默认值 = YYJSON分配器.偏好设置>
    {
        @ @<当前对象>.to_imut_val(@<内存分配器>)
    }

    # JSON文档属性 ---

    方法 为空文档 <公开 静态 类型 = 逻辑型 注释 = "返回当前的JSON文档是否为空" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.empty()
    }

    方法 置文本池大小 <公开 静态 类型 = 逻辑型 注释 = "设置JSON文档的文本池大小." 注释 = "本功能不会立即分配内存,而是在下次分配内存时使用设置的大小."
            注释 = "如果你知道文档大致需要多少字节来存储文本数据,设置一个更大的" 注释 = "数值可以避免多次分配内存和提高效率." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 大小 <注释 = "字节单位" @匹配类型 = 通用整数型>
    {
        @ @<当前对象>.set_str_pool_size(static_cast<size_t>(@<大小>))
    }

    方法 置值池大小 <公开 静态 类型 = 逻辑型 注释 = "设置JSON文档的JSON值池大小." 注释 = "本功能不会立即分配内存,而是在下次分配内存时使用设置的大小."
            注释 = "如果你知道文档大致有多少个JSON值,以此设置一个更大的数值" 注释 = "可以避免多次分配内存和提高效率." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 容量 <注释 = "以JSON值的数量为单位,每个键名和值都是一个JSON值." @匹配类型 = 通用整数型>
    {
        @ @<当前对象>.set_val_pool_size(static_cast<size_t>(@<容量>))
    }

    # JSON值属性 ---

    方法 为根节点 <公开 静态 类型 = 逻辑型 注释 = "判断当前的JSON值是否为JSON文档的根节点" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.is_root()
    }

    方法 为同一文档 <公开 静态 类型 = 逻辑型 注释 = "判断两个JSON值是否由同一个JSON文档管理" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 欲比较的值 <类型 = YYJSON值>
    {
        @ @<当前对象>.is_same_doc(@<欲比较的值>)
    }

    方法 取成员数 <公开 静态 类型 = 整数 注释 = "返回当前JSON值的内容长度." 注释 = "根据JSON值类型,可以是数组成员数、对象键值对数量、文本值长度." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ (INT)@<当前对象>.size()
    }

    方法 取类型 <公开 静态 类型 = 无符号字节 注释 = "获取当前JSON值的类型,请参考\"YYJSON类型\"的常量." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.type()
    }

    方法 取子类型 <公开 静态 类型 = 无符号字节 注释 = "获取当前JSON值的子类型,请参考\"YYJSON子类型\"的常量." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.subtype()
    }

    方法 取标签值 <公开 静态 类型 = 无符号字节 注释 = "获取当前JSON值的标签值,为\"YYJSON类型\"和\"YYJSON子类型\"的组合值."
            注释 = "如果JSON值是文本,还会组合文本长度." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.tag()
    }

    方法 取类型描述 <公开 静态 类型 = 文本型 注释 = "以文本返回当前JSON值类型的英文描述名称" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ PivU2Ws{@<当前对象>.desc()}.str
    }

    方法 是否为空 <公开 静态 类型 = 逻辑型 注释 = "返回当前的JSON值是否为空指针" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.empty_val()
    }

    方法 是否为原始值 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值的类型是否为原始值(用文本来表达数值).." 注释 = "注: 根据解析时的选项,部分或所有数字会被读取为原始文本值."
            折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.is_raw()
    }

    方法 是否为空值 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值的类型是否为\"空/null\"值." 注释 = "注: JSON空值不等于空指针." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.is_null()
    }

    方法 是否为逻辑型 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值得类型是否为逻辑值(bool)" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.is_bool()
    }

    方法 是否为数字 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值的类型是否为数字(有符号整数/无符号整数/小数)." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.is_num()
    }

    方法 是否为整数 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值得类型是否为有符号整数" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.is_sint()
    }

    方法 是否为无符号整数 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值得类型是否为无符号整数" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.is_uint()
    }

    方法 是否为小数 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值得类型是否为小数" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.is_real)
    }

    方法 是否为文本 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值得类型是否为文本" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.is_str()
    }

    方法 是否为数组 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值得类型是否为数组" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.is_arr()
    }

    方法 是否为对象 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值得类型是否为对象" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.is_obj()
    }

    方法 是否为容器 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值得类型是否为容器(数组/对象)" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.is_ctn()
    }

    # 获取JSON值 ---

    方法 取文本 <公开 静态 类型 = 文本型 注释 = "以文本型返回当前的JSON文本值." 注释 = "如果当前值为空或不是JSON文本值,将返回空文本." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ PivU2Ws{@<当前对象>.get_str()}.str
    }

    方法 取文本指针 <公开 静态 类型 = PIV.类型.字符串指针 注释 = "以字符串指针(const char*)返回当前的JSON文本值."
            注释 = "如果当前值为空或不是JSON文本值,将返回空指针." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.get_str()
    }

    方法 取标准文本 <公开 静态 类型 = 标准文本类U 注释 = "以标准文本类U返回当前的JSON文本值." 注释 = "如果当前值为空或不是JSON文本值,将返回空文本." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @dt<标准文本类U>{@<当前对象>.get_str()}
    }

    方法 取文本视图 <公开 静态 类型 = 文本视图类U 注释 = "以文本视图类U返回当前的JSON文本值." 注释 = "如果当前值为空或不是JSON文本值,将返回空视图." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @dt<文本视图类U>{@<当前对象>.get_str()}
    }

    方法 取整数 <公开 静态 类型 = 整数 注释 = "以整数返回当前的JSON数字值." 注释 = "如果当前值为空或不是JSON数字值,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.get_num<INT>()
    }

    方法 取长整数 <公开 静态 类型 = 长整数 注释 = "以长整数返回当前的JSON数字值." 注释 = "如果当前值为空或不是JSON数字值,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.get_num<INT64>()
    }

    方法 取小数 <公开 静态 类型 = 小数 注释 = "以小数返回当前的JSON数字值." 注释 = "如果当前值为空或不是JSON数字值,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.get_real()
    }

    方法 取数值 <公开 静态 注释 = "以指定的数值类型返回当前的JSON数字值." 注释 = "如果当前值为空或不是JSON数字值,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 数值类型 <注释 = "指定以何种类型返回JSON数字值,支持小数、有符号和无符号整数型." @需求类型 = 数据类型 @匹配类型 = 通用数值型 @返回值类型 = 0>
    {
        @ @<当前对象>.get_num<@<数值类型>>()
    }

    方法 取逻辑 <公开 静态 类型 = 逻辑型 注释 = "返回当前的JSON逻辑值." 注释 = "如果当前值为空或不是JSON逻辑值,将返回假." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.get_bool()
    }

    # JSON数组操作 ---

    方法 取数组成员数 <公开 静态 类型 = 整数 注释 = "返回当前JSON数组值的成员数,如果当前值类型不为数组则返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ (INT)@<当前对象>.arr_size()
    }

    方法 取首成员 <公开 静态 类型 = YYJSON值 注释 = "返回当前JSON数组的第一个成员值" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.arr_get_first()
    }

    方法 取尾成员 <公开 静态 类型 = YYJSON值 注释 = "返回当前JSON数组的最后一个成员值" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.arr_get_last()
    }

    方法 加入成员 <公开 静态 类型 = 逻辑型 注释 = "在当前JSON数组的尾部加入一或多个值,返回是否成功." 注释 = "注意: 本方法默认深拷贝成员值,如需浅拷贝请使用\"加入尾成员\"." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "req_cpp_bool = true">
    参数 当前对象 <类型 = YYJSON值>
    参数 值 <注释 = "所欲加入的值,支持类型(带*号的必会深拷贝):" 注释 = " 通用数值型、无符号型、逻辑型" 注释 = " *JSON只读值、JSON值"
            注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @<当前对象>.append(true, @<值>)
    }

    方法 加入首成员 <公开 静态 类型 = 逻辑型 注释 = "在当前JSON数组的首部加入单个值,返回是否成功." 注释 = "如果当前类型不是JSON数组则返回失败." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_cpp_bool = true">
    参数 当前对象 <类型 = YYJSON值>
    参数 值 <注释 = "所欲加入的值,支持类型(带*号的必会深拷贝):" 注释 = " 通用数值型、无符号型、逻辑型" 注释 = " *JSON只读值、JSON值"
            注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 深拷贝 <类型 = 逻辑型 注释 = "指定是否将文本、对象、数组等类型的数据拷贝到本JSON文档;" 注释 = "如果为假,必须确保该值的作用域大于或等于当前对象,"
            注释 = "且同一个对象/数组值应该仅浅拷贝一次,否则可能出现成员值丢失的情况." @默认值 = 真>
    {
        @ @<当前对象>.prepend(@<深拷贝>, @<值>)
    }

    方法 加入尾成员 <公开 静态 类型 = 逻辑型 注释 = "在当前JSON数组的尾部加入单个值,返回是否成功." 注释 = "如果当前类型不是JSON数组则返回失败." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_cpp_bool = true">
    参数 当前对象 <类型 = YYJSON值>
    参数 值 <注释 = "所欲加入的值,支持类型(带*号的必会深拷贝):" 注释 = " 通用数值型、无符号型、逻辑型" 注释 = " *JSON只读值、JSON值"
            注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 深拷贝 <类型 = 逻辑型 注释 = "指定是否将文本、对象、数组等类型的数据拷贝到本JSON文档;" 注释 = "如果为假,必须确保该值的作用域大于或等于当前对象,"
            注释 = "且同一个对象/数组值应该仅浅拷贝一次,否则可能出现成员值丢失的情况." @默认值 = 真>
    {
        @ @<当前对象>.append(@<深拷贝>, @<值>)
    }

    方法 插入成员 <公开 静态 类型 = 逻辑型 注释 = "在当前JSON数组的指定索引位置插入值,返回是否成功." 注释 = "如果当前类型不是JSON数组则返回失败." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_cpp_bool = true">
    参数 当前对象 <类型 = YYJSON值>
    参数 索引位置 <注释 = "所欲插入的数组索引位置,必须大于等于0且小于数组成员数." @匹配类型 = 通用整数型>
    参数 值 <注释 = "所欲插入的值,支持类型(带*号的必会深拷贝):" 注释 = " 通用数值型、无符号型、逻辑型" 注释 = " *JSON只读值、JSON值"
            注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 深拷贝 <类型 = 逻辑型 注释 = "指定是否将文本、对象、数组等类型的数据拷贝到本JSON文档;" 注释 = "如果为假,必须确保该值的作用域大于或等于当前对象,"
            注释 = "且同一个对象/数组值应该仅浅拷贝一次,否则可能出现成员值丢失的情况." @默认值 = 真>
    {
        @ @<当前对象>.arr_insert(static_cast<size_t>(@<索引位置>), @<值>, @<深拷贝>)
    }

    方法 替换成员 <公开 静态 类型 = YYJSON值 注释 = "替换掉当前JSON数组中指定索引位置的成员值,然后返回被替换的先前值."
            注释 = "如果值类型不是数组或索引超范围,则返回空指针(用\"是否为空\"判断)." 注释 = "注意:"
            注释 = " 1. \"置成员值\"是原位修改值指针的内容,\"替换成员\"是替换掉值指针," 注释 = "先前值依旧有效,只是不能在JSON文档中索引出来;"
            注释 = " 2. 被替换的旧值要等到JSON文档被销毁才会被释放." 返回值注释 = "返回被替换掉的JSON值" 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_cpp_bool = true">
    参数 当前对象 <类型 = YYJSON值>
    参数 索引位置 <注释 = "所欲替换的数组索引位置,必须大于等于0且小于数组成员数." @匹配类型 = 通用整数型>
    参数 值 <注释 = "用于替换的值,支持类型(带*号的必会深拷贝):" 注释 = " 通用数值型、无符号型、逻辑型" 注释 = " *JSON只读值、JSON值"
            注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 深拷贝 <类型 = 逻辑型 注释 = "指定是否将文本、对象、数组等类型的数据拷贝到本JSON文档;" 注释 = "如果为假,必须确保该值的作用域大于或等于当前对象,"
            注释 = "且同一个对象/数组值应该仅浅拷贝一次,否则可能出现成员值丢失的情况." @默认值 = 真>
    {
        @ @<当前对象>.arr_replace(static_cast<size_t>(@<索引位置>), @<值>, @<深拷贝>)
    }

    方法 删除成员 <公开 静态 类型 = YYJSON值 注释 = "将指定索引位置的成员值从当前JSON数组中删除,然后返回被删除的值."
            注释 = "如果值类型不是数组或索引超范围,则返回空指针(用\"是否为空\"判断)." 注释 = "注: 被删除的值要等到JSON文档被销毁才会被释放." 返回值注释 = "返回被删除的JSON值"
            折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 索引位置 <注释 = "所欲删除的数组索引位置,必须大于等于0且小于数组成员数." @匹配类型 = 通用整数型>
    {
        @ @<当前对象>.arr_remove(static_cast<size_t>(@<索引位置>))
    }

    方法 删除首成员 <公开 静态 类型 = YYJSON值 注释 = "删除JSON数组的第一个成员,然后将它返回." 注释 = "如果值类型不是数组或数组为空,则返回空指针(用\"是否为空\"判断)."
            注释 = "注: 被删除的值要等到JSON文档被销毁才会被释放." 返回值注释 = "返回被删除的JSON值" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.remove_first()
    }

    方法 删除尾成员 <公开 静态 类型 = YYJSON值 注释 = "删除JSON数组的最后一个成员,然后将它返回." 注释 = "如果值类型不是数组或数组为空,则返回空指针(用\"是否为空\"判断)."
            注释 = "注: 被删除的值要等到JSON文档被销毁才会被释放." 返回值注释 = "返回被删除的JSON值" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.remove_last()
    }

    方法 删除范围成员 <公开 静态 类型 = 逻辑型 注释 = "将指定索引范围的一或多个成员值从当前JSON数组中删除,返回是否删除成功."
            注释 = "注: 被删除的值要等到JSON文档被销毁才会被释放." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 起始索引 <注释 = "所欲删除的起始数组索引位置,必须大于等于0且小于数组成员数." @匹配类型 = 通用整数型>
    参数 删除数量 <注释 = "所欲删除的成员数量,起始索引+删除数量不能大于数组成员数." @匹配类型 = 通用整数型>
    {
        @ @<当前对象>.arr_remove(static_cast<size_t>(@<起始索引>), static_cast<size_t>(@<删除数量>))
    }

    方法 清空数组 <公开 静态 类型 = 逻辑型 注释 = "删除当前JSON数组的所有成员,如果值类型不是数组则返回假." 注释 = "注: 被删除的值要等到JSON文档被销毁才会被释放." 折叠
            @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.arr_clear()
    }

    方法 旋转数组 <公开 静态 类型 = 逻辑型 注释 = "将当前JSON数组的成员向左旋转指定的成员数,返回是否成功." 注释 = "例: 旋转2次即将数组前两个成员移动到数组尾部." 折叠
            @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 旋转数量 <注释 = "向左旋转的成员数量,必须大于等于0且小于数组成员数." @匹配类型 = 通用整数型>
    {
        @ @<当前对象>.arr_rotate(static_cast<size_t>(@<旋转数量>))
    }

    # JSON对象(键值对)操作 ---

    方法 取键值数 <公开 静态 类型 = 整数 注释 = "返回当前JSON对象值的键值对数量,如果当前值类型不为对象则返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ (INT)@<当前对象>.obj_size()
    }

    方法 取所有键名 <公开 静态 类型 = 整数 注释 = "获取当前JSON对象值的所有键名,返回键名的数量." 返回值注释 = "如果当前值类型不为对象或为空则返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 存放键名的数组 <类型 = 文本数组类 注释 = "获取的键名将存放在此数组变量中">
    {
        @ (INT)@<当前对象>.eume_key(@<存放键名的数组>.data())
    }

    方法 置入键值 <公开 静态 类型 = 逻辑型 注释 = "在当前JSON对象中置入键值对,返回是否成功." 返回值注释 = "如果当前类型不是JSON对象则返回失败." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_cpp_bool = true">
    参数 当前对象 <类型 = YYJSON值>
    参数 键名 <注释 = "所欲置入的键名,支持类型(带*号的必会深拷贝):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W"
            @匹配类型 = 通用型>
    参数 值 <注释 = "所欲置入的值,支持类型(带*号的必会深拷贝):" 注释 = " 通用数值型、无符号型、逻辑型" 注释 = " *JSON只读值、JSON值"
            注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 深拷贝 <类型 = 逻辑型 注释 = "指定是否将文本、对象、数组等类型的数据拷贝到本JSON文档;" 注释 = "如果为假,必须确保该值的作用域大于或等于当前对象,"
            注释 = "且同一个对象/数组值应该仅浅拷贝一次,否则可能出现成员值丢失的情况." @默认值 = 真>
    参数 覆盖模式 <类型 = 逻辑型 注释 = "如果对象中已经存在相同的键名,是否覆盖其中的值;" 注释 = "如果为假,JSON对象将出现键名重复的键值对(非标准JSON格式,不推荐)."
            @默认值 = 真>
    {
        @ @<当前对象>.add(@<键名>, @<值>, @<深拷贝>, @<覆盖模式>)
    }

    方法 替换键值 <公开 静态 类型 = 逻辑型 注释 = "替换JSON对象中指定键名的值,返回是否成功." 注释 = "注: 被替换的旧值要等到JSON文档被销毁才会被释放." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "req_cpp_bool = true">
    参数 当前对象 <类型 = YYJSON值>
    参数 键名 <注释 = "所欲替换值的键名,支持类型(带*号的必会深拷贝):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W"
            @匹配类型 = 通用型>
    参数 值 <注释 = "用于替换的值,支持类型(带*号的必会深拷贝):" 注释 = " 通用数值型、无符号型、逻辑型" 注释 = " *JSON只读值、JSON值"
            注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 深拷贝 <类型 = 逻辑型 注释 = "指定是否将文本、对象、数组等类型的数据拷贝到本JSON文档;" 注释 = "如果为假,必须确保该值的作用域大于或等于当前对象,"
            注释 = "且同一个对象/数组值应该仅浅拷贝一次,否则可能出现成员值丢失的情况." @默认值 = 真>
    {
        @ @<当前对象>.obj_replace(@<键名>, @<值>, @<深拷贝>)
    }

    方法 删除键名 <公开 静态 类型 = YYJSON值 注释 = "从JSON对象中删除匹配指定键名的所有键值对,返回第一个匹配的值."
            注释 = "如果值类型不是对象或未找到指定键名,则返回空指针(用\"是否为空\"判断)." 注释 = "注: 被删除的值要等到JSON文档被销毁才会被释放." 返回值注释 = "返回被删除的JSON值"
            折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 键名 <注释 = "所欲删除的键名,支持类型(带*号的必会深拷贝):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W"
            @匹配类型 = 通用型>
    {
        @ @<当前对象>.obj_remove(@<键名>)
    }

    方法 更改键名 <公开 静态 类型 = 逻辑型 注释 = "将JSON对象中所有匹配的指定键名替换为新键名,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 旧键名 <注释 = "所欲更改的键名,支持类型(带*号的必会深拷贝):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W"
            @匹配类型 = 通用型>
    参数 新键名 <注释 = "提供新的键名,支持类型同上." @匹配类型 = 通用型>
    {
        @ @<当前对象>.obj_rename(@<旧键名>, @<新键名>)
    }

    方法 清空对象 <公开 静态 类型 = 逻辑型 注释 = "删除当前JSON对象的所有键值对,如果值类型不是对象则返回假." 注释 = "注: 被删除的值要等到JSON文档被销毁才会被释放." 折叠
            @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.obj_clear()
    }

    方法 旋转对象 <公开 静态 类型 = 逻辑型 注释 = "将当前JSON对象的键值对向左旋转指定的次数,返回是否成功." 注释 = "例: 旋转2次即将对象前两个键值对移动到对象尾部." 折叠
            @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 旋转数量 <注释 = "向左旋转的键值对数量,必须大于等于0且小于对象键值数." @匹配类型 = 通用整数型>
    {
        @ @<当前对象>.obj_rotate(static_cast<size_t>(@<旋转数量>))
    }

    # 获取JSON成员值 ---

    方法 取成员 <公开 静态 类型 = YYJSON值 注释 = "访问指定索引或键名的JSON值,如果成员不存在则返回空值." 返回值注释 = "支持链式语法" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 成员位置 <注释 = "支持整数值的数组索引,或文本值的对象键名;" 注释 = "其中键名支持以下类型(带*号表示会转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " 文本型、标准文本类W、文本视图类W" @匹配类型 = 通用型>
    {
        @ @<当前对象>.get(@<成员位置>)
    }

    方法 取成员文本 <公开 静态 类型 = 文本型 注释 = "获取指定索引或键名的JSON文本值." 注释 = "如果找不到指定的成员或值类型不是文本,将返回空文本." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ PivU2Ws{@<当前对象>.get_str(@<成员位置>)}.str
    }

    方法 取成员文本指针 <公开 静态 类型 = PIV.类型.字符串指针 注释 = "获取指定索引或键名的JSON文本值." 注释 = "如果找不到指定的成员或值类型不是文本,将返回空指针." 折叠
            @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ @<当前对象>.get_str(@<成员位置>)
    }

    方法 取成员标准文本 <公开 静态 类型 = 标准文本类U 注释 = "获取指定索引或键名的JSON文本值." 注释 = "如果找不到指定的成员或值类型不是文本,将返回空文本." 折叠
            @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ @dt<标准文本类U>{@<当前对象>.get_str(@<成员位置>)}
    }

    方法 取成员文本视图 <公开 静态 类型 = 文本视图类U 注释 = "获取指定索引或键名的JSON文本值." 注释 = "如果找不到指定的成员或值类型不是文本,将返回空文本." 折叠
            @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ @dt<文本视图类U>{@<当前对象>.get_str(@<成员位置>)}
    }

    方法 取成员整数 <公开 静态 类型 = 整数 注释 = "获取指定索引或键名的JSON数字值,并转换到整数." 注释 = "如果找不到指定的成员或值类型不是数字,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ @<当前对象>.get_num<INT>(@<成员位置>)
    }

    方法 取成员长整数 <公开 静态 类型 = 长整数 注释 = "获取指定索引或键名的JSON数字值,并转换到长整数." 注释 = "如果找不到指定的成员或值类型不是数字,将返回0." 折叠
            @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ @<当前对象>.get_num<INT64>(@<成员位置>)
    }

    方法 取成员小数 <公开 静态 类型 = 小数 注释 = "获取指定索引或键名的JSON数字值,并转换到小数." 注释 = "如果找不到指定的成员或值类型不是数字,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ @<当前对象>.get_real(@<成员位置>)
    }

    方法 取成员数值 <公开 静态 注释 = "获取指定索引或键名的JSON数字值,并转换到指定的数值类型." 注释 = "如果找不到指定的成员或值类型不是数字,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 数值类型 <注释 = "指定以何种类型返回JSON数字值,支持小数、有符号和无符号整数型." @需求类型 = 数据类型 @匹配类型 = 通用数值型 @返回值类型 = 0>
    {
        @ @<当前对象>.get_num<@<数值类型>>(@<成员位置>)
    }

    方法 取成员逻辑 <公开 静态 类型 = 逻辑型 注释 = "获取指定索引或键名的JSON逻辑值." 注释 = "如果找不到指定的成员或值类型不是逻辑型,将返回假." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 成员位置 <注释 = "支持通用整数型的数组索引,或文本值的对象键名;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ @<当前对象>.get_bool(@<成员位置>)
    }

    # 获取JSON路径值 ---

    方法 取路径 <公开 静态 类型 = YYJSON值 注释 = "访问指定路径的JSON值,如果成员不存在则返回空值." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    参数 路径上下文 <类型 = YYJSON路径上下文 注释 = "提供非空指针时,将返回JSON路径的上下文." @默认值 = YYJSON路径上下文.空指针>
    {
        @ @<当前对象>.ptr(@<路径>, @<错误信息>, @<路径上下文>)
    }

    方法 取路径文本 <公开 静态 类型 = 文本型 注释 = "获取指定路径的JSON文本值." 注释 = "如果找不到指定的成员或值类型不是文本,将返回空文本." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    参数 路径上下文 <类型 = YYJSON路径上下文 注释 = "提供非空指针时,将返回JSON路径的上下文." @默认值 = YYJSON路径上下文.空指针>
    {
        @ PivU2Ws{@<当前对象>.get_ptr_str(@<路径>, @<错误信息>, @<路径上下文>)}.str
    }

    方法 取路径文本指针 <公开 静态 类型 = PIV.类型.字符串指针 注释 = "获取指定路径的JSON文本值." 注释 = "如果找不到指定的成员或值类型不是文本,将返回空指针." 折叠
            @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    参数 路径上下文 <类型 = YYJSON路径上下文 注释 = "提供非空指针时,将返回JSON路径的上下文." @默认值 = YYJSON路径上下文.空指针>
    {
        @ @<当前对象>.get_ptr_str(@<路径>, @<错误信息>, @<路径上下文>)
    }

    方法 取路径标准文本 <公开 静态 类型 = 标准文本类U 注释 = "获取指定路径的JSON文本值." 注释 = "如果找不到指定的成员或值类型不是文本,将返回空文本." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    参数 路径上下文 <类型 = YYJSON路径上下文 注释 = "提供非空指针时,将返回JSON路径的上下文." @默认值 = YYJSON路径上下文.空指针>
    {
        @ @dt<标准文本类U>{@<当前对象>.get_ptr_str(@<路径>, @<错误信息>, @<路径上下文>)}
    }

    方法 取路径文本视图 <公开 静态 类型 = 文本视图类U 注释 = "获取指定路径的JSON文本值." 注释 = "如果找不到指定的成员或值类型不是文本,将返回空文本." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    参数 路径上下文 <类型 = YYJSON路径上下文 注释 = "提供非空指针时,将返回JSON路径的上下文." @默认值 = YYJSON路径上下文.空指针>
    {
        @ @dt<文本视图类U>{@<当前对象>.get_ptr_str(@<路径>, @<错误信息>, @<路径上下文>)}
    }

    方法 取路径整数 <公开 静态 类型 = 整数 注释 = "获取指定路径的JSON数字值,并转换到整数." 注释 = "如果找不到指定的成员或值类型不是数字,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    参数 路径上下文 <类型 = YYJSON路径上下文 注释 = "提供非空指针时,将返回JSON路径的上下文." @默认值 = YYJSON路径上下文.空指针>
    {
        @ @<当前对象>.get_ptr_num<INT>(@<路径>, @<错误信息>, @<路径上下文>)
    }

    方法 取路径长整数 <公开 静态 类型 = 长整数 注释 = "获取指定路径的JSON数字值,并转换到长整数." 注释 = "如果找不到指定的成员或值类型不是数字,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    参数 路径上下文 <类型 = YYJSON路径上下文 注释 = "提供非空指针时,将返回JSON路径的上下文." @默认值 = YYJSON路径上下文.空指针>
    {
        @ @<当前对象>.get_ptr_num<INT64>(@<路径>, @<错误信息>, @<路径上下文>)
    }

    方法 取路径小数 <公开 静态 类型 = 小数 注释 = "获取指定路径的JSON数字值,并转换到小数." 注释 = "如果找不到指定的成员或值类型不是数字,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    参数 路径上下文 <类型 = YYJSON路径上下文 注释 = "提供非空指针时,将返回JSON路径的上下文." @默认值 = YYJSON路径上下文.空指针>
    {
        @ @<当前对象>.get_ptr_real(@<路径>, @<错误信息>, @<路径上下文>)
    }

    方法 取路径数值 <公开 静态 注释 = "获取指定路径的JSON数字值,并转换到指定的数值类型." 注释 = "如果找不到指定的成员或值类型不是数字,将返回0." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 数值类型 <注释 = "指定以何种类型返回JSON数字值,支持小数、有符号和无符号整数型." 折叠2 @需求类型 = 数据类型 @匹配类型 = 通用数值型 @返回值类型 = 0>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    参数 路径上下文 <类型 = YYJSON路径上下文 注释 = "提供非空指针时,将返回JSON路径的上下文." @默认值 = YYJSON路径上下文.空指针>
    {
        @ @<当前对象>.get_ptr_num<@<数值类型>>(@<路径>, @<错误信息>, @<路径上下文>)
    }

    方法 取路径逻辑 <公开 静态 类型 = 逻辑型 注释 = "获取指定路径的JSON逻辑值." 注释 = "如果找不到指定的成员或值类型不是逻辑型,将返回假." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在获取JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    参数 路径上下文 <类型 = YYJSON路径上下文 注释 = "提供非空指针时,将返回JSON路径的上下文." @默认值 = YYJSON路径上下文.空指针>
    {
        @ @<当前对象>.get_ptr_bool(@<路径>, @<错误信息>, @<路径上下文>)
    }

    # JSON路径操作 ---

    方法 置入路径 <公开 静态 类型 = 逻辑型 注释 = "根据提供的数据类型设置指定路径的JSON值,返回是否成功." 注释 = "如果父节点不存在,将会自动创建."
            注释 = "注: 如果当前为空值(null),将自动设置为JSON对象," 注释 = "若你需要当前值为JSON数组,请先用\"置空数组\"." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_cpp_bool = true">
    参数 当前对象 <类型 = YYJSON值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 值 <注释 = "所欲设置的值,支持类型(带*号的必会深拷贝):" 注释 = " 通用数值型、无符号型、逻辑型" 注释 = " *JSON只读值、JSON值"
            注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 深拷贝 <类型 = 逻辑型 注释 = "指定是否将文本、对象、数组等类型的数据拷贝到本JSON文档;" 注释 = "如果为假,必须确保该值的作用域大于或等于当前对象,"
            注释 = "且同一个对象/数组值应该仅浅拷贝一次,否则可能出现成员值丢失的情况." @默认值 = 真>
    参数 覆盖模式 <类型 = 逻辑型 注释 = "如果目标值已经存在,选择是否用新值将它覆盖." @默认值 = 真>
    参数 路径错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在访问JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    参数 路径上下文 <类型 = YYJSON路径上下文 注释 = "提供非空指针时,将返回JSON路径的上下文." @默认值 = YYJSON路径上下文.空指针>
    {
        @ @<当前对象>.ptr_add(@<路径>, @<值>, @<深拷贝>, @<覆盖模式>, @<路径错误信息>, @<路径上下文>)
    }

    方法 删除路径 <公开 静态 类型 = YYJSON值 注释 = "从JSON中删除指定路径的值,返回被删除的JSON值." 注释 = "如果未找到指定路径,则返回空指针(用\"是否为空\"判断)."
            注释 = "注: 被删除的值要等到JSON文档被销毁才会被释放." 返回值注释 = "返回被删除的JSON值" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    参数 路径 <注释 = "JSON路径必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "JSON路径支持两个转义符: \'~0\'=\'~\', \'~1\'=\'/\';"
            注释 = "支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 错误信息 <类型 = YYJSON路径错误 注释 = "提供非空指针时,可在访问JSON路径失败时返回错误信息." @默认值 = YYJSON路径错误.空指针>
    参数 路径上下文 <类型 = YYJSON路径上下文 注释 = "提供非空指针时,将返回JSON路径的上下文." @默认值 = YYJSON路径上下文.空指针>
    {
        @ @<当前对象>.ptr_remove(@<路径>, @<错误信息>, @<路径上下文>)
    }

    # 枚举循环 ---

    方法 枚举循环 <公开 静态 注释 = "启动一个循环来枚举当前JSON数组值中的每一个成员,或JSON对象值的每一个键值对." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = yyjson_mut_iter\r\nhas_loop_body = true">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ for (auto &yyjson_mut_iter : @<当前对象>)
    }

    方法 取枚举索引 <公开 静态 类型 = 整数 注释 = "返回当前所枚举到的JSON成员的索引." 注释 = "注: 只能在本类的\"枚举循环\"语句的子语句体中使用." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "parent = yyjson_mut_iter">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ static_cast<INT>(yyjson_mut_iter.idx)
    }

    方法 取枚举键 <公开 静态 类型 = YYJSON值 注释 = "返回当前所枚举到的JSON对象键名." 注释 = "注: 只能在本类的\"枚举循环\"语句的子语句体中使用." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "parent = yyjson_mut_iter">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ yyjson_mut_iter.get_key()
    }

    方法 取枚举键文本 <公开 静态 类型 = 文本型 注释 = "用\"文本型\"返回当前所枚举到的JSON对象键名." 注释 = "注: 只能在本类的\"枚举循环\"语句的子语句体中使用." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "parent = yyjson_mut_iter">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ PivU2Ws{yyjson_mut_iter.get_key_str()}.str
    }

    方法 取枚举键文本指针 <公开 静态 类型 = PIV.类型.字符串指针 注释 = "用字符串指针(const char*)返回当前所枚举到的JSON对象键名."
            注释 = "注: 只能在本类的\"枚举循环\"语句的子语句体中使用." 折叠 隐藏值属性 = "0" @嵌入式方法 = "parent = yyjson_mut_iter">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ yyjson_mut_iter.get_key_str()
    }

    方法 取枚举键标准文本 <公开 静态 类型 = 标准文本类U 注释 = "用\"标准文本类U\"返回当前所枚举到的JSON对象键名." 注释 = "注: 只能在本类的\"枚举循环\"语句的子语句体中使用."
            折叠 隐藏值属性 = "0" @嵌入式方法 = "parent = yyjson_mut_iter">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @dt<标准文本类U>{yyjson_mut_iter.get_key_str()}
    }

    方法 取枚举值 <公开 静态 类型 = YYJSON值 注释 = "返回当前所枚举到的(JSON对象/JSON数组)成员值." 注释 = "注: 只能在本类的\"枚举循环\"语句的子语句体中使用." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "parent = yyjson_mut_iter">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ yyjson_mut_iter.get_val()
    }

    # 设置值 ---

    方法 置值 <公开 静态 类型 = 逻辑型 注释 = "根据提供的数据类型设置当前的JSON值,返回是否成功," 注释 = "如果当前的JSON值为空指针则返回失败."
            注释 = "注意: 如果先前值包含了由JSON文档管理的文本数据," 注释 = "其占用的内存不会立即释放,而是要随JSON文档一同释放." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_cpp_bool = true">
    参数 当前对象 <类型 = YYJSON值>
    参数 值 <注释 = "所欲设置的值,支持类型(带*号的必会深拷贝):" 注释 = " 通用数值型、无符号型、逻辑型" 注释 = " *JSON只读值、JSON值"
            注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    参数 深拷贝 <类型 = 逻辑型 注释 = "指定是否将文本、对象、数组等类型的数据拷贝到本JSON文档;" 注释 = "如果为假,必须确保该值的作用域大于或等于当前对象,"
            注释 = "且同一个对象/数组值应该仅浅拷贝一次,否则可能出现成员值丢失的情况." @默认值 = 真>
    {
        @ @<当前对象>.set_val(@<值>, @<深拷贝>)
    }

    方法 置空值 <公开 静态 类型 = 逻辑型 注释 = "将当前的JSON值重置为空值" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ yyjson_mut_set_null(@<当前对象>.m_val)
    }

    方法 置空数组 <公开 静态 类型 = 逻辑型 注释 = "将当前的JSON值重置为空数组" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.set_arr()
    }

    方法 置空对象 <公开 静态 类型 = 逻辑型 注释 = "将当前的JSON值重置为空对象" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.set_obj()
    }

    # 创建JSON值 ---

    方法 创建值 <公开 静态 类型 = YYJSON值 注释 = "使用提供的初始值,在当前的JSON文档中创建一个JSON简单值." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_cpp_bool = true">
    参数 当前对象 <类型 = YYJSON值>
    参数 值 <注释 = "所欲初始化的值,支持通用数值型、逻辑型,文本数据;" 注释 = "文本值支持以下类型(*号表示需要转换编码):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = " *文本型、*标准文本类W、*文本视图类W" @匹配类型 = 通用型>
    {
        @ @<当前对象>.make_val(@<值>)
    }

    方法 创建空值 <公开 静态 类型 = YYJSON值 注释 = "在当前的JSON文档中创建一个JSON空值(null)" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.make_null()
    }

    方法 创建空对象 <公开 静态 类型 = YYJSON值 注释 = "在当前的JSON文档中创建一个空的JSON对象" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.make_obj()
    }

    方法 创建空数组 <公开 静态 类型 = YYJSON值 注释 = "在当前的JSON文档中创建一个空的JSON数组" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值>
    {
        @ @<当前对象>.make_arr()
    }

    方法 创建对象 <公开 静态 类型 = YYJSON值 注释 = "使用提供的键值对,在当前的JSON文档中初始化构造一个JSON对象." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_cpp_bool = true">
    参数 当前对象 <类型 = YYJSON值>
    参数 键值对 <注释 = "作为初始值的一系列键值对,必须以两个参数为一组,分别提供\"键\"和\"值\"." 注释 = "1. \"键\"必须为文本值(带*号表示会转换编码):"
            注释 = "   *文本型、字节集类(UTF-8)、*标准文本类W、*文本视图类W、标准文本类U、文本视图类U" 注释 = "2. \"值\"支持更多类型:"
            注释 = "   通用数值型、YYJSON只读值、YYJSON值、*文本型、字节集类(UTF-8)" 注释 = "   *标准文本类W、*文本视图类W、标准文本类U、文本视图类U"
            @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @<当前对象>.make_obj(true, true, @<键值对>)
    }

    方法 创建数组 <公开 静态 类型 = YYJSON值 注释 = "使用提供的成员,在当前的JSON文档中初始化构造一个JSON数组." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_cpp_bool = true">
    参数 当前对象 <类型 = YYJSON值>
    参数 成员值 <注释 = "作为初始值的一系列数组成员,支持的成员类型(带*号表示会转换编码):" 注释 = " 通用数值型、JSON对象、JSON数组、*文本型、字节集类(UTF-8)"
            注释 = " *标准文本类W、*文本视图类W、标准文本类U、文本视图类U" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @<当前对象>.make_arr(true, @<成员值>)
    }

    # JSON补丁 ---

    方法 执行补丁 <公开 静态 类型 = YYJSON值 注释 = "在当前的JSON值中执行指定JSON补丁中的所有操作,返回补丁后的JSON值." 注释 = "注: 当前JSON值不会被修改."
            返回值注释 = "成功返回修补后的JSON值." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值 "">
    参数 JSON补丁 <类型 = YYJSON值 注释 = "JSON补丁是一种JSON文档结构,用于描述应用于JSON文档的一系列操作." 注释 = "JSON补丁必须是JSON数组,格式如:"
            注释 = " [" 注释 = "   { \"op\": \"replace\", \"path\": \"/baz\", \"value\": \"boo\" },"
            注释 = "   { \"op\": \"add\", \"path\": \"/hello\", \"value\": [\"world\"] },"
            注释 = "   { \"op\": \"remove\", \"path\": \"/foo\"}" 注释 = " ]">
    参数 错误信息 <类型 = YYJSON补丁错误 注释 = "如果提供了非空指针,将在补丁失败时返回错误信息." @默认值 = YYJSON补丁错误.空指针>
    {
        @ @<当前对象>.patch(@<JSON补丁>, @<错误信息>)
    }

    方法 合并补丁 <公开 静态 类型 = YYJSON值 注释 = "使用HTTP PATCH方法将JSON补丁合并到当前的JSON值中,返回补丁后的JSON值."
            注释 = "注: 当前JSON值不会被修改." 注释 = "规则: 如果是合并JSON对象,两个对象中不同的键值都会保留,相同的键则覆盖为补丁的值;"
            注释 = "如果是合并其他的值类型,则完全覆盖为补丁的值." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = YYJSON值 "">
    参数 JSON补丁 <类型 = YYJSON值 注释 = "所欲应用的补丁JSON,跟\"执行补丁\"不同,本方法使用的补丁就是普通的JSON;">
    {
        @ @<当前对象>.merge_patch(@<JSON补丁>)
    }
}

# 辅助指针 ---

类 YYJSON分配器 <公开 注释 = "提供JSON文档的内存分配器." 注释 = "* 本类型为指针,通常使用本类的常量即可;"
        注释 = "* 如有特殊用途,可以通过\"创建...\"方法创建对应的分配器指针;" 折叠 隐藏值属性 = "0" @文档 = "category = \"JSON支持.YYJSON.辅助类\""
        @别名 = "yyjson_alc*" @别名类型 = 本地整数基本类型 @有效值范围 = "0">
{
    常量 偏好设置 <公开 类型 = YYJSON分配器 值 = @nullptr
            注释 = "等于空指针,表示使用全局的偏好设置,默认为\"火山内存池\"或\"mimalloc\"(配置了mimalloc模块后);"
            注释 = "偏好设置可以通过\"YYJSON分配器.置偏好设置()\"方法修改.">
    常量 默认 <公开 类型 = YYJSON分配器 值 = @"@piv_yyjson_alc::instance().def_alc()"
            注释 = "[线程安全]表示使用C的标准函数(malloc/realloc/free)分配内存.">
    常量 火山内存池 <公开 类型 = YYJSON分配器 值 = @"@piv_yyjson_alc::instance().vol_alc()"
            注释 = "[线程安全]使用火山内部的全局内存池来分配内存;" 注释 = "火山的字节集类、文本型、数组类都使用了这个内存池,速度比C的标准函数快.">
    常量 mimalloc <公开 类型 = YYJSON分配器 值 = @"@piv_yyjson_alc::instance().mi_alc()"
            注释 = "[线程安全]使用微软的mimalloc高性能分配内存;" 注释 = "需要配合官方的\"高性能内存分配类\",或其他的的第三方mimalloc模块,否则将返回空指针(等于使用偏好设置).">

    # 全局设置 ---

    方法 置偏好设置 <公开 静态 注释 = "设置YYJSON的全局默认内存分配器." 注释 = "* 默认的偏好设置为\"火山内存池\"或\"mimalloc\"(配置了mimalloc模块后)."
            注释 = "* \"YYJSON值\"对象实例化时只能使用\"偏好设置\"中的分配器." 注释 = "* 解析和序列化等方法可以通过参数使用其他的分配器."
            注释 = "* 不应将\"动态内存池\"和\"固定内存池\"等非线程安全的分配器设置为偏好设置." 折叠 @嵌入式方法 = "">
    参数 偏好分配器 <类型 = YYJSON分配器 注释 = "欲设置为偏好设置的分配器">
    {
        @ piv_yyjson_alc::instance().set_pref(@<偏好分配器>)
    }

    # 动态内存池 ---

    方法 创建动态内存池 <公开 静态 类型 = YYJSON分配器 注释 = "创建并返回一个动态长度的内存池分配器." 注释 = "* 注意: 此分配器非线程安全!!!使用时请注意加锁!"
            注释 = "* 更推荐使用常量中的\"火山内存池\"." 注释 = "* 此分配器将按需分配内存,且不会立即释放未使用的内存," 注释 = "而是将未使用的内存放入空闲列表中,以备将来重用."
            注释 = "* 只有当整个分配器被销毁时,所有先前分配的内存才会立即释放." 折叠 @嵌入式方法 = "">
    {
        @ yyjson_alc_dyn_new()
    }

    方法 销毁动态内存池 <公开 静态 注释 = "销毁先前创建的动态内存池分配器,其中分配的内存将会立即释放." 注释 = "* 注意: 非线程安全,且必须确保已经没有JSON文档在使用此分配器." 折叠>
    参数 本指针 <类型 = YYJSON分配器 @视窗.后缀文本 = "&">
    {
        @ yyjson_alc_dyn_free(@<本指针>);
        @ @<本指针> = nullptr;
    }

    # 固定内存池 ---

    方法 创建固定内存池 <公开 静态 类型 = YYJSON分配器 注释 = "创建一个固定长度的内存池分配器." 注释 = "* 注意: 此分配器非线程安全!!!"
            注释 = "* 此分配器可以避免多次调用malloc/realloc." 注释 = "* 这不是一个通用的分配器,应该仅用于处理单个\"YYJSON只读值\"的解析." 折叠 @禁止流程检查 = 真>
    参数 缓冲区指针 <类型 = 通用指针>
    参数 缓冲区长度 <类型 = 变整数 "">
    {
        @ yyjson_alc* alc = new yyjson_alc{0};
        @ if (yyjson_alc_pool_init(alc, @<缓冲区指针>, static_cast<size_t>(缓冲区长度)))
        @     return alc;
        @ delete alc;
        @ return nullptr;
    }

    方法 销毁固定内存池 <公开 静态 注释 = "销毁先前创建的固定内存池分配器,分配器关联的缓冲区需要你自行释放." 注释 = "* 注意: 非线程安全,且必须确保已经没有JSON文档在使用此分配器."
            折叠>
    参数 本指针 <类型 = YYJSON分配器 @视窗.后缀文本 = "&">
    {
        @ if (@<本指针>) {
        @     delete @<本指针>;
        @     @<本指针> = nullptr;
        @ }
    }

    # 自定义分配器 ---

    方法 创建分配器 <公开 静态 类型 = YYJSON分配器 注释 = "创建一个自定义的内存分配器" 折叠 @嵌入式方法 = "">
    参数 分配 <注释 = "提供分配内存的函数" @匹配方法 = "分配内存模板">
    参数 重分配 <注释 = "提供重分配内存的函数" @匹配方法 = "重分配内存模板">
    参数 释放 <注释 = "提供释放分配内存的函数" @匹配方法 = "释放内存模板">
    参数 上下文 <类型 = 通用指针 注释 = "用户参数,可以为空" "">
    {
        @ new yyjson_alc{@<分配>, @<重分配>, @<释放>, @<上下文>}
    }

    方法 销毁分配器 <公开 静态 注释 = "销毁自定义的内存分配器" 折叠>
    参数 本指针 <类型 = YYJSON分配器 @视窗.后缀文本 = "&">
    {
        @ if (@<本指针>) {
        @     delete @<本指针>;
        @     @<本指针> = nullptr;
        @ }
    }

    方法 分配内存模板 <静态 类型 = 通用指针 注释 = "malloc" 折叠 @视窗.前缀文本 = "@CDECL">
    参数 上下文 <类型 = 通用指针 注释 = "用户参数,可以为空">
    参数 分配长度 <类型 = size_t 注释 = "所欲分配的内存长度">
    {
        返回 (0)
    }

    方法 重分配内存模板 <静态 类型 = 通用指针 注释 = "relloc" 折叠 @视窗.前缀文本 = "@CDECL">
    参数 上下文 <类型 = 通用指针 注释 = "用户参数,可以为空">
    参数 内存地址 <类型 = 通用指针 注释 = "之前分配的内存地址">
    参数 旧长度 <类型 = size_t 注释 = "之前的内存长度">
    参数 新长度 <类型 = size_t 注释 = "新的内存长度">
    {
        返回 (0)
    }

    方法 释放内存模板 <静态 注释 = "free" 折叠 @视窗.前缀文本 = "@CDECL">
    参数 上下文 <类型 = 通用指针 注释 = "用户参数,可以为空">
    参数 内存地址 <类型 = 通用指针 注释 = "欲释放的内存地址">
    {

    }
}

类 YYJSON解析错误 <公开 注释 = "提供JSON解析(反序列化)时返回的错误信息." 注释 = "* 本类型为指针,仅当指针不为空时才会返回信息."
        注释 = "* 请使用\"创建\"申请指针,以及使用\"销毁\"释放指针." 折叠 隐藏值属性 = "0" @文档 = "category = \"JSON支持.YYJSON.辅助类\""
        @别名 = "yyjson_read_err*" @别名类型 = 本地整数基本类型 @有效值范围 = "0">
{
    常量 空指针 <公开 类型 = YYJSON解析错误 值 = @nullptr>

    方法 创建 <公开 静态 类型 = YYJSON解析错误 注释 = "创建并返回一个本类指针,注意不使用后必须调用销毁命令将其销毁." 折叠 @嵌入式方法 = "">
    {
        @ new yyjson_read_err{0}
    }

    方法 销毁 <公开 静态 注释 = "销毁先前调用\"创建\"方法所创建的本类指针" 折叠>
    参数 本指针 <类型 = YYJSON解析错误 @视窗.后缀文本 = "&">
    {
        @ if (@<本指针>) {
        @     delete @<本指针>;
        @     @<本指针> = nullptr;
        @ }
    }

    方法 为空指针 <公开 静态 类型 = 逻辑型 注释 = "返回本指针是否为空" 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = YYJSON解析错误>
    {
        @ @<本指针> == nullptr
    }

    # ---

    方法 错误代码 <公开 静态 属性读 类型 = YYJSON解析错误码 注释 = "返回错误代码,请参考\"YYJSON解析错误码\"的常量值." 注释 = "注意: 使用本方法前必须确保指针不为空!"
            折叠 @禁止流程检查 = 真>
    参数 本指针 <类型 = YYJSON解析错误>
    {
        @ return @<本指针>->code;
    }

    方法 错误信息 <公开 静态 属性读 类型 = 文本型 注释 = "返回具体的错误信息,空文本表示解析成功." 注释 = "注意: 使用本方法前必须确保指针不为空!" 折叠 @禁止流程检查 = 真>
    参数 本指针 <类型 = YYJSON解析错误>
    {
        @ return @<本指针>->msg != nullptr ? @an<CVolString>{@<本指针>->msg} : _CT2(L"");
    }

    方法 错误位置 <公开 静态 属性读 类型 = 整数 注释 = "输入数据的错误位置(以字节为单位),返回0表示成功." 注释 = "注意: 使用本方法前必须确保指针不为空!" 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = YYJSON解析错误>
    {
        @ (INT)@<本指针>->pos
    }

    # @begin
    # <> <global>
    # <> <include>
    # static void PivDumpStr(CVolString &strDebug, INT nMaxDumpSize, yyjson_read_err* value)
    # {
    #     if (value != nullptr)
    #         strDebug.AddFormatText(L"<YYJSON解析错误> 错误代码: %u; 错误信息: %s; 错误位置: %u",
    #                                value->code, CVolString{value->msg}.GetText(), value->pos);
    #     else
    #         strDebug.SetText(L"yyjson_read_err: nullptr");
    # }
    # <> </include>
    # <> </global>
    # @end
}

类 YYJSON序列化错误 <公开 注释 = "提供JSON序列化时返回的错误信息." 注释 = "* 本类型为指针,仅当指针不为空时才会返回信息."
        注释 = "* 请使用\"创建\"申请指针,以及使用\"销毁\"释放指针." 折叠 隐藏值属性 = "0" @文档 = "category = \"JSON支持.YYJSON.辅助类\""
        @别名 = "yyjson_write_err*" @别名类型 = 本地整数基本类型 @有效值范围 = "0">
{
    常量 空指针 <公开 类型 = YYJSON序列化错误 值 = @nullptr>

    方法 创建 <公开 静态 类型 = YYJSON序列化错误 注释 = "创建并返回一个本类指针,注意不使用后必须调用销毁命令将其销毁." 折叠 @嵌入式方法 = "">
    {
        @ new yyjson_write_err{0}
    }

    方法 销毁 <公开 静态 注释 = "销毁先前调用\"创建\"方法所创建的本类指针" 折叠>
    参数 本指针 <类型 = YYJSON序列化错误 @视窗.后缀文本 = "&">
    {
        @ if (@<本指针>) {
        @     delete @<本指针>;
        @     @<本指针> = nullptr;
        @ }
    }

    方法 为空指针 <公开 静态 类型 = 逻辑型 注释 = "返回本指针是否为空" 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = YYJSON序列化错误>
    {
        @ @<本指针> == nullptr
    }

    # ---

    方法 错误代码 <公开 静态 属性读 类型 = YYJSON序列化错误码 注释 = "返回错误代码,请参考\"YYJSON序列化错误码\"的常量值." 注释 = "注意: 使用本方法前必须确保指针不为空!"
            折叠 @禁止流程检查 = 真>
    参数 本指针 <类型 = YYJSON序列化错误>
    {
        @ return @<本指针>->code;
    }

    方法 错误信息 <公开 静态 属性读 类型 = 文本型 注释 = "返回具体的错误信息,空文本表示解析成功." 注释 = "注意: 使用本方法前必须确保指针不为空!" 折叠 @禁止流程检查 = 真>
    参数 本指针 <类型 = YYJSON序列化错误>
    {
        @ return @<本指针>->msg != nullptr ? @an<CVolString>{@<本指针>->msg} : _CT2(L"");
    }

    # @begin
    # <> <global>
    # <> <include>
    # static void PivDumpStr(CVolString &strDebug, INT nMaxDumpSize, yyjson_write_err* value)
    # {
    #     if (value != nullptr)
    #         strDebug.AddFormatText(L"<YYJSON序列化错误> 错误代码: %u; 错误信息: %s",
    #                                value->code, CVolString{value->msg}.GetText());
    #     else
    #         strDebug.SetText(L"yyjson_write_err: nullptr");
    # }
    # <> </include>
    # <> </global>
    # @end
}

类 YYJSON路径错误 <公开 注释 = "提供获取JSON路径时返回的错误信息." 注释 = "* 本类型为指针,仅当指针不为空时才会返回信息."
        注释 = "* 请使用\"创建\"申请指针,以及使用\"销毁\"释放指针." 折叠 隐藏值属性 = "0" @文档 = "category = \"JSON支持.YYJSON.辅助类\""
        @别名 = "yyjson_ptr_err*" @别名类型 = 本地整数基本类型 @有效值范围 = "0">
{
    常量 空指针 <公开 类型 = YYJSON路径错误 值 = @nullptr>

    方法 创建 <公开 静态 类型 = YYJSON路径错误 注释 = "创建并返回一个本类指针,注意不使用后必须调用销毁命令将其销毁." 折叠 @嵌入式方法 = "">
    {
        @ new yyjson_ptr_err{0}
    }

    方法 销毁 <公开 静态 注释 = "销毁先前调用\"创建\"方法所创建的本类指针" 折叠>
    参数 本指针 <类型 = YYJSON路径错误 @视窗.后缀文本 = "&">
    {
        @ if (@<本指针>) {
        @     delete @<本指针>;
        @     @<本指针> = nullptr;
        @ }
    }

    方法 为空指针 <公开 静态 类型 = 逻辑型 注释 = "返回本指针是否为空" 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = YYJSON路径错误>
    {
        @ @<本指针> == nullptr
    }

    # ---

    方法 错误代码 <公开 静态 属性读 类型 = YYJSON路径错误码 注释 = "返回错误代码,请参考\"YYJSON路径错误码\"的常量值." 注释 = "注意: 使用本方法前必须确保指针不为空!"
            折叠 @禁止流程检查 = 真>
    参数 本指针 <类型 = YYJSON路径错误>
    {
        @ return @<本指针>->code;
    }

    方法 错误信息 <公开 静态 属性读 类型 = 文本型 注释 = "返回具体的错误信息,空文本表示成功." 注释 = "注意: 使用本方法前必须确保指针不为空!" 折叠 @禁止流程检查 = 真>
    参数 本指针 <类型 = YYJSON路径错误>
    {
        @ return @<本指针>->msg != nullptr ? @an<CVolString>{@<本指针>->msg} : _CT2(L"");
    }

    方法 错误位置 <公开 静态 属性读 类型 = 整数 注释 = "输入数据的错误位置(以字节为单位),返回0表示成功." 注释 = "注意: 使用本方法前必须确保指针不为空!" 折叠 @禁止流程检查 = 真>
    参数 本指针 <类型 = YYJSON路径错误>
    {
        @ return (INT)@<本指针>->pos;
    }

    # @begin
    # <> <global>
    # <> <include>
    # static void PivDumpStr(CVolString &strDebug, INT nMaxDumpSize, yyjson_ptr_err* value)
    # {
    #     if (value != nullptr)
    #         strDebug.AddFormatText(L"<YYJSON路径错误> 错误代码: %u; 错误信息: %s; 错误位置: %u",
    #                                value->code, CVolString{value->msg}.GetText(), value->pos);
    #     else
    #         strDebug.SetText(L"yyjson_ptr_err: nullptr");
    # }
    # <> </include>
    # <> </global>
    # @end
}

类 YYJSON路径上下文 <公开 注释 = "提供JSON路径的上下文信息." 注释 = "* 本类型为指针,仅当指针不为空时才会返回信息."
        注释 = "* 请使用\"创建\"申请指针,以及使用\"销毁\"释放指针." 折叠 隐藏值属性 = "0" @文档 = "category = \"JSON支持.YYJSON.辅助类\""
        @别名 = "piv_yyjson_mut_val::ptr_ctx*" @别名类型 = 本地整数基本类型 @有效值范围 = "0">
{
    常量 空指针 <公开 类型 = YYJSON路径上下文 值 = @nullptr>

    方法 创建 <公开 静态 类型 = YYJSON路径上下文 注释 = "创建并返回一个本类指针,注意不使用后必须调用销毁命令将其销毁." 折叠 @嵌入式方法 = "">
    {
        @ new piv_yyjson_mut_val::ptr_ctx
    }

    方法 销毁 <公开 静态 注释 = "销毁先前调用\"创建\"方法所创建的本类指针" 折叠>
    参数 本指针 <类型 = YYJSON路径上下文 @视窗.后缀文本 = "&">
    {
        @ if (@<本指针>) {
        @     delete @<本指针>;
        @     @<本指针> = nullptr;
        @ }
    }

    方法 为空指针 <公开 静态 类型 = 逻辑型 注释 = "返回本指针是否为空" 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = YYJSON路径上下文>
    {
        @ @<本指针> == nullptr
    }

    # ---

    方法 容器 <公开 静态 属性读 类型 = YYJSON值 注释 = "路径目标值的父容器,应为一个JSON对象或JSON数组." 注释 = "注意: 使用本方法前必须确保指针不为空!" 折叠
            @禁止流程检查 = 真>
    参数 本指针 <类型 = YYJSON路径上下文>
    {
        @ return @dt<YYJSON值>{@<本指针>->doc, @<本指针>->ptr.ctn};
    }

    方法 上一值 <公开 静态 属性读 类型 = YYJSON值 注释 = "路径目标值的上一个同级成员值,可能是数组中的一个成员,或对象中的一个键名." 注释 = "注意: 使用本方法前必须确保指针不为空!"
            折叠 @禁止流程检查 = 真>
    参数 本指针 <类型 = YYJSON路径上下文>
    {
        @ return @dt<YYJSON值>{@<本指针>->doc, @<本指针>->ptr.pre};
    }

    方法 旧值 <公开 静态 属性读 类型 = YYJSON值 注释 = "如果修改过路径目标值,可以在这里访问之前的旧值." 注释 = "注意: 使用本方法前必须确保指针不为空!" 折叠
            @禁止流程检查 = 真>
    参数 本指针 <类型 = YYJSON路径上下文>
    {
        @ return @dt<YYJSON值>{@<本指针>->doc, @<本指针>->ptr.old};
    }

    # ---

    方法 加入值 <公开 静态 类型 = 逻辑型 注释 = "在当前路径的父数组上加入成员值." 注释 = "注意: 使用本方法前必须确保指针不为空!" 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = YYJSON路径上下文>
    参数 值 <@匹配类型 = 通用型>
    参数 深拷贝 <类型 = 逻辑型 注释 = "指定是否将文本、对象、数组等类型的数据拷贝到本JSON文档;" 注释 = "如果为假,必须确保该值的作用域大于或等于当前对象,"
            注释 = "且同一个对象/数组值应该仅浅拷贝一次,否则可能出现成员值丢失的情况." @默认值 = 真>
    {
        @ @<本指针>->append(@<值>, @<深拷贝>)
    }

    方法 置入值 <公开 静态 类型 = 逻辑型 注释 = "在当前路径的父对象上添加键值对." 注释 = "注意: 使用本方法前必须确保指针不为空!" 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = YYJSON路径上下文>
    参数 键名 <@匹配类型 = 通用型>
    参数 值 <@匹配类型 = 通用型>
    参数 深拷贝 <类型 = 逻辑型 注释 = "指定是否将文本、对象、数组等类型的数据拷贝到本JSON文档;" 注释 = "如果为假,必须确保该值的作用域大于或等于当前对象,"
            注释 = "且同一个对象/数组值应该仅浅拷贝一次,否则可能出现成员值丢失的情况." @默认值 = 真>
    {
        @ @<本指针>->append(@<键名>, @<值>, @<深拷贝>)
    }

    方法 替换值 <公开 静态 类型 = 逻辑型 注释 = "替换当前路径的值,被替换的值可以通过\"旧值\"访问." 注释 = "注意: 使用本方法前必须确保指针不为空!" 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = YYJSON路径上下文>
    参数 值 <@匹配类型 = 通用型>
    {
        @ @<本指针>->replace(@<值>)
    }

    方法 删除值 <公开 静态 类型 = 逻辑型 注释 = "删除当前JSON路径上下文指向的JSON值." 注释 = "注意: 使用本方法前必须确保指针不为空!" 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = YYJSON路径上下文>
    {
        @ @<本指针>->remove()
    }
}

类 YYJSON补丁错误 <公开 注释 = "提供操作JSON补丁时返回的错误信息." 注释 = "* 本类型为指针,仅当指针不为空时才会返回信息."
        注释 = "* 请使用\"创建\"申请指针,以及使用\"销毁\"释放指针." 折叠 隐藏值属性 = "0" @文档 = "category = \"JSON支持.YYJSON.辅助类\""
        @别名 = "yyjson_patch_err*" @别名类型 = 本地整数基本类型 @有效值范围 = "0">
{
    常量 空指针 <公开 类型 = YYJSON补丁错误 值 = @nullptr>

    方法 创建 <公开 静态 类型 = YYJSON补丁错误 注释 = "创建并返回一个本类指针,注意不使用后必须调用销毁命令将其销毁." 折叠 @嵌入式方法 = "">
    {
        @ new yyjson_patch_err{0}
    }

    方法 销毁 <公开 静态 注释 = "销毁先前调用\"创建\"方法所创建的本类指针" 折叠>
    参数 本指针 <类型 = YYJSON补丁错误 @视窗.后缀文本 = "&">
    {
        @ if (@<本指针>) {
        @     delete @<本指针>;
        @     @<本指针> = nullptr;
        @ }
    }

    方法 为空指针 <公开 静态 类型 = 逻辑型 注释 = "返回本指针是否为空" 折叠 @嵌入式方法 = "">
    参数 本指针 <类型 = YYJSON补丁错误>
    {
        @ @<本指针> == nullptr
    }

    # ---

    方法 错误代码 <公开 静态 属性读 类型 = YYJSON补丁错误码 注释 = "返回错误代码,请参考\"YYJSON补丁错误码\"的常量值." 注释 = "注意: 使用本方法前必须确保指针不为空!"
            折叠 @禁止流程检查 = 真>
    参数 本指针 <类型 = YYJSON补丁错误>
    {
        @ return @<本指针>->code;
    }

    方法 错误索引 <公开 静态 属性读 类型 = 整数 注释 = "补丁操作失败的数组索引,返回0表示成功." 注释 = "注意: 使用本方法前必须确保指针不为空!" 折叠 @禁止流程检查 = 真>
    参数 本指针 <类型 = YYJSON补丁错误>
    {
        @ return (INT)@<本指针>->idx;
    }

    方法 错误信息 <公开 静态 属性读 类型 = 文本型 注释 = "返回具体的错误信息,空文本表示操作成功." 注释 = "注意: 使用本方法前必须确保指针不为空!" 折叠 @禁止流程检查 = 真>
    参数 本指针 <类型 = YYJSON补丁错误>
    {
        @ return @<本指针>->msg != nullptr ? @an<CVolString>{@<本指针>->msg} : _CT2(L"");
    }

    方法 路径错误 <公开 静态 属性读 类型 = YYJSON路径错误 注释 = "返回JSON路径错误" 注释 = "注意: 使用本方法前必须确保指针不为空!" 折叠 @禁止流程检查 = 真>
    参数 本指针 <类型 = YYJSON补丁错误>
    {
        @ return &@<本指针>->ptr;
    }
}

# 常量 ---

类 YYJSON类型 <公开 注释 = "表示一个JSON值的类型" 折叠 隐藏值属性 = "0" @文档 = "category = \"JSON支持.YYJSON.常量\"">
{
    常量 无效 <公开 类型 = 无符号字节 值 = @YYJSON_TYPE_NONE 注释 = "无类型,无效值">
    常量 原始文本值 <公开 类型 = 无符号字节 值 = @YYJSON_TYPE_RAW 注释 = "原始文本(nan/inf等特殊数字),无子类型">
    常量 空值 <公开 类型 = 无符号字节 值 = @YYJSON_TYPE_NULL 注释 = "null文字,无子类型">
    常量 逻辑值 <公开 类型 = 无符号字节 值 = @YYJSON_TYPE_BOOL 注释 = "逻辑型,子类型: 假值、真值">
    常量 数字值 <公开 类型 = 无符号字节 值 = @YYJSON_TYPE_NUM 注释 = "数字类型,子类型: 无符号整数值、有符号整数值、小数值">
    常量 文本值 <公开 类型 = 无符号字节 值 = @YYJSON_TYPE_STR 注释 = "文本类型,子类型: 无、无需转义">
    常量 数组值 <公开 类型 = 无符号字节 值 = @YYJSON_TYPE_ARR 注释 = "JSON数组值,无子类型">
    常量 对象值 <公开 类型 = 无符号字节 值 = @YYJSON_TYPE_OBJ 注释 = "JSON对象值,无子类型">
}

类 YYJSON子类型 <公开 注释 = "表示一个JSON值的子类型" 折叠 隐藏值属性 = "0" @文档 = "category = \"JSON支持.YYJSON.常量\"">
{
    常量 无 <公开 类型 = 无符号字节 值 = @YYJSON_SUBTYPE_NONE 注释 = "无子类型">
    常量 假值 <公开 类型 = 无符号字节 值 = @YYJSON_SUBTYPE_FALSE 注释 = "false文字">
    常量 真值 <公开 类型 = 无符号字节 值 = @YYJSON_SUBTYPE_TRUE 注释 = "true文字">
    常量 无符号整数值 <公开 类型 = 无符号字节 值 = @YYJSON_SUBTYPE_UINT 注释 = "uint64_t">
    常量 有符号整数值 <公开 类型 = 无符号字节 值 = @YYJSON_SUBTYPE_SINT 注释 = "int64_t">
    常量 小数值 <公开 类型 = 无符号字节 值 = @YYJSON_SUBTYPE_REAL 注释 = "double">
    常量 无需转义 <公开 类型 = 无符号字节 值 = @YYJSON_SUBTYPE_NOESC 注释 = "表示该文本在序列化时不需要转义">
}

类 YYJSON解析选项 <公开 注释 = "提供解析JSON文档时的选项" 折叠 折叠2 @文档 = "category = \"JSON支持.YYJSON.常量\""
        @别名 = "yyjson_read_flag" @别名类型 = 本地整数基本类型 @有效值范围 = "0, 0xFFFFFFFF">
{
    常量 默认 <公开 类型 = YYJSON解析选项 值 = @YYJSON_READ_NOFLAG 注释 = "默认选项(RFC 8259兼容)" 注释 = " - 将正整数读取为无符号长整数"
            注释 = " - 将负整数读取为有符号长整数" 注释 = " - 以最接近的值舍入模式将浮点数读取为双精度小数" 注释 = " - 将不能适配为整数的值读取为双精度小数"
            注释 = " - 遇到无穷大的小数时报错" 注释 = " - 文本包含无效的UTF-8字符或BOM时报错" 注释 = " - 遇到尾随逗号、注释、inf和nan字面量时报错">
    常量 原位解析 <公开 类型 = YYJSON解析选项 值 = @YYJSON_READ_INSITU 注释 = "不复制数据,直接使用原数据内存(注意: 原数据将被修改)."
            注释 = "此选项允许解析器修改和使用输入数据来存储文本值,可以略微提高读取速度." 注释 = "调用者应在释放JSON文档之前保留输入数据." 注释 = "使用此选项,输入数据必须至少填充4个字节.">
    常量 完成后停止 <公开 类型 = YYJSON解析选项 值 = @YYJSON_READ_STOP_WHEN_DONE 注释 = "如果JSON文档后面还有其他内容,请在解析完成后停止,而不是发出错误."
            注释 = "此选项可用于解析较大数据中的一小块JSON.">
    常量 允许尾随逗号 <公开 类型 = YYJSON解析选项 值 = @YYJSON_READ_ALLOW_TRAILING_COMMAS 注释 = "允许在对象和数组末尾使用单个尾随逗号(非标准)."
            注释 = "例如: [1,2,3,] 和 {\"a\":1,\"b\":2,}">
    常量 允许注释 <公开 类型 = YYJSON解析选项 值 = @YYJSON_READ_ALLOW_COMMENTS 注释 = "允许JSON文档中存在有C语言风格的单行注释和多行注释(非标准).">
    常量 允许特殊值 <公开 类型 = YYJSON解析选项 值 = @YYJSON_READ_ALLOW_INF_AND_NAN 注释 = "允许 nan/inf 数字或不区分大小写的文字(非标准).">
    常量 读取数字为原始值 <公开 类型 = YYJSON解析选项 值 = @YYJSON_READ_NUMBER_AS_RAW 注释 = "将所有数字读取为原始文本值">
    常量 允许无效Unicode <公开 类型 = YYJSON解析选项 值 = @YYJSON_READ_ALLOW_INVALID_UNICODE 注释 = "解析字符串值时允许读取无效的Unicode.">
    常量 读取大数为原始值 <公开 类型 = YYJSON解析选项 值 = @YYJSON_READ_BIGNUM_AS_RAW 注释 = "将大数读取为原始文本值">
    常量 跳过BOM <公开 类型 = YYJSON解析选项 值 = @YYJSON_READ_ALLOW_BOM 注释 = "允许存在UTF-8 BOM签名,并在解析前跳过它(非标准).">
}

类 YYJSON序列化选项 <公开 注释 = "提供序列化JSON值时的选项" 折叠 折叠2 @文档 = "category = \"JSON支持.YYJSON.常量\""
        @别名 = "yyjson_write_flag" @别名类型 = 本地整数基本类型 @有效值范围 = "0, 0xFFFFFFFF">
{
    常量 默认 <公开 类型 = YYJSON序列化选项 值 = @YYJSON_WRITE_NOFLAG 注释 = "默认选项:" 注释 = " - 以最小占用输出JSON"
            注释 = " - 遇到 inf/nan 数字时报错" 注释 = " - 遇到无效的UTF-8字符时报错" 注释 = " - 不转义Unicode字符和斜杠">
    常量 缩进 <公开 类型 = YYJSON序列化选项 值 = @YYJSON_WRITE_PRETTY 注释 = "以4个空格符号缩进方式输出内容">
    常量 转义Unicode <公开 类型 = YYJSON序列化选项 值 = @YYJSON_WRITE_ESCAPE_UNICODE
            注释 = "将Unicode字符转义为\'uXXXX\',仅输出ASCII码.">
    常量 转义斜杠 <公开 类型 = YYJSON序列化选项 值 = @YYJSON_WRITE_ESCAPE_SLASHES 注释 = "将\'/\'转义为\'\\/\'">
    常量 允许特殊值 <公开 类型 = YYJSON序列化选项 值 = @YYJSON_WRITE_ALLOW_INF_AND_NAN
            注释 = "将 inf/nan 数字输出为\"Infinity\"和\"NaN\"字面(非标准)">
    常量 输出特殊值为空值 <公开 类型 = YYJSON序列化选项 值 = @YYJSON_WRITE_INF_AND_NAN_AS_NULL 注释 = "将 inf/nan 数字输出为null字面">
    常量 允许无效Unicode <公开 类型 = YYJSON序列化选项 值 = @YYJSON_WRITE_ALLOW_INVALID_UNICODE
            注释 = "在编码文本值时允许无效的Unicode字符(非标准)." 注释 = "将按字节复制无效的Unicode字符."
            注释 = "如果同时设置了\"转义Unicode\",所有的无效字符将转义为\'U+FFFD\'(替代字符).">
    常量 缩进两个空格 <公开 类型 = YYJSON序列化选项 值 = @YYJSON_WRITE_PRETTY_TWO_SPACES 注释 = "以2个空格符号缩进方式输出内容">
    常量 末尾换行 <公开 类型 = YYJSON序列化选项 值 = @YYJSON_WRITE_NEWLINE_AT_END 注释 = "在JSON的末尾添加一个\'\\n\'换行符">
}

类 YYJSON解析错误码 <公开 注释 = "\"YYJSON解析错误\"中的\"错误代码\"" 折叠 折叠2 隐藏值属性 = "0"
        @文档 = "category = \"JSON支持.YYJSON.常量\"" @别名 = "yyjson_read_code" @别名类型 = 本地整数基本类型
        @有效值范围 = "0, 0xFFFFFFFF">
{
    常量 成功 <公开 类型 = YYJSON解析错误码 值 = @YYJSON_READ_SUCCESS 注释 = "0 执行成功,没有错误.">
    常量 无效的参数 <公开 类型 = YYJSON解析错误码 值 = @YYJSON_READ_ERROR_INVALID_PARAMETER
            注释 = "1 提供的参数无效,例如输入文本为空指针或长度为0.">
    常量 内存分配失败 <公开 类型 = YYJSON解析错误码 值 = @YYJSON_READ_ERROR_MEMORY_ALLOCATION 注释 = "2 内存分配失败">
    常量 内容为空 <公开 类型 = YYJSON解析错误码 值 = @YYJSON_READ_ERROR_EMPTY_CONTENT 注释 = "3 输入的JSON文本为空">
    常量 意外内容 <公开 类型 = YYJSON解析错误码 值 = @YYJSON_READ_ERROR_UNEXPECTED_CONTENT
            注释 = "4 文本后面存在意外的内容,例如 `[123]abc`">
    常量 意外结尾 <公开 类型 = YYJSON解析错误码 值 = @YYJSON_READ_ERROR_UNEXPECTED_END 注释 = "5 存在意外的结尾,例如 `[123`">
    常量 意外字符 <公开 类型 = YYJSON解析错误码 值 = @YYJSON_READ_ERROR_UNEXPECTED_CHARACTER 注释 = "6 文档中出现了意外字符,比如 `[abc]`">
    常量 无效的JSON结构 <公开 类型 = YYJSON解析错误码 值 = @YYJSON_READ_ERROR_JSON_STRUCTURE 注释 = "7 无效的JSON结构,例如 `[1,]`">
    常量 无效的注释 <公开 类型 = YYJSON解析错误码 值 = @YYJSON_READ_ERROR_INVALID_COMMENT 注释 = "8 无效的注释,例如未封闭的多行注释.">
    常量 无效的数值 <公开 类型 = YYJSON解析错误码 值 = @YYJSON_READ_ERROR_INVALID_NUMBER
            注释 = "9 存在无效的数值,例如 `123.e12`, `000`">
    常量 无效的文本 <公开 类型 = YYJSON解析错误码 值 = @YYJSON_READ_ERROR_INVALID_STRING 注释 = "10 无效的字符串,例如文本中有无效的转义字符.">
    常量 无效的字面 <公开 类型 = YYJSON解析错误码 值 = @YYJSON_READ_ERROR_LITERAL 注释 = "11 无效的JSON字面量,例如 `true` 写错成 `truu`">
    常量 无法打开文件 <公开 类型 = YYJSON解析错误码 值 = @YYJSON_READ_ERROR_FILE_OPEN 注释 = "12 无法打开文件">
    常量 无法读入文件 <公开 类型 = YYJSON解析错误码 值 = @YYJSON_READ_ERROR_FILE_READ 注释 = "13 无法读入文件">
}

类 YYJSON序列化错误码 <公开 注释 = "\"YYJSON序列化错误\"中的\"错误代码\"" 折叠 折叠2 隐藏值属性 = "0"
        @文档 = "category = \"JSON支持.YYJSON.常量\"" @别名 = "yyjson_write_code" @别名类型 = 本地整数基本类型
        @有效值范围 = "0, 0xFFFFFFFF">
{
    常量 成功 <公开 类型 = YYJSON序列化错误码 值 = @YYJSON_WRITE_SUCCESS 注释 = "0 执行成功,没有错误.">
    常量 无效的参数 <公开 类型 = YYJSON序列化错误码 值 = @YYJSON_WRITE_ERROR_INVALID_PARAMETER 注释 = "1 提供的参数无效,例如JSON文档为空指针.">
    常量 内存分配失败 <公开 类型 = YYJSON序列化错误码 值 = @YYJSON_WRITE_ERROR_MEMORY_ALLOCATION 注释 = "2 内存分配失败">
    常量 无效的值类型 <公开 类型 = YYJSON序列化错误码 值 = @YYJSON_WRITE_ERROR_INVALID_VALUE_TYPE 注释 = "3 JSON文档的值类型无效">
    常量 出现特殊值 <公开 类型 = YYJSON序列化错误码 值 = @YYJSON_WRITE_ERROR_NAN_OR_INF 注释 = "4 存在非数或无穷数等特殊值">
    常量 无法打开文件 <公开 类型 = YYJSON序列化错误码 值 = @YYJSON_WRITE_ERROR_FILE_OPEN 注释 = "5 无法打开文件">
    常量 无法写出文件 <公开 类型 = YYJSON序列化错误码 值 = @YYJSON_WRITE_ERROR_FILE_WRITE 注释 = "6 无法写出文件">
    常量 无效的文本 <公开 类型 = YYJSON序列化错误码 值 = @YYJSON_WRITE_ERROR_INVALID_STRING 注释 = "7 字符串中有无效的Unicode码">
}

类 YYJSON路径错误码 <公开 注释 = "\"YYJSON路径错误\"中的\"错误代码\"" 折叠 折叠2 隐藏值属性 = "0"
        @文档 = "category = \"JSON支持.YYJSON.常量\"" @别名 = "yyjson_ptr_code" @别名类型 = 本地整数基本类型
        @有效值范围 = "0, 0xFFFFFFFF">
{
    常量 成功 <公开 类型 = YYJSON路径错误码 值 = @YYJSON_PTR_ERR_NONE 注释 = "0 执行成功,没有错误.">
    常量 无效的参数 <公开 类型 = YYJSON路径错误码 值 = @YYJSON_PTR_ERR_PARAMETER 注释 = "1 提供的参数无效,例如JSON文档为空指针.">
    常量 语法错误 <公开 类型 = YYJSON路径错误码 值 = @YYJSON_PTR_ERR_SYNTAX 注释 = "2 JSON路径语法错误,如无效转义.">
    常量 解析失败 <公开 类型 = YYJSON路径错误码 值 = @YYJSON_PTR_ERR_RESOLVE 注释 = "3 JSON路径解析失败,例如索引超出范围、找不到键名.">
    常量 根节点为空 <公开 类型 = YYJSON路径错误码 值 = @YYJSON_PTR_ERR_NULL_ROOT 注释 = "4 文档的根节点为NULL,但它是函数调用所必需的.">
    常量 无法设置根节点 <公开 类型 = YYJSON路径错误码 值 = @YYJSON_PTR_ERR_SET_ROOT 注释 = "5 无法设置根节点,因为目标不是JSON文档.">
    常量 内存分配失败 <公开 类型 = YYJSON路径错误码 值 = @YYJSON_PTR_ERR_MEMORY_ALLOCATION 注释 = "6 内存分配失败,无法创建新值.">
}

类 YYJSON补丁错误码 <公开 注释 = "\"YYJSON补丁错误\"中的\"错误代码\"" 折叠 折叠2 隐藏值属性 = "0"
        @文档 = "category = \"JSON支持.YYJSON.常量\"" @别名 = "yyjson_patch_code" @别名类型 = 本地整数基本类型
        @有效值范围 = "0, 0xFFFFFFFF">
{
    常量 成功 <公开 类型 = YYJSON补丁错误码 值 = @YYJSON_PATCH_SUCCESS 注释 = "0 执行成功,没有错误.">
    常量 无效的参数 <公开 类型 = YYJSON补丁错误码 值 = @YYJSON_PATCH_ERROR_INVALID_PARAMETER
            注释 = "1 提供的参数无效,例如空JSON文档或非数组补丁.">
    常量 内存分配失败 <公开 类型 = YYJSON补丁错误码 值 = @YYJSON_PATCH_ERROR_MEMORY_ALLOCATION 注释 = "2 内存分配失败">
    常量 无效的操作 <公开 类型 = YYJSON补丁错误码 值 = @YYJSON_PATCH_ERROR_INVALID_OPERATION 注释 = "3 JSON补丁操作的不是对象类型">
    常量 丢失键名 <公开 类型 = YYJSON补丁错误码 值 = @YYJSON_PATCH_ERROR_MISSING_KEY 注释 = "4 JSON补丁操作缺少了必需的键名">
    常量 无效的成员 <公开 类型 = YYJSON补丁错误码 值 = @YYJSON_PATCH_ERROR_INVALID_MEMBER 注释 = "5 JSON补丁操作的成员无效">
    常量 不相等 <公开 类型 = YYJSON补丁错误码 值 = @YYJSON_PATCH_ERROR_EQUAL 注释 = "6 JSON补丁操作的测试结果不相等">
    常量 路径错误 <公开 类型 = YYJSON补丁错误码 值 = @YYJSON_PATCH_ERROR_POINTER 注释 = "7 JSON补丁操作中遇到JSON路径错误">

    #
}

#
