<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "WinHTTP" 注释 = "注意: WinHTTP的很多API只能在较新版的Windows上使用,甚至需要Windows 11的SDK才能支持全部API."
        注释 = "除非你的程序不考虑兼容老系统,一般不建议使用Windows 8及更高版本才能使用的API." @视窗.外部头文件 = "winhttp.h" @视窗.外部库 = "Winhttp.lib">

# 面向用户的二次封装 ===

类 网络同步访问类 <公开 注释 = "是\"WinHTTP网络类\"的简单封装,提供同步的网页访问支持." 折叠 @文档 = "category = \"WinHTTP\"">
{
    变量 用户代理 <公开 类型 = 文本型 注释 = "设置User-Agent,只能本实例首次网页访问之前设置;" 注释 = "空文本为默认UA,空对象为不使用UA(默认不添加这个协议头)."
            @属性变量 = 真>
    变量 代理类型 <公开 类型 = 访问类型_WinHTTP 值 = 访问类型_WinHTTP.不使用代理 注释 = "设置代理的类型,只能本实例首次网页访问之前设置." @属性变量 = 真>
    变量 代理服务器 <公开 类型 = 文本型 注释 = "设置代理服务器,仅在\"代理类型\"为\"命名代理\"时可用,只能本实例首次网页访问之前设置;"
            注释 = "无论代理是什么协议,都一律填http/https,例如Socoks5的代理也是填: \"http://127.0.0.1:7890\";"
            注释 = "可以用分号支持多个代理服务器,也可以对不同的协议使用不同的代理,例如:"
            注释 = "\"http=http://127.0.0.1:7890;https=http://192.168.1.1:8080\"" @属性变量 = 真>
    变量 代理跳过列表 <公开 类型 = 文本型 值 = "<local>" 注释 = "仅在\"代理类型\"为\"命名代理\"时可用,列表内的域名和IP不会通过代理访问;"
            注释 = "请提供用分号分隔的主机域名或IP地址,可以使用通配符;" 注释 = "请勿提供空文本,默认的\"<local>\"为忽略所有不含句点的主机名." @属性变量 = 真>
    变量 是否编码网址 <公开 类型 = 逻辑型 值 = 假 注释 = "是否自动对网址进行URL编码,默认为假. 请注意不要重复编码." @属性变量 = 真>
    变量 _自动Cookie管理 <类型 = 逻辑型 值 = 真>
    变量 _会话句柄 <类型 = 变整数>

    方法 类_清理 <折叠>
    {
        如果 (_会话句柄 != 0)
        {
            WinHTTP网络类.关闭句柄 (_会话句柄)
        }
    }

    方法 会话句柄 <公开 属性读 类型 = 变整数 注释 = "返回WinHTTP对象的会话句柄" 折叠>
    {
        返回 (_会话句柄)
    }

    方法 Cookie管理 <公开 属性写 注释 = "WinHTTP默认在缓冲区中保存服务器返回的Cookie,并在下一次请求时自动提交该Cookie."
            注释 = "这些Cookie数据在对象销毁后即失效,不能进行持久化管理." 注释 = "设置为假后将不再自动管理Cookie." 折叠>
    参数 是否启用 <类型 = 逻辑型 注释 = "默认为真">
    {
        _自动Cookie管理 = 是否启用
    }

    方法 网页访问 <公开 类型 = 网络请求响应类 注释 = "对指定网址发送请求并获取响应内容" 返回值注释 = "返回访问网页的结果,如果响应码为0则表示无法连接到目标网址或内部代码错误." 折叠>
    参数 网址 <类型 = 文本型 注释 = "提供所欲访问的网址内容">
    参数 请求方式 <类型 = 请求方式_WinHTTP 注释 = "提供所欲使用的请求方式" @默认值 = 请求方式_WinHTTP.GET>
    参数 提交信息 <类型 = 文本型 注释 = "设置本次请求所提交的文本,非POST请求也支持提交请求体,如需携带请求体务必保证该参数不为空;" 注释 = "如有必要,请自行对提交文本进行URL编码;"
            注释 = "本方法会根据提交信息的类型自动添加\"Content-Type\"协议头,无需你手动添加." @默认值 = 空对象>
    参数 附加协议头 <类型 = 文本数组类 注释 = "提供本次请求所欲使用的附加协议头,每一个成员表示一个协议." @默认值 = 空对象>
    参数 提交Cookie <类型 = 文本型 注释 = "提供本次请求所欲使用的Cookie内容,注意该参数提交的内容不会同步到\"自动Cookie管理\"." @默认值 = "">
    参数 内容编码 <类型 = 文本型 注释 = "指定所欲请求服务器使用的内容编码(压缩)方式,即\"Accept-Encoding\"协议内容;"
            注释 = "本参数只对Windows 8及更高版本的系统有效,旧系统不支持WinHTTP的自动解压缩;"
            注释 = "提供空文本时自动设置为\"Accept-Encoding: gzip, deflate\",提供空对象则禁用压缩;"
            注释 = "WinHTTP自动解压缩后,会将响应头的Content-Length、Content-Encoding删除掉." @默认值 = "">
    参数 代理地址 <类型 = 文本型 注释 = "设置当前一次网页访问使用的代理地址列表,非空时将代理模式临时改为\"命名代理\";"
            注释 = "无论代理是什么协议,都一律填http/https,例如Socoks5的代理也是填: \"http://127.0.0.1:7890\";"
            注释 = "可以用分号支持多个代理服务器,也可以对不同的协议使用不同的代理,例如:"
            注释 = "\"http=http://127.0.0.1:7890;https=http://192.168.1.1:8080\"" @默认值 = "">
    参数 代理账号 <类型 = 文本型 注释 = "提供代理服务器所需的用户名(可空),仅在代理模式为\"命名代理\"时可用." @默认值 = "">
    参数 代理密码 <类型 = 文本型 注释 = "提供代理服务器所需的用户密码(可空),仅在代理模式为\"命名代理\"时可用." @默认值 = "">
    参数 超时时间 <类型 = 整数 注释 = "指定本次完成整个请求所限定的超时时间,为-1时不限制,单位:毫秒." @默认值 = -1>
    参数 重定向次数 <类型 = 整数 注释 = "欲遵循网站重定向的最大次数,为0时禁止重定向." @默认值 = 10>
    参数 忽略SSL错误 <类型 = 逻辑型 注释 = "是否忽略任何SSL验证相关错误,即不验证证书也不验证服务器(如使用了代理将会被一同忽略)." @默认值 = 真>
    参数 是否UTF8 <类型 = 逻辑型 注释 = "指定提交信息的文本编码类型是否为UTF8,否则为ANSI多字节." @默认值 = 真>
    {
        变量 提交内容 <类型 = 字节集类>
        如果 (文本是否为空 (提交信息) == 假)
        {
            提交内容 = 选择 (是否UTF8, 文本到UTF8 (提交信息, 假), 文本到多字节 (提交信息, 假))
        }
        返回 (网页访问2 (网址, 请求方式, 提交内容, 附加协议头, 提交Cookie, 内容编码, 代理地址, 代理账号, 代理密码, 超时时间, 重定向次数, 忽略SSL错误))
    }

    方法 网页访问2 <公开 类型 = 网络请求响应类 注释 = "与\"网页访问\"基本一致,不同的是本方法提交的请求体内容为字节集类型."
            返回值注释 = "返回访问网页的结果,如果响应码为0则表示无法连接到目标网址或内部代码错误." 折叠>
    参数 网址 <类型 = 文本型 注释 = "提供所欲访问的网址内容">
    参数 请求方式 <类型 = 请求方式_WinHTTP 注释 = "提供所欲使用的请求方式" @默认值 = 请求方式_WinHTTP.GET>
    参数 提交信息 <类型 = 字节集类 注释 = "设置本次请求所提交的数据,非POST请求也支持提交请求体,如需携带请求体务必保证该参数不为空;" 注释 = "如有必要,请自行对提交信息进行URL编码;"
            注释 = "本方法会根据提交信息的类型自动添加\"Content-Type\"协议头,无需你手动添加." @默认值 = 空对象>
    参数 附加协议头 <类型 = 文本数组类 注释 = "提供本次请求所欲使用的附加协议头,每一个成员表示一个协议." @默认值 = 空对象>
    参数 提交Cookie <类型 = 文本型 注释 = "提供本次请求所欲使用的Cookie内容,注意该参数提交的内容不会同步到\"自动Cookie管理\"." @默认值 = "">
    参数 内容编码 <类型 = 文本型 注释 = "指定所欲请求服务器使用的内容编码(压缩)方式,即\"Accept-Encoding\"协议内容;"
            注释 = "本参数只对Windows 8及更高版本的系统有效,旧系统不支持WinHTTP的自动解压缩;"
            注释 = "提供空文本时自动设置为\"Accept-Encoding: gzip, deflate\",提供空对象则禁用压缩;"
            注释 = "WinHTTP自动解压缩后,会将响应头的Content-Length、Content-Encoding删除掉." @默认值 = "">
    参数 代理地址 <类型 = 文本型 注释 = "设置当前一次网页访问使用的代理地址列表,非空时将代理模式临时改为\"命名代理\";"
            注释 = "无论代理是什么协议,都一律填http/https,例如Socoks5的代理也是填: \"http://127.0.0.1:7890\";"
            注释 = "可以用分号支持多个代理服务器,也可以对不同的协议使用不同的代理,例如:"
            注释 = "\"http=http://127.0.0.1:7890;https=http://192.168.1.1:8080\"" @默认值 = "">
    参数 代理账号 <类型 = 文本型 注释 = "提供代理服务器所需的用户名(可空),仅在代理模式为\"命名代理\"时可用." @默认值 = "">
    参数 代理密码 <类型 = 文本型 注释 = "提供代理服务器所需的用户密码(可空),仅在代理模式为\"命名代理\"时可用." @默认值 = "">
    参数 超时时间 <类型 = 整数 注释 = "指定本次完成整个请求所限定的超时时间,为-1时不限制,单位:毫秒." @默认值 = -1>
    参数 重定向次数 <类型 = 整数 注释 = "欲遵循网站重定向的最大次数,为0时禁止重定向." @默认值 = 10>
    参数 忽略SSL错误 <类型 = 逻辑型 注释 = "是否忽略任何SSL验证相关错误,即不验证证书也不验证服务器(如使用了代理将会被一同忽略)." @默认值 = 真>
    {
        变量 协议头数据 <类型 = 文本型>
        附加协议头.枚举循环 ()
        {
            加入文本 (协议头数据, 附加协议头.取枚举值 ())
            加入换行文本 (协议头数据)
        }
        删自身尾空 (协议头数据)
        返回 (网页访问3 (网址, 请求方式, 提交信息, 协议头数据, 提交Cookie, 内容编码, 代理地址, 代理账号, 代理密码, 超时时间, 重定向次数, 忽略SSL错误))
    }

    方法 网页访问3 <公开 类型 = 网络请求响应类 注释 = "与\"网页访问2\"基本一致,不同的是本方法的\"附加协议头\"参数为文本型."
            返回值注释 = "返回访问网页的结果,如果响应码为0则表示无法连接到目标网址或内部代码错误." 折叠 @虚拟方法 = 可覆盖>
    参数 网址 <类型 = 文本型 注释 = "提供所欲访问的网址内容">
    参数 请求方式 <类型 = 请求方式_WinHTTP 注释 = "提供所欲使用的请求方式" @默认值 = 请求方式_WinHTTP.GET>
    参数 提交信息 <类型 = 字节集类 注释 = "设置本次请求所提交的数据,非POST请求也支持提交请求体,如需携带请求体务必保证该参数不为空;" 注释 = "如有必要,请自行对提交信息进行URL编码;"
            注释 = "本方法会根据提交信息的类型自动添加\"Content-Type\"协议头,无需你手动添加." @默认值 = 空对象>
    参数 附加协议头 <类型 = 文本型 注释 = "提供本次请求所欲使用的附加协议头,每个协议之间请用\"\\r\\n\"换行." @默认值 = 空对象>
    参数 提交Cookie <类型 = 文本型 注释 = "提供本次请求所欲使用的Cookie内容,注意该参数提交的内容不会同步到\"自动Cookie管理\"." @默认值 = "">
    参数 内容编码 <类型 = 文本型 注释 = "指定所欲请求服务器使用的内容编码(压缩)方式,即\"Accept-Encoding\"协议内容;"
            注释 = "本参数只对Windows 8及更高版本的系统有效,旧系统不支持WinHTTP的自动解压缩;"
            注释 = "提供空文本时自动设置为\"Accept-Encoding: gzip, deflate\",提供空对象则禁用压缩;"
            注释 = "WinHTTP自动解压缩后,会将响应头的Content-Length、Content-Encoding删除掉." @默认值 = "">
    参数 代理地址 <类型 = 文本型 注释 = "设置当前一次网页访问使用的代理地址列表,非空时将代理模式临时改为\"命名代理\";"
            注释 = "无论代理是什么协议,都一律填http/https,例如Socoks5的代理也是填: \"http://127.0.0.1:7890\";"
            注释 = "可以用分号支持多个代理服务器,也可以对不同的协议使用不同的代理,例如:"
            注释 = "\"http=http://127.0.0.1:7890;https=http://192.168.1.1:8080\"" @默认值 = "">
    参数 代理账号 <类型 = 文本型 注释 = "提供代理服务器所需的用户名(可空),仅在代理模式为\"命名代理\"时可用." @默认值 = "">
    参数 代理密码 <类型 = 文本型 注释 = "提供代理服务器所需的用户密码(可空),仅在代理模式为\"命名代理\"时可用." @默认值 = "">
    参数 超时时间 <类型 = 整数 注释 = "指定本次完成整个请求所限定的超时时间,为-1时不限制,单位:毫秒." @默认值 = -1>
    参数 重定向次数 <类型 = 整数 注释 = "欲遵循网站重定向的最大次数,为0时禁止重定向." @默认值 = 10>
    参数 忽略SSL错误 <类型 = 逻辑型 注释 = "是否忽略任何SSL验证相关错误,即不验证证书也不验证服务器(如使用了代理将会被一同忽略)." @默认值 = 真>
    {
        变量 返回结果 <类型 = 网络请求响应类>
        变量 连接句柄 <类型 = 变整数>
        变量 URL组件信息 <类型 = URL组件信息类>
        变量 启动时间 <类型 = 长整数>
        启动时间 = 取现行纳秒时间戳 ()
        如果 (_初始化 () == 假)
        {
            返回结果.错误信息 = "初始化失败: " + WinHTTP网络类.取最后错误信息 ()
            返回结果.请求耗时 = (取现行纳秒时间戳 () - 启动时间) / 1000000
            返回 (返回结果)
        }
        如果 (WinHTTP网络类.拆分URL (网址, URL组件信息, 选择 (是否编码网址, URL操作_WinHTTP.URL编码, 0)) == 假)
        {
            返回结果.错误信息 = "拆分URL失败: " + WinHTTP网络类.取最后错误信息 ()
            返回结果.请求耗时 = (取现行纳秒时间戳 () - 启动时间) / 1000000
            返回 (返回结果)
        }
        连接句柄 = WinHTTP网络类.连接服务器 (_会话句柄, URL组件信息.域名, 选择 (URL组件信息.端口 == 80 || URL组件信息.端口 == 443, 0, URL组件信息.端口))
        如果 (连接句柄 == 0)
        {
            返回结果.错误信息 = "连接服务器失败: " + WinHTTP网络类.取最后错误信息 ()
            返回结果.请求耗时 = (取现行纳秒时间戳 () - 启动时间) / 1000000
            返回 (返回结果)
        }
        变量 请求句柄 <类型 = 变整数>
        变量 基本协议头 <类型 = 文本数组类>
        变量 请求标志 <类型 = 整数>
        变量 请求头修改方式 <类型 = 整数>
        // 请求标志 = 请求标志_WinHTTP.URL编码  // 对URL的路径和参数部分进行URL编码
        如果 (URL组件信息.协议类型 == 2)
        {
            请求标志 = 位或 (请求标志, 请求标志_WinHTTP.安全连接)  // HTTPS必须加上这个标志
        }
        请求句柄 = WinHTTP网络类.打开请求 (连接句柄, 请求方式, URL组件信息.路径 + URL组件信息.附加信息, , , 空对象, 请求标志)
        如果 (请求句柄 == 0)
        {
            返回结果.错误信息 = "打开请求失败: " + WinHTTP网络类.取最后错误信息 ()
            WinHTTP网络类.关闭句柄 (连接句柄)
            返回结果.请求耗时 = (取现行纳秒时间戳 () - 启动时间) / 1000000
            返回 (返回结果)
        }
        如果 (文本是否为空 (代理地址) == 假)
        {
            变量 代理信息 <类型 = WinHTTP代理信息类>
            代理信息.访问类型 = 访问类型_WinHTTP.命名代理
            代理信息.代理服务器 = 代理地址
            代理信息.代理跳过列表 = 代理跳过列表
            WinHTTP网络类.置选项_代理信息 (请求句柄, 代理信息)
        }
        如果 (文本是否为空 (代理账号) == 假)
        {
            WinHTTP网络类.置选项_代理用户名 (请求句柄, 代理账号)
            WinHTTP网络类.置选项_代理密码 (请求句柄, 代理密码)
        }
        请求头修改方式 = 位或 (请求头修改方式_WinHTTP.替换和删除, 请求头修改方式_WinHTTP.添加请求头)
        基本协议头.加入成员 ("Accept: */*")
        基本协议头.加入成员 ("Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,zh-TW;q=0.5")
        WinHTTP网络类.添加请求头2 (请求句柄, 基本协议头, 请求头修改方式)
        如果 (文本是否为空对象 (内容编码) == 假 && WinHTTP网络类.置选项_解压缩 (请求句柄, 3) == 真)
        {
            // Windows 8.1以上才能使用自动解压缩,旧系统设置该选项只会返回假,不会造成崩溃.
            如果 (文本是否为空 (内容编码) == 真)
            {
                WinHTTP网络类.添加请求头 (请求句柄, "Accept-Encoding: gzip, deflate", 请求头修改方式)
            }
            否则
            {
                WinHTTP网络类.添加请求头 (请求句柄, 内容编码, 请求头修改方式)
            }
        }
        如果 (_自动Cookie管理 == 假)
        {
            WinHTTP网络类.置选项_禁止功能 (请求句柄, 禁止功能标志_WinHTTP.禁止Cookies)
        }
        如果 (文本是否为空 (提交Cookie) == 假)
        {
            如果 (是否以文本开头 (提交Cookie, "Cookie:", 假) == 假)
            {
                WinHTTP网络类.添加请求头 (请求句柄, "Cookie: " + 提交Cookie, 请求头修改方式)
            }
            否则
            {
                WinHTTP网络类.添加请求头 (请求句柄, 提交Cookie, 请求头修改方式)
            }
        }
        如果 (提交信息.取字节集长度 () > 0)
        {
            如果 (提交信息.取字节集数据 (0, 字节) == 123 || 提交信息.取字节集数据 (0, 字节) == 91)  // 首尾字符为'{'或'[',表示是JSON数据
            {
                WinHTTP网络类.添加请求头 (请求句柄, "Content-Type: application/json; charset=utf-8", 请求头修改方式)
            }
            否则
            {
                WinHTTP网络类.添加请求头 (请求句柄, "Content-Type: application/x-www-form-urlencoded; charset=utf-8", 请求头修改方式)
            }
        }
        如果 (文本是否为空 (附加协议头) == 假)
        {
            WinHTTP网络类.添加请求头 (请求句柄, 附加协议头, 请求头修改方式)
        }
        如果 (重定向次数 <= 0)
        {
            WinHTTP网络类.置选项_禁止功能 (请求句柄, 禁止功能标志_WinHTTP.禁止重定向)
        }
        否则
        {
            WinHTTP网络类.置选项_最大重定向次数 (请求句柄, 重定向次数)
            WinHTTP网络类.置状态回调 (请求句柄, _重定向回调, 回调标志_WinHTTP.重定向)
        }
        WinHTTP网络类.置选项_发送超时 (请求句柄, 超时时间)
        WinHTTP网络类.置选项_接收超时 (请求句柄, 超时时间)
        如果 (忽略SSL错误 == 真)
        {
            WinHTTP网络类.置选项_安全标志 (请求句柄, 安全标志_WinHTTP.忽略所有证书错误)
        }
        // 开始发送请求
        如果 (WinHTTP网络类.发送请求 (请求句柄, 空对象, 提交信息, 提交信息.取字节集长度 (), 返回结果.取对象自身指针 ()) == 真)
        {
            如果 (WinHTTP网络类.接收响应 (请求句柄) == 真)
            {
                // 接收响应头
                变量 响应头 <类型 = 文本型>
                WinHTTP网络类.取响应头 (请求句柄, 响应头, 协议头标志_WinHTTP.所有标头_换行)
                分割文本 (响应头, "\r\n", 返回结果.响应头, 真, 真)
                返回结果.响应码 = WinHTTP网络类.取响应头_整数 (请求句柄, 协议头标志_WinHTTP.状态码)
                // 接收主体内容
                如果 (请求方式 != 请求方式_WinHTTP.HEAD)
                {
                    变量 内容长度 <类型 = 整数>
                    变量 接收数量 <类型 = 整数类>
                    内容长度 = WinHTTP网络类.取响应头_整数 (请求句柄, 协议头标志_WinHTTP.内容长度)
                    如果 (内容长度 > 0)
                    {
                        变量 次数 <类型 = 整数>
                        返回结果.请求结果.分配字节集 (内容长度, 真)  // 提前分配内存
                        次数 = 内容长度 / 1048576  // 分段接收数据,每次1MB
                        计次循环 (次数)
                        {
                            如果 (WinHTTP网络类.接收数据2 (请求句柄, 返回结果.请求结果.取字节集指针 () + 取循环索引 () * 1048576, 1048576, 接收数量) == 假 && 接收数量.值 != 1048576)
                            {
                                返回结果.错误信息 = "接收数据失败: " + WinHTTP网络类.取最后错误信息 ()
                                跳出循环
                            }
                        }
                        如果 (内容长度 % 1048576 > 0)
                        {
                            如果 (WinHTTP网络类.接收数据2 (请求句柄, 返回结果.请求结果.取字节集指针 () + 次数 * 1048576, 内容长度 % 1048576, 接收数量) == 假 && 接收数量.值 != 内容长度 % 1048576)
                            {
                                返回结果.错误信息 = "接收数据失败: " + WinHTTP网络类.取最后错误信息 ()
                            }
                        }
                    }
                    否则  // 内容长度不定(WinHTTP解压缩内容后就取不到长度)
                    {
                        变量 可用数量 <类型 = 整数类>
                        返回结果.请求结果.置字节集预分配尺寸 (8192)  // 8KB是WinHTTP内部的默认缓冲区大小
                        循环判断首 ()
                        {
                            变量 缓冲区 <类型 = 字节集类>
                            如果 (WinHTTP网络类.取可用数据量 (请求句柄, 可用数量) == 假)
                            {
                                返回结果.错误信息 = "取可用数据量失败: " + WinHTTP网络类.取最后错误信息 ()
                                跳出循环
                            }
                            缓冲区.分配字节集 (可用数量.值)
                            如果 (WinHTTP网络类.接收数据 (请求句柄, 缓冲区, 接收数量) == 真)
                            {
                                如果 (接收数量.值 == 0)
                                {
                                    跳出循环
                                }
                                返回结果.请求结果.添加字节集 (缓冲区)
                            }
                            否则
                            {
                                返回结果.错误信息 = "接收数据失败: " + WinHTTP网络类.取最后错误信息 ()
                                跳出循环
                            }
                        }
                        循环判断尾 (可用数量.值 > 0)
                    }
                }
                // 获取cookies
                变量 索引 <类型 = 整数类>
                索引.值 = 0
                循环判断首 ()
                {
                    变量 cookie <类型 = 文本型>
                    如果 (WinHTTP网络类.取响应头 (请求句柄, cookie, 协议头标志_WinHTTP.设置Cookie, 空对象, 索引) == 假)
                    {
                        跳出循环
                    }
                    返回结果.Cookies.加入成员 (WinHTTP网络类.取Cookie内容 (cookie))
                }
                循环判断尾 (索引.值 >= 0)
            }
            否则
            {
                返回结果.错误信息 = "接收响应失败: " + WinHTTP网络类.取最后错误信息 ()
            }
        }
        否则
        {
            返回结果.错误信息 = "发送请求失败: " + WinHTTP网络类.取最后错误信息 ()
        }
        WinHTTP网络类.关闭句柄 (请求句柄)
        WinHTTP网络类.关闭句柄 (连接句柄)
        返回结果.请求耗时 = (取现行纳秒时间戳 () - 启动时间) / 1000000
        返回 (返回结果)
    }

    方法 _初始化 <类型 = 逻辑型 注释 = "内部方法" 折叠>
    {
        如果 (_会话句柄 == 0)
        {
            _会话句柄 = WinHTTP网络类.初始化 (用户代理, 代理类型, 假, 代理服务器, 代理跳过列表)
            如果 (_会话句柄 == 0)
            {
                返回 (假)
            }
            WinHTTP网络类.置选项_IPv6快速回退 (_会话句柄, 真)  // 在较新系统会优先解析IPV6地址,因为很多网络无法正常访问IPV6,必须设置该选项快速回退到IPV4
            WinHTTP网络类.置选项_TCP快速打开 (_会话句柄, 真)
            WinHTTP网络类.置超时时间 (_会话句柄, 5000, 2000, 30000, 30000)

        }
        返回 (真)
    }

    方法 _重定向回调 <静态 注释 = "内部方法" 折叠>
    参数 网络句柄 <类型 = 变整数 注释 = "与状态回调关联的网络句柄.">
    参数 上下文值 <类型 = 变整数 注释 = "  与网络句柄关联的的上下文值,可以通过\"置选项_上下文值\"或\"发送请求\"设置," 注释 = "可用于传递用户自定义的数据.">
    参数 网络状态 <类型 = 回调状态标志_WinHTTP 注释 = "请参考\"回调状态标志_WinHTTP\"中的常量.">
    参数 状态信息指针 <类型 = 变整数 注释 = "指向缓冲区的指针,数据类型取决于参数\"网络状态\"的值.">
    参数 状态信息长度 <类型 = 整数 注释 = "如果状态信息为文本数据,则本参数为文本的字符数,为其他类型时则为字节数.">
    {
        如果 (网络状态 == 回调状态标志_WinHTTP.重定向)
        {
            读指针处对象 (上下文值, 网络请求响应类).重定向次数 = 读指针处对象 (上下文值, 网络请求响应类).重定向次数 + 1
            读指针处对象 (上下文值, 网络请求响应类).重定向地址.加入成员 (指针到文本 (状态信息指针))
            // 获取当前重定向的cookies
            变量 索引 <类型 = 整数类>
            索引.值 = 0
            循环判断首 ()
            {
                变量 cookie <类型 = 文本型>
                如果 (WinHTTP网络类.取响应头 (网络句柄, cookie, 协议头标志_WinHTTP.设置Cookie, 空对象, 索引) == 假)
                {
                    跳出循环
                }
                读指针处对象 (上下文值, 网络请求响应类).Cookies.加入成员 (WinHTTP网络类.取Cookie内容 (cookie))
            }
            循环判断尾 (索引.值 >= 0)
        }
    }
}

类 网络异步访问类 <公开 注释 = "是\"WinHTTP网络类\"的简单封装,提供异步并发式的网页访问支持." 折叠 @文档 = "category = \"WinHTTP\"">
{
    变量 是否编码网址 <公开 类型 = 逻辑型 值 = 假 注释 = "是否自动对网址进行URL编码,默认为假. 请注意不要重复编码." @属性变量 = 真>
    变量 _自动Cookie管理 <类型 = 逻辑型 值 = 真>
    变量 _轮询时间 <类型 = 整数 值 = 50>
    变量 _任务上限 <类型 = 长整数>
    变量 _会话句柄 <类型 = 变整数>
    变量 _工作数 <类型 = 原子整数类>
    变量 _并发数 <类型 = 原子整数类>
    变量 _退出线程 <类型 = 同步事件类>
    变量 _优先任务 <类型 = 网络访问参数队列>
    变量 _任务队列 <类型 = 网络访问参数阻塞队列 注释 = "存放已提交的传输参数">

    # 公开方法 ---

    方法 会话句柄 <公开 属性读 类型 = 变整数 注释 = "返回WinHTTP对象的会话句柄" 折叠>
    {
        返回 (_会话句柄)
    }

    方法 Cookie管理 <公开 属性写 注释 = "WinHTTP默认在缓冲区中保存服务器返回的Cookie,并在下一次请求时自动提交该Cookie."
            注释 = "这些Cookie数据在对象销毁后即失效,不能进行持久化管理." 注释 = "设置为假后将不再自动管理Cookie." 折叠>
    参数 是否启用 <类型 = 逻辑型 注释 = "默认为真">
    {
        _自动Cookie管理 = 是否启用
    }

    方法 轮询时间 <公开 属性读 类型 = 整数 注释 = "返回当前的轮询时间,单位为毫秒." 注释 = "该值表示每隔多少毫秒,尝试从队列中获取并执行任务." 折叠>
    {
        返回 (_轮询时间)
    }

    方法 轮询时间 <公开 属性写 注释 = "设置轮询时间,单位为毫秒." 注释 = "该值表示每隔多少毫秒,尝试从队列中获取并执行任务." 折叠>
    参数 时间间隔 <类型 = 整数 注释 = "所欲设置的延迟时间(单位为毫秒),不能小于10">
    {
        _轮询时间 = 取较大值 (时间间隔, 10)
    }

    方法 启动连接池 <公开 类型 = 逻辑型 注释 = "必须启动连接池才会开始进行网络传输,也可以在投递任务后启动." 返回值注释 = "返回是否成功,重复调用本方法亦会返回真,但不会执行初始化操作."
            折叠>
    参数 工作线程数 <类型 = 整数 注释 = "默认值0表示CPU线程数,最小值为1." @默认值 = 0>
    参数 最大任务数 <类型 = 长整数 注释 = "最大可提交的任务数量,小于等于0为不限制数量;" 注释 = "超过此上限后投递任务会返回失败;" 注释 = "提交任务过多时,任务队列会占用较大的内存."
            @默认值 = 0>
    参数 用户代理 <类型 = 文本型 注释 = "即User Agent,简称UA,使服务器能识别客户使用的操作系统及版本、CPU类型、"
            注释 = "浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等." 注释 = "空文本为使用默认UA,空对象为不使用UA(默认不添加这个协议头)." @默认值 = "">
    参数 代理类型 <类型 = 访问类型_WinHTTP 注释 = "指定是否使用代理服务器" @默认值 = 访问类型_WinHTTP.不使用代理>
    参数 代理服务器 <类型 = 文本型 注释 = "仅在\"代理类型\"为\"命名代理\"时可用,需要提供CERN类型的HTTP代理." @默认值 = "">
    参数 代理跳过列表 <类型 = 文本型 注释 = "仅在\"代理类型\"为\"命名代理\"时可用,列表内的域名和IP不会通过代理访问;" 注释 = "请提供用分号分隔的主机域名或IP地址,可以使用通配符;"
            注释 = "请勿提供空文本,默认的\"<local>\"为忽略所有不含句点的主机名." @默认值 = "<local>">
    {
        如果 (_会话句柄 == 0)
        {
            _会话句柄 = WinHTTP网络类.初始化 (用户代理, 代理类型, 真, 代理服务器, 代理跳过列表)
            如果 (_会话句柄 == 0)
            {
                返回 (假)
            }
            如果 (工作线程数 == 0)  // 取CPU线程数
            {
                工作线程数 = 取CPU核心数 ()
            }
            _并发数.置值 (取较大值 (工作线程数, 1))
            WinHTTP网络类.置选项_线程数量 (_并发数.取值 ())
            _任务上限 = 最大任务数
            _任务队列.重置队列 (选择 (_任务上限 > 0, _任务上限, (长整数)1024))
            WinHTTP网络类.置选项_IPv6快速回退 (_会话句柄, 真)  // 在较新系统会优先解析IPV6地址,因为大部分网络无法访问IPV6,必须设置该选项快速回退到IPV4
            WinHTTP网络类.置选项_TCP快速打开 (_会话句柄, 真)
            WinHTTP网络类.置超时时间 (_会话句柄, 5000, 2000, 30000, 30000)
            _退出线程.重置 ()
            线程对象类.启动无参数无返回值动态线程 (本对象, _线程运行)
        }
        返回 (真)
    }

    方法 销毁连接池 <公开 注释 = "当你不再使用本类时,应当手动调用本方法提前释放被占用的资源." 注释 = "类析构时会自动调用." 折叠>
    {
        如果 (_会话句柄 != 0)
        {
            _退出线程.放行 ()
            清空任务 ()
            WinHTTP网络类.关闭句柄 (_会话句柄)
            _会话句柄 = 0
        }
    }

    方法 最大并发数 <公开 属性读 类型 = 整数 注释 = "返回网络传输的最大并发数" 折叠>
    {
        返回 (_并发数.取值 ())
    }

    方法 任务上限数 <公开 属性读 类型 = 长整数 注释 = "返回最大可提交的任务数量,0为不限制数量." 注释 = "提交任务过多时,任务队列会占用较大的内存,应适度限制." 折叠>
    {
        返回 (_任务上限)
    }

    方法 执行任务数 <公开 属性读 类型 = 整数 注释 = "获取当前正在执行的任务数量" 折叠>
    {
        返回 (_工作数.取值 ())
    }

    方法 剩余任务数 <公开 属性读 类型 = 长整数 注释 = "获取剩余的任务数量" 折叠>
    {
        返回 (_任务队列.取成员数 ())
    }

    方法 清空任务 <公开 注释 = "清空所有已投递的网络传输任务,传输中的任务仍会继续完成." 折叠>
    {
        变量 参数指针 <类型 = 网络访问参数指针>
        判断循环 (_优先任务.出队 (参数指针) == 真)
        {
            参数指针.销毁 ()
        }
        判断循环 (_任务队列.出队 (参数指针) == 真)
        {
            参数指针.销毁 ()
        }
    }

    方法 投递网页访问 <公开 类型 = 逻辑型 注释 = "对指定网址发送请求,当传输结束后,请在\"网页访问完毕\"事件中获取响应内容." 折叠>
    参数 网址 <类型 = 文本型 注释 = "提供所欲访问的网址内容">
    参数 请求方式 <类型 = 请求方式_WinHTTP 注释 = "提供所欲使用的请求方式" @默认值 = 请求方式_WinHTTP.GET>
    参数 提交信息 <类型 = 文本型 注释 = "设置本次请求所提交的数据,非POST请求也支持提交请求体,如需携带请求体务必保证该参数不为空;" 注释 = "如有必要,请自行对提交信息进行URL编码;"
            注释 = "本方法会根据提交信息的类型自动添加\"Content-Type\"协议头,无需你手动添加." @默认值 = 空对象>
    参数 附加协议头 <类型 = 文本数组类 注释 = "提供本次请求所欲使用的附加协议头,每一个成员表示一个协议." @默认值 = 空对象>
    参数 提交Cookie <类型 = 文本型 注释 = "提供本次请求所欲使用的Cookie内容,注意该参数提交的内容不会同步到\"自动Cookie管理\"." @默认值 = "">
    参数 内容编码 <类型 = 文本型 注释 = "指定所欲请求服务器使用的内容编码(压缩)方式,即\"Accept-Encoding\"协议内容;"
            注释 = "本参数只对Windows 8及更高版本的系统有效,旧系统不支持WinHTTP的自动解压缩;"
            注释 = "提供空文本时自动设置为\"Accept-Encoding: gzip, deflate\",提供空对象则禁用压缩;"
            注释 = "WinHTTP自动解压缩后,会将响应头的Content-Length、Content-Encoding删除掉." @默认值 = "">
    参数 代理地址 <类型 = 文本型 注释 = "设置当前一次网页访问使用的代理地址列表,非空时将代理模式临时改为\"命名代理\";"
            注释 = "无论代理是什么协议,都一律填http/https,例如Socoks5的代理也是填: \"http://127.0.0.1:7890\";"
            注释 = "可以用分号支持多个代理服务器,也可以对不同的协议使用不同的代理,例如:"
            注释 = "\"http=http://127.0.0.1:7890;https=http://192.168.1.1:8080\"" @默认值 = "">
    参数 代理账号 <类型 = 文本型 注释 = "提供代理服务器所需的用户名(可空),仅在代理模式为\"命名代理\"时可用." @默认值 = "">
    参数 代理密码 <类型 = 文本型 注释 = "提供代理服务器所需的用户密码(可空),仅在代理模式为\"命名代理\"时可用." @默认值 = "">
    参数 超时时间 <类型 = 整数 注释 = "指定本次完成整个请求所限定的超时时间,为-1时不限制,单位:毫秒." @默认值 = -1>
    参数 重定向次数 <类型 = 整数 注释 = "欲遵循网站重定向的最大次数,为0时禁止重定向." @默认值 = 10>
    参数 忽略SSL错误 <类型 = 逻辑型 注释 = "是否忽略任何SSL验证相关错误,即不验证证书也不验证服务器(如使用了代理将会被一同忽略)." @默认值 = 真>
    参数 是否优先 <类型 = 逻辑型 注释 = "是否优先执行该任务,会自动排到常规任务的前面,优先执行不受任务上限数限制." @默认值 = 假>
    参数 是否UTF8 <类型 = 逻辑型 注释 = "指定提交信息的文本编码类型是否为UTF8,否则为ANSI多字节." @默认值 = 真>
    参数 URL编码 <类型 = 逻辑型 注释 = "是否对提交信息进行URL编码,如果提供的文本已经编码过,请设置为假;"
            注释 = "如果提交信息为JSON必须设置为假,如有必要请用JSON库自带的序列转义功能;" 注释 = "如果设置为真,请确保参数值不含\"=\"和\"&\"号,否则请自行手动URL编码."
            @默认值 = 假>
    参数 用户数据 <类型 = 变整数 注释 = "用户提供的自定义数据,可以是指针或自定义的标识,在\"网络请求响应类\"中接收." @默认值 = 0>
    {
        变量 提交内容 <类型 = 字节集类>
        如果 (文本是否为空对象 (提交信息) == 假)
        {
            如果 (文本是否为空 (提交信息) == 假)
            {
                提交内容 = 选择 (是否UTF8, 文本到UTF8 (提交信息, 假), 文本到多字节 (提交信息, 假))
                如果 (URL编码 == 真)
                {
                    变量 位置1 <类型 = 整数>
                    变量 位置2 <类型 = 整数>
                    位置1 = 提交内容.倒找字节集 (文本到UTF8 ("=", 假))
                    位置2 = 提交内容.取字节集长度 ()
                    判断循环 (位置1 != -1)
                    {
                        提交内容.字节集替换 (位置1 + 1, 位置2 - 位置1 - 1, URL编解码类.编码 (提交内容.取字节集中间 (位置1 + 1, 位置2 - 位置1 - 1)))
                        位置2 = 提交内容.倒找字节集 (文本到UTF8 ("&", 假), 位置1)
                        如果 (位置2 == -1)
                        {
                            跳出循环
                        }
                        位置1 = 提交内容.倒找字节集 (文本到UTF8 ("=", 假), 位置2)
                    }
                }
            }
        }
        否则
        {
            提交内容.重置为空对象 ()  // 空对象标志
        }
        返回 (投递网页访问2 (网址, 请求方式, 提交内容, 附加协议头, 提交Cookie, 内容编码, 代理地址, 代理账号, 代理密码, 超时时间, 重定向次数, 忽略SSL错误, 是否优先, 用户数据))
    }

    方法 投递网页访问2 <公开 类型 = 逻辑型 注释 = "对指定网址发送请求,当传输结束后,请在\"网页访问完毕\"事件中获取响应内容."
            注释 = "与\"投递网页访问\"命令基本一致,不同的是本方法提交的请求体内容为字节集类型." 折叠>
    参数 网址 <类型 = 文本型 注释 = "提供所欲访问的网址内容">
    参数 请求方式 <类型 = 请求方式_WinHTTP 注释 = "提供所欲使用的请求方式" @默认值 = 请求方式_WinHTTP.GET>
    参数 提交信息 <类型 = 字节集类 注释 = "设置本次请求所提交的数据,非POST请求也支持提交请求体,如需携带请求体务必保证该参数不为空;" 注释 = "如有必要,请自行对提交信息进行URL编码;"
            注释 = "本方法会根据提交信息的类型自动添加\"Content-Type\"协议头,无需你手动添加." @默认值 = 空对象>
    参数 附加协议头 <类型 = 文本数组类 注释 = "提供本次请求所欲使用的附加协议头,每一个成员表示一个协议." @默认值 = 空对象>
    参数 提交Cookie <类型 = 文本型 注释 = "提供本次请求所欲使用的Cookie内容,注意该参数提交的内容不会同步到\"自动Cookie管理\"." @默认值 = "">
    参数 内容编码 <类型 = 文本型 注释 = "指定所欲请求服务器使用的内容编码(压缩)方式,即\"Accept-Encoding\"协议内容;"
            注释 = "本参数只对Windows 8及更高版本的系统有效,旧系统不支持WinHTTP的自动解压缩;"
            注释 = "提供空文本时自动设置为\"Accept-Encoding: gzip, deflate\",提供空对象则禁用压缩;"
            注释 = "WinHTTP自动解压缩后,会将响应头的Content-Length、Content-Encoding删除掉." @默认值 = "">
    参数 代理地址 <类型 = 文本型 注释 = "设置当前一次网页访问使用的代理地址列表,非空时将代理模式临时改为\"命名代理\";"
            注释 = "无论代理是什么协议,都一律填http/https,例如Socoks5的代理也是填: \"http://127.0.0.1:7890\";"
            注释 = "可以用分号支持多个代理服务器,也可以对不同的协议使用不同的代理,例如:"
            注释 = "\"http=http://127.0.0.1:7890;https=http://192.168.1.1:8080\"" @默认值 = "">
    参数 代理账号 <类型 = 文本型 注释 = "提供代理服务器所需的用户名(可空),仅在代理模式为\"命名代理\"时可用." @默认值 = "">
    参数 代理密码 <类型 = 文本型 注释 = "提供代理服务器所需的用户密码(可空),仅在代理模式为\"命名代理\"时可用." @默认值 = "">
    参数 超时时间 <类型 = 整数 注释 = "指定本次完成整个请求所限定的超时时间,为-1时不限制,单位:毫秒." @默认值 = -1>
    参数 重定向次数 <类型 = 整数 注释 = "欲遵循网站重定向的最大次数,为0时禁止重定向." @默认值 = 10>
    参数 忽略SSL错误 <类型 = 逻辑型 注释 = "是否忽略任何SSL验证相关错误,即不验证证书也不验证服务器(如使用了代理将会被一同忽略)." @默认值 = 真>
    参数 是否优先 <类型 = 逻辑型 注释 = "是否优先执行该任务,会自动排到常规任务的前面,优先执行不受任务上限数限制." @默认值 = 假>
    参数 用户数据 <类型 = 变整数 注释 = "用户提供的自定义数据,可以是指针或自定义的标识,在\"网络请求响应类\"中接收." @默认值 = 0>
    {
        如果 (_任务上限 > 0 && _任务队列.取成员数 () >= _任务上限)
        {
            如果 (是否优先 == 假)
            {
                返回 (假)
            }
        }
        变量 参数指针 <类型 = 网络访问参数指针>
        参数指针 = 网络访问参数指针.创建 ()
        如果 (参数指针.为空指针 ())
        {
            返回 (假)
        }
        参数指针.值.访问类型 = 0
        参数指针.值.网址 = 网址
        参数指针.值.请求方式 = 请求方式
        参数指针.值.提交信息 = 提交信息
        参数指针.值.附加协议头 = 附加协议头
        参数指针.值.提交Cookie = 提交Cookie
        参数指针.值.内容编码 = 内容编码
        参数指针.值.代理地址 = 代理地址
        参数指针.值.代理账号 = 代理账号
        参数指针.值.代理密码 = 代理密码
        参数指针.值.超时时间 = 超时时间
        参数指针.值.重定向次数 = 重定向次数
        参数指针.值.忽略SSL错误 = 忽略SSL错误
        参数指针.值.实例指针 = 本对象.取对象自身指针 ()
        参数指针.值.返回结果.用户数据 = 用户数据
        如果 (是否优先)
        {
            _优先任务.入队 (参数指针)
        }
        否则
        {
            如果 (任务上限数 == 0)
            {
                _任务队列.入队 (参数指针)
            }
            否则
            {
                如果 (_任务队列.尝试入队 (参数指针) == 假)
                {
                    参数指针.销毁 ()
                    返回 (假)
                }
            }
        }
        返回 (真)
    }

    方法 网页访问完毕 <公开 定义事件 类型 = 整数 注释 = "网页访问结束后,将会响应本事件." 注释 = "为免阻塞连接池,请尽快返回,如有耗时操作请在线程中执行."
            返回值注释 = "该返回值无意义" 折叠>
    参数 访问地址 <类型 = 文本型 注释 = "本次访问请求的地址">
    参数 访问响应 <类型 = 网络请求响应类 注释 = "本次访问返回的请求结果和响应.离开本事件后,该对象立即释放.">

    # 内部方法 ---

    方法 _线程运行 <注释 = "内部线程方法" 折叠>
    {
        变量 消费者令牌 <类型 = 消费者队列令牌>
        变量 任务 <类型 = 网络访问参数指针>
        消费者令牌 = _任务队列.创建消费者令牌 ()
        判断循环 (_退出线程.限时等待 (0) == 假)
        {
            如果 (_优先任务.取成员数 () > 0)
            {
                判断循环 (_优先任务.出队 (任务) == 真 && 任务.为空指针 () == 假)
                {
                    _工作数.加 (1)
                    分支判断 (任务.值.访问类型)
                    {
                        分支 (0)  // 网页访问
                        {
                            如果 (_设置网页访问 (任务.值) == 假)
                            {
                                网页访问完毕 (任务.值.网址, 任务.值.返回结果)
                                _工作数.减 (1)
                                任务.销毁 ()
                            }
                        }
                        分支 (1)  // 下载
                        {

                        }
                    }
                    任务.置空指针 ()
                }
            }
            如果 (_工作数.取值 () < _并发数.取值 ())
            {
                如果 (_任务队列.限时出队EX (消费者令牌, 任务, 20000) == 真 && 任务.为空指针 () == 假)
                {
                    _工作数.加 (1)
                    分支判断 (任务.值.访问类型)
                    {
                        分支 (0)  // 网页访问
                        {
                            如果 (_设置网页访问 (任务.值) == 假)
                            {
                                网页访问完毕 (任务.值.网址, 任务.值.返回结果)
                                _工作数.减 (1)
                                任务.销毁 ()
                            }
                            任务.置指针 (0)
                        }
                        分支 (1)  // 下载
                        {

                        }
                    }
                    任务.置空指针 ()
                }
            }
            否则
            {
                延时 (_轮询时间)
            }
            // 结束
        }
    }

    方法 _设置网页访问 <类型 = 逻辑型 注释 = "内部方法" 返回值注释 = "返回是否成功" 折叠 @虚拟方法 = 可覆盖>
    参数 访问参数 <类型 = 网络访问参数类>
    {
        变量 连接句柄 <类型 = 变整数>
        变量 URL组件信息 <类型 = URL组件信息类>
        访问参数.返回结果.请求耗时 = 取现行纳秒时间戳 ()
        如果 (WinHTTP网络类.拆分URL (访问参数.网址, URL组件信息, 选择 (是否编码网址, URL操作_WinHTTP.URL编码, 0)) == 假)
        {
            访问参数.返回结果.错误信息 = "拆分URL失败: " + WinHTTP网络类.取最后错误信息 ()
            访问参数.返回结果.请求耗时 = (取现行纳秒时间戳 () - 访问参数.返回结果.请求耗时) / 1000000
            返回 (假)
        }
        连接句柄 = WinHTTP网络类.连接服务器 (_会话句柄, URL组件信息.域名, 选择 (URL组件信息.端口 == 80 || URL组件信息.端口 == 443, 0, URL组件信息.端口))
        如果 (连接句柄 == 0)
        {
            访问参数.返回结果.错误信息 = "连接服务器失败: " + WinHTTP网络类.取最后错误信息 ()
            访问参数.返回结果.请求耗时 = (取现行纳秒时间戳 () - 访问参数.返回结果.请求耗时) / 1000000
            返回 (假)
        }
        变量 请求句柄 <类型 = 变整数>
        变量 基本协议头 <类型 = 文本数组类>
        变量 请求标志 <类型 = 整数>
        变量 请求头修改方式 <类型 = 整数>
        // 请求标志 = 请求标志_WinHTTP.URL编码  // 对URL的路径和参数部分进行URL编码
        如果 (URL组件信息.协议类型 == 2)
        {
            请求标志 = 位或 (请求标志, 请求标志_WinHTTP.安全连接)  // HTTPS必须加上这个标志
        }
        请求句柄 = WinHTTP网络类.打开请求 (连接句柄, 访问参数.请求方式, URL组件信息.路径 + URL组件信息.附加信息, , , 空对象, 请求标志)
        如果 (请求句柄 == 0)
        {
            访问参数.返回结果.错误信息 = "打开请求失败: " + WinHTTP网络类.取最后错误信息 ()
            访问参数.返回结果.请求耗时 = (取现行纳秒时间戳 () - 访问参数.返回结果.请求耗时) / 1000000
            WinHTTP网络类.关闭句柄 (连接句柄)
            返回 (假)
        }
        如果 (文本是否为空 (访问参数.代理地址) == 假)
        {
            变量 代理信息 <类型 = WinHTTP代理信息类>
            代理信息.访问类型 = 访问类型_WinHTTP.命名代理
            代理信息.代理服务器 = 访问参数.代理地址
            WinHTTP网络类.置选项_代理信息 (请求句柄, 代理信息)
        }
        如果 (文本是否为空 (访问参数.代理账号) == 假)
        {
            WinHTTP网络类.置选项_代理用户名 (请求句柄, 访问参数.代理账号)
            WinHTTP网络类.置选项_代理密码 (请求句柄, 访问参数.代理密码)
        }
        请求头修改方式 = 位或 (请求头修改方式_WinHTTP.替换和删除, 请求头修改方式_WinHTTP.添加请求头)
        基本协议头.加入成员 ("Accept: */*")
        基本协议头.加入成员 ("Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,zh-TW;q=0.5")
        WinHTTP网络类.添加请求头2 (请求句柄, 基本协议头, 请求头修改方式)
        如果 (文本是否为空对象 (访问参数.内容编码) == 假 && WinHTTP网络类.置选项_解压缩 (请求句柄, 3) == 真)
        {
            // Windows 8.1以上才能使用自动解压缩,旧系统设置该选项只会返回假,不会造成崩溃.
            如果 (文本是否为空 (访问参数.内容编码) == 真)
            {
                WinHTTP网络类.添加请求头 (请求句柄, "Accept-Encoding: gzip, deflate", 请求头修改方式)
            }
            否则
            {
                WinHTTP网络类.添加请求头 (请求句柄, 访问参数.内容编码, 请求头修改方式)
            }
        }
        如果 (_自动Cookie管理 == 假)
        {
            WinHTTP网络类.置选项_禁止功能 (请求句柄, 禁止功能标志_WinHTTP.禁止Cookies)
        }
        如果 (文本是否为空 (访问参数.提交Cookie) == 假)
        {
            如果 (是否以文本开头 (访问参数.提交Cookie, "Cookie:", 假) == 假)
            {
                WinHTTP网络类.添加请求头 (请求句柄, "Cookie: " + 访问参数.提交Cookie, 请求头修改方式)
            }
            否则
            {
                WinHTTP网络类.添加请求头 (请求句柄, 访问参数.提交Cookie, 请求头修改方式)
            }
        }
        如果 (访问参数.提交信息.取字节集长度 () > 0)
        {
            如果 (访问参数.提交信息.取字节集数据 (0, 字节) == 123 || 访问参数.提交信息.取字节集数据 (0, 字节) == 91)  // 首尾字符为'{'或'[',表示是JSON数据
            {
                WinHTTP网络类.添加请求头 (请求句柄, "Content-Type: application/json; charset=utf-8", 请求头修改方式)
            }
            否则
            {
                WinHTTP网络类.添加请求头 (请求句柄, "Content-Type: application/x-www-form-urlencoded; charset=utf-8", 请求头修改方式)
            }
        }
        如果 (访问参数.附加协议头.是否为空 () == 假)
        {
            WinHTTP网络类.添加请求头2 (请求句柄, 访问参数.附加协议头, 请求头修改方式)
        }
        如果 (访问参数.重定向次数 <= 0)
        {
            WinHTTP网络类.置选项_禁止功能 (请求句柄, 禁止功能标志_WinHTTP.禁止重定向)
        }
        否则
        {
            WinHTTP网络类.置选项_最大重定向次数 (请求句柄, 访问参数.重定向次数)
            WinHTTP网络类.置状态回调 (请求句柄, _状态回调, 回调标志_WinHTTP.全部状态通知)
        }
        WinHTTP网络类.置选项_发送超时 (请求句柄, 访问参数.超时时间)
        WinHTTP网络类.置选项_接收超时 (请求句柄, 访问参数.超时时间)
        如果 (访问参数.忽略SSL错误 == 真)
        {
            WinHTTP网络类.置选项_安全标志 (请求句柄, 安全标志_WinHTTP.忽略所有证书错误)
        }
        // 开始发送请求
        如果 (WinHTTP网络类.发送请求 (请求句柄, 空对象, 访问参数.提交信息, 访问参数.提交信息.取字节集长度 (), 访问参数.取对象自身指针 ()) == 真)
        {
            返回 (真)
        }
        否则
        {
            访问参数.返回结果.错误信息 = "发送请求失败: " + WinHTTP网络类.取最后错误信息 ()
            WinHTTP网络类.关闭句柄 (请求句柄)
            WinHTTP网络类.关闭句柄 (连接句柄)
            返回 (假)
        }
    }

    方法 _状态回调 <静态 注释 = "内部方法" 折叠>
    参数 网络句柄 <类型 = 变整数 注释 = "与状态回调关联的网络句柄">
    参数 上下文值 <类型 = 变整数 注释 = "与网络句柄关联的的上下文值,可以通过\"置选项_上下文值\"或\"发送请求\"设置," 注释 = "可用于传递用户自定义的数据.">
    参数 网络状态 <类型 = 回调状态标志_WinHTTP 注释 = "请参考\"回调状态标志_WinHTTP\"中的常量">
    参数 状态信息指针 <类型 = 变整数 注释 = "指向缓冲区的指针,数据类型取决于参数\"网络状态\"的值.">
    参数 状态信息长度 <类型 = 整数 注释 = "如果状态信息为文本数据,则本参数为文本的字符数,为其他类型时则为字节数.">
    {
        如果 (上下文值 == 0)
        {
            返回
        }
        变量 参数指针 <类型 = 网络访问参数指针>
        参数指针.置指针 (上下文值)
        分支判断 ((整数)网络状态)
        {
            分支 ((整数)回调状态标志_WinHTTP.请求错误)  // 发生错误
            {
                变量 异步结果 <类型 = WinHTTP异步结果类>
                异步结果.置指针 (状态信息指针)
                输出调试 (异步结果)
                参数指针.值.返回结果.错误信息 = "异步请求错误: " + WinHTTP网络类.取最后错误信息 ()
                _结束访问 (读指针处对象 (参数指针.值.实例指针, 网络异步访问类), 参数指针, 网络句柄)
            }
            // ===
            分支 ((整数)回调状态标志_WinHTTP.重定向)  // 重定向处理
            {
                参数指针.值.返回结果.重定向次数 = 参数指针.值.返回结果.重定向次数 + 1
                参数指针.值.返回结果.重定向地址.加入成员 (指针到文本 (状态信息指针))
                // 获取当前重定向的cookies
                变量 索引 <类型 = 整数类>
                索引.值 = 0
                循环判断首 ()
                {
                    变量 cookie <类型 = 文本型>
                    如果 (WinHTTP网络类.取响应头 (网络句柄, cookie, 协议头标志_WinHTTP.设置Cookie, 空对象, 索引) == 假)
                    {
                        跳出循环
                    }
                    参数指针.值.返回结果.Cookies.加入成员 (WinHTTP网络类.取Cookie内容 (cookie))

                }
                循环判断尾 (索引.值 >= 0)
            }
            // ===
            分支 ((整数)回调状态标志_WinHTTP.发送请求完成)  // 请求成功,开始接收响应
            {
                如果 (WinHTTP网络类.接收响应 (网络句柄) == 假)
                {
                    // 错误处理
                    参数指针.值.返回结果.错误信息 = "接收响应失败: " + WinHTTP网络类.取最后错误信息 ()
                    _结束访问 (读指针处对象 (参数指针.值.实例指针, 网络异步访问类), 参数指针, 网络句柄)
                }
            }
            // ===
            分支 ((整数)回调状态标志_WinHTTP.响应头可用)  // 接收响应头
            {
                变量 响应头 <类型 = 文本型>
                变量 内容长度 <类型 = 整数>
                变量 接收数量 <类型 = 整数类>
                如果 (WinHTTP网络类.取响应头 (网络句柄, 响应头, 协议头标志_WinHTTP.所有标头_换行) == 真)
                {
                    分割文本 (响应头, "\r\n", 参数指针.值.返回结果.响应头, 真, 真)
                    参数指针.值.缓冲区.分配字节集 (8192)
                    参数指针.值.返回结果.响应码 = WinHTTP网络类.取响应头_整数 (网络句柄, 协议头标志_WinHTTP.状态码)
                    内容长度 = WinHTTP网络类.取响应头_整数 (网络句柄, 协议头标志_WinHTTP.内容长度)
                    // 接收主体内容
                    如果 (内容长度 > 0)
                    {
                        参数指针.值.返回结果.请求结果.置字节集预分配尺寸 (内容长度)
                    }
                    否则  // 内容长度不定(WinHTTP解压缩内容后就取不到长度
                    {
                        参数指针.值.返回结果.请求结果.置字节集预分配尺寸 (8192)

                    }
                    WinHTTP网络类.取可用数据量 (网络句柄, 空对象)
                }
                否则
                {
                    // 错误处理
                    参数指针.值.返回结果.错误信息 = "接收响应头失败: " + WinHTTP网络类.取最后错误信息 ()
                    _结束访问 (读指针处对象 (参数指针.值.实例指针, 网络异步访问类), 参数指针, 网络句柄)
                }
            }
            // ===
            分支 ((整数)回调状态标志_WinHTTP.数据可用)  // 获取可接收数据量
            {
                如果 (参数指针.值.请求方式 == 请求方式_WinHTTP.HEAD)
                {
                    跳出分支 ()
                }
                变量 数据量 <类型 = 整数>
                数据量 = 读指针处值 (状态信息指针, 整数)
                如果 (数据量 > 0)  // 还有未接收的数据
                {
                    如果 (WinHTTP网络类.接收数据2 (网络句柄, 参数指针.值.缓冲区.取字节集指针 (), 数据量, 空对象) == 假)
                    {
                        // 错误处理
                        参数指针.值.返回结果.错误信息 = "接收数据失败: " + WinHTTP网络类.取最后错误信息 ()
                        _结束访问 (读指针处对象 (参数指针.值.实例指针, 网络异步访问类), 参数指针, 网络句柄)
                    }
                }
                否则  // 数据接收完毕,准备收尾
                {
                    // 获取cookies
                    变量 索引 <类型 = 整数类>
                    索引.值 = 0
                    循环判断首 ()
                    {
                        变量 cookie <类型 = 文本型>
                        如果 (WinHTTP网络类.取响应头 (网络句柄, cookie, 协议头标志_WinHTTP.设置Cookie, 空对象, 索引) == 假)
                        {
                            跳出循环
                        }
                        参数指针.值.返回结果.Cookies.加入成员 (WinHTTP网络类.取Cookie内容 (cookie))
                    }
                    循环判断尾 (索引.值 >= 0)
                    // 请求完成
                    _结束访问 (读指针处对象 (参数指针.值.实例指针, 网络异步访问类), 参数指针, 网络句柄)
                }
            }
            // ===
            分支 ((整数)回调状态标志_WinHTTP.接收数据完成)  // 接收数据
            {
                如果 (状态信息指针 != 0)
                {
                    参数指针.值.返回结果.请求结果.指针添加字节集 (状态信息指针, 状态信息长度)
                    如果 (WinHTTP网络类.取可用数据量 (网络句柄, 空对象) == 假)
                    {
                        // 错误处理
                        参数指针.值.返回结果.错误信息 = "取可用数据量失败: " + WinHTTP网络类.取最后错误信息 ()
                        _结束访问 (读指针处对象 (参数指针.值.实例指针, 网络异步访问类), 参数指针, 网络句柄)
                    }
                }
            }
            // ===
        }
    }

    方法 _结束访问 <静态 注释 = "内部方法" 折叠>
    参数 网络对象 <类型 = 网络异步访问类>
    参数 访问参数 <类型 = 网络访问参数指针>
    参数 网络句柄 <类型 = 变整数>
    {
        访问参数.值.返回结果.请求耗时 = (取现行纳秒时间戳 () - 访问参数.值.返回结果.请求耗时) / 1000000
        网络对象.网页访问完毕 (访问参数.值.网址, 访问参数.值.返回结果)
        变量 连接句柄 <类型 = 变整数>
        连接句柄 = WinHTTP网络类.取选项_父句柄 (网络句柄)
        WinHTTP网络类.关闭句柄 (网络句柄)
        WinHTTP网络类.关闭句柄 (连接句柄)
        网络对象._工作数.减 (1)
        访问参数.销毁 ()
    }

    # ---
    # @begin
    # <> <include>
    # inline void @an<_OnBeforeCleanup>() { @<销毁连接池>(); }
    # <> </include>
    # @end
}

# Cookie持久管理 ===

类 网络同步访问类EX <公开 基础类 = 网络同步访问类 注释 = "在\"网络同步访问类\"的基础上加上\"Cookie持久化管理\"." 注释 = "需要依赖\"PivJson\"." 折叠
        @文档 = "category = \"WinHTTP\"">
{
    方法 Cookie管理文件 <公开 属性写 注释 = "提供Cookie管理文件,如果为空对象则不会管理Cookie内容(可使用\"附加协议头/提交Cookie\"参数自行提交)."
            注释 = "如提供空文本则表示在内存中管理Cookie(非持久化储存),如果指定了文件则表示持久化储存管理Cookie."
            注释 = "设置本属性后会同步到程序中的其他\"网络同步访问类EX\"实例,也就是内存中的管理的Cookie对所有变量有效." 折叠>
    参数 文件 <类型 = 文本型 @默认值 = 空对象>
    {
        如果 (文本是否为空对象 (文件) == 假)
        {
            取全局单例 (Cookie自动管理类).是否启用 = 真
            取全局单例 (Cookie自动管理类).是否启用 = 真
            如果 (文本是否为空 (文件))
            {
                取全局单例 (Cookie自动管理类).文件名 = ""
            }
            否则
            {
                取全局单例 (Cookie自动管理类).文件名 = 文件
            }
        }
        否则
        {
            取全局单例 (Cookie自动管理类).是否启用 = 假
        }
    }

    方法 网页访问3 <公开 类型 = 网络请求响应类 注释 = "与\"网页访问2\"基本一致,不同的是本方法的\"附加协议头\"参数为文本型."
            返回值注释 = "返回访问网页的结果,如果响应码为0则表示无法连接到目标网址或内部代码错误." 折叠 @虚拟方法 = 可覆盖>
    参数 网址 <类型 = 文本型 注释 = "提供所欲访问的网址内容">
    参数 请求方式 <类型 = 请求方式_WinHTTP 注释 = "提供所欲使用的请求方式" @默认值 = 请求方式_WinHTTP.GET>
    参数 提交信息 <类型 = 字节集类 注释 = "设置本次请求所提交的数据,非POST请求也支持提交请求体,如需携带请求体务必保证该参数不为空;" 注释 = "如有必要,请自行对提交信息进行URL编码;"
            注释 = "本方法会根据提交信息的类型自动添加\"Content-Type\"协议头,无需你手动添加." @默认值 = 空对象>
    参数 附加协议头 <类型 = 文本型 注释 = "提供本次请求所欲使用的附加协议头,每个协议之间请用\"\\r\\n\"换行." @默认值 = 空对象>
    参数 提交Cookie <类型 = 文本型 注释 = "提供本次请求所欲使用的Cookie内容,注意该参数提交的内容不会同步到\"自动Cookie管理\"." @默认值 = "">
    参数 内容编码 <类型 = 文本型 注释 = "指定所欲请求服务器使用的内容编码(压缩)方式,即\"Accept-Encoding\"协议内容;"
            注释 = "本参数只对Windows 8及更高版本的系统有效,旧系统不支持WinHTTP的自动解压缩;"
            注释 = "提供空文本时自动设置为\"Accept-Encoding: gzip, deflate\",提供空对象则禁用压缩;"
            注释 = "WinHTTP自动解压缩后,会将响应头的Content-Length、Content-Encoding删除掉." @默认值 = "">
    参数 代理地址 <类型 = 文本型 注释 = "设置当前一次网页访问使用的代理地址列表,非空时将代理模式临时改为\"命名代理\";"
            注释 = "无论代理是什么协议,都一律填http/https,例如Socoks5的代理也是填: \"http://127.0.0.1:7890\";"
            注释 = "可以用分号支持多个代理服务器,也可以对不同的协议使用不同的代理,例如:"
            注释 = "\"http=http://127.0.0.1:7890;https=http://192.168.1.1:8080\"" @默认值 = "">
    参数 代理账号 <类型 = 文本型 注释 = "提供代理服务器所需的用户名(可空),仅在代理模式为\"命名代理\"时可用." @默认值 = "">
    参数 代理密码 <类型 = 文本型 注释 = "提供代理服务器所需的用户密码(可空),仅在代理模式为\"命名代理\"时可用." @默认值 = "">
    参数 超时时间 <类型 = 整数 注释 = "指定本次完成整个请求所限定的超时时间,为-1时不限制,单位:毫秒." @默认值 = -1>
    参数 重定向次数 <类型 = 整数 注释 = "欲遵循网站重定向的最大次数,为0时禁止重定向." @默认值 = 10>
    参数 忽略SSL错误 <类型 = 逻辑型 注释 = "是否忽略任何SSL验证相关错误,即不验证证书也不验证服务器(如使用了代理将会被一同忽略)." @默认值 = 真>
    {
        变量 返回结果 <类型 = 网络请求响应类>
        变量 连接句柄 <类型 = 变整数>
        变量 URL组件信息 <类型 = URL组件信息类>
        变量 启动时间 <类型 = 长整数>
        启动时间 = 取现行纳秒时间戳 ()
        如果 (_初始化 () == 假)
        {
            返回结果.错误信息 = "初始化失败: " + WinHTTP网络类.取最后错误信息 ()
            返回结果.请求耗时 = (取现行纳秒时间戳 () - 启动时间) / 1000000
            返回 (返回结果)
        }
        如果 (WinHTTP网络类.拆分URL (网址, URL组件信息, 选择 (是否编码网址, URL操作_WinHTTP.URL编码, 0)) == 假)
        {
            返回结果.错误信息 = "拆分URL失败: " + WinHTTP网络类.取最后错误信息 ()
            返回结果.请求耗时 = (取现行纳秒时间戳 () - 启动时间) / 1000000
            返回 (返回结果)
        }
        连接句柄 = WinHTTP网络类.连接服务器 (_会话句柄, URL组件信息.域名, 选择 (URL组件信息.端口 == 80 || URL组件信息.端口 == 443, 0, URL组件信息.端口))
        如果 (连接句柄 == 0)
        {
            返回结果.错误信息 = "连接服务器失败: " + WinHTTP网络类.取最后错误信息 ()
            返回结果.请求耗时 = (取现行纳秒时间戳 () - 启动时间) / 1000000
            返回 (返回结果)
        }
        变量 请求句柄 <类型 = 变整数>
        变量 基本协议头 <类型 = 文本数组类>
        变量 请求标志 <类型 = 整数>
        变量 请求头修改方式 <类型 = 整数>
        // 请求标志 = 请求标志_WinHTTP.URL编码  // 对URL的路径和参数部分进行URL编码
        如果 (URL组件信息.协议类型 == 2)
        {
            请求标志 = 位或 (请求标志, 请求标志_WinHTTP.安全连接)  // HTTPS必须加上这个标志
        }
        请求句柄 = WinHTTP网络类.打开请求 (连接句柄, 请求方式, URL组件信息.路径 + URL组件信息.附加信息, , , 空对象, 请求标志)
        如果 (请求句柄 == 0)
        {
            返回结果.错误信息 = "打开请求失败: " + WinHTTP网络类.取最后错误信息 ()
            WinHTTP网络类.关闭句柄 (连接句柄)
            返回结果.请求耗时 = (取现行纳秒时间戳 () - 启动时间) / 1000000
            返回 (返回结果)
        }
        如果 (文本是否为空 (代理地址) == 假)
        {
            变量 代理信息 <类型 = WinHTTP代理信息类>
            代理信息.访问类型 = 访问类型_WinHTTP.命名代理
            代理信息.代理服务器 = 代理地址
            代理信息.代理跳过列表 = 代理跳过列表
            WinHTTP网络类.置选项_代理信息 (请求句柄, 代理信息)
        }
        如果 (文本是否为空 (代理账号) == 假)
        {
            WinHTTP网络类.置选项_代理用户名 (请求句柄, 代理账号)
            WinHTTP网络类.置选项_代理密码 (请求句柄, 代理密码)
        }
        请求头修改方式 = 位或 (请求头修改方式_WinHTTP.替换和删除, 请求头修改方式_WinHTTP.添加请求头)
        基本协议头.加入成员 ("Accept: */*")
        基本协议头.加入成员 ("Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,zh-TW;q=0.5")
        WinHTTP网络类.添加请求头2 (请求句柄, 基本协议头, 请求头修改方式)
        如果 (文本是否为空对象 (内容编码) == 假 && WinHTTP网络类.置选项_解压缩 (请求句柄, 3) == 真)
        {
            // Windows 8.1以上才能使用自动解压缩,旧系统设置该选项只会返回假,不会造成崩溃.
            如果 (文本是否为空 (内容编码) == 真)
            {
                WinHTTP网络类.添加请求头 (请求句柄, "Accept-Encoding: gzip, deflate", 请求头修改方式)
            }
            否则
            {
                WinHTTP网络类.添加请求头 (请求句柄, 内容编码, 请求头修改方式)
            }
        }
        // 提交 Cookie
        WinHTTP网络类.置选项_禁止功能 (请求句柄, 禁止功能标志_WinHTTP.禁止Cookies)
        变量 Cookie协议头 <类型 = 文本型>
        如果 (文本是否为空 (提交Cookie) == 假)
        {
            如果 (取全局单例 (Cookie自动管理类).是否启用 == 真)
            {
                取全局单例 (Cookie自动管理类).添加Cookie (URL组件信息.域名, 提交Cookie)
            }
            否则
            {
                Cookie协议头 = 提交Cookie
            }
        }
        如果 (取全局单例 (Cookie自动管理类).是否启用 == 真)
        {
            加入文本 (Cookie协议头, 取全局单例 (Cookie自动管理类).取Cookie (URL组件信息.域名, URL组件信息.路径))
        }
        如果 (文本是否为空 (Cookie协议头) == 假)
        {
            如果 (是否以文本开头 (Cookie协议头, "Cookie:", 假) == 假)
            {
                Cookie协议头 = "Cookie: " + Cookie协议头
            }
            WinHTTP网络类.添加请求头 (请求句柄, Cookie协议头, 请求头修改方式)
        }
        // 提交数据
        如果 (提交信息.取字节集长度 () > 0)
        {
            如果 (提交信息.取字节集数据 (0, 字节) == 123 || 提交信息.取字节集数据 (0, 字节) == 91)  // 首尾字符为'{'或'[',表示是JSON数据
            {
                WinHTTP网络类.添加请求头 (请求句柄, "Content-Type: application/json; charset=utf-8", 请求头修改方式)
            }
            否则
            {
                WinHTTP网络类.添加请求头 (请求句柄, "Content-Type: application/x-www-form-urlencoded; charset=utf-8", 请求头修改方式)
            }
        }
        如果 (文本是否为空 (附加协议头) == 假)
        {
            WinHTTP网络类.添加请求头 (请求句柄, 附加协议头, 请求头修改方式)
        }
        如果 (重定向次数 <= 0)
        {
            WinHTTP网络类.置选项_禁止功能 (请求句柄, 禁止功能标志_WinHTTP.禁止重定向)
        }
        否则
        {
            WinHTTP网络类.置选项_最大重定向次数 (请求句柄, 重定向次数)
            WinHTTP网络类.置状态回调 (请求句柄, _重定向回调EX, 回调标志_WinHTTP.重定向)
        }
        WinHTTP网络类.置选项_发送超时 (请求句柄, 超时时间)
        WinHTTP网络类.置选项_接收超时 (请求句柄, 超时时间)
        如果 (忽略SSL错误 == 真)
        {
            WinHTTP网络类.置选项_安全标志 (请求句柄, 安全标志_WinHTTP.忽略所有证书错误)
        }
        // 开始发送请求
        如果 (WinHTTP网络类.发送请求 (请求句柄, 空对象, 提交信息, 提交信息.取字节集长度 (), 返回结果.取对象自身指针 ()) == 真)
        {
            如果 (WinHTTP网络类.接收响应 (请求句柄) == 真)
            {
                // 接收响应头
                变量 响应头 <类型 = 文本型>
                WinHTTP网络类.取响应头 (请求句柄, 响应头, 协议头标志_WinHTTP.所有标头_换行)
                分割文本 (响应头, "\r\n", 返回结果.响应头, 真, 真)
                返回结果.响应码 = WinHTTP网络类.取响应头_整数 (请求句柄, 协议头标志_WinHTTP.状态码)
                // 接收主体内容
                如果 (请求方式 != 请求方式_WinHTTP.HEAD)
                {
                    变量 内容长度 <类型 = 整数>
                    变量 接收数量 <类型 = 整数类>
                    内容长度 = WinHTTP网络类.取响应头_整数 (请求句柄, 协议头标志_WinHTTP.内容长度)
                    如果 (内容长度 > 0)
                    {
                        变量 次数 <类型 = 整数>
                        返回结果.请求结果.分配字节集 (内容长度, 真)  // 提前分配内存
                        次数 = 内容长度 / 1048576  // 分段接收数据,每次1MB
                        计次循环 (次数)
                        {
                            如果 (WinHTTP网络类.接收数据2 (请求句柄, 返回结果.请求结果.取字节集指针 () + 取循环索引 () * 1048576, 1048576, 接收数量) == 假 && 接收数量.值 != 1048576)
                            {
                                返回结果.错误信息 = "接收数据失败: " + WinHTTP网络类.取最后错误信息 ()
                                跳出循环
                            }
                        }
                        如果 (内容长度 % 1048576 > 0)
                        {
                            如果 (WinHTTP网络类.接收数据2 (请求句柄, 返回结果.请求结果.取字节集指针 () + 次数 * 1048576, 内容长度 % 1048576, 接收数量) == 假 && 接收数量.值 != 内容长度 % 1048576)
                            {
                                返回结果.错误信息 = "接收数据失败: " + WinHTTP网络类.取最后错误信息 ()
                            }
                        }
                    }
                    否则  // 内容长度不定(WinHTTP解压缩内容后就取不到长度)
                    {
                        变量 可用数量 <类型 = 整数类>
                        返回结果.请求结果.置字节集预分配尺寸 (8192)  // 8KB是WinHTTP内部的默认缓冲区大小
                        循环判断首 ()
                        {
                            变量 缓冲区 <类型 = 字节集类>
                            如果 (WinHTTP网络类.取可用数据量 (请求句柄, 可用数量) == 假)
                            {
                                返回结果.错误信息 = "取可用数据量失败: " + WinHTTP网络类.取最后错误信息 ()
                                跳出循环
                            }
                            缓冲区.分配字节集 (可用数量.值)
                            如果 (WinHTTP网络类.接收数据 (请求句柄, 缓冲区, 接收数量) == 真)
                            {
                                如果 (接收数量.值 == 0)
                                {
                                    跳出循环
                                }
                                返回结果.请求结果.添加字节集 (缓冲区)
                            }
                            否则
                            {
                                返回结果.错误信息 = "接收数据失败: " + WinHTTP网络类.取最后错误信息 ()
                                跳出循环
                            }
                        }
                        循环判断尾 (可用数量.值 > 0)
                    }
                }
                如果 (返回结果.重定向次数 > 0)
                {
                    WinHTTP网络类.拆分URL (返回结果.重定向地址.取成员 (返回结果.重定向次数 - 1), URL组件信息, 0)
                }
                // 获取cookies
                变量 索引 <类型 = 整数类>
                索引.值 = 0
                循环判断首 ()
                {
                    变量 cookie <类型 = 文本型>
                    如果 (WinHTTP网络类.取响应头 (请求句柄, cookie, 协议头标志_WinHTTP.设置Cookie, 空对象, 索引) == 假)
                    {
                        跳出循环
                    }
                    如果 (取全局单例 (Cookie自动管理类).是否启用 == 真)
                    {
                        返回结果.Cookies.加入成员 (取全局单例 (Cookie自动管理类).添加Cookie (URL组件信息.域名, cookie, 真))
                    }
                    否则
                    {
                        返回结果.Cookies.加入成员 (取全局单例 (Cookie自动管理类).取Cookie内容 (cookie))
                    }
                }
                循环判断尾 (索引.值 >= 0)
            }
            否则
            {
                返回结果.错误信息 = "接收响应失败: " + WinHTTP网络类.取最后错误信息 ()
            }
        }
        否则
        {
            返回结果.错误信息 = "发送请求失败: " + WinHTTP网络类.取最后错误信息 ()
        }
        WinHTTP网络类.关闭句柄 (请求句柄)
        WinHTTP网络类.关闭句柄 (连接句柄)
        返回结果.请求耗时 = (取现行纳秒时间戳 () - 启动时间) / 1000000
        返回 (返回结果)
    }

    方法 _重定向回调EX <静态 注释 = "内部方法" 折叠>
    参数 网络句柄 <类型 = 变整数 注释 = "与状态回调关联的网络句柄.">
    参数 上下文值 <类型 = 变整数 注释 = "  与网络句柄关联的的上下文值,可以通过\"置选项_上下文值\"或\"发送请求\"设置," 注释 = "可用于传递用户自定义的数据.">
    参数 网络状态 <类型 = 回调状态标志_WinHTTP 注释 = "请参考\"回调状态标志_WinHTTP\"中的常量.">
    参数 状态信息指针 <类型 = 变整数 注释 = "指向缓冲区的指针,数据类型取决于参数\"网络状态\"的值.">
    参数 状态信息长度 <类型 = 整数 注释 = "如果状态信息为文本数据,则本参数为文本的字符数,为其他类型时则为字节数.">
    {
        如果 (网络状态 == 回调状态标志_WinHTTP.重定向)
        {
            读指针处对象 (上下文值, 网络请求响应类).重定向次数 = 读指针处对象 (上下文值, 网络请求响应类).重定向次数 + 1
            读指针处对象 (上下文值, 网络请求响应类).重定向地址.加入成员 (指针到文本 (状态信息指针))
            // 获取当前重定向的cookies
            变量 索引 <类型 = 整数类>
            变量 URL组件信息 <类型 = URL组件信息类>
            WinHTTP网络类.拆分URL (指针到文本 (状态信息指针), URL组件信息)
            索引.值 = 0
            循环判断首 ()
            {
                变量 cookie <类型 = 文本型>
                如果 (WinHTTP网络类.取响应头 (网络句柄, cookie, 协议头标志_WinHTTP.设置Cookie, 空对象, 索引) == 假)
                {
                    跳出循环
                }
                如果 (取全局单例 (Cookie自动管理类).是否启用 == 真)
                {
                    读指针处对象 (上下文值, 网络请求响应类).Cookies.加入成员 (取全局单例 (Cookie自动管理类).添加Cookie (URL组件信息.域名, cookie))
                }
                否则
                {
                    读指针处对象 (上下文值, 网络请求响应类).Cookies.加入成员 (取全局单例 (Cookie自动管理类).取Cookie内容 (cookie))
                }
            }
            循环判断尾 (索引.值 >= 0)
        }
    }
}

类 网络异步访问类EX <公开 基础类 = 网络异步访问类 注释 = "在\"网络异步访问类\"的基础上加上\"Cookie持久化管理\"." 注释 = "需要依赖\"PivJson\"." 折叠
        @文档 = "category = \"WinHTTP\"">
{

    # 公开方法 ---

    方法 Cookie管理文件 <公开 属性写 注释 = "提供Cookie管理文件,如果为空对象则不会管理Cookie内容(可使用\"附加协议头/提交Cookie\"参数自行提交)."
            注释 = "如提供空文本则表示在内存中管理Cookie(非持久化储存),如果指定了文件则表示持久化储存管理Cookie."
            注释 = "设置本属性后会同步到程序中的其他\"网络同步访问类EX\"实例,也就是内存中的管理的Cookie对所有变量有效." 折叠>
    参数 文件 <类型 = 文本型 @默认值 = 空对象>
    {
        如果 (文本是否为空对象 (文件) == 假)
        {
            取全局单例 (Cookie自动管理类).是否启用 = 真
            如果 (文本是否为空 (文件))
            {
                取全局单例 (Cookie自动管理类).文件名 = ""
            }
            否则
            {
                取全局单例 (Cookie自动管理类).文件名 = 文件
            }
        }
        否则
        {
            取全局单例 (Cookie自动管理类).是否启用 = 假
        }
    }

    # 内部方法 ---

    方法 _设置网页访问 <类型 = 逻辑型 注释 = "内部方法" 返回值注释 = "返回是否成功" 折叠 @虚拟方法 = 可覆盖>
    参数 访问参数 <类型 = 网络访问参数类>
    {
        变量 连接句柄 <类型 = 变整数>
        变量 URL组件信息 <类型 = URL组件信息类>
        访问参数.返回结果.请求耗时 = 取现行纳秒时间戳 ()
        如果 (WinHTTP网络类.拆分URL (访问参数.网址, URL组件信息, 选择 (是否编码网址, URL操作_WinHTTP.URL编码, 0)) == 假)
        {
            访问参数.返回结果.错误信息 = "拆分URL失败: " + WinHTTP网络类.取最后错误信息 ()
            访问参数.返回结果.请求耗时 = (取现行纳秒时间戳 () - 访问参数.返回结果.请求耗时) / 1000000
            返回 (假)
        }
        连接句柄 = WinHTTP网络类.连接服务器 (_会话句柄, URL组件信息.域名, 选择 (URL组件信息.端口 == 80 || URL组件信息.端口 == 443, 0, URL组件信息.端口))
        如果 (连接句柄 == 0)
        {
            访问参数.返回结果.错误信息 = "连接服务器失败: " + WinHTTP网络类.取最后错误信息 ()
            访问参数.返回结果.请求耗时 = (取现行纳秒时间戳 () - 访问参数.返回结果.请求耗时) / 1000000
            返回 (假)
        }
        变量 请求句柄 <类型 = 变整数>
        变量 基本协议头 <类型 = 文本数组类>
        变量 请求标志 <类型 = 整数>
        变量 请求头修改方式 <类型 = 整数>
        // 请求标志 = 请求标志_WinHTTP.URL编码  // 对URL的路径和参数部分进行URL编码
        如果 (URL组件信息.协议类型 == 2)
        {
            请求标志 = 位或 (请求标志, 请求标志_WinHTTP.安全连接)  // HTTPS必须加上这个标志
        }
        请求句柄 = WinHTTP网络类.打开请求 (连接句柄, 访问参数.请求方式, URL组件信息.路径 + URL组件信息.附加信息, , , 空对象, 请求标志)
        如果 (请求句柄 == 0)
        {
            访问参数.返回结果.错误信息 = "打开请求失败: " + WinHTTP网络类.取最后错误信息 ()
            访问参数.返回结果.请求耗时 = (取现行纳秒时间戳 () - 访问参数.返回结果.请求耗时) / 1000000
            WinHTTP网络类.关闭句柄 (连接句柄)
            返回 (假)
        }
        如果 (文本是否为空 (访问参数.代理地址) == 假)
        {
            变量 代理信息 <类型 = WinHTTP代理信息类>
            代理信息.访问类型 = 访问类型_WinHTTP.命名代理
            代理信息.代理服务器 = 访问参数.代理地址
            WinHTTP网络类.置选项_代理信息 (请求句柄, 代理信息)
        }
        如果 (文本是否为空 (访问参数.代理账号) == 假)
        {
            WinHTTP网络类.置选项_代理用户名 (请求句柄, 访问参数.代理账号)
            WinHTTP网络类.置选项_代理密码 (请求句柄, 访问参数.代理密码)
        }
        请求头修改方式 = 位或 (请求头修改方式_WinHTTP.替换和删除, 请求头修改方式_WinHTTP.添加请求头)
        基本协议头.加入成员 ("Accept: */*")
        基本协议头.加入成员 ("Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,zh-TW;q=0.5")
        WinHTTP网络类.添加请求头2 (请求句柄, 基本协议头, 请求头修改方式)
        如果 (文本是否为空对象 (访问参数.内容编码) == 假 && WinHTTP网络类.置选项_解压缩 (请求句柄, 3) == 真)
        {
            // Windows 8.1以上才能使用自动解压缩,旧系统设置该选项只会返回假,不会造成崩溃.
            如果 (文本是否为空 (访问参数.内容编码) == 真)
            {
                WinHTTP网络类.添加请求头 (请求句柄, "Accept-Encoding: gzip, deflate", 请求头修改方式)
            }
            否则
            {
                WinHTTP网络类.添加请求头 (请求句柄, 访问参数.内容编码, 请求头修改方式)
            }
        }
        // 提交 Cookie
        WinHTTP网络类.置选项_禁止功能 (请求句柄, 禁止功能标志_WinHTTP.禁止Cookies)
        变量 Cookie协议头 <类型 = 文本型>
        如果 (文本是否为空 (访问参数.提交Cookie) == 假)
        {
            如果 (取全局单例 (Cookie自动管理类).是否启用 == 真)
            {
                取全局单例 (Cookie自动管理类).添加Cookie (URL组件信息.域名, 访问参数.提交Cookie)
            }
            否则
            {
                Cookie协议头 = 访问参数.提交Cookie
            }
        }
        如果 (取全局单例 (Cookie自动管理类).是否启用 == 真)
        {
            加入文本 (Cookie协议头, 取全局单例 (Cookie自动管理类).取Cookie (URL组件信息.域名, URL组件信息.路径))
        }
        如果 (文本是否为空 (Cookie协议头) == 假)
        {
            如果 (是否以文本开头 (Cookie协议头, "Cookie:", 假) == 假)
            {
                Cookie协议头 = "Cookie: " + Cookie协议头
            }
            WinHTTP网络类.添加请求头 (请求句柄, Cookie协议头, 请求头修改方式)
        }
        // 提交数据
        如果 (访问参数.提交信息.取字节集长度 () > 0)
        {
            如果 (访问参数.提交信息.取字节集数据 (0, 字节) == 123 || 访问参数.提交信息.取字节集数据 (0, 字节) == 91)  // 首尾字符为'{'或'[',表示是JSON数据
            {
                WinHTTP网络类.添加请求头 (请求句柄, "Content-Type: application/json; charset=utf-8", 请求头修改方式)
            }
            否则
            {
                WinHTTP网络类.添加请求头 (请求句柄, "Content-Type: application/x-www-form-urlencoded; charset=utf-8", 请求头修改方式)
            }
        }
        如果 (访问参数.附加协议头.是否为空 () == 假)
        {
            WinHTTP网络类.添加请求头2 (请求句柄, 访问参数.附加协议头, 请求头修改方式)
        }
        如果 (访问参数.重定向次数 <= 0)
        {
            WinHTTP网络类.置选项_禁止功能 (请求句柄, 禁止功能标志_WinHTTP.禁止重定向)
        }
        否则
        {
            WinHTTP网络类.置选项_最大重定向次数 (请求句柄, 访问参数.重定向次数)
            WinHTTP网络类.置状态回调 (请求句柄, _状态回调EX, 回调标志_WinHTTP.全部状态通知)
        }
        WinHTTP网络类.置选项_发送超时 (请求句柄, 访问参数.超时时间)
        WinHTTP网络类.置选项_接收超时 (请求句柄, 访问参数.超时时间)
        如果 (访问参数.忽略SSL错误 == 真)
        {
            WinHTTP网络类.置选项_安全标志 (请求句柄, 安全标志_WinHTTP.忽略所有证书错误)
        }
        // 开始发送请求
        如果 (WinHTTP网络类.发送请求 (请求句柄, 空对象, 访问参数.提交信息, 访问参数.提交信息.取字节集长度 (), 访问参数.取对象自身指针 ()) == 真)
        {
            返回 (真)
        }
        否则
        {
            访问参数.返回结果.错误信息 = "发送请求失败: " + WinHTTP网络类.取最后错误信息 ()
            WinHTTP网络类.关闭句柄 (请求句柄)
            WinHTTP网络类.关闭句柄 (连接句柄)
            返回 (假)
        }
    }

    方法 _状态回调EX <静态 注释 = "内部方法" 折叠>
    参数 网络句柄 <类型 = 变整数 注释 = "与状态回调关联的网络句柄">
    参数 上下文值 <类型 = 变整数 注释 = "与网络句柄关联的的上下文值,可以通过\"置选项_上下文值\"或\"发送请求\"设置," 注释 = "可用于传递用户自定义的数据.">
    参数 网络状态 <类型 = 回调状态标志_WinHTTP 注释 = "请参考\"回调状态标志_WinHTTP\"中的常量">
    参数 状态信息指针 <类型 = 变整数 注释 = "指向缓冲区的指针,数据类型取决于参数\"网络状态\"的值.">
    参数 状态信息长度 <类型 = 整数 注释 = "如果状态信息为文本数据,则本参数为文本的字符数,为其他类型时则为字节数.">
    {
        如果 (上下文值 == 0)
        {
            返回
        }
        变量 参数指针 <类型 = 网络访问参数指针>
        参数指针.置指针 (上下文值)
        分支判断 ((整数)网络状态)
        {
            分支 ((整数)回调状态标志_WinHTTP.请求错误)  // 发生错误
            {
                变量 异步结果 <类型 = WinHTTP异步结果类>
                异步结果.置指针 (状态信息指针)
                输出调试 (异步结果)
                参数指针.值.返回结果.错误信息 = "异步请求错误: " + WinHTTP网络类.取最后错误信息 ()
                _结束访问EX (读指针处对象 (参数指针.值.实例指针, 网络异步访问类EX), 参数指针, 网络句柄)
            }
            // ===
            分支 ((整数)回调状态标志_WinHTTP.重定向)  // 重定向处理
            {
                参数指针.值.返回结果.重定向次数 = 参数指针.值.返回结果.重定向次数 + 1
                参数指针.值.返回结果.重定向地址.加入成员 (指针到文本 (状态信息指针))
                // 获取当前重定向的cookies
                变量 索引 <类型 = 整数类>
                变量 URL组件信息 <类型 = URL组件信息类>
                WinHTTP网络类.拆分URL (指针到文本 (状态信息指针), URL组件信息)
                索引.值 = 0
                循环判断首 ()
                {
                    变量 cookie <类型 = 文本型>
                    如果 (WinHTTP网络类.取响应头 (网络句柄, cookie, 协议头标志_WinHTTP.设置Cookie, 空对象, 索引) == 假)
                    {
                        跳出循环
                    }
                    如果 (取全局单例 (Cookie自动管理类).是否启用 == 真)
                    {
                        参数指针.值.返回结果.Cookies.加入成员 (取全局单例 (Cookie自动管理类).添加Cookie (URL组件信息.域名, cookie))
                    }
                    否则
                    {
                        参数指针.值.返回结果.Cookies.加入成员 (取全局单例 (Cookie自动管理类).取Cookie内容 (cookie))

                    }
                }
                循环判断尾 (索引.值 >= 0)
            }
            // ===
            分支 ((整数)回调状态标志_WinHTTP.发送请求完成)  // 请求成功,开始接收响应
            {
                如果 (WinHTTP网络类.接收响应 (网络句柄) == 假)
                {
                    // 错误处理
                    参数指针.值.返回结果.错误信息 = "接收响应失败: " + WinHTTP网络类.取最后错误信息 ()
                    _结束访问EX (读指针处对象 (参数指针.值.实例指针, 网络异步访问类EX), 参数指针, 网络句柄)
                }
            }
            // ===
            分支 ((整数)回调状态标志_WinHTTP.响应头可用)  // 接收响应头
            {
                变量 响应头 <类型 = 文本型>
                变量 内容长度 <类型 = 整数>
                变量 接收数量 <类型 = 整数类>
                如果 (WinHTTP网络类.取响应头 (网络句柄, 响应头, 协议头标志_WinHTTP.所有标头_换行) == 真)
                {
                    分割文本 (响应头, "\r\n", 参数指针.值.返回结果.响应头, 真, 真)
                    参数指针.值.缓冲区.分配字节集 (8192)
                    参数指针.值.返回结果.响应码 = WinHTTP网络类.取响应头_整数 (网络句柄, 协议头标志_WinHTTP.状态码)
                    内容长度 = WinHTTP网络类.取响应头_整数 (网络句柄, 协议头标志_WinHTTP.内容长度)
                    // 接收主体内容
                    如果 (内容长度 > 0)
                    {
                        参数指针.值.返回结果.请求结果.置字节集预分配尺寸 (内容长度)
                    }
                    否则  // 内容长度不定(WinHTTP解压缩内容后就取不到长度
                    {
                        参数指针.值.返回结果.请求结果.置字节集预分配尺寸 (8192)
                    }
                    WinHTTP网络类.取可用数据量 (网络句柄, 空对象)
                }
                否则
                {
                    // 错误处理
                    参数指针.值.返回结果.错误信息 = "接收响应头失败: " + WinHTTP网络类.取最后错误信息 ()
                    _结束访问EX (读指针处对象 (参数指针.值.实例指针, 网络异步访问类EX), 参数指针, 网络句柄)
                }
            }
            // ===
            分支 ((整数)回调状态标志_WinHTTP.数据可用)  // 获取可接收数据量
            {
                如果 (参数指针.值.请求方式 == 请求方式_WinHTTP.HEAD)
                {
                    跳出分支 ()
                }
                变量 数据量 <类型 = 整数>
                数据量 = 读指针处值 (状态信息指针, 整数)
                如果 (数据量 > 0)  // 还有未接收的数据
                {
                    如果 (WinHTTP网络类.接收数据2 (网络句柄, 参数指针.值.缓冲区.取字节集指针 (), 数据量, 空对象) == 假)
                    {
                        // 错误处理
                        参数指针.值.返回结果.错误信息 = "接收数据失败: " + WinHTTP网络类.取最后错误信息 ()
                        _结束访问EX (读指针处对象 (参数指针.值.实例指针, 网络异步访问类EX), 参数指针, 网络句柄)
                    }
                }
                否则  // 数据接收完毕,准备收尾
                {
                    变量 URL组件信息 <类型 = URL组件信息类>
                    如果 (参数指针.值.返回结果.重定向次数 > 0)
                    {
                        WinHTTP网络类.拆分URL (参数指针.值.返回结果.重定向地址.取成员 (参数指针.值.返回结果.重定向地址.取成员数 () - 1), URL组件信息, 0)
                    }
                    否则
                    {
                        WinHTTP网络类.拆分URL (参数指针.值.网址, URL组件信息, 0)
                    }
                    // 获取cookies
                    变量 索引 <类型 = 整数类>
                    索引.值 = 0
                    循环判断首 ()
                    {
                        变量 cookie <类型 = 文本型>
                        如果 (WinHTTP网络类.取响应头 (网络句柄, cookie, 协议头标志_WinHTTP.设置Cookie, 空对象, 索引) == 假)
                        {
                            跳出循环
                        }
                        如果 (取全局单例 (Cookie自动管理类).是否启用 == 真)
                        {
                            参数指针.值.返回结果.Cookies.加入成员 (取全局单例 (Cookie自动管理类).添加Cookie (URL组件信息.域名, cookie, 真))
                        }
                        否则
                        {
                            参数指针.值.返回结果.Cookies.加入成员 (取全局单例 (Cookie自动管理类).取Cookie内容 (cookie))
                        }

                    }
                    循环判断尾 (索引.值 >= 0)
                    // 请求完成
                    _结束访问EX (读指针处对象 (参数指针.值.实例指针, 网络异步访问类EX), 参数指针, 网络句柄)
                }
            }
            // ===
            分支 ((整数)回调状态标志_WinHTTP.接收数据完成)  // 接收数据
            {
                如果 (状态信息指针 != 0)
                {
                    参数指针.值.返回结果.请求结果.指针添加字节集 (状态信息指针, 状态信息长度)
                    如果 (WinHTTP网络类.取可用数据量 (网络句柄, 空对象) == 假)
                    {
                        // 错误处理
                        参数指针.值.返回结果.错误信息 = "取可用数据量失败: " + WinHTTP网络类.取最后错误信息 ()
                        _结束访问EX (读指针处对象 (参数指针.值.实例指针, 网络异步访问类EX), 参数指针, 网络句柄)
                    }
                }
            }
            // ===
        }
    }

    方法 _结束访问EX <静态 注释 = "内部方法" 折叠>
    参数 网络对象 <类型 = 网络异步访问类EX>
    参数 访问参数 <类型 = 网络访问参数指针>
    参数 网络句柄 <类型 = 变整数>
    {
        访问参数.值.返回结果.请求耗时 = (取现行纳秒时间戳 () - 访问参数.值.返回结果.请求耗时) / 1000000
        网络对象.网页访问完毕 (访问参数.值.网址, 访问参数.值.返回结果)
        变量 连接句柄 <类型 = 变整数>
        连接句柄 = WinHTTP网络类.取选项_父句柄 (网络句柄)
        WinHTTP网络类.关闭句柄 (网络句柄)
        WinHTTP网络类.关闭句柄 (连接句柄)
        网络对象._工作数.减 (1)
        访问参数.销毁 ()
    }
}

类 Cookie自动管理类 <注释 = "处理时只保留Cookie的域名、路径和过期时间几个属性,忽略其他属性." 注释 = "如果服务器返回的Cookie未设置到期时间,则设置为保存1天."
        注释 = "需要依赖\"PivJson\"." 折叠 @文档 = "category = \"WinHTTP.Cookie管理\"">
{
    变量 Cookies数据 <类型 = PivJSON>
    变量 文件名 <公开 类型 = 文本型>
    变量 互斥锁 <类型 = 互斥锁类>
    变量 是否启用 <公开 类型 = 逻辑型>

    方法 类_清理 <折叠>
    {
        保存文件 ()
    }

    方法 添加Cookie <公开 类型 = 文本型 注释 = "将服务器返回的\"Set-Cookie\"协议头添加到Cookies数据中."
            返回值注释 = "返回Cookie内容,用于请求时提交给服务器." 折叠>
    参数 域名 <类型 = 文本型 注释 = "不需要前面的http和后面的路径,比如\"aaa.com\"或\"bb.aaa.com\"">
    参数 Cookie <类型 = 文本型 注释 = "服务器返回的Set-Cookie协议头">
    参数 立即保存文件 <类型 = 逻辑型 @默认值 = 真>
    {
        变量 返回结果 <类型 = 文本型>
        变量 值文本 <类型 = 文本型>
        变量 值数组 <类型 = 文本数组类>
        变量 键值对 <类型 = 文本数组类>
        变量 局Cookie <类型 = 文本型>
        变量 域名小写 <类型 = 文本型>
        变量 局_域名 <类型 = 文本型>
        变量 局_路径 <类型 = 文本型>
        变量 局_到期时间 <类型 = 整数>
        变量 局_生命期 <类型 = 整数>
        变量 临时Cookie <类型 = 逻辑型 值 = 真>
        变量 是否删除 <类型 = 逻辑型>
        变量 现行时间戳 <类型 = 整数>
        局Cookie = Cookie
        现行时间戳 = 取时间戳 (取现行时间 ())
        如果 (是否以文本开头 (局Cookie, "Set-Cookie:", 假) == 真)
        {
            删除字符 (局Cookie, 0, 11)
        }
        置文本预分配字符数 (返回结果, 取文本长度 (局Cookie))
        分割文本 (局Cookie, ";", 值数组, 真, 真)
        值数组.枚举循环 ()
        {
            值文本 = 值数组.取枚举值 ()
            如果 (分割文本 (值文本, "=", 键值对, 真, 真) == 2)
            {
                如果 (文本比较 (键值对.取成员 (0), "Domain", 假) == 0)
                {
                    局_域名 = 到小写 (键值对.取成员 (1))
                }
                否则 (文本比较 (键值对.取成员 (0), "Path", 假) == 0)
                {
                    局_路径 = 到小写 (键值对.取成员 (1))
                }
                否则 (文本比较 (键值对.取成员 (0), "Expires", 假) == 0)
                {
                    临时Cookie = 假
                    局_到期时间 = WinHTTP网络类.格林威治到时间戳 (键值对.取成员 (1))
                    如果 (局_到期时间 != -1 && 局_到期时间 < 现行时间戳)
                    {
                        是否删除 = 真
                    }
                }
                否则 (文本比较 (键值对.取成员 (0), "Max-Age", 假) == 0)
                {
                    临时Cookie = 假
                    局_生命期 = 文本到整数 (键值对.取成员 (1))
                    如果 (局_生命期 <= 0)
                    {
                        是否删除 = 真
                    }
                }
                否则 (文本比较 (键值对.取成员 (0), "SameSite", 假) == 0)
                {

                }
                否则 (文本比较 (键值对.取成员 (0), "Priority", 假) == 0)
                {

                }
                否则
                {
                    如果 (文本是否为空 (返回结果) == 真)
                    {
                        加入文本 (返回结果, 值文本)
                    }
                    否则
                    {
                        加入文本 (返回结果, "; " + 值文本)
                    }
                }
            }
        }
        域名小写 = 到小写 (域名)
        如果 (文本比较 (域名小写, 局_域名) == 0)
        {
            清空文本 (局_域名)
        }
        如果 (文本是否为空 (局_路径) == 真)
        {
            局_路径 = "/"
        }
        如果 (临时Cookie == 真)
        {
            局_到期时间 = 现行时间戳 + 60 * 60 * 24
        }
        否则
        {
            如果 (局_生命期 > 0)
            {
                局_到期时间 = 现行时间戳 + 局_生命期
            }
        }
        分割文本 (返回结果, ";", 值数组, 真, 真)
        变量 键值数组 <类型 = 文本数组类>
        值数组.枚举循环 ()
        {
            如果 (分割文本 (值数组.取枚举值 (), "=", 键值数组, 真, 真) == 2)
            {
                如果 (文本是否为空 (键值数组.取成员 (1)) == 真 || 文本比较 (键值数组.取成员 (1), "null", 假) == 0 || 是否删除 == 真)
                {
                    互斥锁.加锁 ()
                    如果 (Cookies数据.是否存在 (域名小写) == 真 && Cookies数据.取成员 (域名小写).是否存在 (局_路径) == 真)
                    {
                        如果 (Cookies数据.取成员 (域名小写).取成员 (局_路径).是否存在 (键值数组.取成员 (0)) == 真)
                        {
                            Cookies数据.取成员 (域名小写).取成员 (局_路径).删除 (键值数组.取成员 (0))
                        }
                    }
                    如果 (文本是否为空 (局_域名) == 假 && Cookies数据.是否存在 (局_域名) == 真 && Cookies数据.取成员 (局_域名).是否存在 (局_路径) == 真)
                    {
                        如果 (Cookies数据.取成员 (局_域名).取成员 (局_路径).是否存在 (键值数组.取成员 (0)) == 真)
                        {
                            Cookies数据.取成员 (局_域名).取成员 (局_路径).删除 (键值数组.取成员 (0))
                        }
                    }
                    互斥锁.解锁 ()
                }
                否则
                {
                    互斥锁.加锁 ()
                    Cookies数据.成员 (域名小写).成员 (局_路径).成员 (键值数组.取成员 (0)).成员 ("Value").置文本 (键值数组.取成员 (1))
                    Cookies数据.成员 (域名小写).成员 (局_路径).成员 (键值数组.取成员 (0)).成员 ("Expires").置数值 (局_到期时间)
                    如果 (文本是否为空 (局_域名) == 假)
                    {
                        Cookies数据.成员 (局_域名).成员 (局_路径).成员 (键值数组.取成员 (0)).成员 ("Value").置文本 (键值数组.取成员 (1))
                        Cookies数据.成员 (局_域名).成员 (局_路径).成员 (键值数组.取成员 (0)).成员 ("Expires").置数值 (局_到期时间)
                    }
                    互斥锁.解锁 ()
                }
            }
        }
        如果 (立即保存文件 == 真)
        {
            本对象.保存文件 ()
        }
        返回 (返回结果)
    }

    方法 取Cookie <公开 类型 = 文本型 注释 = "从Cookies数据中获取Cookie,如果Cookie已过期则删除掉." 返回值注释 = "成功返回Cookie,失败或不存在时返回空文本."
            折叠>
    参数 域名 <类型 = 文本型 注释 = "不需要前面的http和后面的路径,比如\"aaa.com\"或\"bb.aaa.com\"">
    参数 路径 <类型 = 文本型 @默认值 = "/">
    {
        如果 (Cookies数据.是否为空 () == 真)
        {
            如果 (文本是否为空 (文件名) == 真 || 本对象.打开文件 () == 假)
            {
                返回 ("")
            }
        }
        变量 局_域名 <类型 = 文本型>
        变量 局_路径 <类型 = 文本型>
        变量 返回结果 <类型 = 文本型>
        变量 现行时间戳 <类型 = 整数>
        局_域名 = 到小写 (域名)
        局_路径 = 到小写 (路径)
        如果 (是否以字符结束 (局_路径, '/', 真) == 假)
        {
            加入字符 (局_路径, '/')
        }
        现行时间戳 = 取时间戳 (取现行时间 ())
        互斥锁.加锁 ()
        如果 (Cookies数据.是否存在 (局_域名) == 假)
        {
            变量 域名子数组 <类型 = 文本数组类>
            变量 成员数 <类型 = 整数>
            成员数 = 分割文本 (局_域名, ".", 域名子数组, 真, 真)
            如果 (成员数 == 2)
            {
                局_域名 = "." + 局_域名
            }
            否则 (成员数 > 2)
            {
                局_域名 = "." + 域名子数组.取成员 (成员数 - 2) + "." + 域名子数组.取成员 (成员数 - 1)
            }
            否则
            {
                互斥锁.解锁 ()
                返回 ("")

            }
            如果 (Cookies数据.是否存在 (局_域名) == 假)
            {
                互斥锁.解锁 ()
                返回 ("")
            }
        }
        Cookies数据.取成员 (局_域名).枚举循环 ()
        {
            如果 (是否以文本开头 (局_路径, Cookies数据.取枚举键 (), 真) == 真)
            {
                变量 临时Json <类型 = PivJSON>
                变量 临时路径 <类型 = 文本型>
                临时Json = Cookies数据.取枚举值 ()
                临时路径 = Cookies数据.取枚举键 ()
                临时Json.枚举循环 ()
                {
                    如果 (现行时间戳 <= 临时Json.取枚举值 ().成员 ("Expires").取整数 ())
                    {
                        如果 (文本是否为空 (返回结果) == 真)
                        {
                            加入文本 (返回结果, 临时Json.取枚举键 () + "=" + 临时Json.取枚举值 ().成员 ("Value").取文本 ())
                        }
                        否则
                        {
                            加入文本 (返回结果, "; " + 临时Json.取枚举键 () + "=" + 临时Json.取枚举值 ().成员 ("Value").取文本 ())
                        }
                    }
                    否则  // Cookie已过期,删除掉
                    {
                        Cookies数据.取成员 (局_域名).取成员 (临时路径).删除 (临时Json.取枚举键 ())

                    }
                }
            }
        }
        互斥锁.解锁 ()
        返回 (返回结果)
    }

    方法 打开文件 <公开 类型 = 逻辑型 注释 = "从本地文件打开Cookies数据." 折叠>
    {
        变量 数据 <类型 = 字节集类>
        如果 (文本是否为空 (文件名) == 真)
        {
            返回 (假)
        }
        如果 (数据.从文件读字节集 (文件名) == -1)
        {
            返回 (假)
        }
        变量 配置 <类型 = PivJSON>
        如果 (配置.解析 (数据, 假, 假, SIMD编码类型.UTF8) == 真)
        {
            互斥锁.加锁 ()
            Cookies数据 = 配置
            互斥锁.解锁 ()
            返回 (真)
        }
        否则
        {
            返回 (假)
        }
    }

    方法 保存文件 <公开 类型 = 逻辑型 注释 = "将Cookies数据保存为文件." 折叠>
    {
        如果 (文本是否为空 (文件名) == 假)
        {
            变量 数据 <类型 = 字节集类>
            互斥锁.加锁 ()
            数据 = Cookies数据.到UTF8 (-1, 32, 假)
            互斥锁.解锁 ()
            返回 (数据.写字节集到文件 (文件名))

        }
        返回 (假)
    }

    方法 取Cookie内容 <公开 类型 = 文本型 注释 = "从服务器返回的\"Set-Cookie\"协议头中提取出Cokkie的名字和值字段."
            返回值注释 = "返回Cookie内容,用于请求时提交给服务器." 折叠>
    参数 Cookie <类型 = 文本型 注释 = "服务器返回的Set-Cookie协议头">
    {
        变量 返回结果 <类型 = 文本型>
        变量 值文本 <类型 = 文本型>
        变量 值数组 <类型 = 文本数组类>
        变量 局Cookie <类型 = 文本型>
        局Cookie = Cookie
        如果 (是否以文本开头 (局Cookie, "Set-Cookie:", 假) == 真)
        {
            删除字符 (局Cookie, 0, 11)
        }
        置文本预分配字符数 (返回结果, 取文本长度 (局Cookie))
        分割文本 (局Cookie, ";", 值数组, 真, 真)
        值数组.枚举循环 ()
        {
            值文本 = 值数组.取枚举值 ()
            如果 (寻找字符 (值文本, '=', 0) != -1)
            {
                如果 (是否以文本开头 (值文本, "Domain", 假) == 假 && 是否以文本开头 (值文本, "Path", 假) == 假 && 是否以文本开头 (值文本, "Expires", 假) == 假 && 是否以文本开头 (值文本, "Max-Age", 假) == 假 && 是否以文本开头 (值文本, "SameSite", 假) == 假 && 是否以文本开头 (值文本, "Priority", 假) == 假)
                {
                    如果 (文本是否为空 (返回结果) == 真)
                    {
                        加入文本 (返回结果, 值文本)
                    }
                    否则
                    {
                        加入文本 (返回结果, "; " + 值文本)
                    }

                }
            }
        }
        返回 (返回结果)
    }
}

# 数据类型 ===

类 网络请求响应类 <公开 基础类 = 扩展对象类 注释 = "包含网页访问所返回的结果内容" 折叠 @文档 = "category = \"WinHTTP.辅助类\"">
{
    变量 请求结果 <公开 类型 = 字节集类 注释 = "本次请求所返回的结果数据" @属性变量 = 真>
    变量 Cookies <公开 类型 = 文本数组类 注释 = "本次请求所返回的Cookie内容" @属性变量 = 真>
    变量 响应头 <公开 类型 = 文本数组类 注释 = "本次请求所接收到服务器的响应头内容" @属性变量 = 真>
    变量 重定向地址 <公开 类型 = 文本数组类 注释 = "本次请求所有的重定向地址" @属性变量 = 真>
    变量 重定向次数 <公开 类型 = 整数 注释 = "本次请求所遵循重定向的次数" @属性变量 = 真>
    变量 响应码 <公开 类型 = 整数 注释 = "本次请求的HTTP状态码" @属性变量 = 真>
    变量 请求耗时 <公开 类型 = 长整数 注释 = "本次请求所耗时长(毫秒)." @属性变量 = 真>
    变量 错误信息 <公开 类型 = 文本型 注释 = "本次请求遇到的错误" @属性变量 = 真>
    变量 用户数据 <公开 类型 = 变整数 注释 = "(异步访问专用)本次请求的用户数据,可以是指针或自定义的标识." @属性变量 = 真>

    方法 取合并Cookies <公开 类型 = 文本型 注释 = "返回将Cookies数组合并后的结果" 折叠>
    {
        变量 结果 <类型 = 文本型>
        Cookies.枚举循环 ()
        {
            如果 (文本是否为空 (结果) == 假)
            {
                加入文本 (结果, "; ")
            }
            加入文本 (结果, Cookies.取枚举值 ())
        }
        返回 (结果)
    }

    方法 取结果文本 <公开 类型 = 文本型 注释 = "取出请求结果所对应的文本内容" 折叠>
    参数 文本编码 <类型 = 文本编码类型 注释 = "提供网页编码类型,默认为utf8编码,如果是gbk网页请使用\"文本编码类型.多字节\"." @默认值 = 文本编码类型.UTF8>
    {
        如果 (文本编码 == 文本编码类型.多字节)
        {
            返回 (多字节到文本 (请求结果))
        }
        否则 (文本编码 == 文本编码类型.UTF16)
        {
            返回 (字节集到文本 (请求结果))
        }
        返回 (UTF8到文本 (请求结果))
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<网络请求响应类> 总共 8 个成员:\r\n"
        加入文本 (展示内容, "1.请求结果: " + 取调试文本2 (最大展示数据尺寸, 请求结果) + "\r\n")
        加入文本 (展示内容, "2.Cookies: " + 取调试文本2 (最大展示数据尺寸, Cookies) + "\r\n")
        加入文本 (展示内容, "3.响应头: " + 取调试文本2 (最大展示数据尺寸, 响应头) + "\r\n")
        加入文本 (展示内容, "4.重定向地址: " + 取调试文本2 (最大展示数据尺寸, 重定向地址) + "\r\n")
        加入文本 (展示内容, "5.重定向次数: " + 取调试文本2 (最大展示数据尺寸, 重定向次数) + "\r\n")
        加入文本 (展示内容, "6.响应码: " + 取调试文本2 (最大展示数据尺寸, 响应码) + "\r\n")
        加入文本 (展示内容, "7.请求耗时: " + 取调试文本2 (最大展示数据尺寸, 请求耗时) + "\r\n")
        加入文本 (展示内容, "8.错误信息: " + 取调试文本2 (最大展示数据尺寸, 错误信息))
    }
}

类 网络访问参数类 <注释 = "\"网络异步访问类\"内部使用,不公开." 折叠 @文档 = "category = \"WinHTTP.辅助类\"">
{
    变量 访问类型 <公开 类型 = 整数 注释 = "0=网页访问, 1=下载, 2=上传(未写)..." "">
    变量 ""
    变量 网址 <公开 类型 = 文本型 注释 = "提供所欲访问的网址内容">
    变量 请求方式 <公开 类型 = 请求方式_WinHTTP 注释 = "提供所欲使用的请求方式">
    变量 提交信息 <公开 类型 = 字节集类 注释 = "设置本次请求所提交的数据,非POST请求也支持提交请求体,如需携带请求体务必保证该参数不为空;"
            注释 = "如有必要,请自行对提交信息进行URL编码;" 注释 = "本方法会根据提交信息的类型自动添加\"Content-Type\"协议头,无需你手动添加.">
    变量 附加协议头 <公开 类型 = 文本数组类 注释 = "提供本次请求所欲使用的附加协议头,每个协议之间请用\"\\r\\n\"换行.">
    变量 提交Cookie <公开 类型 = 文本型 注释 = "提供本次请求所欲使用的Cookie内容,注意该参数提交的内容不会同步到\"自动Cookie管理\".">
    变量 内容编码 <公开 类型 = 文本型 注释 = "指定所欲请求服务器使用的内容编码(压缩)方式,即\"Accept-Encoding\"协议内容;"
            注释 = "本参数只对Windows 8及更高版本的系统有效,旧系统不支持WinHTTP的自动解压缩;"
            注释 = "提供空文本时自动设置为\"Accept-Encoding: gzip, deflate\",提供空对象则禁用压缩;"
            注释 = "WinHTTP自动解压缩后,会将响应头的Content-Length、Content-Encoding删除掉.">
    变量 代理地址 <公开 类型 = 文本型 注释 = "设置当前一次网页访问使用的代理地址列表,非空时将代理模式临时改为\"命名代理\";"
            注释 = "无论代理是什么协议,都一律填http/https,例如Socoks5的代理也是填: \"http://127.0.0.1:7890\";"
            注释 = "可以用分号支持多个代理服务器,也可以对不同的协议使用不同的代理,例如:"
            注释 = "\"http=http://127.0.0.1:7890;https=http://192.168.1.1:8080\"">
    变量 代理账号 <公开 类型 = 文本型 值 = "" 注释 = "提供代理服务器所需的用户名(可空),仅在代理模式为\"命名代理\"时可用.">
    变量 代理密码 <公开 类型 = 文本型 值 = "" 注释 = "提供代理服务器所需的用户密码(可空),仅在代理模式为\"命名代理\"时可用.">
    变量 超时时间 <公开 类型 = 整数 值 = -1 注释 = "指定本次完成整个请求所限定的超时时间,为-1时不限制,单位:毫秒.">
    变量 重定向次数 <公开 类型 = 整数 值 = 10 注释 = "欲遵循网站重定向的最大次数,为0时禁止重定向." "">
    变量 忽略SSL错误 <公开 类型 = 逻辑型 注释 = "是否忽略任何SSL验证相关错误,即不验证证书也不验证服务器(如使用了代理将会被一同忽略).">
    变量 保存位置 <公开 类型 = 文本型 注释 = "下载的文本保存在此位置中,请以\"\\\\\"结尾.">
    变量 返回结果 <公开 类型 = 网络请求响应类>
    变量 实例指针 <公开 类型 = 变整数>
    变量 缓冲区 <公开 类型 = 字节集类>
}

类 网络访问参数指针 <基础类 = PIV参考指针模板 @模板实现类 = "网络访问参数类">

类 网络访问参数队列 <基础类 = 无锁队列模板类 @模板实现类 = "网络访问参数指针">

类 网络访问参数阻塞队列 <基础类 = 无锁阻塞队列模板类 @模板实现类 = "网络访问参数指针">

# =====
# WinHTTP C/C++ API
# =====

类 WinHTTP网络类 <公开 注释 = "  完整封装了WinHTTP的API,本类仅供给对HTTP协议有足够认识的开发者使用."
        注释 = "  请注意部分方法对Windows版本的要求,如果使用了这些方法,你需要使用版本" 注释 = "足够高的Windows SDK才能编译." 折叠
        @文档 = "category = \"WinHTTP\"" @别名 = "//" @别名类型 = 本地类 @类用途 = 访问静态成员>
{
    常量 User_Agent <类型 = 文本型
            值 = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.124 Safari/537.36 Edg/102.0.1245.41"
            注释 = "默认的用户代理UA">

    方法 检查平台支持 <公开 静态 类型 = 逻辑型 注释 = "检查当前运行的平台是否支持该版本的WinHTTP." 折叠 @嵌入式方法 = "">
    {
        @ WinHttpCheckPlatform()
    }

    方法 取最后错误信息 <公开 静态 类型 = 文本型 注释 = "获取最后一次错误的代码和描述信息." 返回值注释 = "成功返回错误信息,失败返回空文本." 折叠 @禁止流程检查 = 真>
    {
        @ DWORD dwLastError = ::GetLastError();
        @ LPVOID lpvMessageBuffer;
        @ @an<CVolString> ErrorMsg;
        @ if (::FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        @                      NULL, dwLastError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPWSTR)&lpvMessageBuffer, 0, NULL)) {
        @     ErrorMsg.Format(L"错误(%u): %s", dwLastError, (LPWSTR)lpvMessageBuffer);
        @     ::LocalFree(lpvMessageBuffer);
        @ }
        @ return ErrorMsg;
    }

    # 主要函数 ===

    方法 初始化 <公开 静态 类型 = 变整数 注释 = "初始化会话句柄." 注释 = "使用WinHTTP之前必须调用本方法." 返回值注释 = "成功返回会话句柄,失败返回0." 折叠
            @禁止流程检查 = 真>
    参数 用户代理 <类型 = 文本型 注释 = "  即User Agent,简称UA,使服务器能识别客户使用的操作系统及版本、CPU类型、"
            注释 = "浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等." 注释 = "  空文本表示使用本类的常量\"User_Agent\",空对象表示不使用UA." @默认值 = 空对象>
    参数 代理类型 <类型 = 访问类型_WinHTTP 注释 = "指定是否使用代理服务器" @默认值 = 访问类型_WinHTTP.不使用代理>
    参数 异步模式 <类型 = 逻辑型 注释 = "是否使用异步模式" @默认值 = 假>
    参数 代理服务器 <类型 = 文本型 注释 = "仅在\"代理类型\"为\"命名代理\"时可用,需要提供CERN类型的HTTP代理." @默认值 = "">
    参数 代理跳过列表 <类型 = 文本型 注释 = "仅在\"代理类型\"为\"命名代理\"时可用,列表内的域名和IP不会通过代理访问;" 注释 = "请提供用分号分隔的主机域名或IP地址,可以使用通配符;"
            注释 = "请勿提供空文本,默认的\"<local>\"为忽略所有不含句点的主机名." @默认值 = "<local>">
    {
        @ return (INT_P)WinHttpOpen(@<用户代理>.IsNullObject() ? NULL : (@<用户代理>.IsEmpty() ? @<User_Agent>.GetText() : @<用户代理>.GetText()),
        @                           (DWORD)@<代理类型>,
        @                           (DWORD)@<代理类型> == WINHTTP_ACCESS_TYPE_NAMED_PROXY ? @<代理服务器>.GetText() : WINHTTP_NO_PROXY_NAME,
        @                           (DWORD)@<代理类型> == WINHTTP_ACCESS_TYPE_NAMED_PROXY ? @<代理跳过列表>.GetText() : WINHTTP_NO_PROXY_BYPASS,
        @                           @<异步模式> ? WINHTTP_FLAG_ASYNC : 0);
    }

    方法 关闭句柄 <公开 静态 类型 = 逻辑型 注释 = "网络句柄不再使用时必须调用本方法关闭." 折叠 @嵌入式方法 = "">
    参数 网络句柄 <类型 = 变整数 注释 = "可以是连接句柄、请求句柄、会话句柄、解析器句柄.">
    {
        @ WinHttpCloseHandle((HINTERNET)@<网络句柄>)
    }

    方法 连接服务器 <公开 静态 类型 = 变整数 注释 = "设置HTTP请求的初始目标服务器,并返回连接句柄." 注释 = "使用本方法之前必须先调用\"初始化\"."
            返回值注释 = "成功返回连接句柄,失败返回0." 折叠 @嵌入式方法 = "">
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 服务器域名 <类型 = 文本型 注释 = "目标HTTP服务器的域名或IP地址." 注释 = "前面不能有\"http://\"或\"https://\"等协议,后面也不能有端口号或URL路径.">
    参数 服务器端口 <类型 = 整数 注释 = "可以使用自定义的端口号或以下三个常用数值之一:" 注释 = "  80  使用HTTP服务器的默认端口;"
            注释 = "  443 使用HTTPS服务器的默认端口;" 注释 = "  0   将端口80用于HTTP,将端口443用于HTTPS;" @默认值 = 0>
    {
        @ (INT_P)WinHttpConnect((HINTERNET)@<会话句柄>, @<服务器域名>.GetText(), (INTERNET_PORT)@<服务器端口>, 0)
    }

    方法 打开请求 <公开 静态 类型 = 变整数 注释 = "创建请求句柄,并设置请求方式和访问的URL路径." 返回值注释 = "成功返回请求句柄,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 连接句柄 <类型 = 变整数 注释 = "请提供调用\"连接服务器\"成功时返回的连接句柄.">
    参数 请求方式 <类型 = 请求方式_WinHTTP 注释 = "请提供请求方式." @默认值 = 请求方式_WinHTTP.GET>
    参数 目标路径 <类型 = 文本型 注释 = "请求的URL路径,可省略前面的根路径\"/\"" @默认值 = "">
    参数 HTTP版本 <类型 = 文本型 注释 = "留空为默认的\"HTTP/1.1\"" @默认值 = 空对象>
    参数 来源参考 <类型 = 文本型 注释 = "  指定\"目标路径\"的访问来源,即表示当前页面是通过此来源页面的链接进入的." 注释 = "  留空表示没有来源参考网页." @默认值 = 空对象>
    参数 接受类型 <类型 = 文本数组类 注释 = "  该数组指定客户端接受的媒体类型,\"*/*\"表示接受所有类型."
            注释 = "  留空表示除了\"text/*\"等文档类型外,不接受其他任何类型."
            注释 = "  更多媒体类型可参考 http://www.iana.org/assignments/media-types/" @默认值 = 空对象>
    参数 请求标志 <类型 = 整数 注释 = "请参考\"请求标志_WinHTTP\"中的常量和备注,部分常量可以用\"位或\"组合使用." @默认值 = 0>
    {
        @ HINTERNET hRequest = NULL;
        @ LPCWSTR* ppwszAcceptTypes = WINHTTP_DEFAULT_ACCEPT_TYPES;
        @ if (@<接受类型>.data().IsEmpty() == FALSE) {
        @     DWORD cAcceptTypes = (DWORD)@<接受类型>.data().GetCount();
        @     ppwszAcceptTypes = (LPCWSTR*)malloc(sizeof(LPCWSTR) * (cAcceptTypes + 1));
        @     ppwszAcceptTypes[cAcceptTypes] = NULL;
        @     for (DWORD i = 0; i < cAcceptTypes; i++) {
        @         ppwszAcceptTypes[i] = (LPCWSTR)@<接受类型>.data().GetAt(i);
        @     }
        @ }
        @ hRequest = WinHttpOpenRequest((HINTERNET)@<连接句柄>, @<请求方式>.GetText(),
        @                               @<目标路径>.GetText(),
        @                               @<HTTP版本>.GetTextMaybeNull(),
        @                               @<来源参考>.IsEmpty() ? WINHTTP_NO_REFERER : @<来源参考>.GetText(),
        @                               ppwszAcceptTypes, (DWORD)@<请求标志>);
        @ if (ppwszAcceptTypes) { free (ppwszAcceptTypes); }
        @ return (INT_P)hRequest;
    }

    方法 取身份验证方案 <公开 静态 类型 = 逻辑型 注释 = "获取HTTP服务器支持的身份验证方案."
            注释 = "服务器响应状态码401或407时,表示需要进行身份验证,本方法用来获取所需的身份验证方案." 返回值注释 = "返回是否成功." 折叠 @嵌入式方法 = "">
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 身份验证方案 <类型 = 整数 注释 = "返回服务器支持的身份验证方案,为\"身份验证方案_WinHTTP\"中的常量的组合值,可以用\"位与\"判断." @需求类型 = 可写入变量>
    参数 第一种方案 <类型 = 整数 注释 = "返回服务器支持的第一种身份验证方案." @需求类型 = 可写入变量>
    参数 身份验证目标 <类型 = 整数 注释 = "返回身份验证的目标,0为将凭据传递给服务器(响应状态码为401),1为将凭据传递给代理(响应状态码为407)." @需求类型 = 可写入变量>
    {
        @ WinHttpQueryAuthSchemes((HINTERNET)@<请求句柄>, (LPDWORD)&@<身份验证方案>, (LPDWORD)&@<第一种方案>, (LPDWORD)&@<身份验证目标>)
    }

    方法 置凭据 <公开 静态 类型 = 逻辑型 注释 = "将所需的凭据数据传递给HTTP服务器." 注释 = "服务器响应状态码401或407时,表示需要进行身份验证,本方法用来提供身份凭据."
            返回值注释 = "返回是否成功." 折叠 @嵌入式方法 = "">
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 身份验证目标 <类型 = 整数 注释 = "提供身份验证的目标,0为将凭据传递到服务器." 注释 = "1为将凭据传递到代理." @默认值 = 0>
    参数 身份验证方案 <类型 = 整数 注释 = "必须为\"取身份验证方案\"返回的方案类型,请参考\"身份验证方案_WinHTTP\"中的常量.">
    参数 用户名 <类型 = 文本型 注释 = "提供有效的用户名." "">
    参数 密码 <类型 = 文本型 注释 = "提供有效的密码,密码可以为空." @默认值 = 空对象>
    {
        @ WinHttpSetCredentials((HINTERNET)@<请求句柄>, (DWORD)@<身份验证目标>,
        @                       (DWORD)@<身份验证方案>, @<用户名>.GetText(),
        @                       @<密码>.GetTextMaybeNull(), NULL);
    }

    方法 发送请求 <公开 静态 类型 = 逻辑型 注释 = "将指定的请求发送到HTTP服务器." 注释 = "异步模式下执行成功会响应\"发送请求完成\"回调,接着应调用\"接收响应\"."
            返回值注释 = "返回是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 附加请求头 <类型 = 文本型 注释 = "额外添加的请求头(可空),必须在请求头后面加上换行符\"\\r\\n\"." @默认值 = 空对象>
    参数 提交数据 <类型 = 字节集类 注释 = "POST或PUT请求时,需要在此提供提交请求体参数." @默认值 = 空对象>
    参数 数据总长度 <类型 = 整数 注释 = "  所发送数据的字节总长度,提交数据不为空时需要填写本参数,如果" 注释 = "提供的长度大于提交数据,则可以使用\"发送数据\"继续发送其他数据."
            @默认值 = 0>
    参数 上下文 <类型 = 变整数 注释 = "用户自定义的指针值,将伴随请求句柄传递给任意回调方法." @默认值 = 0>
    {
        @ return WinHttpSendRequest((HINTERNET)@<请求句柄>,
        @                           @<附加请求头>.IsEmpty() ? WINHTTP_NO_ADDITIONAL_HEADERS : @<附加请求头>.GetText(),
        @                           @<附加请求头>.IsEmpty() ? 0 : (DWORD)@<附加请求头>.GetLength(),
        @                           @<提交数据>.IsEmpty() ? WINHTTP_NO_REQUEST_DATA : (LPVOID)@<提交数据>.GetPtr(),
        @                           @<提交数据>.IsEmpty() ? 0 : (DWORD)@<提交数据>.GetSize(),
        @                           (DWORD)@<数据总长度>, (DWORD_PTR)@<上下文>);
    }

    方法 发送数据 <公开 静态 类型 = 逻辑型 注释 = "将请求数据发送给HTTP服务器,在POST、PUT请求发送更多数据时使用."
            注释 = "异步模式下执行成功会响应\"发送请求完成\"回调,接着应调用\"接收响应\"." 返回值注释 = "返回是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄,且使用过\"发送请求\".">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲发送的数据.">
    参数 写入字节数 <类型 = 整数类 注释 = "成功时返回写入到缓冲区的字节数.异步模式下本参数必须为空对象." @默认值 = 空对象>
    {
        @ return WinHttpWriteData((HINTERNET)@<请求句柄>, (LPCVOID)@<数据>.GetPtr(), (DWORD)@<数据>.GetSize(),
        @                         piv::GetBaseDataPtr<LPDWORD>(@<写入字节数>));
    }

    方法 接收响应 <公开 静态 类型 = 逻辑型 注释 = "等待接收HTTP服务器的响应头." 注释 = "必须在执行了\"发送请求\"之后才能使用本方法."
            注释 = "异步模式下执行成功会响应\"响应头可用\"回调,接着应调用\"取响应头\"." 返回值注释 = "返回是否成功." 折叠 @嵌入式方法 = "">
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄,且使用过\"发送请求\".">
    {
        @ WinHttpReceiveResponse((HINTERNET)@<请求句柄>, NULL)
    }

    方法 取可用数据量 <公开 静态 类型 = 逻辑型 注释 = "  返回可使用\"接收数据\"读取的数据量(以字节为单位)." 注释 = "  本方法不会一次性返回所有的数据量(最多不超过8KB),"
            注释 = "需要配合\"接收数据\"反复调用." 注释 = "  你也可以跳过本方法直接用\"接收数据\"."
            注释 = "  异步模式下执行成功会响应\"数据可用\"回调,接着应调用\"接收数据\"." 返回值注释 = "返回是否成功." 折叠 @嵌入式方法 = "">
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄,且使用过\"接收响应\".">
    参数 可用数据量 <类型 = 整数类 注释 = "返回当前可用的数据量(字节). 异步模式时本参数必须为空对象." @默认值 = 空对象>
    {
        @ WinHttpQueryDataAvailable((HINTERNET)@<请求句柄>, piv::GetBaseDataPtr<LPDWORD>(@<可用数据量>))
    }

    方法 接收数据 <公开 静态 类型 = 逻辑型 注释 = "读取HTTP服务器发来的数据,需要提前给缓冲区分配内存." 注释 = "异步模式下执行成功会响应\"接收数据完成\"回调."
            返回值注释 = "返回是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄,且使用过\"接收响应\".">
    参数 缓冲区 <类型 = 字节集类 注释 = "成功时在此缓冲区返回接收的数据,必须提前分配字节集的长度.">
    参数 已接收长度 <类型 = 整数类 注释 = "  返回缓冲区成功接收的字节数. 异步模式时本参数必须为空对象." 注释 = "  如果执行成功时本参数返回0,则表示传输已完成." @默认值 = 空对象>
    {
        @ return WinHttpReadData((HINTERNET)@<请求句柄>, (LPVOID)@<缓冲区>.GetPtr(), (DWORD)@<缓冲区>.GetSize(),
        @                        piv::GetBaseDataPtr<LPDWORD>(@<已接收长度>));
    }

    方法 接收数据2 <公开 静态 类型 = 逻辑型 注释 = "跟\"接收数据\"的不同之处是需要提供缓冲区指针,而非字节集." 注释 = "异步模式下执行成功会响应\"接收数据完成\"回调."
            返回值注释 = "返回是否成功." 折叠 @嵌入式方法 = "">
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄,且使用过\"接收响应\".">
    参数 缓冲区指针 <类型 = 变整数 注释 = "成功时在此缓冲区指针返回接收的数据.">
    参数 缓冲区长度 <类型 = 整数 注释 = "提供缓冲区长度">
    参数 已接收长度 <类型 = 整数类 注释 = "  返回缓冲区成功接收的字节数. 异步模式时本参数必须为空对象." 注释 = "  如果执行成功时本参数返回0,则表示传输已完成." @默认值 = 空对象>
    {
        @ WinHttpReadData((HINTERNET)@<请求句柄>, (LPVOID)@<缓冲区指针>, (DWORD)@<缓冲区长度>,
        @                 piv::GetBaseDataPtr<LPDWORD>(@<已接收长度>))
    }

    方法 接收数据EX <公开 静态 类型 = 整数 注释 = "读取HTTP服务器发来的数据,需要提前给缓冲区分配内存." 注释 = "异步模式下执行成功会响应\"接收数据完成\"回调."
            注释 = "本方法此为Windows 10 Version 21H2新增的API,之前的系统不可用." 返回值注释 = "成功返回0,失败返回错误码." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄,且使用过\"接收响应\".">
    参数 缓冲区 <类型 = 字节集类 注释 = "成功时在此缓冲区返回接收的数据,必须提前分配字节集的长度.">
    参数 已接收长度 <类型 = 整数类 注释 = "返回缓冲区成功接收的字节数. 异步模式时本参数必须为空对象." @默认值 = 空对象>
    参数 填满缓冲区 <类型 = 逻辑型 注释 = "如果为真,在接收完数据或填满缓冲区之前不会结束本函数." @默认值 = 真>
    {
        @ return (INT)WinHttpReadDataEx((HINTERNET)@<请求句柄>, (LPVOID)@<缓冲区>.GetPtr(), (DWORD)@<缓冲区>.GetSize(),
        @                               piv::GetBaseDataPtr<LPDWORD>(@<已接收长度>),
        @                               @<填满缓冲区> ? WINHTTP_READ_DATA_EX_FLAG_FILL_BUFFER : 0, 0, NULL);
    }

    方法 接收数据EX2 <公开 静态 类型 = 整数 注释 = "跟\"接收数据EX\"的不同之处是需要提供缓冲区指针,而非字节集." 注释 = "异步模式下执行成功会响应\"接收数据完成\"回调."
            注释 = "本方法此为Windows 10 Version 21H2新增的API,之前的系统不可用." 返回值注释 = "成功返回0,失败返回错误码." 折叠 @嵌入式方法 = "">
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄,且使用过\"接收响应\".">
    参数 缓冲区指针 <类型 = 变整数 注释 = "成功时在此缓冲区指针返回接收的数据.">
    参数 缓冲区长度 <类型 = 整数 注释 = "提供缓冲区长度">
    参数 已接收长度 <类型 = 整数类 注释 = "返回缓冲区成功接收的字节数. 异步模式时本参数必须为空对象." @默认值 = 空对象>
    参数 填满缓冲区 <类型 = 逻辑型 注释 = "如果为真,在接收完数据或填满缓冲区之前不会结束本函数." @默认值 = 真>
    {
        @ (INT)WinHttpReadDataEx((HINTERNET)@<请求句柄>, (LPVOID)@<缓冲区指针>, (DWORD)@<缓冲区长度>,
        @                        piv::GetBaseDataPtr<LPDWORD>(@<已接收长度>),
        @                        @<填满缓冲区> ? WINHTTP_READ_DATA_EX_FLAG_FILL_BUFFER : 0, 0, NULL)
    }

    方法 取连接组状态 <公开 静态 类型 = 整数 注释 = "获取WinHTTP连接的当前状态描述." 注释 = "本方法此为Windows 11新增的API,之前的系统不可用."
            返回值注释 = "成功返回0,失败返回错误码." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供连接句柄或请求句柄.">
    参数 返回结果 <类型 = 主机连接组数组类 注释 = "成功返回连接组的状态信息.">
    参数 连接GUID <类型 = 文本型 注释 = "如果提供本参数,则仅返回与GUID匹配的连接,留空则将返回所连接主机的所有连接(由网络句柄而定)."
            注释 = "必须提供符合规格的GUID文本,例如:\"{00000000-0000-0000-0000-000000000000}\"" @默认值 = 空对象>
    参数 是否HTTPS <类型 = 逻辑型 注释 = "提供的连接句柄是否为HTTPS连接." "">
    {
        @ typedef BOOL(WINAPI* pfn_GUIDFromStringW)(LPCWSTR psz, LPGUID pguid);
        @ PWINHTTP_QUERY_CONNECTION_GROUP_RESULT pResult = NULL;
        @ GUID guid;
        @ if (@<连接GUID>.GetLength() == 38) {
        @     static pfn_GUIDFromStringW GUIDFromStringW = (pfn_GUIDFromStringW)GetProcAddress(::GetModuleHandleW(L"Shell32.dll"), "GUIDFromStringW");
        @     if (GUIDFromStringW) {
        @         GUIDFromStringW(@<连接GUID>.GetText(), &guid);
        @     }
        @ }
        @ DWORD dwRes = WinHttpQueryConnectionGroup((HINTERNET)@<网络句柄>, @<连接GUID>.IsEmpty() ? NULL : &guid,
        @                                           @<是否HTTPS> ? 0 : WINHTTP_QUERY_CONNECTION_GROUP_FLAG_INSECURE, &pResult);
        @ if (pResult) {
        @     for (ULONG i = 0; i < pResult->cHosts; i++) {
        @         @dt<主机连接组类> hostGroup;
        @         if (pResult->pHostConnectionGroups[i].pwszHost) hostGroup.pwszHost.SetText(pResult->pHostConnectionGroups[i].pwszHost);
        @         hostGroup.cConnectionGroups = (INT)pResult->pHostConnectionGroups[i].cConnectionGroups;
        @         for (INT n = 0; n < hostGroup.cConnectionGroups; n++) {
        @             @dt<连接组类> ConnectionGroups(&pResult->pHostConnectionGroups[i].pConnectionGroups[n]);
        @             hostGroup.pConnectionGroups.Add(ConnectionGroups, NULL);
        @         }
        @         @<返回结果>.Add(hostGroup, NULL);
        @     }
        @     WinHttpFreeQueryConnectionGroupResult(pResult);
        @ }
        @ return dwRes;
    }

    # 协议头 ===

    方法 添加请求头 <公开 静态 类型 = 逻辑型 注释 = "添加一个或多个协议头到请求中." 返回值注释 = "返回是否添加成功,本函数会检查协议头是否合规,如果添加的协议头不规范将返回失败." 折叠
            @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 协议头 <类型 = 文本型 注释 = "  可以添加一个或多个协议头,添加多个协议头时," 注释 = "各协议头之间必须用\"\\r\\n\"分隔."
            注释 = "  添加单个协议头时无需添加换行符.">
    参数 修改方式 <类型 = 整数 注释 = "请参考\"请求头修改方式_WinHTTP\"中的常量和备注,部分常量可以用\"位或\"组合使用." @默认值 = 请求头修改方式_WinHTTP.仅新建添加>
    {
        @ return WinHttpAddRequestHeaders((HINTERNET)@<请求句柄>, @<协议头>.GetText (), (DWORD)@<协议头>.GetLength(), (DWORD)@<修改方式>);
    }

    方法 添加请求头2 <公开 静态 类型 = 逻辑型 注释 = "跟\"添加请求头\"一样,不同的是添加的协议头为文本数组类."
            返回值注释 = "返回是否添加成功,本函数会检查协议头是否合规,如果添加的协议头不规范将返回失败." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 协议头数组 <类型 = 文本数组类 注释 = "提供的协议头跟curl的一样,无需在单个成员的尾部加入换行符.">
    参数 修改方式 <类型 = 整数 注释 = "请参考\"请求头修改方式_WinHTTP\"中的常量和备注,部分常量可以用\"位或\"组合使用." @默认值 = 请求头修改方式_WinHTTP.仅新建添加>
    {
        @ @an<CVolString> szHeaders;
        @ for (INT_P npIndex = 0; npIndex < @<协议头数组>.data().GetCount(); npIndex++) {
        @     szHeaders.AddText(@<协议头数组>.data().GetAt(npIndex));
        @     szHeaders.AddText(L"\r\n");
        @ }
        @ szHeaders.TrimRight();
        @ return WinHttpAddRequestHeaders((HINTERNET)@<请求句柄>, szHeaders.GetText(), (DWORD)szHeaders.GetLength(), (DWORD)@<修改方式>);
    }

    方法 添加请求头EX <公开 静态 类型 = 逻辑型 注释 = "使用键值对的方式,添加一个或多个协议头到请求中."
            注释 = "本方法此为Windows 10 Version 21H2新增的API,之前的系统不可用."
            返回值注释 = "返回是否添加成功,本函数会检查协议头是否合规,如果添加的协议头不规范将返回失败." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 协议头键值对 <类型 = 文本到文本哈希表 注释 = "  可以添加一个或多个协议头,添加多个协议头时," 注释 = "各协议头之间必须用\"\\r\\n\"分隔."
            注释 = "  添加单个协议头时无需添加换行符.">
    参数 修改方式 <类型 = 整数 注释 = "请参考\"请求头修改方式_WinHTTP\"中的常量和备注,部分常量可以用\"位或\"组合使用." @默认值 = 请求头修改方式_WinHTTP.仅新建添加>
    {
        @ DOWRD cHeaders = @<协议头键值对>.m_map.size ();
        @ PWINHTTP_EXTENDED_HEADER pHeaders = (PWINHTTP_EXTENDED_HEADER)calloc (cHeaders, sizeof (WINHTTP_EXTENDED_HEADER));
        @ for (auto iter = @<协议头键值对>.m_map.begin (), DWORD dwIndex = 0; iter != @<协议头键值对>.m_map.end (); iter++, dwIndex++) {
        @     pHeaders[i]->pwszName = iter->first;
        @     pHeaders[i]->pwszName = iter->second;
        @ }
        @ DWORD dwRes = WinHttpAddRequestHeadersEx ((HINTERNET)@<请求句柄>, (DWORD)@<修改方式>, WINHTTP_EXTENDED_HEADER_FLAG_UNICODE, NULL, cHeaders, pHeaders);
        @ free (pHeaders);
        @ return (dwRes == 0);
    }

    方法 取响应头 <公开 静态 类型 = 逻辑型 注释 = "获取HTTP服务器返回的指定响应头信息." 注释 = "本方法返回文本型信息,API内部已经做了编码转换." 返回值注释 = "返回是否成功."
            折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄,且使用过\"接收响应\".">
    参数 响应头 <类型 = 文本型 注释 = "执行成功时在此参数返回获取的响应头.">
    参数 标头类型 <类型 = 协议头标志_WinHTTP 注释 = "指定所欲获取的响应头,默认为以换行符分隔的全部响应头." @默认值 = 协议头标志_WinHTTP.所有标头_换行>
    参数 标头名称 <类型 = 文本型 注释 = "  \"标头类型\"为\"协议头标志_WinHTTP.自定义\"时可用." 注释 = "  提供所欲获取信息的标头名称,不区分大小写,只要"
            注释 = "含有完整的名称即可获取." 注释 = "  如\"Content-Type\"和\"content-type: \"都能成功获取." @默认值 = 空对象>
    参数 标头索引 <类型 = 整数类 注释 = "  此参数用于枚举拥有相同名称的多个标头,首索引为0." 注释 = "  执行成功后会在本参数返回下一个标头的索引."
            注释 = "  如果下一个标头不存在,则返回-1." 注释 = "  留空则只取找到的第一个标头,获取所有标头时忽略." @默认值 = 空对象>
    {
        @ @<响应头>.Empty();
        @ DWORD dwSize = 0, dwIndex = (DWORD)@<标头索引.值>;
        @ WinHttpQueryHeaders((HINTERNET)@<请求句柄>, (DWORD)@<标头类型>,
        @                     ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? @<标头名称>.GetText() : WINHTTP_HEADER_NAME_BY_INDEX,
        @                     WINHTTP_NO_OUTPUT_BUFFER, &dwSize, &dwIndex);
        @ if (dwSize == 0) {
        @     if (dwIndex > 0 && GetLastError() == ERROR_WINHTTP_HEADER_NOT_FOUND) { @<标头索引.值> = -1; }
        @     return FALSE; }
        @ LPVOID Buffer = malloc(dwSize);
        @ BOOL bRes;
        @ bRes = WinHttpQueryHeaders((HINTERNET)@<请求句柄>, (DWORD)@<标头类型>,
        @                            ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? @<标头名称>.GetText() : WINHTTP_HEADER_NAME_BY_INDEX,
        @                             Buffer, &dwSize, &dwIndex);
        @ if (bRes) {
        @     @<标头索引.值> = (INT)dwIndex;
        @     @<响应头>.SetText((const WCHAR*)Buffer);
        @ }
        @ free (Buffer);
        @ return bRes;
    }

    方法 取响应头_字节集 <公开 静态 类型 = 逻辑型 注释 = "获取HTTP服务器返回的指定响应头信息." 注释 = "本方法返回原始编码的字节集,如需转换到文本型请注意文本编码."
            返回值注释 = "返回是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄,且使用过\"接收响应\".">
    参数 响应头 <类型 = 字节集类 注释 = "执行成功时在此参数返回获取的响应头.">
    参数 标头类型 <类型 = 协议头标志_WinHTTP 注释 = "指定所欲获取的响应头,默认为以换行符分隔的全部响应头." @默认值 = 协议头标志_WinHTTP.所有标头_换行>
    参数 标头名称 <类型 = 文本型 注释 = "  \"标头类型\"为\"协议头标志_WinHTTP.自定义\"时可用." 注释 = "  提供所欲获取信息的标头名称,不区分大小写,只要"
            注释 = "含有完整的名称即可获取." 注释 = "  如\"Content-Type\"和\"content-type: \"都能成功获取." @默认值 = 空对象>
    参数 标头索引 <类型 = 整数类 注释 = "  此参数用于枚举拥有相同名称的多个标头,首索引为0." 注释 = "  执行成功后会在本参数返回下一个标头的索引."
            注释 = "  如果下一个标头不存在,则返回-1." 注释 = "  留空则只取找到的第一个标头,获取所有标头时忽略." @默认值 = 空对象>
    {
        @ @<响应头>.Empty();
        @ DWORD dwSize = 0, dwIndex = (DWORD)@<标头索引.值>;
        @ WinHttpQueryHeaders((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_WIRE_ENCODING,
        @                     ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? @<标头名称>.GetText() : WINHTTP_HEADER_NAME_BY_INDEX,
        @                     WINHTTP_NO_OUTPUT_BUFFER, &dwSize, &dwIndex);
        @ if (dwSize == 0) {
        @     if (dwIndex > 0 && GetLastError() == ERROR_WINHTTP_HEADER_NOT_FOUND) { @<标头索引.值> = -1; }
        @     return FALSE; }
        @ @<响应头>.Alloc(dwSize, TRUE);
        @ BOOL bRes;
        @ bRes = WinHttpQueryHeaders((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_WIRE_ENCODING,
        @                            ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? @<标头名称>.GetText() : WINHTTP_HEADER_NAME_BY_INDEX,
        @                            (LPVOID)@<响应头>.GetPtr(), &dwSize, &dwIndex);
        @ if (bRes) { @<标头索引.值> = (INT)dwIndex; }
        @ return bRes;
    }

    方法 取响应头_时间戳 <公开 静态 类型 = 整数 注释 = "以时间戳的方式获取HTTP服务器返回的时间类响应头信息." 返回值注释 = "成功返回10位时间戳,失败返回0." 折叠
            @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄,且使用过\"接收响应\".">
    参数 标头类型 <类型 = 协议头标志_WinHTTP 注释 = "指定所欲获取的响应头,只支持内容值为日期和时间类型的标头." @默认值 = 协议头标志_WinHTTP.日期>
    参数 标头名称 <类型 = 文本型 注释 = "  \"标头类型\"为\"协议头标志_WinHTTP.自定义\"时可用." 注释 = "  提供所欲获取信息的标头名称,不区分大小写,只要"
            注释 = "含有完整的名称即可获取." 注释 = "  如\"Content-Type\"和\"content-type: \"都能成功获取." @默认值 = 空对象>
    参数 标头索引 <类型 = 整数类 注释 = "  此参数用于枚举拥有相同名称的多个标头,首索引为0." 注释 = "  执行成功后会在本参数返回下一个标头的索引."
            注释 = "  如果下一个标头不存在,则返回-1." 注释 = "  留空则只取找到的第一个标头." @默认值 = 空对象>
    {
        @ SYSTEMTIME st;
        @ DWORD dwSize = sizeof(SYSTEMTIME), dwIndex = (DWORD)@<标头索引.值>;
        @ if (WinHttpQueryHeaders((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_SYSTEMTIME,
        @                         ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? @<标头名称>.GetText() : WINHTTP_HEADER_NAME_BY_INDEX,
        @                         &st, &dwSize, &dwIndex)) {
        @     @<标头索引.值> = (INT)dwIndex;
        @     TIME_ZONE_INFORMATION tz { };
        @     GetTimeZoneInformation(&tz);
        @     struct tm timeinfo { st.wSecond, st.wMinute, st.wHour, st.wDay, st.wMonth - 1, st.wYear - 1900, st.wDayOfWeek, 0, 0 };
        @     return (INT)mktime(&timeinfo) - tz.Bias * 60;
        @ }
        @ if (dwIndex > 0 && GetLastError() == ERROR_WINHTTP_HEADER_NOT_FOUND) { @<标头索引.值> = -1; }
        @ return 0;
    }

    方法 取响应头_整数 <公开 静态 类型 = 整数 注释 = "以整数的方式获取HTTP服务器返回的数值类型的响应头信息." 返回值注释 = "成功返回整数值,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄,且使用过\"接收响应\".">
    参数 标头类型 <类型 = 协议头标志_WinHTTP 注释 = "指定所欲获取的响应头,只支持内容值为数值类型的标头." @默认值 = 协议头标志_WinHTTP.内容长度>
    参数 标头名称 <类型 = 文本型 注释 = "  \"标头类型\"为\"协议头标志_WinHTTP.自定义\"时可用." 注释 = "  提供所欲获取信息的标头名称,不区分大小写,只要"
            注释 = "含有完整的名称即可获取." 注释 = "  如\"Content-Type\"和\"content-type: \"都能成功获取." @默认值 = 空对象>
    参数 标头索引 <类型 = 整数类 注释 = "  此参数用于枚举拥有相同名称的多个标头,首索引为0." 注释 = "  执行成功后会在本参数返回下一个标头的索引."
            注释 = "  如果下一个标头不存在,则返回-1." 注释 = "  留空则只取找到的第一个标头." @默认值 = 空对象>
    {
        @ INT nRes = 0;
        @ DWORD dwSize = 4, dwIndex = (DWORD)@<标头索引.值>;
        @ if (WinHttpQueryHeaders((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_NUMBER,
        @                         ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? @<标头名称>.GetText() : WINHTTP_HEADER_NAME_BY_INDEX,
        @                         &nRes, &dwSize, &dwIndex)) {
        @     @<标头索引.值> = (INT)dwIndex;
        @     return nRes;
        @ }
        @ if (dwIndex > 0 && GetLastError() == ERROR_WINHTTP_HEADER_NOT_FOUND) { @<标头索引.值> = -1; }
        @ return 0;
    }

    方法 取响应头_长整数 <公开 静态 类型 = 长整数 注释 = "以长整数的方式获取HTTP服务器返回的数值类型的响应头信息." 返回值注释 = "成功返回整数值,失败返回0." 折叠
            @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄,且使用过\"接收响应\".">
    参数 标头类型 <类型 = 协议头标志_WinHTTP 注释 = "指定所欲获取的响应头,只支持内容值为数值类型的标头." @默认值 = 协议头标志_WinHTTP.内容长度>
    参数 标头名称 <类型 = 文本型 注释 = "  \"标头类型\"为\"协议头标志_WinHTTP.自定义\"时可用." 注释 = "  提供所欲获取信息的标头名称,不区分大小写,只要"
            注释 = "含有完整的名称即可获取." 注释 = "  如\"Content-Type\"和\"content-type: \"都能成功获取." @默认值 = 空对象>
    参数 标头索引 <类型 = 整数类 注释 = "  此参数用于枚举拥有相同名称的多个标头,首索引为0." 注释 = "  执行成功后会在本参数返回下一个标头的索引."
            注释 = "  如果下一个标头不存在,则返回-1." 注释 = "  留空则只取找到的第一个标头." @默认值 = 空对象>
    {
        @ INT64 nRes = 0;
        @ DWORD dwSize = 8, dwIndex = (DWORD)@<标头索引.值>;
        @ if (WinHttpQueryHeaders((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_NUMBER64,
        @                         ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? @<标头名称>.GetText() : WINHTTP_HEADER_NAME_BY_INDEX,
        @                         &nRes, &dwSize, &dwIndex)) {
        @     @<标头索引.值> = (INT)dwIndex;
        @     return nRes;
        @ }
        @ if (dwIndex > 0 && GetLastError() == ERROR_WINHTTP_HEADER_NOT_FOUND) { @<标头索引.值> = -1; }
        @ return 0;
    }

    方法 取请求头 <公开 静态 类型 = 逻辑型 注释 = "获取发送到HTTP服务器的指定请求头信息,可以在\"发送请求\"前获取." 注释 = "本方法返回文本型信息,API内部已经做了编码转换."
            返回值注释 = "返回是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 请求头 <类型 = 文本型 注释 = "执行成功时在此参数返回获取的请求头.">
    参数 标头类型 <类型 = 协议头标志_WinHTTP 注释 = "指定所欲获取的请求头,默认为以换行符分隔的全部请求头." @默认值 = 协议头标志_WinHTTP.所有标头_换行>
    参数 标头名称 <类型 = 文本型 注释 = "  \"标头类型\"为\"协议头标志_WinHTTP.自定义\"时可用." 注释 = "  提供所欲获取信息的标头名称,不区分大小写,只要"
            注释 = "含有完整的名称即可获取." 注释 = "  如\"Content-Type\"和\"content-type: \"都能成功获取." @默认值 = 空对象>
    参数 标头索引 <类型 = 整数类 注释 = "  此参数用于枚举拥有相同名称的多个标头,首索引为0." 注释 = "  执行成功后会在本参数返回下一个标头的索引."
            注释 = "  如果下一个标头不存在,则返回-1." 注释 = "  留空则只取找到的第一个标头,获取所有标头时忽略." @默认值 = 空对象>
    {
        @ @<请求头>.Empty();
        @ DWORD dwSize = 0, dwIndex = (DWORD)@<标头索引.值>;
        @ WinHttpQueryHeaders((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_REQUEST_HEADERS,
        @                     ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? @<标头名称>.GetText() : WINHTTP_HEADER_NAME_BY_INDEX,
        @                     WINHTTP_NO_OUTPUT_BUFFER, &dwSize, &dwIndex);
        @ if (dwSize == 0) {
        @     if (dwIndex > 0 && GetLastError() == ERROR_WINHTTP_HEADER_NOT_FOUND) { @<标头索引.值> = -1; }
        @     return FALSE;
        @ }
        @ LPVOID Buffer = malloc(dwSize);
        @ BOOL bRes = WinHttpQueryHeaders((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_REQUEST_HEADERS,
        @                                 ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? @<标头名称>.GetText() : WINHTTP_HEADER_NAME_BY_INDEX,
        @                                 Buffer, &dwSize, &dwIndex);
        @ if (bRes) {
        @     @<标头索引.值> = (INT)dwIndex;
        @     @<请求头>.SetText((const WCHAR*)Buffer);
        @ }
        @ free(Buffer);
        @ return bRes;
    }

    方法 取请求头_字节集 <公开 静态 类型 = 逻辑型 注释 = "获取发送到HTTP服务器的指定请求头信息,可以在\"发送请求\"前获取."
            注释 = "本方法返回原始编码的字节集,如需转换到文本型请注意文本编码." 返回值注释 = "返回是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 请求头 <类型 = 字节集类 注释 = "执行成功时在此参数返回获取的请求头.">
    参数 标头类型 <类型 = 协议头标志_WinHTTP 注释 = "指定所欲获取的请求头,默认为以换行符分隔的全部请求头." @默认值 = 协议头标志_WinHTTP.所有标头_换行>
    参数 标头名称 <类型 = 文本型 注释 = "  \"标头类型\"为\"协议头标志_WinHTTP.自定义\"时可用." 注释 = "  提供所欲获取信息的标头名称,不区分大小写,只要"
            注释 = "含有完整的名称即可获取." 注释 = "  如\"Content-Type\"和\"content-type: \"都能成功获取." @默认值 = 空对象>
    参数 标头索引 <类型 = 整数类 注释 = "  此参数用于枚举拥有相同名称的多个标头,首索引为0." 注释 = "  执行成功后会在本参数返回下一个标头的索引."
            注释 = "  如果下一个标头不存在,则返回-1." 注释 = "  留空则只取找到的第一个标头,获取所有标头时忽略." @默认值 = 空对象>
    {
        @ @<请求头>.Empty();
        @ DWORD dwSize = 0, dwIndex = (DWORD)@<标头索引.值>;
        @ WinHttpQueryHeaders((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_REQUEST_HEADERS | WINHTTP_QUERY_FLAG_WIRE_ENCODING,
        @                     ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? @<标头名称>.GetText() : WINHTTP_HEADER_NAME_BY_INDEX,
        @                     WINHTTP_NO_OUTPUT_BUFFER, &dwSize, &dwIndex);
        @ if (dwSize == 0) {
        @     if (dwIndex > 0 && GetLastError() == ERROR_WINHTTP_HEADER_NOT_FOUND) { @<标头索引.值> = -1; }
        @     return FALSE;
        @ }
        @ @<请求头>.Alloc (dwSize, TRUE);
        @ BOOL bRes = WinHttpQueryHeaders((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_REQUEST_HEADERS | WINHTTP_QUERY_FLAG_WIRE_ENCODING,
        @                                 ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? @<标头名称>.GetText() : WINHTTP_HEADER_NAME_BY_INDEX,
        @                                 (LPVOID)@<请求头>.GetPtr(), &dwSize, &dwIndex);
        @ if (bRes) { @<标头索引.值> = (INT)dwIndex; }
        @ return bRes;
    }

    方法 取请求头_时间戳 <公开 静态 类型 = 整数 注释 = "以时间戳的方式获取发送到HTTP服务器的指定请求头信息." 返回值注释 = "成功返回10位时间戳,失败返回0." 折叠
            @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 标头类型 <类型 = 协议头标志_WinHTTP 注释 = "指定所欲获取的请求头,只支持内容值为日期和时间类型的标头." @默认值 = 协议头标志_WinHTTP.日期>
    参数 标头名称 <类型 = 文本型 注释 = "  \"标头类型\"为\"协议头标志_WinHTTP.自定义\"时可用." 注释 = "  提供所欲获取信息的标头名称,不区分大小写,只要"
            注释 = "含有完整的名称即可获取." 注释 = "  如\"Content-Type\"和\"content-type: \"都能成功获取." @默认值 = 空对象>
    参数 标头索引 <类型 = 整数类 注释 = "  此参数用于枚举拥有相同名称的多个标头,首索引为0." 注释 = "  执行成功后会在本参数返回下一个标头的索引."
            注释 = "  如果下一个标头不存在,则返回-1." 注释 = "  留空则只取找到的第一个标头." @默认值 = 空对象>
    {
        @ SYSTEMTIME st;
        @ DWORD dwSize = sizeof(SYSTEMTIME), dwIndex = (DWORD)@<标头索引.值>;
        @ if (WinHttpQueryHeaders((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_REQUEST_HEADERS | WINHTTP_QUERY_FLAG_SYSTEMTIME,
        @                         ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? @<标头名称>.GetText() : WINHTTP_HEADER_NAME_BY_INDEX,
        @                         &st, &dwSize, &dwIndex)) {
        @     @<标头索引.值> = (INT)dwIndex;
        @     TIME_ZONE_INFORMATION tz { };
        @     GetTimeZoneInformation(&tz);
        @     struct tm timeinfo { st.wSecond, st.wMinute, st.wHour, st.wDay, st.wMonth - 1, st.wYear - 1900, st.wDayOfWeek, 0, 0 };
        @     return (INT)mktime(&timeinfo) - tz.Bias * 60;
        @ }
        @ if (dwIndex > 0 && GetLastError() == ERROR_WINHTTP_HEADER_NOT_FOUND) { @<标头索引.值> = -1; }
        @ return 0;
    }

    方法 取请求头_整数 <公开 静态 类型 = 整数 注释 = "以整数的方式获取发送到HTTP服务器的指定请求头信息." 返回值注释 = "成功返回整数值,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 标头类型 <类型 = 协议头标志_WinHTTP 注释 = "指定所欲获取的请求头,只支持内容值为数值类型的标头." @默认值 = 协议头标志_WinHTTP.内容长度>
    参数 标头名称 <类型 = 文本型 注释 = "  \"标头类型\"为\"协议头标志_WinHTTP.自定义\"时可用." 注释 = "  提供所欲获取信息的标头名称,不区分大小写,只要"
            注释 = "含有完整的名称即可获取." 注释 = "  如\"Content-Type\"和\"content-type: \"都能成功获取." @默认值 = 空对象>
    参数 标头索引 <类型 = 整数类 注释 = "  此参数用于枚举拥有相同名称的多个标头,首索引为0." 注释 = "  执行成功后会在本参数返回下一个标头的索引."
            注释 = "  如果下一个标头不存在,则返回-1." 注释 = "  留空则只取找到的第一个标头." @默认值 = 空对象>
    {
        @ INT nRes = 0;
        @ DWORD dwSize = 4, dwIndex = (DWORD)@<标头索引.值>;
        @ if (WinHttpQueryHeaders((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_REQUEST_HEADERS | WINHTTP_QUERY_FLAG_NUMBER,
        @                         ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? @<标头名称>.GetText() : WINHTTP_HEADER_NAME_BY_INDEX,
        @                         &nRes, &dwSize, &dwIndex)) {
        @     @<标头索引.值> = (INT)dwIndex;
        @     return nRes;
        @ }
        @ if (dwIndex > 0 && GetLastError() == ERROR_WINHTTP_HEADER_NOT_FOUND) { @<标头索引.值> = -1; }
        @ return 0;
    }

    方法 取请求头_长整数 <公开 静态 类型 = 长整数 注释 = "以长整数的方式获取发送到HTTP服务器的指定请求头信息." 返回值注释 = "成功返回整数值,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 标头类型 <类型 = 协议头标志_WinHTTP 注释 = "指定所欲获取的请求头,只支持内容值为数值类型的标头." @默认值 = 协议头标志_WinHTTP.内容长度>
    参数 标头名称 <类型 = 文本型 注释 = "  \"标头类型\"为\"协议头标志_WinHTTP.自定义\"时可用." 注释 = "  提供所欲获取信息的标头名称,不区分大小写,只要"
            注释 = "含有完整的名称即可获取." 注释 = "  如\"Content-Type\"和\"content-type: \"都能成功获取." @默认值 = 空对象>
    参数 标头索引 <类型 = 整数类 注释 = "  此参数用于枚举拥有相同名称的多个标头,首索引为0." 注释 = "  执行成功后会在本参数返回下一个标头的索引."
            注释 = "  如果下一个标头不存在,则返回-1." 注释 = "  留空则只取找到的第一个标头." @默认值 = 空对象>
    {
        @ INT64 nRes = 0;
        @ DWORD dwSize = 8, dwIndex = (DWORD)@<标头索引.值>;
        @ if (WinHttpQueryHeaders((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_REQUEST_HEADERS | WINHTTP_QUERY_FLAG_NUMBER64,
        @                         ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? @<标头名称>.GetText() : WINHTTP_HEADER_NAME_BY_INDEX,
        @                         &nRes, &dwSize, WINHTTP_NO_HEADER_INDEX)) {
        @     @<标头索引.值> = (INT)dwIndex;
        @     return nRes;
        @ }
        @ if (dwIndex > 0 && GetLastError() == ERROR_WINHTTP_HEADER_NOT_FOUND) { @<标头索引.值> = -1; }
        @ return 0;
    }

    # 取标头还有尾端(WINHTTP_QUERY_FLAG_TRAILERS)未实现

    方法 取响应头EX <公开 静态 类型 = 整数 注释 = "获取HTTP服务器返回的指定响应头键值对."
            注释 = "本方法此为Windows 10 Version 21H2新增的API,之前的系统不可用." 返回值注释 = "成功返回0,失败返回错误代码." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 响应头键值对 <类型 = 文本到文本哈希表 注释 = "执行成功时在此参数返回获取的响应头键值对.">
    参数 标头类型 <类型 = 协议头标志_WinHTTP 注释 = "  指定所欲获取的响应头,默认为全部响应头." 注释 = "  本API不支持部分标志(看备注)."
            @默认值 = 协议头标志_WinHTTP.所有标头>
    参数 标头名称 <类型 = 文本型 注释 = "  \"标头类型\"为\"协议头标志_WinHTTP.自定义\"时可用." 注释 = "  提供所欲获取信息的标头名称,不区分大小写,只要"
            注释 = "含有完整的名称即可获取." 注释 = "  如\"Content-Type\"和\"content-type: \"都能成功获取." @默认值 = 空对象>
    参数 标头索引 <类型 = 整数类 注释 = "  此参数用于枚举拥有相同名称的多个标头,首索引为0." 注释 = "  执行成功后会在本参数返回下一个标头的索引."
            注释 = "  如果下一个标头不存在,则返回-1." 注释 = "  留空则只取找到的第一个标头." @默认值 = 空对象>
    参数 代码页 <类型 = 整数 注释 = "用于Unicode转换的编码页,0为系统的默认编码CP_ACP." @默认值 = 0>
    {
        @ @<响应头键值对>.m_map.clear();
        @ DWORD dwSize = 0, dwHeadersCount = 0, dwIndex = (DWORD)@<标头索引.值>;
        @ PWINHTTP_EXTENDED_HEADER pHeaders = NULL;
        @ WINHTTP_HEADER_NAME headrName { };
        @ if ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) { headrName.pwszName = (PCWSTR)@<标头名称>.GetText(); }
        @ DWORD dwRes = WinHttpQueryHeadersEx((HINTERNET)@<请求句柄>, (DWORD)@<标头类型>, 0, (UINT)@<代码页>, &dwIndex,
        @                                     ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? &headrName : NULL, NULL,
        @                                     &dwSize, &pHeaders, &dwHeadersCount);
        @ if (dwSize == 0) {
        @     if (dwRes == ERROR_WINHTTP_HEADER_NOT_FOUND) { @<标头索引.值> = -1; }
        @     return dwRes;
        @ }
        @ PVOID Buffer = malloc (dwSize);
        @ dwRes = WinHttpQueryHeadersEx((HINTERNET)@<请求句柄>, (DWORD)@<标头类型>, 0, (UINT)@<代码页>, &dwIndex,
        @                               ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? &headrName : NULL, Buffer,
        @                               &dwSize, &pHeaders, &dwHeadersCount);
        @ if (dwRes == 0) {
        @     @<标头索引.值> = (INT)dwIndex;
        @     for (DWORD i = 0; i < dwHeadersCount; i++) {
        @         @<响应头键值对>.m_map[@an<CVolString>(pHeaders[i].pwszName)] = @an<CVolString>(pHeaders[i].pwszValue);
        @     }
        @ }
        @ free(Buffer);
        @ return dwRes;
    }

    方法 取响应头EX_字节集 <公开 静态 类型 = 整数 注释 = "获取HTTP服务器返回的指定响应头键值对." 注释 = "本方法返回原始编码的字节集属性值,但标头名称仍会转换成文本型."
            注释 = "本方法此为Windows 10 Version 21H2新增的API,之前的系统不可用." 返回值注释 = "成功返回0,失败返回错误代码." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 响应头键值对 <类型 = 协议头键值对类 注释 = "执行成功时在此参数返回获取的响应头键值对,为文本到字节集哈希表.">
    参数 标头类型 <类型 = 协议头标志_WinHTTP 注释 = "  指定所欲获取的响应头,默认为全部响应头." 注释 = "  本API不支持部分标志(看备注)."
            @默认值 = 协议头标志_WinHTTP.所有标头>
    参数 标头名称 <类型 = 文本型 注释 = "  \"标头类型\"为\"协议头标志_WinHTTP.自定义\"时可用." 注释 = "  提供所欲获取信息的标头名称,不区分大小写,只要"
            注释 = "含有完整的名称即可获取." 注释 = "  如\"Content-Type\"和\"content-type: \"都能成功获取." @默认值 = 空对象>
    参数 标头索引 <类型 = 整数类 注释 = "  此参数用于枚举拥有相同名称的多个标头,首索引为0." 注释 = "  执行成功后会在本参数返回下一个标头的索引."
            注释 = "  如果下一个标头不存在,则返回-1." 注释 = "  留空则只取找到的第一个标头." @默认值 = 空对象>
    {
        @ @<响应头键值对>.clear();
        @ DWORD dwSize = 0, dwHeadersCount = 0, dwIndex = (DWORD)@<标头索引.值>;
        @ PWINHTTP_EXTENDED_HEADER pHeaders = NULL;
        @ WINHTTP_HEADER_NAME headrName { };
        @ @an<CVolMem> memCustm;
        @ if ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) { headrName.pszName = (PCSTR)GetMbsText(@<标头名称>.GetText(), memCustm, NULL); }
        @ DWORD dwRes = WinHttpQueryHeadersEx((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_WIRE_ENCODING,
        @                                     0, 0, &dwIndex,
        @                                     ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? &headrName : NULL, NULL, &dwSize,
        @                                     &pHeaders, &dwHeadersCount);
        @ if (dwSize == 0) {
        @     if (dwRes == ERROR_WINHTTP_HEADER_NOT_FOUND) { @<标头索引.值> = -1; }
        @     return dwRes;
        @ }
        @ PVOID Buffer = malloc(dwSize);
        @ dwRes = WinHttpQueryHeadersEx((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_WIRE_ENCODING,
        @                               0, 0, &dwIndex,
        @                               ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? &headrName : NULL, Buffer, &dwSize,
        @                               &pHeaders, &dwHeadersCount);
        @ if (dwRes == 0) {
        @     @<标头索引.值> = (INT)dwIndex;
        @     @an<CVolMem> strbuf;
        @     for (DWORD i = 0; i < dwHeadersCount; i++) {
        @         @<响应头键值对>[@an<CVolString>(GetWideText(pHeaders[i].pszName, strbuf, NULL))] = @an<CVolMem>(pHeaders[i].pszValue, strlen(pHeaders[i].pszValue));
        @     }
        @ }
        @ free (Buffer);
        @ return dwRes;
    }

    方法 取请求头EX <公开 静态 类型 = 整数 注释 = "获取发送到HTTP服务器的指定请求头键值对,可以在\"发送请求\"前获取."
            注释 = "本方法此为Windows 10 Version 21H2新增的API,之前的系统不可用." 返回值注释 = "成功返回0,失败返回错误代码." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 请求头键值对 <类型 = 文本到文本哈希表 注释 = "执行成功时在此参数返回获取的请求头键值对.">
    参数 标头类型 <类型 = 协议头标志_WinHTTP 注释 = "  指定所欲获取的请求头,默认为全部请求头." 注释 = "  本API不支持部分标志(看备注)."
            @默认值 = 协议头标志_WinHTTP.所有标头>
    参数 标头名称 <类型 = 文本型 注释 = "  \"标头类型\"为\"协议头标志_WinHTTP.自定义\"时可用." 注释 = "  提供所欲获取信息的标头名称,不区分大小写,只要"
            注释 = "含有完整的名称即可获取." 注释 = "  如\"Content-Type\"和\"content-type: \"都能成功获取." @默认值 = 空对象>
    参数 标头索引 <类型 = 整数类 注释 = "  此参数用于枚举拥有相同名称的多个标头,首索引为0." 注释 = "  执行成功后会在本参数返回下一个标头的索引."
            注释 = "  如果下一个标头不存在,则返回-1." 注释 = "  留空则只取找到的第一个标头." @默认值 = 空对象>
    参数 代码页 <类型 = 整数 注释 = "用于Unicode转换的编码页,0为系统的默认编码CP_ACP." @默认值 = 0>
    {
        @ @<请求头键值对>.m_map.clear();
        @ DWORD dwSize = 0, dwHeadersCount = 0, dwIndex = (DWORD)@<标头索引.值>;
        @ PWINHTTP_EXTENDED_HEADER pHeaders = NULL;
        @ WINHTTP_HEADER_NAME headrName { };
        @ if ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) { headrName.pwszName = (PCWSTR)@<标头名称>.GetText(); }
        @ DWORD dwRes = WinHttpQueryHeadersEx((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_REQUEST_HEADERS,
        @                                     0, (UINT)@<代码页>, &dwIndex,
        @                                     ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? &headrName : NULL, NULL, &dwSize,
        @                                     &pHeaders, &dwHeadersCount);
        @ if (dwSize == 0) {
        @     if (dwRes == ERROR_WINHTTP_HEADER_NOT_FOUND) { @<标头索引.值> = -1; }
        @     return dwRes;
        @ }
        @ PVOID Buffer = malloc(dwSize);
        @ dwRes = WinHttpQueryHeadersEx((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_REQUEST_HEADERS,
        @                               0, (UINT)@<代码页>, &dwIndex,
        @                               ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? &headrName : NULL, Buffer, &dwSize,
        @                               &pHeaders, &dwHeadersCount);
        @ if (dwRes == 0) {
        @     @<标头索引.值> = (INT)dwIndex;
        @     for (DWORD i = 0; i < dwHeadersCount; i++) {
        @         @<请求头键值对>.m_map[@an<CVolString>(pHeaders[i].pwszName)] = @an<CVolString>(pHeaders[i].pwszValue);
        @     }
        @ }
        @ free(Buffer);
        @ return dwRes;
    }

    方法 取请求头EX_字节集 <公开 静态 类型 = 整数 注释 = "获取发送到HTTP服务器的指定请求头键值对,可以在\"发送请求\"前获取."
            注释 = "本方法返回原始编码的字节集属性值,但标头名称仍会转换成文本型." 注释 = "本方法此为Windows 10 Version 21H2新增的API,之前的系统不可用."
            返回值注释 = "成功返回0,失败返回错误代码." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 请求头键值对 <类型 = 协议头键值对类 注释 = "执行成功时在此参数返回获取的请求头键值对,为文本到字节集哈希表.">
    参数 标头类型 <类型 = 协议头标志_WinHTTP 注释 = "  指定所欲获取的请求头,默认为全部请求头." 注释 = "  本API不支持部分标志(看备注)."
            @默认值 = 协议头标志_WinHTTP.所有标头>
    参数 标头名称 <类型 = 文本型 注释 = "  \"标头类型\"为\"协议头标志_WinHTTP.自定义\"时可用." 注释 = "  提供所欲获取信息的标头名称,不区分大小写,只要"
            注释 = "含有完整的名称即可获取." 注释 = "  如\"Content-Type\"和\"content-type: \"都能成功获取." @默认值 = 空对象>
    参数 标头索引 <类型 = 整数类 注释 = "  此参数用于枚举拥有相同名称的多个标头,首索引为0." 注释 = "  执行成功后会在本参数返回下一个标头的索引."
            注释 = "  如果下一个标头不存在,则返回-1." 注释 = "  留空则只取找到的第一个标头." @默认值 = 空对象>
    {
        @ @<请求头键值对>.clear();
        @ DWORD dwSize = 0, dwHeadersCount = 0, dwIndex = (DWORD)@<标头索引.值>;
        @ PWINHTTP_EXTENDED_HEADER pHeaders = NULL;
        @ WINHTTP_HEADER_NAME headrName { };
        @ @an<CVolMem> memCustm;
        @ if ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) { headrName.pszName = (PCSTR)GetMbsText(@<标头名称>.GetText(), memCustm, NULL); }
        @ DWORD dwRes = WinHttpQueryHeadersEx((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_WIRE_ENCODING,
        @                                     0, 0, &dwIndex,
        @                                     ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? &headrName : NULL, NULL, &dwSize,
        @                                     &pHeaders, &dwHeadersCount);
        @ if (dwSize == 0) {
        @     if (dwRes == ERROR_WINHTTP_HEADER_NOT_FOUND) { @<标头索引.值> = -1; }
        @     return dwRes;
        @ }
        @ PVOID Buffer = malloc (dwSize);
        @ dwRes = WinHttpQueryHeadersEx((HINTERNET)@<请求句柄>, (DWORD)@<标头类型> | WINHTTP_QUERY_FLAG_WIRE_ENCODING,
        @                               0, 0, &dwIndex,
        @                               ((DWORD)@<标头类型> == WINHTTP_QUERY_CUSTOM) ? &headrName : NULL, Buffer, &dwSize,
        @                               &pHeaders, &dwHeadersCount);
        @ if (dwRes == 0) {
        @     @<标头索引.值> = (INT)dwIndex;
        @     @an<CVolMem> strbuf;
        @     for (DWORD i = 0; i < dwHeadersCount; i++) {
        @         @<请求头键值对>[@an<CVolString>(GetWideText(pHeaders[i].pszName, strbuf, NULL))] = @an<CVolMem>(pHeaders[i].pszValue, strlen(pHeaders[i].pszValue));
        @     }
        @ }
        @ free(Buffer);
        @ return dwRes;
    }

    # 状态回调 ===

    方法 置状态回调 <公开 静态 类型 = 变整数 注释 = "设置一个回调函数,WinHTTP可以在操作过程中取得进展时调用该函数."
            返回值注释 = "失败返回-1,成功返回上一次设置的回调指针,如果之前没设置过回调则返回0." 折叠 @嵌入式方法 = "">
    参数 网络句柄 <类型 = 变整数 注释 = "所欲设置回调的网络句柄,可以为会话句柄、连接句柄与请求句柄.">
    参数 回调方法 <注释 = "所欲执行的静态回调方法" @匹配方法 = "状态回调模板">
    参数 通知标志 <类型 = 回调标志_WinHTTP 注释 = "注意: 函数不检查此参数,只要提供的网络句柄和回调方法正确,就能返回成功."
            注释 = "但如果提供的通知标志不正确,将无法触发对应的回调.">
    {
        @ (INT_P)WinHttpSetStatusCallback((HINTERNET)@<网络句柄>, (WINHTTP_STATUS_CALLBACK)&@<回调方法>, (DWORD)@<通知标志>, NULL)
    }

    方法 状态回调模板 <公开 静态 注释 = "\"置状态回调\"中回调方法的模板,请勿直接使用." 折叠>
    参数 网络句柄 <类型 = 变整数 注释 = "与状态回调关联的网络句柄.">
    参数 上下文值 <类型 = 变整数 注释 = "  与网络句柄关联的的上下文值,可以通过\"置选项_上下文值\"或\"发送请求\"设置," 注释 = "可用于传递用户自定义的数据.">
    参数 网络状态 <类型 = 回调状态标志_WinHTTP 注释 = "请参考\"回调状态标志_WinHTTP\"中的常量.">
    参数 状态信息指针 <类型 = 变整数 注释 = "指向缓冲区的指针,数据类型取决于参数\"网络状态\"的值.">
    参数 状态信息长度 <类型 = 整数 注释 = "如果状态信息为文本数据,则本参数为文本的字符数,为其他类型时则为字节数.">

    # 时间操作 ===

    方法 置超时时间 <公开 静态 类型 = 逻辑型 注释 = "设置各种网络连接的超时时间,操作超过指定的时间后将被取消,返回失败." 返回值注释 = "返回是否成功." 折叠 @嵌入式方法 = "">
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 解析超时 <类型 = 整数 注释 = "解析域名的超时时间(毫秒),0为无限等待." @默认值 = 10000>
    参数 连接超时 <类型 = 整数 注释 = "连接目标服务器的请求超时时间(毫秒),初始值为60秒." @默认值 = 600000>
    参数 发送超时 <类型 = 整数 注释 = "发送请求的超时时间(毫秒),初始值为30秒." @默认值 = 300000>
    参数 接收超时 <类型 = 整数 注释 = "接收服务器响应的超时时间(毫秒),初始值为30秒." @默认值 = 300000>
    {
        @ WinHttpSetTimeouts((HINTERNET)@<会话句柄>, @<解析超时>, @<连接超时>, @<发送超时>, @<接收超时>)
    }

    方法 取格林威治时间 <公开 静态 类型 = 文本型 注释 = "获取 HTTP version 1.0 规范的GTM时间文本."
            注释 = "例如: Thu, 16 Jun 2022 14:20:20 GMT" 返回值注释 = "成功返回GTM时间文本,失败返回空文本." 折叠 @禁止流程检查 = 真>
    参数 时间戳 <类型 = 整数 注释 = "-1为自动获取现行的GMT时间戳." @默认值 = -1>
    {
        @ SYSTEMTIME sTime;
        @ @an<CVolString> szTimeStr;
        @ szTimeStr.SetLength(WINHTTP_TIME_FORMAT_BUFSIZE / 2);
        @ if (@<时间戳> == -1) {
        @     GetSystemTime(&sTime);
        @ } else {
        @     struct tm timeinfo;
        @     time_t timestamp = (time_t)@<时间戳>;
        @     gmtime_s(&timeinfo, &timestamp);
        @     sTime.wYear = (WORD)(timeinfo.tm_year + 1900);
        @     sTime.wMonth = (WORD)(timeinfo.tm_mon + 1);
        @     sTime.wDayOfWeek = (WORD)timeinfo.tm_wday;
        @     sTime.wDay = (WORD)timeinfo.tm_mday;
        @     sTime.wHour = (WORD)timeinfo.tm_hour;
        @     sTime.wMinute = (WORD)timeinfo.tm_min;
        @     sTime.wSecond = (WORD)timeinfo.tm_sec;
        @     sTime.wMilliseconds = 0;
        @ }
        @ if (WinHttpTimeFromSystemTime(&sTime, (LPWSTR)szTimeStr.GetText()))
        @     return szTimeStr;
        @ return @an<CVolString>(L"");
    }

    方法 格林威治到时间戳 <公开 静态 类型 = 整数 注释 = "将 HTTP version 1.0 规范的GTM时间文本转换到10位的Unix时间戳."
            返回值注释 = "成功返回10位的秒时间戳,失败返回-1." 折叠 @禁止流程检查 = 真>
    参数 GMT时间 <类型 = 文本型 注释 = "必须是\"Thu, 16 Jun 2022 14:20:20 GMT\"这样的时间格式.">
    {
        @ SYSTEMTIME st;
        @ if (WinHttpTimeToSystemTime(@<GMT时间>.GetText(), &st)) {
        @     TIME_ZONE_INFORMATION tz { };
        @     GetTimeZoneInformation(&tz);
        @     struct tm timeinfo { st.wSecond, st.wMinute, st.wHour, st.wDay, st.wMonth - 1, st.wYear - 1900, st.wDayOfWeek, 0, 0 };
        @     return (INT)mktime(&timeinfo) - tz.Bias * 60;
        @ }
        @ return -1;
    }

    # URL操作 ===

    方法 拆分URL <公开 静态 类型 = 逻辑型 注释 = "将完整的URL网址拆分成下列的组件,本方法只能解析http和https协议的网址."
            注释 = "<scheme>://<user>:<password>@<host>:<port>/<path>?<query>#<fragment>" 返回值注释 = "返回是否成功" 折叠
            @禁止流程检查 = 真>
    参数 URL <类型 = 文本型 注释 = "所欲解析的规范网址,本函数不会检查URL的格式是否正确.">
    参数 URL组件 <类型 = URL组件信息类 注释 = "解析成功在此参数中返回URL各个组件的信息.">
    参数 URL操作 <类型 = 整数 注释 = "  请参考\"URL操作_WinHTTP\"中的常量和备注,部分常量可以用\"位或\"组合使用."
            注释 = "  可以对URL路径以后的部分进行URL编码和URL解码." 注释 = "  默认值0表示不进行任何特殊操作,速度最快." @默认值 = 0>
    参数 预分配字符 <类型 = 整数 注释 = "  \"URL操作\"为URL编码或URL解码时,本参数指定接收URL路径部分和提交参数"
            注释 = "部分的编解码结果的缓冲区长度.2048是IE浏览器最大允许的URL路径长度." 注释 = "  如果不进行URL编解码时将本参数设置为0,则表示不拆分URL路径和附加信息."
            @默认值 = 2048>
    {
        @ @<URL组件>.ResetObject();
        @ URL_COMPONENTS urlComp { };
        @ urlComp.dwStructSize      = sizeof (urlComp);
        @ urlComp.dwSchemeLength    = 10;
        @ urlComp.dwHostNameLength  = 256;
        @ urlComp.dwUrlPathLength   = (DWORD)@<预分配字符>;
        @ urlComp.dwExtraInfoLength = (DWORD)@<预分配字符>;
        @ if ((DWORD)@<URL操作> != ICU_REJECT_USERPWD) {
        @     urlComp.dwUserNameLength = 256; urlComp.dwPasswordLength = 256;
        @ }
        @ if ((DWORD)@<URL操作> == ICU_DECODE || (DWORD)@<URL操作> == ICU_ESCAPE) {
        @     urlComp.lpszScheme    = new WCHAR[10];
        @     urlComp.lpszHostName  = new WCHAR[256];
        @     urlComp.lpszUrlPath   = new WCHAR[urlComp.dwUrlPathLength];
        @     urlComp.lpszExtraInfo = new WCHAR[urlComp.dwExtraInfoLength];
        @     if ((DWORD)@<URL操作> != ICU_REJECT_USERPWD) {
        @         urlComp.lpszUserName = new WCHAR[256]; urlComp.lpszPassword = new WCHAR[256];
        @     }
        @ }
        @ BOOL bRes = WinHttpCrackUrl(@<URL>.GetText(), (DWORD)@<URL>.GetLength(), (DWORD)@<URL操作>, &urlComp);
        @ if (bRes) { @<URL组件>.SetInfo(&urlComp); }
        @ if ((DWORD)@<URL操作> == ICU_DECODE || (DWORD)@<URL操作> == ICU_ESCAPE) {
        @     delete urlComp.lpszScheme; delete urlComp.lpszHostName; delete urlComp.lpszUrlPath; delete urlComp.lpszExtraInfo;
        @     if ((DWORD)@<URL操作> != ICU_REJECT_USERPWD) { delete urlComp.lpszUserName; delete urlComp.lpszPassword; }
        @ }
        @ return bRes;
    }

    方法 创建URL <公开 静态 类型 = 文本型 注释 = "从URL的域名和路径等组件构造成一个完整的URL网址." 返回值注释 = "成功返回URL网址,失败返回空文本." 折叠 @禁止流程检查 = 真>
    参数 URL组件 <类型 = URL组件信息类 注释 = "所欲构造的URL组件,需要你提前填写好内容.">
    参数 URL操作 <类型 = 整数 注释 = "  请参考\"URL操作_WinHTTP\"中的常量和备注,部分常量可以用\"位或\"组合使用."
            注释 = "  可以对URL路径以后的部分进行URL编码(本方法不能进行URL解码)." 注释 = "  默认值0表示不进行任何特殊操作,速度最快." @默认值 = 0>
    参数 预分配字符 <类型 = 整数 注释 = "  目标URL网址的预分配字符长度,必须尽可能大于结果文本的长度." 注释 = "  2083字符是IE浏览器支持的最大的URL长度,其他浏览器可以更长."
            @默认值 = 2083>
    {
        @ URL_COMPONENTS urlComp;
        @ DWORD dwUrlLength = (DWORD)@<预分配字符>;
        @ @an<CVolString> szUrl;
        @ szUrl.SetLength(dwUrlLength);
        @ if (!WinHttpCreateUrl(@<URL组件>.GetInfo(&urlComp), (DWORD)@<URL操作>, (LPWSTR)szUrl.GetText(), &dwUrlLength))
        @     return @an<CVolString>(L"");
        @ return szUrl.Left(dwUrlLength);
    }

    # 代理 ===

    方法 检测自动代理配置URL <公开 静态 类型 = 逻辑型 注释 = "查找代理自动配置(PAC)文件的URL,此函数仅返回PAC文件的URL,而不会下载它." 返回值注释 = "返回是否成功." 折叠
            @禁止流程检查 = 真>
    参数 自动配置URL <类型 = 文本型 注释 = "成功返回自动代理配置URL,即使函数调用成功,仍可能返回空文本.">
    参数 自动检测选项 <类型 = 整数 注释 = "可使用下列三个数值对应的PAC文件检测类型:" 注释 = "  1 使用DHCP定位代理自动配置文件;"
            注释 = "  2 使用DNS尝试在本地计算机域上的已知位置定位代理自动配置文件;" 注释 = "  3 同时使用以上两种方式,优先使用DHCP,若DHCP未发现再用DNS;" @默认值 = 3>
    {
        @ LPWSTR szAutoConfigUrl;
        @ if (WinHttpDetectAutoProxyConfigUrl((DWORD)@<自动检测选项>, &szAutoConfigUrl)) {
        @     @<自动配置URL>.SetText(szAutoConfigUrl);
        @     GlobalFree(szAutoConfigUrl);
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 从URL获取代理 <公开 静态 类型 = 逻辑型 注释 = "从指定的URL中获取代理数据." 返回值注释 = "返回是否成功." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 URL <类型 = 文本型 注释 = "代理PAC文件的URL,本函数只支持ECMAScript格式的PAC文件.">
    参数 自动代理选项 <类型 = WinHTTP自动代理选项类 注释 = "指定所欲使用的自动代理选项">
    参数 代理信息 <类型 = WinHTTP代理信息类 注释 = "执行成功在此返回代理的各项信息.">
    {
        @ @<代理信息>.ResetObject();
        @ WINHTTP_PROXY_INFO ProxyInfo;
        @ if (WinHttpGetProxyForUrl((HINTERNET)@<会话句柄>, @<URL>.GetText(),
        @                           &@<自动代理选项>, &ProxyInfo)) {
        @     @<代理信息>.SetInfo(&ProxyInfo);
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 取默认代理配置 <公开 静态 类型 = 逻辑型 注释 = "从注册表中获取默认的WinHTTP代理配置." 返回值注释 = "返回是否成功." 折叠 @禁止流程检查 = 真>
    参数 代理配置 <类型 = WinHTTP代理信息类 注释 = "成功返回代理配置.">
    {
        @ @<代理配置>.ResetToNullObject();
        @ WINHTTP_PROXY_INFO proxyInfo;
        @ if (WinHttpGetDefaultProxyConfiguration(&proxyInfo)) {
        @     @<代理配置>.SetInfo(&proxyInfo);
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 置默认代理配置 <公开 静态 类型 = 逻辑型 注释 = "注意: 本方法已经在Windows 8.1及更高版本上弃用,不建议再使用." 注释 = "在注册表中设置默认的WinHTTP代理配置."
            注释 = "设置后用\"初始化\"创建的新会话都将使用新的默认代理设置." 返回值注释 = "返回是否成功." 折叠 @禁止流程检查 = 真>
    参数 代理配置 <类型 = WinHTTP代理信息类 注释 = "其中的\"访问类型\"成员只能使用\"命名代理\"或\"默认代理\".">
    {
        @ WINHTTP_PROXY_INFO proxyInfo;
        @ @<代理配置>.GetInfo(&proxyInfo);
        @ return WinHttpSetDefaultProxyConfiguration(&proxyInfo);
    }

    方法 取当前用户的IE代理配置 <公开 静态 类型 = 逻辑型 注释 = "获取当前用户的Internet Explorer代理配置." 注释 = "用于未实现代理自动发现协议的网络环境中."
            返回值注释 = "返回是否成功." 折叠 @禁止流程检查 = 真>
    参数 是否自动检测 <类型 = 逻辑型类 注释 = "返回当前用户的IE代理配置是否指定了\"自动检测设置\"." @默认值 = 空对象>
    参数 自动配置URL <类型 = 文本型 注释 = "若当前用户的IE代理配置指定为\"使用自动代理配置\",成功时将返回自动配置URL." @默认值 = 空对象>
    参数 代理服务器 <类型 = 文本型 注释 = "若当前用户的IE代理配置指定为\"使用代理服务器\",成功时将返回代理URL." @默认值 = 空对象>
    参数 代理跳过列表 <类型 = 文本型 注释 = "若当前用户的IE代理配置指定为\"使用代理服务器\",成功时将返回代理跳过列表." @默认值 = 空对象>
    {
        @ WINHTTP_CURRENT_USER_IE_PROXY_CONFIG ProxyConfig;
        @ if (WinHttpGetIEProxyConfigForCurrentUser(&ProxyConfig)) {
        @     @<是否自动检测.值> = ProxyConfig.fAutoDetect;
        @     if (ProxyConfig.lpszAutoConfigUrl != NULL) {
        @         @<自动配置URL>.SetText(ProxyConfig.lpszAutoConfigUrl);
        @         GlobalFree(ProxyConfig.lpszAutoConfigUrl);
        @     }
        @     if (ProxyConfig.lpszProxy != NULL) {
        @         @<代理服务器>.SetText(ProxyConfig.lpszProxy);
        @         GlobalFree(ProxyConfig.lpszProxy);
        @     }
        @     if (ProxyConfig.lpszProxyBypass != NULL) {
        @         @<代理跳过列表>.SetText(ProxyConfig.lpszProxyBypass);
        @         GlobalFree(ProxyConfig.lpszProxyBypass);
        @     }
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    # 以下至少要求 Windows 8 ---

    方法 创建代理解析器 <公开 静态 类型 = 整数 注释 = "创建代理的解析器句柄,用于下一步的\"从URL获取代理EX\"." 注释 = "本函数只能在异步模式下使用."
            注释 = "本方法此为Windows 8新增的API,之前的系统不可用." 返回值注释 = "成功返回0,失败返回错误码." 折叠 @嵌入式方法 = "">
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 解析器句柄 <类型 = 变整数 注释 = "请提供变整数变量,新的句柄会返回到此变量中." 注释 = "使用完毕后需要用\"关闭句柄\"关闭此句柄." @需求类型 = 可写入变量>
    {
        @ (INT)WinHttpCreateProxyResolver((HINTERNET)@<会话句柄>, (HINTERNET*)&@<解析器句柄>)
    }

    方法 从URL获取代理EX <公开 静态 类型 = 逻辑型 注释 = "从指定的URL中获取代理数据,执行成功后请在回调函数中等待通知,然后调用\"取代理结果\"."
            注释 = "本函数只能在异步模式下使用." 注释 = "本方法此为Windows 8新增的API,之前的系统不可用." 返回值注释 = "成功返回真,表示操作在异步中继续,失败返回假." 折叠
            @禁止流程检查 = 真>
    参数 解析器句柄 <类型 = 变整数 注释 = "请提供由\"创建代理解析器\"返回的句柄.">
    参数 URL <类型 = 文本型 注释 = "代理PAC文件的URL,本函数只支持ECMAScript格式的PAC文件.">
    参数 自动代理选项 <类型 = WinHTTP自动代理选项类 注释 = "指定所欲使用的自动代理选项">
    参数 上下文 <类型 = 变整数 注释 = "将传递到完成回调函数中" @默认值 = 0>
    {
        @ DWORD dwRes = WinHttpGetProxyForUrlEx((HINTERNET)@<解析器句柄>, @<URL>.GetText(),
        @                                       &@<自动代理选项>, (DWORD_PTR)@<上下文>);
        @ return (dwRes == ERROR_IO_PENDING);
    }

    方法 取代理结果 <公开 静态 类型 = 逻辑型 注释 = "异步执行\"从URL获取代理EX\"完毕后,调用本方法获取结果." 注释 = "本方法此为Windows 8新增的API,之前的系统不可用."
            返回值注释 = "返回是否成功,失败的原因可能是解析器句柄错误," 返回值注释 = "或未完成对\"从URL获取代理EX\"的调用." 折叠 @禁止流程检查 = 真>
    参数 解析器句柄 <类型 = 变整数 注释 = "请提供由\"创建代理解析器\"返回的句柄.">
    参数 代理结果数组 <类型 = WinHTTP代理结果数组类 注释 = "成功在此参数返回代理结果">
    {
        @ @<代理结果数组>.RemoveAll();
        @ WINHTTP_PROXY_RESULT ProxyResult;
        @ if (WinHttpGetProxyResult((HINTERNET)@<解析器句柄>, &ProxyResult) == 0) {
        @     for (DWORD i = 0; i < ProxyResult.cEntries; i++) {
        @         @dt<WinHTTP代理结果类> Entrie(ProxyResult.pEntries[i]);
        @         @<代理结果数组>.Add(Entrie, NULL);
        @     }
        @     WinHttpFreeProxyResult(&ProxyResult);
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 重置自动代理 <公开 静态 类型 = 整数 注释 = "重置自动代理的配置,两次调用本方法至少应间隔30秒以上,否则可能会返回成功,但实际未发生重置."
            注释 = "本方法此为Windows 8新增的API,之前的系统不可用." 返回值注释 = "成功返回0,失败返回错误码." 折叠 @嵌入式方法 = "">
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 重置操作 <类型 = 整数 注释 = "请使用\"重置代理_WinHTTP\"中的常量之一或其\"位或\"值." @默认值 = 重置代理_WinHTTP.重置全部>
    {
        @ (INT)WinHttpResetAutoProxy((HINTERNET)@<会话句柄>, (DWORD)@<重置操作> | WINHTTP_RESET_OUT_OF_PROC)
    }

    # WebSocket ===
    # 仅 Windows 8 及更高版本可用

    方法 升级到WebSocket <公开 静态 类型 = 逻辑型 注释 = "将HTTP请求升级为WebSocket握手,需要在\"发送请求\"之前调用本方法."
            注释 = "本方法此为Windows 8新增的API,之前的系统不可用." 返回值注释 = "返回是否成功." 折叠 @嵌入式方法 = "">
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    {
        @ WinHttpSetOption((HINTERNET)@<请求句柄>, 114, NULL, 0) // WINHTTP_OPTION_UPGRADE_TO_WEB_SOCKET
    }

    方法 WebSocket升级完成 <公开 静态 类型 = 变整数 注释 = "完成一次由\"发送请求\"开始的WebSocket握手."
            注释 = "在发送请求之前,必须调用\"升级到WebSocket\"将请求句柄标记为\"WebSocket升级\"."
            注释 = "应检查服务器返回的HTTP状态代码,仅在当状态代码为101时才调用本方法." 注释 = "本方法此为Windows 8新增的API,之前的系统不可用."
            返回值注释 = "成功返回新的WebSocket句柄,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄,且使用过\"接收响应\".">
    参数 上下文 <类型 = 变整数 注释 = "用户自定义的指针值,将伴随请求句柄传递给任意回调方法." @默认值 = 0>
    {
        @ return (INT_P)WinHttpWebSocketCompleteUpgrade((HINTERNET)@<请求句柄>, (DWORD_PTR)@<上下文>);
    }

    方法 停止WebSocket <公开 静态 类型 = 整数 注释 = "向WebSocket服务器发送一个关闭帧以关闭发送通道,但仍保持打开接收通道."
            注释 = "当你需要完全关闭时请调用\"关闭WebSocket\"." 注释 = "本方法此为Windows 8新增的API,之前的系统不可用." 返回值注释 = "成功返回0,失败返回错误码." 折叠
            @禁止流程检查 = 真>
    参数 WebSocket句柄 <类型 = 变整数 注释 = "  请提供调用\"WebSocket升级完成\"返回的句柄,本方法不会关闭此句柄," 注释 = "你需要调用\"关闭句柄\"才能关闭.">
    参数 关闭状态码 <类型 = 短整数 注释 = "提供关闭状态码,请参考\"关闭状态码_WinHTTP\"中的常量.">
    参数 关闭原因 <类型 = 文本型 注释 = "提供关闭的详细原因,不能超过60个字符,可以留空." @默认值 = 空对象>
    {
        @ return (INT)WinHttpWebSocketShutdown((HINTERNET)@<WebSocket句柄>, (USHORT)@<关闭状态码>,
        @                                      (PVOID)@<关闭原因>.GetTextMaybeNull(), (DWORD)@<关闭原因>.GetLength());
    }

    方法 关闭WebSocket <公开 静态 类型 = 整数 注释 = "完全关闭WebSocket连接." 注释 = "本方法此为Windows 8新增的API,之前的系统不可用."
            返回值注释 = "成功返回0,失败返回错误码." 折叠 @禁止流程检查 = 真>
    参数 WebSocket句柄 <类型 = 变整数 注释 = "  请提供调用\"WebSocket升级完成\"返回的句柄,本方法不会关闭此句柄," 注释 = "你需要调用\"关闭句柄\"才能关闭.">
    参数 关闭状态码 <类型 = 短整数 注释 = "提供关闭状态码,请参考\"关闭状态码_WinHTTP\"中的常量.">
    参数 关闭原因 <类型 = 文本型 注释 = "提供关闭的详细原因,不能超过60个字符,可以留空." @默认值 = 空对象>
    {
        @ return (INT)WinHttpWebSocketClose((HINTERNET)@<WebSocket句柄>, (USHORT)@<关闭状态码>,
        @                                   (PVOID)@<关闭原因>.GetTextMaybeNull(), (DWORD)@<关闭原因>.GetLength ());
    }

    方法 取WebSocket关闭状态 <公开 静态 类型 = 整数 注释 = "获取WebSocket服务器发来的关闭状态码." 返回值注释 = "成功返回0,失败返回错误码." 折叠 @禁止流程检查 = 真>
    参数 WebSocket句柄 <类型 = 变整数 注释 = "请提供调用\"WebSocket升级完成\"返回的句柄.">
    参数 关闭状态码 <类型 = 短整数类 注释 = "返回关闭状态码,请参考\"关闭状态码_WinHTTP\"中的常量." @默认值 = 空对象>
    参数 关闭原因 <类型 = 文本型 注释 = "返回关闭的详细原因,不能超过60个字符." @默认值 = 空对象>
    {
        @ @<关闭原因>.Empty();
        @ DWORD dwRes, cbReason = 0;
        @ dwRes = WinHttpWebSocketQueryCloseStatus((HINTERNET)@<WebSocket句柄>, (USHORT*)&@<关闭状态码.值>,
        @                                          NULL, 0, &cbReason);
        @ if (dwRes == NO_ERROR && cbReason > 0) {
        @     const WCHAR* szReason = new WCHAR[cbReason];
        @     WinHttpWebSocketQueryCloseStatus((HINTERNET)@<WebSocket句柄>, (USHORT*)&@<关闭状态码.值>,
        @                                      (PVOID)szReason, cbReason, &cbReason);
        @     @<关闭原因>.SetText(szReason);
        @     delete[] szReason;
        @ }
        @ return (INT)dwRes;
    }

    方法 WebSocket发送数据 <公开 静态 类型 = 整数 注释 = "通过WebSocket连接发送数据." 注释 = "本方法此为Windows 8新增的API,之前的系统不可用."
            返回值注释 = "成功返回0,失败返回错误码." 折叠 @禁止流程检查 = 真>
    参数 WebSocket句柄 <类型 = 变整数 注释 = "请提供调用\"WebSocket升级完成\"返回的句柄.">
    参数 缓冲区类型 <类型 = 整数 注释 = "提供缓冲区的类型,请参考\"缓冲区类型_WinHTTP\"中的常量.">
    参数 缓冲区 <类型 = 字节集类 注释 = "所欲发送的缓冲区数据." @默认值 = 空对象>
    {
        @ return (INT)WinHttpWebSocketSend((HINTERNET)@<WebSocket句柄>, (WINHTTP_WEB_SOCKET_BUFFER_TYPE)@<缓冲区类型>,
        @                                  (PVOID)@<缓冲区>.GetPtr(), (DWORD)@<缓冲区>.GetSize());
    }

    方法 WebSocket接收数据 <公开 静态 类型 = 整数 注释 = "通过WebSocket连接接收数据." 注释 = "本方法此为Windows 8新增的API,之前的系统不可用."
            返回值注释 = "成功返回0,失败返回错误码." 折叠 @禁止流程检查 = 真>
    参数 WebSocket句柄 <类型 = 变整数 注释 = "请提供调用\"WebSocket升级完成\"返回的句柄.">
    参数 缓冲区 <类型 = 字节集类 注释 = "返回接收的缓冲区数据,返回的字节集长度为实际接收数据长度.">
    参数 缓冲区大小 <类型 = 整数 注释 = "提供缓冲区的字节大小,内部会根据此大小分配缓冲区字节集." @默认值 = 1024>
    参数 接收数据量 <类型 = 整数类 注释 = "返回接收到的数据量(字节单位),异步模式下必须为空对象." @默认值 = 空对象>
    参数 缓冲区类型 <类型 = 整数类 注释 = "返回缓冲区类型,请参考\"缓冲区类型_WinHTTP\"中的常量值." 注释 = "异步模式下必须为空对象." @默认值 = 空对象>
    {
        @ @<缓冲区>.Alloc(@<缓冲区大小>, TRUE);
        @ DWORD dwRes;
        @ dwRes = WinHttpWebSocketReceive((HINTERNET)@<WebSocket句柄>, (PVOID)@<缓冲区>.GetPtr(),
        @                                 (DWORD)@<缓冲区大小>, piv::GetBaseDataPtr<LPDWORD>(@<接收数据量>),
        @                                 @<缓冲区类型>.IsNullObject() ? NULL : (WINHTTP_WEB_SOCKET_BUFFER_TYPE*)&@<缓冲区类型.值>);
        @ if (@<接收数据量.值> < @<缓冲区大小>)
        @     @<缓冲区>.RemoveToEnd(@<接收数据量.值>);
        @ return (INT)dwRes;
    }

    方法 置WebSocket关闭超时 <公开 静态 类型 = 逻辑型 注释 = "设置等待\"关闭WebSocket\"完成关闭握手的时间." 返回值注释 = "返回设置是否成功." 折叠
            @禁止流程检查 = 真>
    参数 WebSocket句柄 <类型 = 变整数 注释 = "请提供调用\"WebSocket升级完成\"返回的句柄.">
    参数 超时时间 <类型 = 整数 注释 = "默认为100000(毫秒),即10秒.">
    {
        @ DWORD dwOption = (DWORD)@<超时时间>;
        @ return WinHttpSetOption((HINTERNET)@<WebSocket句柄>, 115, // WINHTTP_OPTION_WEB_SOCKET_CLOSE_TIMEOUT
        @                         (LPVOID)&dwOption, 4);
    }

    方法 取WebSocket关闭超时 <公开 静态 类型 = 整数 注释 = "获取等待\"关闭WebSocket\"完成关闭握手的时间." 返回值注释 = "返回超时时间." 折叠 @禁止流程检查 = 真>
    参数 WebSocket句柄 <类型 = 变整数 注释 = "请提供调用\"WebSocket升级完成\"返回的句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption = 0, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<WebSocket句柄>, 115, // WINHTTP_OPTION_WEB_SOCKET_CLOSE_TIMEOUT
        @                                     (LPVOID)&dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 置WebSocket保持活动间隔 <公开 静态 类型 = 逻辑型 注释 = "设置通过连接发送保持活动状态数据包的时间间隔." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 WebSocket句柄 <类型 = 变整数 注释 = "请提供调用\"WebSocket升级完成\"返回的句柄.">
    参数 间隔 <类型 = 整数 注释 = "默认为30000(毫秒),即30秒,最小间隔为15000(15秒)">
    {
        @ return WinHttpSetOption((HINTERNET)@<WebSocket句柄>, 116, &@<间隔>, 4); // WINHTTP_OPTION_WEB_SOCKET_KEEPALIVE_INTERVAL
    }

    方法 取WebSocket保持活动间隔 <公开 静态 类型 = 整数 注释 = "获取通过连接发送保持活动状态数据包的时间间隔." 返回值注释 = "返回间隔(毫秒)." 折叠 @禁止流程检查 = 真>
    参数 WebSocket句柄 <类型 = 变整数 注释 = "请提供调用\"WebSocket升级完成\"返回的句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption = 0, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<WebSocket句柄>, 116, // WINHTTP_OPTION_WEB_SOCKET_KEEPALIVE_INTERVAL
        @                                     &dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 置WebSocket接收缓冲区大小 <公开 静态 类型 = 逻辑型 注释 = "设置在WebSocket连接上使用的接收缓冲区大小."
            注释 = "本方法此为Windows 8新增的API,之前的系统不可用." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 大小 <类型 = 整数 注释 = "单位为字节">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, 122, &@<大小>, 4); // WINHTTP_OPTION_WEB_SOCKET_RECEIVE_BUFFER_SIZE
    }

    方法 取WebSocket接收缓冲区大小 <公开 静态 类型 = 整数 注释 = "获取在WebSocket连接上使用的接收缓冲区大小."
            注释 = "本方法此为Windows 8新增的API,之前的系统不可用." 返回值注释 = "返回缓冲区字节大小." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption = 0, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>,
        @                                     122, &dwOption, &dwLength); // WINHTTP_OPTION_WEB_SOCKET_RECEIVE_BUFFER_SIZE
        @ return (INT)dwOption;
    }

    方法 置WebSocket发送缓冲区大小 <公开 静态 类型 = 逻辑型 注释 = "设置在WebSocket连接上使用的发送缓冲区大小."
            注释 = "本方法此为Windows 8新增的API,之前的系统不可用." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 大小 <类型 = 整数 注释 = "单位为字节">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, 123, &@<大小>, 4); // WINHTTP_OPTION_WEB_SOCKET_SEND_BUFFER_SIZE
    }

    方法 取WebSocket发送缓冲区大小 <公开 静态 类型 = 整数 注释 = "获取在WebSocket连接上使用的发送缓冲区大小."
            注释 = "本方法此为Windows 8新增的API,之前的系统不可用." 返回值注释 = "返回缓冲区字节大小." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption = 0, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>,
        @                                     123, (LPVOID)&dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    # 选项 ===

    方法 置选项_线程数量 <公开 静态 类型 = 逻辑型 注释 = "设置线程池用于异步的工作线程数." 注释 = "此选项需要在发生异步操作之前设置,且只能设置一次."
            返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 线程数量 <类型 = 整数 注释 = "默认为0,等于CPU的线程数.">
    {
        @ return WinHttpSetOption(NULL, WINHTTP_OPTION_WORKER_THREAD_COUNT, &@<线程数量>, 4);
    }

    # 通用选项 ---

    方法 取选项_状态回调指针 <公开 静态 类型 = 变整数 注释 = "返回最后一次\"置状态回调\"所设置的回调方法指针." 返回值注释 = "返回状态回调指针." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ LPVOID pOption = NULL; DWORD dwLength = sizeof(LPVOID);
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>,
        @                                     WINHTTP_OPTION_CALLBACK, (LPVOID)&pOption, &dwLength);
        @ return (INT_P)pOption;
    }

    方法 置选项_解析超时 <公开 静态 类型 = 逻辑型 注释 = "设置解析域名的超时时间,默认为无限." 注释 = "如果设置了非默认值,则为每个域名解析增加一个创建线程的开销."
            返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 超时时间 <类型 = 整数 注释 = "默认为无限时,一直等待到解析结束.">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_RESOLVE_TIMEOUT, &@<超时时间>, 4);
    }

    方法 取选项_解析超时 <公开 静态 类型 = 整数 注释 = "获取解析域名的超时时间,默认为无限." 注释 = "如果设置了非默认值,则为每个域名解析增加一个创建线程的开销."
            返回值注释 = "返回超时时间." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption = 0, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>,
        @                                     WINHTTP_OPTION_RESOLVE_TIMEOUT, (LPVOID)&dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 置选项_连接超时 <公开 静态 类型 = 逻辑型 注释 = "设置WinHTTP连接的超时时间,如果连接的时间超过该选项则会取消请求."
            注释 = "当你连接到多地址主机时,每个IP地址的超时限制都是单独计算的." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 超时时间 <类型 = 整数 注释 = "默认为600000(毫秒),即60秒.设置为-1时禁用超时.">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_CONNECT_TIMEOUT, &@<超时时间>, 4);
    }

    方法 取选项_连接超时 <公开 静态 类型 = 整数 注释 = "获取WinHTTP连接的超时时间,如果连接的时间超过该选项则会取消请求."
            注释 = "当你连接到多地址主机时,每个IP地址的超时限制都是单独计算的." 返回值注释 = "返回超时时间." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption = 0, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>,
        @                                     WINHTTP_OPTION_CONNECT_TIMEOUT, (LPVOID)&dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 置选项_重连次数 <公开 静态 类型 = 逻辑型 注释 = "设置WinHTTP尝试连接到主机的次数."
            注释 = "  WinHTTP对每个IP地址只尝试连接一次,如果目标是拥有10个IP的多地址主机," 注释 = "而重试次数为5,则只尝试连接到前5个IP地址.如果重试次数为20,则对10个IP都"
            注释 = "尝试连接一次,10次后仍失败则会取消请求." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 重试次数 <类型 = 整数 注释 = "默认为5次.">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_CONNECT_RETRIES, &@<重试次数>, 4);
    }

    方法 取选项_重连次数 <公开 静态 类型 = 整数 注释 = "获取WinHTTP尝试连接到主机的次数."
            注释 = "  WinHTTP对每个IP地址只尝试连接一次,如果目标是拥有10个IP的多地址主机," 注释 = "而重试次数为5,则只尝试连接到前5个IP地址.如果重试次数为20,则对10个IP都"
            注释 = "尝试连接一次,10次后仍失败则会取消请求." 返回值注释 = "返回重试次数." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption = 0, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>,
        @                                     WINHTTP_OPTION_CONNECT_RETRIES, &dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 取选项_发送超时 <公开 静态 类型 = 整数 注释 = "获取发送请求或发送数据的超时时间,如果在此超时期限内未发送完数据,则会取消请求." 返回值注释 = "返回超时时间." 折叠
            @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption = 0, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>,
        @                                     WINHTTP_OPTION_SEND_TIMEOUT, &dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 置选项_发送超时 <公开 静态 类型 = 逻辑型 注释 = "设置发送请求或发送数据的超时时间,如果在此超时期限内未发送完数据,则会取消请求." 返回值注释 = "返回设置是否成功." 折叠
            @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 超时时间 <类型 = 整数 注释 = "默认为300000(毫秒),即30秒.设置为-1时禁用超时.">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_SEND_TIMEOUT, &@<超时时间>, 4);
    }

    方法 置选项_接收超时 <公开 静态 类型 = 逻辑型 注释 = "设置接收部分响应的超时时间,如果在此超时期限内未接收完数据,则会取消请求." 返回值注释 = "返回设置是否成功." 折叠
            @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 超时时间 <类型 = 整数 注释 = "默认为300000(毫秒),即30秒.设置为-1时禁用超时.">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_RECEIVE_TIMEOUT, &@<超时时间>, 4);
    }

    方法 取选项_接收超时 <公开 静态 类型 = 整数 注释 = "获取接收部分响应的超时时间,如果在此超时期限内未接收完数据,则会取消请求." 返回值注释 = "返回超时时间." 折叠
            @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption = 0, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>,
        @                                     WINHTTP_OPTION_RECEIVE_TIMEOUT, &dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 置选项_接收响应头超时 <公开 静态 类型 = 逻辑型 注释 = "设置等待到接收所有响应头为止的超时时间,如果WinHTTP在此超时期限内无法接收所有标头,则会取消请求."
            注释 = "仅当从套接字接收数据时,才会检查此超时." 注释 = "如果没有数据到达,则超时过期和客户端通知之间的延迟可能与\"置超时时间\"的\"接收超时\"参数的值一样大."
            返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 超时时间 <类型 = 整数 注释 = "默认为900000(毫秒),即90秒.设置为-1时禁用超时.">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_RECEIVE_RESPONSE_TIMEOUT, &@<超时时间>, 4);
    }

    方法 取选项_接收响应头超时 <公开 静态 类型 = 整数 注释 = "获取等待到接收所有响应头为止的超时时间,如果WinHTTP在此超时期限内无法接收所有标头,则会取消请求."
            注释 = "仅当从套接字接收数据时,才会检查此超时." 注释 = "如果没有数据到达,则超时过期和客户端通知之间的延迟可能与\"置超时时间\"的\"接收超时\"参数的值一样大."
            返回值注释 = "返回超时时间." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption = 0, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>,
        @                                     WINHTTP_OPTION_RECEIVE_RESPONSE_TIMEOUT, &dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 取选项_句柄类型 <公开 静态 类型 = 整数 注释 = "获取所提供句柄的类型." 返回值注释 = "返回1为会话句柄,返回2为连接句柄,返回3为请求句柄."
            返回值注释 = "其他值表示执行方法失败." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄、连接句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>,
        @                                     WINHTTP_OPTION_HANDLE_TYPE, &dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 取选项_父句柄 <公开 静态 类型 = 变整数 注释 = "获取指定网络句柄的父句柄,比如通过请求句柄取连接句柄." 返回值注释 = "返回父句柄." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄、连接句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ HINTERNET hOption; DWORD dwLength = sizeof(HINTERNET);
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>,
        @                                     WINHTTP_OPTION_PARENT_HANDLE, &hOption, &dwLength);
        @ return (INT_P)hOption;
    }

    方法 取选项_上次错误 <公开 静态 类型 = 整数 注释 = "返回网络句柄上一次的错误代码(ERROR_WINHTTP_*)." 返回值注释 = "返回上次错误代码." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption; DWORD dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>,
        @                                     WINHTTP_OPTION_EXTENDED_ERROR, &dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 置选项_代理信息 <公开 静态 类型 = 逻辑型 注释 = "设置现有会话句柄或请求句柄上的代理数据." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.设置为0表示查询全局代理数据(默认代理).">
    参数 代理信息 <类型 = WinHTTP代理信息类>
    {
        @ WINHTTP_PROXY_INFO proxyInfo;
        @ @<代理信息>.GetInfo(&proxyInfo);
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_PROXY,
        @                         &proxyInfo, sizeof(WINHTTP_PROXY_INFO));
    }

    方法 取选项_代理信息 <公开 静态 类型 = 逻辑型 注释 = "获取现有会话句柄或请求句柄上的代理数据." 返回值注释 = "返回是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄." 注释 = "为0时会自动获取当前的会话句柄." @默认值 = 0>
    参数 代理信息 <类型 = WinHTTP代理信息类 注释 = "成功返回代理信息.">
    {
        @ @<代理信息>.ResetToNullObject();
        @ WINHTTP_PROXY_INFO proxyInfo;
        @ dwLength = sizeof(WINHTTP_PROXY_INFO);
        @ if (WinHttpQueryOption((HINTERNET)@<网络句柄>,
        @                        WINHTTP_OPTION_PROXY, &proxyInfo, &dwLength)) {
        @     @<代理信息>.SetInfo(&proxyInfo);
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 置选项_上下文值 <公开 静态 类型 = 逻辑型 注释 = "设置一个跟网络句柄关联的上下文值指针,该值会出现在状态回调的参数中." 返回值注释 = "返回设置是否成功." 折叠
            @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 上下文值 <类型 = 变整数>
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_CONTEXT_VALUE, &@<上下文值>, sizeof(DWORD_PTR));
    }

    方法 取选项_上下文值 <公开 静态 类型 = 变整数 注释 = "获取跟网络句柄关联的上下文值指针." 返回值注释 = "返回上下文值,失败时为0." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD_PTR pOption = NULL; DWORD dwLength = sizeof(DWORD_PTR);
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_CONTEXT_VALUE,
        @                                     &pOption, &dwLength);
        @ return (INT_P)pOption;
    }

    方法 置选项_HTTP版本 <公开 静态 类型 = 逻辑型 注释 = "设置HTTP的版本号." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 主要版本 <类型 = 整数 注释 = "必须为1" @默认值 = 1>
    参数 次要版本 <类型 = 整数 注释 = "1或0">
    {
        @ HTTP_VERSION_INFO httpVer;
        @ httpVer.dwMajorVersion = (DWORD)@<主要版本>;
        @ httpVer.dwMinorVersion = (DWORD)@<次要版本>;
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_HTTP_VERSION,
        @                         &httpVer, sizeof(httpVer));
    }

    方法 取选项_HTTP版本 <公开 静态 类型 = 逻辑型 注释 = "获取HTTP的版本号." 返回值注释 = "返回获取是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 主要版本 <类型 = 整数类 注释 = "返回HTTP的主要版本">
    参数 次要版本 <类型 = 整数类 注释 = "返回HTTP的次要版本">
    {
        @ HTTP_VERSION_INFO httpVer;
        @ DWORD dwLength = sizeof(HTTP_VERSION_INFO);
        @ BOOL bRes = WinHttpQueryOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_HTTP_VERSION,
        @                                &httpVer, &dwLength);
        @ @<主要版本.值> = (INT)httpVer.dwMajorVersion;
        @ @<次要版本.值> = (INT)httpVer.dwMinorVersion;
        @ return bRes;
    }

    方法 置选项_启用功能 <公开 静态 类型 = 逻辑型 注释 = "设置是否开启部分功能." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 启用功能 <类型 = 整数 注释 = "只能使用以下两个数值之一:" 注释 = "  1 允许SSL吊销,只能在请求句柄上设置此值;"
            注释 = "  2 将在SSL证书身份验证操作期间临时还原客户端模拟,只能在会话句柄上设置此值.">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_ENABLE_FEATURE, &@<启用功能>, 4);
    }

    方法 置选项_启用跟踪 <公开 静态 类型 = 逻辑型 注释 = "设置是否允许启用跟踪." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 是否启用 <类型 = 逻辑型>
    {
        @ return WinHttpSetOption(NULL, WINHTTP_OPTION_ENABLETRACING, &@<是否启用>, 4);
    }

    方法 取选项_跟踪状态 <公开 静态 类型 = 逻辑型 注释 = "返回是否允许跟踪." 返回值注释 = "返回是否跟踪." 折叠 @禁止流程检查 = 真>
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ BOOL bOption; DWORD dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption(NULL, WINHTTP_OPTION_ENABLETRACING,
        @                                     &bOption, &dwLength);
        @ return bOption;
    }

    方法 置选项_重定向策略 <公开 静态 类型 = 逻辑型 注释 = "设置WinHTTP处理30x HTTP重定向状态码的行为." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 重定向策略 <类型 = 整数 注释 = "只能设置为以下三个值之一:" 注释 = "  0 不遵从重定向;" 注释 = "  1 遵从重定向,除了拒绝从HTTPS重定向到HTTP,此为默认值;"
            注释 = "  2 遵从所有重定向;">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_REDIRECT_POLICY, &@<重定向策略>, 4);
    }

    方法 取选项_重定向策略 <公开 静态 类型 = 整数 注释 = "获取WinHTTP处理30x HTTP重定向状态码的行为." 返回值注释 = "返回重定向策略:"
            返回值注释 = "  0 不遵从重定向;" 返回值注释 = "  1 遵从重定向,除了拒绝从HTTPS重定向到HTTP,此为默认值;" 返回值注释 = "  2 遵从所有重定向;" 折叠
            @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption = 0, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_REDIRECT_POLICY,
        @                                     &dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 置选项_最大重定向次数 <公开 静态 类型 = 逻辑型 注释 = "设置WinHTTP遵循的最大重定向次数." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 重定向次数 <类型 = 整数 注释 = "默认为10次.">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS, &@<重定向次数>, 4);
    }

    方法 取选项_最大重定向次数 <公开 静态 类型 = 整数 注释 = "返回WinHTTP遵循的最大重定向次数." 返回值注释 = "返回最大重定向次数." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption = 0, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS,
        @                                     &dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 置选项_最大继续状态次数 <公开 静态 类型 = 逻辑型 注释 = "设置在返回最终状态码到客户端之前,忽略100-199信息状态码响应的最大次数."
            注释 = "100-199信息状态码可以由服务器在最终状态码之前发送,并在HTTP/1.1的规范中进行了描述." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 继续次数 <类型 = 整数 注释 = "默认为10次.">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_MAX_HTTP_STATUS_CONTINUE, &@<继续次数>, 4);
    }

    方法 取选项_最大继续状态次数 <公开 静态 类型 = 整数 注释 = "获取在返回最终状态码到客户端之前,忽略100-199信息状态码响应的最大次数."
            注释 = "100-199信息状态码可以由服务器在最终状态码之前发送,并在HTTP/1.1的规范中进行了描述." 返回值注释 = "返回最大继续次数." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption = 0, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_MAX_HTTP_STATUS_CONTINUE,
        @                                     &dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 置选项_最大响应头大小 <公开 静态 类型 = 逻辑型 注释 = "设置服务器响应头部分的最大尺寸限制."
            注释 = "此限制可防止客户端受到未经授权服务器的攻击,比如服务器发送无限量的响应头数据来瘫痪客户端." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 数据量 <类型 = 整数 注释 = "单位为字节,默认为65536(64KB).">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_MAX_RESPONSE_HEADER_SIZE, &@<数据量>, 4);
    }

    方法 取选项_最大响应头大小 <公开 静态 类型 = 整数 注释 = "获取服务器响应头部分的最大尺寸限制."
            注释 = "此限制可防止客户端受到未经授权服务器的攻击,比如服务器发送无限量的响应头数据来瘫痪客户端." 返回值注释 = "返回数据量." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption = 0, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_MAX_RESPONSE_HEADER_SIZE,
        @                                     &dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 置选项_最大响应排出大小 <公开 静态 类型 = 逻辑型 注释 = "设置从响应中排出数据量的最大限制,以便重用连接." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 数据量 <类型 = 整数 注释 = "单位为字节,默认为1048576(1MB)." "">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_MAX_RESPONSE_DRAIN_SIZE, &@<数据量>, 4);
    }

    方法 取选项_最大响应排出大小 <公开 静态 类型 = 整数 注释 = "获取从响应中排出数据量的最大限制,以便重用连接." 返回值注释 = "返回数据量." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption = 0, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_MAX_RESPONSE_DRAIN_SIZE, &dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 置选项_全局代理凭据 <公开 静态 类型 = 逻辑型 注释 = "设置全局的代理服务器凭据." 注释 = "需要将\"置选项_使用全局服务器凭据\"设置为真." 返回值注释 = "返回设置是否成功."
            折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 用户凭据 <类型 = WinHTTP用户凭据类>
    {
        @ WINHTTP_CREDS_EX creds;
        @ @<用户凭据>.GetInfo(&creds);
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_GLOBAL_PROXY_CREDS,
        @                         &creds, sizeof(WINHTTP_CREDS_EX));
    }

    方法 置选项_全局服务器凭据 <公开 静态 类型 = 逻辑型 注释 = "设置全局的服务器凭据." 注释 = "需要将\"置选项_使用全局服务器凭据\"设置为真." 返回值注释 = "返回设置是否成功."
            折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 用户凭据 <类型 = WinHTTP用户凭据类>
    {
        @ WINHTTP_CREDS_EX creds;
        @ @<用户凭据>.GetInfo(&creds);
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_GLOBAL_SERVER_CREDS,
        @                         &creds, sizeof(WINHTTP_CREDS_EX));
    }

    方法 置选项_使用全局服务器凭据 <公开 静态 类型 = 逻辑型 注释 = "设置是否使用全局服务器凭据."
            注释 = "如果设置为真,需要使用\"置选项_全局代理凭据\"或\"置选项_全局服务器凭据\"设置凭据." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否启用 <类型 = 逻辑型 注释 = "默认为假">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_USE_GLOBAL_SERVER_CREDENTIALS, &@<是否启用>, 4);
    }

    方法 置选项_接收代理连接响应 <公开 静态 类型 = 逻辑型 注释 = "设置是否可以获取代理的响应实体." 注释 = "默认情况下,此选项处于禁用状态." 返回值注释 = "返回设置是否成功." 折叠
            @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否启用 <类型 = 逻辑型 注释 = "默认为假.">
    {
        @ return WinHttpSetOption ((HINTERNET)@<网络句柄>, WINHTTP_OPTION_RECEIVE_PROXY_CONNECT_RESPONSE, &@<是否启用>, 4);
    }

    方法 取选项_是否代理连接响应 <公开 静态 类型 = 逻辑型 注释 = "获取是否可以获取代理返回的连接响应." 返回值注释 = "返回是否可以获取." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄、连接句柄或请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ BOOL bOption; DWORD dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<网络句柄>, WINHTTP_OPTION_IS_PROXY_CONNECT_RESPONSE,
        @                                     &bOption, &dwLength);
        @ return bOption;
    }

    # 以下有系统版本限制

    方法 置选项_解压缩 <公开 静态 类型 = 逻辑型 注释 = "设置是否对响应内容自动进行解压缩."
            注释 = "WinHTTP自动解压缩后,会将响应头的Content-Length、Content-Encoding删除掉."
            注释 = "本方法最低系统要求为Windows 8.1,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 解压缩选项 <类型 = 整数 注释 = "只能使用下列4个数值之一,默认为0" 注释 = "  0 禁用解压缩" 注释 = "  1 使用gzip" 注释 = "  2 使用deflate"
            注释 = "  3 同时使用gzip和deflate" @默认值 = 3>
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, 118, &@<解压缩选项>, 4); // WINHTTP_OPTION_DECOMPRESSION
    }

    方法 置选项_启用HTTP协议 <公开 静态 类型 = 逻辑型 注释 = "设置是否使用更高的HTTP版本."
            注释 = "本方法最低系统要求为Windows 10 Version 1607,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 位掩码 <类型 = 整数 注释 = "只能使用以下三个数值之一:" 注释 = "  0 将请求限制为HTTP/1.1及更早版本" 注释 = "  1 为请求启用HTTP/2"
            注释 = "  2 为请求启用HTTP/3">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, 133, &@<位掩码>, 4); // WINHTTP_OPTION_ENABLE_HTTP_PROTOCOL
    }

    方法 置选项_URL编码 <公开 静态 类型 = 逻辑型 注释 = "是否对URL路径和查询字段启用URL编码."
            注释 = "本方法最低系统要求为Windows 10 Version 1803,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否启用 <类型 = 逻辑型 注释 = "是否启用URL编码">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, 138, &@<是否启用>, 4); // WINHTTP_OPTION_ENCODE_EXTRA
    }

    方法 置选项_禁止流队列 <公开 静态 类型 = 逻辑型 注释 = "允许新请求在达到最大并发流限制时打开其他HTTP/2连接,而不是等待现有连接上的下一个可用流."
            注释 = "本方法最低系统要求为Windows 10 Version 1809,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否启用 <类型 = 逻辑型 注释 = "真为禁止">
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, 139, &@<是否启用>, 4); // WINHTTP_OPTION_DISABLE_STREAM_QUEUE
    }

    方法 置选项_必需HTTP协议 <公开 静态 类型 = 逻辑型 注释 = "设置是否防止将\"置选项_启用HTTP协议\"设置之外的协议版本用于请求."
            注释 = "本方法最低系统要求为Windows 10 Version 1903,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否启用 <类型 = 逻辑型>
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, 145, &@<是否启用>, 4); // WINHTTP_OPTION_HTTP_PROTOCOL_REQUIRED
    }

    方法 置选项_必须流结束标志 <公开 静态 类型 = 逻辑型 注释 = "设置是否忽略\"Content-Length\"响应头,并继续在流上接收,直到收到END_STREAM标志."
            注释 = "本方法最低系统要求为Windows 10 Version 21H1,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否启用 <类型 = 逻辑型 @默认值 = 真>
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, 160, &@<是否启用>, 4); // WINHTTP_OPTION_REQUIRE_STREAM_END
    }

    方法 置选项_HTTP2传输编码 <公开 静态 类型 = 逻辑型 注释 = "控制HTTP/2响应包含\"Transfer-Encoding\"协议头时的行为方式."
            注释 = "本方法最低系统要求为Windows 10 Version 21H1,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 网络句柄 <类型 = 变整数 注释 = "请提供会话句柄或请求句柄.">
    参数 是否启用 <类型 = 逻辑型 注释 = "本参数只能设置为真,填假将返回失败." @默认值 = 真>
    {
        @ return WinHttpSetOption((HINTERNET)@<网络句柄>, 169, &<是否启用>, 4); // WINHTTP_OPTION_HTTP2_PLUS_TRANSFER_ENCODING
    }

    # 会话句柄专用选项 ---

    方法 置选项_用户代理 <公开 静态 类型 = 逻辑型 注释 = "设置后续请求的用户代理(User-Agent)." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 用户代理 <类型 = 文本型>
    {
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, 41, // WINHTTP_OPTION_USER_AGENT
        @                         (LPVOID)@<用户代理>.GetText(), (DWORD)@<用户代理>.GetLength());
    }

    方法 取选项_用户代理 <公开 静态 类型 = 文本型 注释 = "获取用户代理(User-Agent)." 返回值注释 = "返回用户代理." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwLength = 1024 * 2;
        @ WCHAR szUA[1024] { };
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<会话句柄>,
        @                                     WINHTTP_OPTION_USER_AGENT, (LPVOID)szUA, &dwLength);
        @ if (dwLength > 0)
        @     return @an<CVolString>((const WCHAR*)szUA);
        @ return @an<CVolString>(L"");
    }

    方法 置选项_代码页 <公开 静态 类型 = 逻辑型 注释 = "设置处理URL的代码页,默认为UTF-8(65001),其他请参考:"
            注释 = "https://docs.microsoft.com/en-us/windows/win32/intl/code-page-identifiers" 返回值注释 = "返回设置是否成功."
            折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 代码页 <类型 = 整数 注释 = "默认为UTF-8(65001).">
    {
        @ DWORD dwOption = (DWORD)@<代码页>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, WINHTTP_OPTION_CODEPAGE, (LPVOID)&dwOption, 4);
    }

    方法 置选项_服务器最大连接数 <公开 静态 类型 = 逻辑型 注释 = "设置每个HTTP服务器允许的最大连接数,默认值为\"无穷大\"." 返回值注释 = "返回设置是否成功." 折叠
            @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 最大连接数 <类型 = 整数 注释 = "最大连接数,设置为0时会自动限制为2.">
    {
        @ DWORD dwOption = (DWORD)@<最大连接数>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, WINHTTP_OPTION_MAX_CONNS_PER_SERVER, (LPVOID)&dwOption, 4);
    }

    方法 取选项_服务器最大连接数 <公开 静态 类型 = 整数 注释 = "设置每个HTTP服务器允许的最大连接数,默认值为\"无穷大\"." 返回值注释 = "返回最大连接数." 折叠
            @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<会话句柄>,
        @                                     WINHTTP_OPTION_MAX_CONNS_PER_SERVER, (LPVOID)&dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 置选项_旧版服务器最大连接数 <公开 静态 类型 = 逻辑型 注释 = "设置每个HTTP/1.0服务器允许的最大连接数,默认值为\"无穷大\"." 返回值注释 = "返回设置是否成功." 折叠
            @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 最大连接数 <类型 = 整数 注释 = "最大连接数">
    {
        @ DWORD dwOption = (DWORD)@<最大连接数>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER, (LPVOID)&dwOption, 4);
    }

    方法 取选项_旧版服务器最大连接数 <公开 静态 类型 = 整数 注释 = "设置每个HTTP/1.0服务器允许的最大连接数,默认值为\"无穷大\"." 返回值注释 = "返回最大连接数." 折叠
            @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<会话句柄>,
        @                                     WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER, (LPVOID)&dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 置选项_Passport身份验证 <公开 静态 类型 = 逻辑型 注释 = "设置是否启用WinHTTP的Passport身份验证." 返回值注释 = "返回设置是否成功." 折叠
            @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 配置 <类型 = 整数 注释 = "只能使用下列4个数值之一,默认为0" 注释 = "  0x00000000 禁用微软Passport身份验证,这是默认设置;"
            注释 = "  0x10000000 禁用Passport密钥环,这是默认设置;" 注释 = "  0x20000000 启用微软Passport身份验证;"
            注释 = "  0x40000000 启用Passport密钥环;">
    {
        @ DWORD dwOption = (DWORD)@<配置>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, WINHTTP_OPTION_CONFIGURE_PASSPORT_AUTH, (LPVOID)&dwOption, 4);
    }

    方法 置选项_安全协议 <公开 静态 类型 = 逻辑型 注释 = "设置启用的安全协议,能使用什么协议跟系统的版本有关,部分系统可以安装补丁支持更高的安全协议."
            注释 = "Windows 11、Windows 10和Windows 8.1 默认情况下,仅启用SSL3、TLS1.0、TLS1.1和TLS1.2"
            注释 = "Windows 8和Windows 7默认情况下,仅启用SSL 和TLS1" 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 协议 <类型 = 整数 注释 = "请使用\"SSL协议_WinHTTP\"中的单个常量,或多个常量的\"位或\"组合值.">
    {
        @ DWORD dwOption = (DWORD)@<协议>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, WINHTTP_OPTION_SECURE_PROTOCOLS, (LPVOID)&dwOption, 4);
    }

    方法 置选项_登出Passport <公开 静态 类型 = 逻辑型 注释 = "在会话句柄上设置注销任何Passport登录的选项." 注释 = "与返回URL相关的所有Cookie将被清除."
            返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 返回URL指针 <类型 = 变整数 注释 = "提供通过\"取选项_Passport返回URL\"获取的URL指针.">
    {
        @ LPVOID pOption = (LPVOID)@<返回URL指针>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, WINHTTP_OPTION_PASSPORT_SIGN_OUT, (LPVOID)&pOption, sizeof(LPVOID));
    }

    方法 置选项_卸载通知事件 <公开 静态 类型 = 逻辑型 注释 = "采用一个事件,该事件将在特定会话的最后一个回调完成时设置." 注释 = "在WinHTTP设置事件之前,无法关闭该事件."
            返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 句柄 <类型 = 变整数>
    {
        @ HINTERNET pOption = (HINTERNET)@<句柄>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, WINHTTP_OPTION_UNLOAD_NOTIFY_EVENT, (LPVOID)&bOption, sizeof(HINTERNET));
    }

    方法 置选项_非阻塞回调 <公开 静态 类型 = 逻辑型 注释 = "是否确保所有的回调方法都是非阻塞的."
            注释 = "如果设置为真,客户端必须在回调中执行最少的操作以避免阻塞,并尽快返回,特别是不能等待任何后续的WinHTTP调用."
            注释 = "如此开启此选项可能会提高性能,否则可能会对性能产生负面影响或导致应用程序挂起." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 是否非阻塞 <类型 = 逻辑型 注释 = "默认为假.">
    {
        @ BOOL bOption = @<是否非阻塞>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, 111, (LPVOID)&bOption, 4); // WINHTTP_OPTION_ASSURED_NON_BLOCKING_CALLBACKS
    }

    # 以下有系统版本限制

    方法 置选项_IPv6快速回退 <公开 静态 类型 = 逻辑型 注释 = "为连接启用IPv6快速回退功能(Happy Eyeballs),用于缩短网络不支持IPv6访问时的连接时间."
            注释 = "本方法最低系统要求为Windows 10 Version 1903,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 是否启用 <类型 = 逻辑型 注释 = "真为启用." 注释 = "  如果IPv6和IPv4均已解析,将首先连接到较短超时(300ms)的第一个IPv6地址."
            注释 = "  如果连接失败,将尝试连接到IPv4地址.">
    {
        @ BOOL bOption = (DWORD)@<是否启用>;
        @ return WinHttpSetOption ((HINTERNET)@<会话句柄>, 140, (LPVOID)&bOption, 4); // WINHTTP_OPTION_IPV6_FAST_FALLBACK
    }

    方法 置选项_禁止安全协议回退 <公开 静态 类型 = 逻辑型 注释 = "设置是否防止WinHTTP在初始协议协商失败时重试具有较低版本安全协议的连接."
            注释 = "本方法最低系统要求为Windows 10 Version 1903,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 是否启用 <类型 = 逻辑型 注释 = "真为禁止安全协议回退">
    {
        @ BOOL bOption = (DWORD)@<是否启用>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, 144, (LPVOID)&bOption, 4); // WINHTTP_OPTION_DISABLE_SECURE_PROTOCOL_FALLBACK
    }

    方法 置选项_TCP保持活动 <公开 静态 类型 = 逻辑型 注释 = "设置启用TCP保持活动状态的行为."
            注释 = "本方法最低系统要求为Windows 10 Version 2004,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 是否保持活动 <类型 = 逻辑型>
    参数 空闲超时 <类型 = 整数 注释 = "单位毫秒,在发送第一个保持活动状态的数据包之后没有任何活动的超时时间">
    参数 探测间隔 <类型 = 整数 注释 = "单位毫秒,在未收到确认时发送保持活动状态数据包的时间间隔">
    {
        @ struct tcp_keepalive_WinHTTP {
        @     ULONG onoff;
        @     ULONG keepalivetime;
        @     ULONG keepaliveinterval;
        @ };
        @ tcp_keepalive_WinHTTP keepalive;
        @ keepalive.onoff = (u_long)@<是否保持活动>;
        @ keepalive.keepalivetime = (u_long)@<空闲超时>;
        @ keepalive.keepaliveinterval = (u_long)@<探测间隔>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, 152, (LPVOID)&keepalive, sizeof(tcp_keepalive_WinHTTP)); // WINHTTP_OPTION_TCP_KEEPALIVE
    }

    方法 置选项_TCP快速打开 <公开 静态 类型 = 逻辑型 注释 = "为连接启用TCP快速打开."
            注释 = "本方法最低系统要求为Windows 10 Version 2004,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 是否启用 <类型 = 逻辑型>
    {
        @ BOOL bOption = @<是否启用>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, 153, (LPVOID)&bOption, 4); // WINHTTP_OPTION_TCP_FAST_OPEN
    }

    方法 置选项_TLS错误启动 <公开 静态 类型 = 逻辑型 注释 = "为连接启用TLS错误启动."
            注释 = "本方法最低系统要求为Windows 10 Version 21H1,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 是否启用 <类型 = 逻辑型>
    {
        @ BOOL bOption = @<是否启用>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, 154, (LPVOID)&bOption, 4); // WINHTTP_OPTION_TLS_FALSE_START
    }

    方法 置选项_TLS协议回退 <公开 静态 类型 = 逻辑型 注释 = "在使用较新的协议版本出现TLS握手失败时,是否允许回退到TLS 1.0"
            注释 = "本方法最低系统要求为Windows 10 Version 21H1,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 是否启用 <类型 = 逻辑型>
    {
        @ BOOL bOption = @<是否启用>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, 158, (LPVOID)&bOption, 4); // WINHTTP_OPTION_TLS_PROTOCOL_INSECURE_FALLBACK
    }

    方法 置选项_HTTP2客户端证书 <公开 静态 类型 = 逻辑型 注释 = "设置是否允许WinHTTP在使用HTTP/2时使用调用方提供的客户端证书上下文."
            注释 = "本方法最低系统要求为Windows 10 Version 21H1,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 是否启用 <类型 = 逻辑型 注释 = "真为启用">
    {
        @ BOOL bOption = (DWORD)@<是否启用>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, 161, (LPVOID)&bOption, 4); // WINHTTP_OPTION_ENABLE_HTTP2_PLUS_CLIENT_CERT
    }

    方法 置选项_HTTP2保持活动 <公开 静态 类型 = 逻辑型 注释 = "设置WinHTTP使用HTTP/2 PING帧作为保持活动机制."
            注释 = "提供毫秒单位的超时时间,如果连接在该超时时间内没有活动,WinHTTP将发送HTTP/2 PING帧."
            注释 = "本方法最低系统要求为Windows 10 Version 21H1,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 超时时间 <类型 = 整数 注释 = "不能小于5000毫秒.">
    {
        @ DWORD dwOption = (DWORD)@<超时时间>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, 164, (LPVOID)&dwOption, 4); // WINHTTP_OPTION_HTTP2_KEEPALIVE
    }

    方法 置选项_禁止生成证书链 <公开 静态 类型 = 逻辑型 注释 = "设置是否禁用生成服务器证书链."
            注释 = "本方法最低系统要求为Windows 10 Version 21H1,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 是否启用 <类型 = 逻辑型 注释 = "真为禁止生成证书链">
    {
        @ BOOL bOption = (DWORD)@<是否启用>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, 171, (LPVOID)&bOption, 4); // WINHTTP_OPTION_DISABLE_CERT_CHAIN_BUILDING
    }

    方法 置选项_后台连接数 <公开 静态 类型 = 逻辑型 注释 = "设置会话的并发连接数."
            注释 = "默认为1,如果设置更多连接数,在首次发送请求时,WinHTTP不是仅打开单个连接,而是并行打开多个连接." 注释 = "这可以提高对同一目标的后续请求的性能,而且不会产生连接建立的开销."
            注释 = "本方法最低系统要求为Windows 10 Version 21H1,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 连接数 <类型 = 整数 注释 = "默认为1.">
    {
        @ DWORD dwOption = (DWORD)@<连接数>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, 172, (LPVOID)&dwOption, 4); // WINHTTP_OPTION_BACKGROUND_CONNECTIONS
    }

    方法 置选项_首选可用连接 <公开 静态 类型 = 逻辑型 注释 = "  默认情况下,当WinHttp发送请求时,如果没有可用的连接来为请求提供服务,WinHTTP将尝试建立新连接,"
            注释 = "并且将请求绑定到此新连接." 注释 = "  设置此选项时,这样的请求将在第一个可用的连接上提供,而不一定是正在建立的连接."
            注释 = "  本方法最低系统要求为Windows 10 Version 21H1,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 会话句柄 <类型 = 变整数 注释 = "请提供调用\"初始化\"成功时返回的会话句柄.">
    参数 是否启用 <类型 = 逻辑型 注释 = "真为启用">
    {
        @ BOOL bOption = (DWORD)@<是否启用>;
        @ return WinHttpSetOption((HINTERNET)@<会话句柄>, 173, (LPVOID)&bOption, 4); // WINHTTP_OPTION_FIRST_AVAILABLE_CONNECTION
    }

    # 请求句柄专用选项 ---

    方法 置选项_安全标志 <公开 静态 类型 = 逻辑型 注释 = "设置请求的安全标志." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 安全标志 <类型 = 整数 注释 = "请使用\"安全标志_WinHTTP\"中单个常量,或多个常量的\"位或\"组合值.">
    {
        @ DWORD dwOption = (DWORD)@<安全标志>;
        @ return WinHttpSetOption((HINTERNET)@<请求句柄>, WINHTTP_OPTION_SECURITY_FLAGS, (LPVOID)&dwOption, 4);
    }

    方法 取选项_安全标志 <公开 静态 类型 = 整数 注释 = "获取请求的安全标志." 返回值注释 = "返回安全标志,请参考\"安全标志_WinHTTP\"." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<请求句柄>,
        @                                     WINHTTP_OPTION_SECURITY_FLAGS, (LPVOID)&dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 取选项_安全证书 <公开 静态 类型 = 逻辑型 注释 = "获取SSL/TLS服务器的证书信息." 返回值注释 = "返回是否成功" 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 安全证书 <类型 = WinHTTP安全证书类 注释 = "成功返回安全证书信息." @默认值 = 空对象>
    {
        @ @<安全证书>.ResetObject();
        @ WINHTTP_CERTIFICATE_INFO certificate { };
        @ DWORD dwLength = sizeof(WINHTTP_CERTIFICATE_INFO);
        @ if (WinHttpQueryOption((HINTERNET)@<请求句柄>,
        @                        WINHTTP_OPTION_SECURITY_CERTIFICATE_STRUCT, (LPVOID)&certificate, &dwLength)) {
        @     @<安全证书>.SetInfo(&certificate);
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 取选项_URL地址 <公开 静态 类型 = 文本型 注释 = "获取请求句柄上包含已下载资源的完整URL地址."
            注释 = "如果原始URL包含任何额外数据(如搜索文本或锚点),或者被重定向,则返回的URL与原始URL不同." 返回值注释 = "返回URL地址." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwLength = 2083 * 2;
        @ WCHAR szUrl[2083] { };
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<请求句柄>,
        @                                     WINHTTP_OPTION_URL, (LPVOID)szUrl, &dwLength);
        @ if (dwLength > 0)
        @     return @an<CVolString>((const WCHAR*)szUrl);
        @ return @an<CVolString>(L"");
    }

    方法 置选项_禁止功能 <公开 静态 类型 = 逻辑型 注释 = "设置是否禁止部分的请求功能,需要在\"发送请求\"之前调用本方法." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 禁止功能 <类型 = 整数 注释 = "请使用\"禁止功能标志_WinHTTP\"中单个常量,或多个常量的\"位或\"组合值.">
    {
        @ DWORD dwOption = (DWORD)@<禁止功能>;
        @ return WinHttpSetOption((HINTERNET)@<请求句柄>, WINHTTP_OPTION_DISABLE_FEATURE, (LPVOID)&dwOption, 4);
    }

    方法 置选项_自动登录策略 <公开 静态 类型 = 逻辑型 注释 = "设置请求的自动登录策略." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 自动登录策略 <类型 = 整数 注释 = "只能使用下列三个数值之一,默认为0" 注释 = "  0 仅使用默认凭据对本地网络的请求执行身份验证登录;"
            注释 = "  1 对所有请求执行使用默认凭据的身份验证登录;" 注释 = "  2 不使用默认凭据. 请注意,此标志仅当在通过实际计算机名称指定服务器时生效,"
            注释 = "若通过\"localhost\"或IP地址指定服务器,则不会生效." @默认值 = 0>
    {
        @ DWORD dwOption = (DWORD)@<自动登录策略>;
        @ return WinHttpSetOption((HINTERNET)@<请求句柄>, WINHTTP_OPTION_AUTOLOGON_POLICY, (LPVOID)&dwOption, 4);
    }

    方法 取选项_安全密钥位数 <公开 静态 类型 = 整数 注释 = "获取加密密钥的密码强度,数字越大表示加密的密码强度越强." 返回值注释 = "返回密钥位数." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<请求句柄>,
        @                                     WINHTTP_OPTION_SECURITY_KEY_BITNESS, (LPVOID)&dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 取选项_Passport联合品牌文本 <公开 静态 类型 = 文本型 注释 = "获取Passport登录服务器提供商的联合品牌文本." 注释 = "应在登录服务器响应401状态码后立即获取此选项."
            返回值注释 = "返回Passport联合品牌文本." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwLength = 2048 * 2;
        @ WCHAR szStr[2048];
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<请求句柄>,
        @                                     WINHTTP_OPTION_PASSPORT_COBRANDING_TEXT, (LPVOID)szStr, &dwLength);
        @ if (dwLength > 0)
        @     return @an<CVolString>(szStr);
        @ return @an<CVolString>(L"");
    }

    方法 取选项_Passport联合品牌URL <公开 静态 类型 = 文本型 注释 = "获取Passport登录服务器提供商的联合品牌图形URL."
            注释 = "应在登录服务器响应401状态码后立即获取此选项." 返回值注释 = "返回Passport联合品牌URL." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwLength = 2048;
        @ WCHAR szStr[2048];
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<请求句柄>,
        @                                     WINHTTP_OPTION_PASSPORT_COBRANDING_URL, (LPVOID)szStr, &dwLength);
        @ if (dwLength > 0)
        @     return @an<CVolString>(szStr);
        @ return @an<CVolString>(L"");
    }

    方法 取选项_Passport返回URL <公开 静态 类型 = 变整数 注释 = "在请求句柄上设置一个只读选项,并获取Passport的返回URL."
            返回值注释 = "返回URL的文本指针,该指针后续可用于\"置选项_登出Passport\"." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwLength = sizeof(LPVOID);
        @ LPVOID szUrl = NULL;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<请求句柄>,
        @                                     WINHTTP_OPTION_PASSPORT_COBRANDING_URL, (LPVOID)&szUrl, &dwLength);
        @ return szUrl;
    }

    方法 置选项_SPN标志 <公开 静态 类型 = 逻辑型 注释 = "在为Kerberos或协商Kerberos身份验证生成SPN服务主体名称时,是否包括或删除服务器端口号."
            返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 标志 <类型 = 整数 注释 = "以下值之一:" 注释 = "  0 删除服务器端口号" 注释 = "  1 包括服务器端口号">
    {
        @ DWORD dwOption = (DWORD)@<标志>;
        @ return WinHttpSetOption((HINTERNET)@<请求句柄>, WINHTTP_OPTION_SPN, (LPVOID)&dwOption, 4);
    }

    方法 置选项_拒绝含用户密码的URL <公开 静态 类型 = 逻辑型 注释 = "设置是否拒绝包含用户名和密码的URL." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 是否拒绝 <类型 = 逻辑型 注释 = "默认为不拒绝">
    {
        @ BOOL bOption = @<是否拒绝>;
        @ return WinHttpSetOption((HINTERNET)@<请求句柄>, WINHTTP_OPTION_REJECT_USERPWD_IN_URL, (LPVOID)&bOption, 4);
    }

    方法 取选项_服务器SPN <公开 静态 类型 = 文本型 注释 = "获取WinHTTP在身份验证期间提供给SSPI的服务器主体名称."
            注释 = "此文本用于在身份验证失败后传递给SspiPromptForCredentials." 返回值注释 = "返回服务器主体名称." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwLength = 1024 * 2;
        @ WCHAR szSPN[1024] { };
        @ @<是否成功.值> = WinHttpQueryOption ((HINTERNET)@<请求句柄>,
        @                                      WINHTTP_OPTION_SERVER_SPN_USED, (LPVOID)szSPN, &dwLength);
        @ if (dwLength > 0)
        @     return @an<CVolString> ((const WCHAR*)szSPN);
        @ return @an<CVolString>(L"");
    }

    方法 取选项_代理SPN <公开 静态 类型 = 文本型 注释 = "获取WinHTTP在身份验证期间提供给SSPI的代理服务器主体名称."
            注释 = "此文本用于在身份验证失败后传递给SspiPromptForCredentials." 返回值注释 = "返回代理服务器主体名称." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwLength = 1024 * 2;
        @ WCHAR szSPN[1024] { };
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<请求句柄>,
        @                                     WINHTTP_OPTION_PROXY_SPN_USED, (LPVOID)szSPN, &dwLength);
        @ if (dwLength > 0)
        @     return @an<CVolString>((const WCHAR*)szSPN);
        @ return @an<CVolString>(L"");
    }

    方法 置选项_用户名 <公开 静态 类型 = 逻辑型 注释 = "在请求句柄上设置用户名." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 用户名 <类型 = 文本型>
    {
        @ return WinHttpSetOption((HINTERNET)@<请求句柄>, WINHTTP_OPTION_USERNAME,
        @                         (LPVOID)@<用户名>.GetText(), (DWORD)@<用户名>.GetLength());
    }

    方法 取选项_用户名 <公开 静态 类型 = 文本型 注释 = "获取请求句柄上的用户名." 返回值注释 = "返回用户名." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwLength = 1024 * 2;
        @ WCHAR szUser[1024] { };
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<请求句柄>,
        @                                     WINHTTP_OPTION_USERNAME, (LPVOID)szUser, &dwLength);
        @ if (dwLength > 0)
        @     return @an<CVolString>((const WCHAR*)szUser);
        @ return @an<CVolString>(L"");
    }

    方法 置选项_密码 <公开 静态 类型 = 逻辑型 注释 = "在请求句柄上设置密码." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 密码 <类型 = 文本型>
    {
        @ return WinHttpSetOption((HINTERNET)@<请求句柄>, WINHTTP_OPTION_PASSWORD,
        @                         (LPVOID)@<密码>.GetText(), (DWORD)@<密码>.GetLength());
    }

    方法 取选项_密码 <公开 静态 类型 = 文本型 注释 = "获取请求句柄上的密码." 返回值注释 = "返回密码." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwLength = 1024 * 2;
        @ WCHAR szPassword[1024] { };
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<请求句柄>,
        @                                     WINHTTP_OPTION_PASSWORD, (LPVOID)szPassword, &dwLength);
        @ if (dwLength > 0)
        @     return @an<CVolString>((const WCHAR*)szPassword);
        @ return @an<CVolString>(L"");
    }

    方法 置选项_代理用户名 <公开 静态 类型 = 逻辑型 注释 = "在请求句柄上设置访问代理的用户名." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 用户名 <类型 = 文本型>
    {
        @ return WinHttpSetOption((HINTERNET)@<请求句柄>, WINHTTP_OPTION_PROXY_USERNAME,
        @                         (LPVOID)@<用户名>.GetText(), (DWORD)@<用户名>.GetLength());
    }

    方法 取选项_代理用户名 <公开 静态 类型 = 文本型 注释 = "获取请求句柄上访问代理的用户名." 返回值注释 = "返回用户名." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwLength = 1024 * 2;
        @ WCHAR szUser[1024] { };
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<请求句柄>,
        @                                     WINHTTP_OPTION_PROXY_USERNAME, (LPVOID)szUser, &dwLength);
        @ if (dwLength > 0)
        @     return @an<CVolString>((const WCHAR*)szUser);
        @ return @an<CVolString>(L"");
    }

    方法 置选项_代理密码 <公开 静态 类型 = 逻辑型 注释 = "在请求句柄上设置访问代理的密码." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 密码 <类型 = 文本型>
    {
        @ return WinHttpSetOption((HINTERNET)@<请求句柄>, WINHTTP_OPTION_PROXY_PASSWORD,
        @                         (LPVOID)@<密码>.GetText(), (DWORD)@<密码>.GetLength());
    }

    方法 取选项_代理密码 <公开 静态 类型 = 文本型 注释 = "获取请求句柄上访问代理的密码." 返回值注释 = "返回代理密码." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwLength = 1024 * 2;
        @ WCHAR szPassword[1024] { };
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<请求句柄>,
        @                                     WINHTTP_OPTION_PROXY_PASSWORD, (LPVOID)szPassword, &dwLength);
        @ if (dwLength > 0)
        @     return @an<CVolString>((const WCHAR*)szPassword);
        @ return @an<CVolString>(L"");
    }

    # 以下有系统版本限制

    方法 取选项_请求次数 <公开 静态 类型 = 逻辑型 注释 = "获取请求句柄返回的请求次数统计信息."
            注释 = "本方法最低系统要求为Windows 10 Version 1903,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 请求次数 <类型 = 长整数数组类 注释 = "返回获取的请求次数统计信息,各成员的含义请使用\"请求次数索引_WinHTTP\"." "">
    {
        @ @<请求次数>.data ().RemoveAll();
        @ WINHTTP_REQUEST_TIMES times;
        @ DWORD dwLength = sizeof(WINHTTP_REQUEST_TIMES);
        @ if (WinHttpQueryOption((HINTERNET)@<请求句柄>, 142, // WINHTTP_OPTION_REQUEST_TIMES
        @                         (LPVOID)&times, &dwLength)) {
        @     @<请求次数>.data().Copy((const INT64*)&times.rgullTimes[0], times.cTimes);
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 置选项_终止连接 <公开 静态 类型 = 逻辑型 注释 = "只能在仍处于活动状态(发送或接收)的请求句柄上设置此选项."
            注释 = "设置此选项将告诉WinHttp停止与请求句柄关联的连接请求,连接将关闭."
            注释 = "本方法最低系统要求为Windows 10 Version 1903,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @嵌入式方法 = "">
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    {
        @ WinHttpSetOption((HINTERNET)@<请求句柄>, 143, NULL, 0) // WINHTTP_OPTION_EXPIRE_CONNECTION
    }

    方法 取选项_请求状态 <公开 静态 类型 = 逻辑型 注释 = "获取请求句柄返回的请求状态统计信息."
            注释 = "本方法最低系统要求为Windows 10 Version 1903,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 请求状态 <类型 = WinHTTP请求状态信息类 注释 = "返回获取的请求状态统计信息." "">
    {
        @ @<请求状态>.ResetToNullObject();
        @ WINHTTP_REQUEST_STATS stats;
        @ DWORD dwLength = sizeof(WINHTTP_REQUEST_STATS);
        @ if (WinHttpQueryOption((HINTERNET)@<请求句柄>, 146, // WINHTTP_OPTION_REQUEST_STATS
        @                        (LPVOID)&stats, &dwLength)) {
        @     @<请求状态>.SetInfo(&stats);
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 取选项_所用HTTP协议 <公开 静态 类型 = 整数 注释 = "获取指定的请求句柄使用了哪个HTTP协议版本."
            注释 = "本方法最低系统要求为Windows 10 Version 1607,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "0 表示HTTP/1.1及更早版本"
            返回值注释 = "1 表示HTTP/2" 返回值注释 = "2 表示HTTP/3" 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<请求句柄>,
        @                                     134, (LPVOID)&dwOption, &dwLength); // WINHTTP_OPTION_HTTP_PROTOCOL_USED
        @ return (INT)dwOption;
    }

    方法 取选项_安全信息 <公开 静态 类型 = 逻辑型 注释 = "获取请求的SChannel连接和密文信息."
            注释 = "本方法最低系统要求为Windows 10 Version 2004,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回是否成功" 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 安全信息 <类型 = WinHTTP安全信息类 注释 = "成功返回安全证书信息." @默认值 = 空对象>
    {
        @ @<安全信息>.ResetObject();
        @ WINHTTP_SECURITY_INFO security;
        @ DWORD dwLength = sizeof(WINHTTP_SECURITY_INFO);
        @ if (WinHttpQueryOption((HINTERNET)@<请求句柄>, 151, // WINHTTP_OPTION_SECURITY_INFO
        @                        (LPVOID)&security, &dwLength)) {
        @     @<安全信息>.SetInfo(&security);
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 取选项_流错误码 <公开 静态 类型 = 整数 注释 = "获取HTTP流上接收的RST_STREAM帧所指示的错误代码."
            注释 = "本方法最低系统要求为Windows 10 Version 21H1,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回流的错误码." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 是否成功 <类型 = 逻辑型类 注释 = "返回获取是否成功,本参数可省略." @默认值 = 空对象>
    {
        @ DWORD dwOption, dwLength = 4;
        @ @<是否成功.值> = WinHttpQueryOption((HINTERNET)@<请求句柄>, 159, // WINHTTP_OPTION_STREAM_ERROR_CODE
        @                                     (LPVOID)&dwOption, &dwLength);
        @ return (INT)dwOption;
    }

    方法 置选项_解析域名 <公开 静态 类型 = 逻辑型 注释 = "可以在\"发送请求\"之前对请求句柄设置此选项." 注释 = "设置后WinHttp将使用提供的文本作为DNS解析的域名."
            注释 = "本方法最低系统要求为Windows 10 Version 21H1,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 域名 <类型 = 文本型>
    {
        @ return WinHttpSetOption((HINTERNET)@<请求句柄>, 165, (LPVOID)@<域名>.GetText(), (DWORD)@<域名>.GetLength()); // WINHTTP_OPTION_RESOLUTION_HOSTNAME
    }

    方法 置选项_忽略证书吊销 <公开 静态 类型 = 逻辑型 注释 = "设置是否允许安全连接在无法下载证书吊销列表时继续使用安全证书."
            注释 = "本方法最低系统要求为Windows 10 Version 2004,但在旧系统不会造成崩溃,只会返回假." 返回值注释 = "返回设置是否成功." 折叠 @禁止流程检查 = 真>
    参数 请求句柄 <类型 = 变整数 注释 = "请提供调用\"打开请求\"成功时返回的请求句柄.">
    参数 是否允许 <类型 = 逻辑型>
    {
        @ BOOL bOption = @<是否允许>;
        @ return WinHttpSetOption((HINTERNET)@<请求句柄>, 155, (LPVOID)&bOption, 4); // WINHTTP_OPTION_IGNORE_CERT_REVOCATION_OFFLINE
    }

    # 自定义方法 ---

    方法 取Cookie内容 <公开 静态 类型 = 文本型 注释 = "从服务器返回的\"Set-Cookie\"协议头中提取出Cokkie的名字和值字段."
            返回值注释 = "返回Cookie内容,用于请求时提交给服务器." 折叠>
    参数 Cookie <类型 = 文本型 注释 = "服务器返回的Set-Cookie协议头">
    {
        变量 返回结果 <类型 = 文本型>
        变量 值文本 <类型 = 文本型>
        变量 值数组 <类型 = 文本数组类>
        变量 局Cookie <类型 = 文本型>
        局Cookie = Cookie
        如果 (是否以文本开头 (局Cookie, "Set-Cookie:", 假) == 真)
        {
            删除字符 (局Cookie, 0, 11)
        }
        置文本预分配字符数 (返回结果, 取文本长度 (局Cookie))
        分割文本 (局Cookie, ";", 值数组, 真, 真)
        值数组.枚举循环 ()
        {
            值文本 = 值数组.取枚举值 ()
            如果 (寻找字符 (值文本, '=', 0) != -1)
            {
                如果 (是否以文本开头 (值文本, "Domain", 假) == 假 && 是否以文本开头 (值文本, "Path", 假) == 假 && 是否以文本开头 (值文本, "Expires", 假) == 假 && 是否以文本开头 (值文本, "Max-Age", 假) == 假 && 是否以文本开头 (值文本, "SameSite", 假) == 假 && 是否以文本开头 (值文本, "Priority", 假) == 假)
                {
                    如果 (文本是否为空 (返回结果) == 假)
                    {
                        加入文本 (返回结果, "; ")
                    }
                    加入文本 (返回结果, 值文本)
                }
            }
        }
        返回 (返回结果)
    }

    # ---
    # 以下选项或已弃用,所以不封装:
    # WINHTTP_OPTION_READ_BUFFER_SIZE
    # WINHTTP_OPTION_WRITE_BUFFER_SIZE
    # WINHTTP_OPTION_REQUEST_PRIORITY
    # ---
    # 以下选项未封装(待完成):
    # WINHTTP_OPTION_CLIENT_CERT_CONTEXT
    # WINHTTP_OPTION_CONNECTION_INFO
    # WINHTTP_OPTION_CLIENT_CERT_ISSUER_LIST
    # WINHTTP_OPTION_CONNECTION_STATS_V0
    # WINHTTP_OPTION_CONNECTION_STATS_V1
    # WINHTTP_OPTION_SERVER_CBT
    # WINHTTP_OPTION_SERVER_CERT_CHAIN_CONTEXT
    # WINHTTP_OPTION_SERVER_CERT_CONTEXT
    # ---
    # 以下选项在MSDN上无资料:
    # WINHTTP_OPTION_PROXY_RESULT_ENTRY
    # WINHTTP_OPTION_PASSPORT_RETURN_URL
    # WINHTTP_OPTION_TCP_PRIORITY_HINT
    # WINHTTP_OPTION_CONNECTION_FILTER
    # WINHTTP_OPTION_KDC_PROXY_SETTINGS
    # WINHTTP_OPTION_UNSAFE_HEADER_PARSING
    # WINHTTP_OPTION_PROXY_DISABLE_SERVICE_CALLS
    # WINHTTP_OPTION_SOURCE_ADDRESS
    # WINHTTP_OPTION_HEAP_EXTENSION
    # WINHTTP_OPTION_FAILED_CONNECTION_RETRIES
    # WINHTTP_OPTION_SET_GLOBAL_CALLBACK
    # WINHTTP_OPTION_SET_TOKEN_BINDING
    # WINHTTP_OPTION_TOKEN_BINDING_PUBLIC_KEY
    # WINHTTP_OPTION_REFERER_TOKEN_BINDING_HOSTNAME
    # WINHTTP_OPTION_RESOLVER_CACHE_CONFIG
    # WINHTTP_OPTION_ENABLE_TEST_SIGNING
    # WINHTTP_OPTION_NTSERVICE_FLAG_TEST
    # WINHTTP_OPTION_DISABLE_PROXY_LINK_LOCAL_NAME_RESOLUTION
    # WINHTTP_OPTION_TCP_PRIORITY_STATUS
    # WINHTTP_OPTION_CONNECTION_GUID
    # WINHTTP_OPTION_MATCH_CONNECTION_GUID
    # WINHTTP_OPTION_PROXY_CONFIG_INFO
    # WINHTTP_OPTION_AGGREGATE_PROXY_CONFIG
    # WINHTTP_OPTION_SELECTED_PROXY_CONFIG_INFO
    # WINHTTP_OPTION_HTTP2_RECEIVE_WINDOW
    # ---
}

# WinHTTP 辅助类 ===

类 URL组件信息类 <公开 基础类 = 扩展对象类 注释 = "用于\"WinHTTP网络类.拆分URL/创建URL\"."
        注释 = "<scheme>://<user>:<password>@<host>:<port>/<path>?<query>#<fragment>" 折叠
        @文档 = "category = \"WinHTTP.辅助类\"">
{
    变量 协议 <公开 类型 = 文本型 注释 = "URL的协议<scheme>" @输出名 = "szScheme">
    变量 协议类型 <公开 类型 = 整数 注释 = "1=HTTP; 2=HTTPS; 3=FTP; 4=SOCKS" @输出名 = "nScheme">
    变量 域名 <公开 类型 = 文本型 注释 = "URL的域名<host>" @输出名 = "szHostName">
    变量 端口 <公开 类型 = 整数 注释 = "URL的端口号<port>" @输出名 = "nPort">
    变量 用户名 <公开 类型 = 文本型 注释 = "URL的用户名字段<user>" @输出名 = "szUserName">
    变量 密码 <公开 类型 = 文本型 注释 = "URL的密码字段<password>" @输出名 = "szPassword">
    变量 路径 <公开 类型 = 文本型 注释 = "URL的路径/<path>" @输出名 = "szUrlPath">
    变量 附加信息 <公开 类型 = 文本型 注释 = "URL的提交参数?<query>和段落#<fragment>" @输出名 = "szExtraInfo">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<URL组件信息类> 总共 8 个成员:\r\n"
        加入文本 (展示内容, "1.协议: " + 取调试文本2 (最大展示数据尺寸, 协议) + "\r\n")
        加入文本 (展示内容, "2.协议类型: " + 取调试文本2 (最大展示数据尺寸, 协议类型) + "\r\n")
        加入文本 (展示内容, "3.域名: " + 取调试文本2 (最大展示数据尺寸, 域名) + "\r\n")
        加入文本 (展示内容, "4.端口: " + 取调试文本2 (最大展示数据尺寸, 端口) + "\r\n")
        加入文本 (展示内容, "5.用户名: " + 取调试文本2 (最大展示数据尺寸, 用户名) + "\r\n")
        加入文本 (展示内容, "6.密码: " + 取调试文本2 (最大展示数据尺寸, 密码) + "\r\n")
        加入文本 (展示内容, "7.路径: " + 取调试文本2 (最大展示数据尺寸, 路径) + "\r\n")
        加入文本 (展示内容, "8.附加信息: " + 取调试文本2 (最大展示数据尺寸, 附加信息))
    }

    # @begin
    # <> <include>
    # inline void SetInfo (LPURL_COMPONENTS urlComp)
    # {
    #     this->ResetObject ();
    #     if (urlComp->dwSchemeLength)    szScheme.SetText (urlComp->lpszScheme, urlComp->dwSchemeLength);
    #     if (urlComp->dwHostNameLength)  szHostName.SetText (urlComp->lpszHostName, urlComp->dwHostNameLength);
    #     if (urlComp->dwUserNameLength)  szUserName.SetText (urlComp->lpszUserName, urlComp->dwUserNameLength);
    #     if (urlComp->dwPasswordLength)  szPassword.SetText (urlComp->lpszPassword, urlComp->dwPasswordLength);
    #     if (urlComp->dwUrlPathLength)   szUrlPath.SetText (urlComp->lpszUrlPath, urlComp->dwUrlPathLength);
    #     if (urlComp->dwExtraInfoLength) szExtraInfo.SetText (urlComp->lpszExtraInfo, urlComp->dwExtraInfoLength);
    #     nScheme = (INT)urlComp->nScheme; nPort = (INT)urlComp->nPort;
    # }
    # inline LPURL_COMPONENTS GetInfo (LPURL_COMPONENTS urlComp)
    # {
    #     ZeroMemory (urlComp, sizeof(URL_COMPONENTS));
    #     urlComp->dwStructSize = sizeof (URL_COMPONENTS);
    #     if (!szScheme.IsEmpty()) {
    #         urlComp->lpszScheme = (LPWSTR)szScheme.GetText ();
    #         urlComp->dwSchemeLength = (DWORD)szScheme.GetLength ();
    #     }
    #     urlComp->nScheme = (INTERNET_SCHEME)nScheme;
    #     if (!szHostName.IsEmpty()) {
    #         urlComp->lpszHostName = (LPWSTR)szHostName.GetText ();
    #         urlComp->dwHostNameLength = (DWORD)szHostName.GetLength ();
    #     }
    #     urlComp->nPort = (INTERNET_PORT)nPort;
    #     if (!szUserName.IsEmpty()) {
    #         urlComp->lpszUserName = (LPWSTR)szUserName.GetText ();
    #         urlComp->dwUserNameLength = (DWORD)szUserName.GetLength ();
    #     }
    #     if (!szPassword.IsEmpty()) {
    #         urlComp->lpszPassword = (LPWSTR)szPassword.GetText ();
    #         urlComp->dwPasswordLength = (DWORD)szPassword.GetLength ();
    #     }
    #     if (!szUrlPath.IsEmpty()) {
    #         urlComp->lpszUrlPath = (LPWSTR)szUrlPath.GetText ();
    #         urlComp->dwUrlPathLength = (DWORD)szUrlPath.GetLength ();
    #     }
    #     if (!szExtraInfo.IsEmpty()) {
    #         urlComp->lpszExtraInfo = (LPWSTR)szExtraInfo.GetText ();
    #         urlComp->dwExtraInfoLength = (DWORD)szExtraInfo.GetLength ();
    #     }
    #     return urlComp;
    # }
    # <> </include>
    # @end
}

类 WinHTTP自动代理选项类 <公开 基础类 = PIV结构模板 注释 = "用于\"WinHTTP网络类.从URL获取代理/从URL获取代理EX\"." 折叠
        @文档 = "category = \"WinHTTP.辅助类\"" @别名 = "WINHTTP_AUTOPROXY_OPTIONS" @别名类型 = 本地结构
        @模板实现类 = "WinHTTP自动代理选项类">
{
    变量 标志 <公开 类型 = 整数 注释 = "获取PAC文件的方式." 注释 = "请参考\"WinHTTP自动代理标志\"的常量和备注,可以用\"位或\"设置多个标志."
            @输出名 = "dwFlags">
    变量 自动检测选项 <公开 类型 = 整数 注释 = "如果\"标志\"成员包含\"WinHTTP自动代理标志.自动检测\",则本成员必须使用下列三个数值之一:"
            注释 = "  1 使用DHCP定位代理自动配置文件;" 注释 = "  2 使用DNS尝试在本地计算机域上的已知位置定位代理自动配置文件;"
            注释 = "  3 同时使用以上两种方式,优先使用DHCP,若DHCP未发现再用DNS;" 注释 = "不包含\"WinHTTP自动代理标志.自动检测\"时,本成员必须为0."
            @输出名 = "dwAutoDetectFlags">
    变量 自动配置URL <公开 类型 = 常量文本指针 注释 = "如果\"标志\"成员包含\"WinHTTP自动代理标志.配置URL\",则本成员必须指定包含代理自动配置(PAC)文件的URL."
            注释 = "否则,本成员必须为空." @输出名 = "lpszAutoConfigUrl">
    变量 自动登录 <公开 类型 = 逻辑型 注释 = "当WinHTTP请求PAC文件时,是否自动发送客户端的域凭据来响应身份验证." @输出名 = "fAutoLogonIfChallenged">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = WinHTTP自动代理选项类>
    {
        变量 展示内容 <类型 = 文本型>
        展示内容 = "<WinHTTP自动代理选项类> 总共 4 个成员:\r\n"
        加入格式文本 (展示内容, "1.标志: %u\r\n", 欲操作本对象.标志)
        加入格式文本 (展示内容, "2.自动检测选项: %u\r\n", 欲操作本对象.自动检测选项)
        加入格式文本 (展示内容, "3.自动配置URL: %s\r\n", 欲操作本对象.自动配置URL.取文本 ())
        加入格式文本 (展示内容, "4.自动登录: %d", 欲操作本对象.自动登录)
        返回 (展示内容)
    }

    # @begin
    # <> <global>
    # <> <include>
    # static void PivDumpStr(CVolString &strDebug, INT nMaxDumpSize, WINHTTP_AUTOPROXY_OPTIONS* value)
    # {
    #     if (value != nullptr)
    #         strDebug.AddFormatText(L"<WinHTTP自动代理选项类> 总共 4 个成员:\r\n1.标志: %u\r\n2.自动检测选项: %u\r\n3.自动配置URL: %s\r\n4.自动登录: %d",
    #                                value->dwFlags, value->dwAutoDetectFlags, value->lpszAutoConfigUrl, value->fAutoLogonIfChallenged);
    #     else
    #         strDebug.SetText(L"WINHTTP_AUTOPROXY_OPTIONS: nullptr");
    # }
    # <> </include>
    # <> </global>
    # @end
}

类 WinHTTP代理结果类 <公开 基础类 = 扩展对象类 注释 = "用于\"WinHTTP网络类.取代理结果\"." 折叠 @文档 = "category = \"WinHTTP.辅助类\"">
{
    变量 是否为代理 <公开 类型 = 逻辑型 @输出名 = "fProxy">
    变量 是否为跳过列表 <公开 类型 = 逻辑型 @输出名 = "fBypass">
    变量 代理协议 <公开 类型 = 整数 注释 = "1=HTTP; 2=HTTPS; 3=FTP; 4=SOCKS" @输出名 = "ProxyScheme">
    变量 代理域名 <公开 类型 = 文本型 @输出名 = "pwszProxy">
    变量 代理端口 <公开 类型 = 整数 @输出名 = "ProxyPort">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<WinHTTP代理结果类> 总共 5 个成员:\r\n"
        加入文本 (展示内容, "1.是否为代理: " + 取调试文本2 (最大展示数据尺寸, 是否为代理) + "\r\n")
        加入文本 (展示内容, "2.是否为跳过列表: " + 取调试文本2 (最大展示数据尺寸, 是否为跳过列表) + "\r\n")
        加入文本 (展示内容, "3.代理协议: " + 取调试文本2 (最大展示数据尺寸, 代理协议) + "\r\n")
        加入文本 (展示内容, "4.代理域名: " + 取调试文本2 (最大展示数据尺寸, 代理域名) + "\r\n")
        加入文本 (展示内容, "5.代理端口: " + 取调试文本2 (最大展示数据尺寸, 代理端口))
    }

    # @begin
    # <> <include>
    # inline void SetInfo (WINHTTP_PROXY_RESULT_ENTRY stInfo)
    # {
    #     this->ResetObject ();
    #     fProxy = stInfo.fProxy;
    #     fBypass = stInfo.fBypass;
    #     ProxyScheme = (INT)stInfo.ProxyScheme;
    #     if (stInfo.pwszProxy) pwszProxy.SetText (stInfo.pwszProxy);
    #     ProxyPort = (INT)stInfo.ProxyPort;
    # }
    # inline @sn<current_class> (WINHTTP_PROXY_RESULT_ENTRY stInfo) : @sn<current_class>() { this->SetInfo(stInfo); }
    # <> </include>
    # @end
}

类 WinHTTP代理结果数组类 <公开 基础类 = 对象数组模板类 注释 = "用于\"WinHTTP网络类.取代理结果\"." @文档 = "category = \"WinHTTP.辅助类\""
        @模板实现类 = "WinHTTP代理结果类">

类 WinHTTP代理信息类 <公开 基础类 = 扩展对象类 注释 = "用于\"WinHTTP网络类.从URL获取代理/置选项_代理信息/取选项_代理信息\"." 折叠
        @文档 = "category = \"WinHTTP.辅助类\"">
{
    变量 访问类型 <公开 类型 = 访问类型_WinHTTP 注释 = "代理服务器的访问类型" @输出名 = "dwAccessType">
    变量 代理服务器 <公开 类型 = 文本型 注释 = "代理服务器列表,仅在\"访问类型\"为\"命名代理\"时可用."
            注释 = "无论代理是什么协议,都一律填http/https,例如Socoks5的代理也是填: \"http://127.0.0.1:7890\""
            注释 = "可以用分号支持多个代理服务器,也可以对不同的协议使用不同的代理,例如:"
            注释 = "\"http=http://127.0.0.1:7890;https=http://192.168.1.1:8080\"" @输出名 = "lpszProxy">
    变量 代理跳过列表 <公开 类型 = 文本型 值 = "<local>" 注释 = "仅在\"代理类型\"为\"命名代理\"时可用,列表内的域名和IP不会通过代理访问."
            注释 = "请提供用分号分隔的主机域名或IP地址,可以使用通配符." 注释 = "请勿提供空文本,默认的\"<local>\"为忽略所有不含句点的主机名."
            @输出名 = "lpszProxyBypass">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<WinHTTP代理信息类> 总共 3 个成员:\r\n"
        加入文本 (展示内容, "1.访问类型: " + 取调试文本2 (最大展示数据尺寸, 访问类型) + "\r\n")
        加入文本 (展示内容, "2.代理服务器: " + 取调试文本2 (最大展示数据尺寸, 代理服务器) + "\r\n")
        加入文本 (展示内容, "3.代理跳过列表: " + 取调试文本2 (最大展示数据尺寸, 代理跳过列表))
    }

    # @begin
    # <> <include>
    # inline void SetInfo (LPWINHTTP_PROXY_INFO stInfo)
    # {
    #     this->ResetObject ();
    #     dwAccessType = (@dt<访问类型_WinHTTP>)stInfo->dwAccessType;
    #     if (stInfo->lpszProxy) {
    #         lpszProxy.SetText (stInfo->lpszProxy);
    #         GlobalFree (stInfo->lpszProxy);
    #     }
    #     if (stInfo->lpszProxyBypass) {
    #         lpszProxyBypass.SetText (stInfo->lpszProxyBypass);
    #         GlobalFree (stInfo->lpszProxyBypass);
    #     }
    # }
    # inline LPWINHTTP_PROXY_INFO GetInfo (LPWINHTTP_PROXY_INFO stInfo)
    # {
    #     ZeroMemory (stInfo, sizeof(WINHTTP_PROXY_INFO));
    #     stInfo->dwAccessType = (DWORD)dwAccessType;
    #     stInfo->lpszProxy = (LPWSTR)lpszProxy.GetText ();
    #     stInfo->lpszProxyBypass = (LPWSTR)lpszProxyBypass.GetText ();
    #     return stInfo;
    # }
    # <> </include>
    # @end
}

类 WinHTTP用户凭据类 <公开 基础类 = 扩展对象类 注释 = "用于\"WinHTTP网络类.置选项_全局代理凭据\"." 注释 = "包含服务器和代理身份验证的用户凭据信息" 折叠
        @文档 = "category = \"WinHTTP.辅助类\"">
{
    变量 用户名 <公开 类型 = 文本型 @输出名 = "lpszUserName">
    变量 密码 <公开 类型 = 文本型 @输出名 = "lpszPassword">
    变量 领域 <公开 类型 = 文本型 @输出名 = "lpszRealm">
    变量 身份验证方案 <公开 类型 = 整数 注释 = "请参考\"身份验证方案_WinHTTP\"的常量" @输出名 = "dwAuthScheme">
    变量 域名 <公开 类型 = 文本型 @输出名 = "lpszHostName">
    变量 端口 <公开 类型 = 整数 @输出名 = "dwPort">
    变量 URL <公开 类型 = 文本型 @输出名 = "lpszUrl">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<WinHTTP用户凭据类> 总共 7 个成员:\r\n"
        加入文本 (展示内容, "1.用户名: " + 取调试文本2 (最大展示数据尺寸, 用户名) + "\r\n")
        加入文本 (展示内容, "2.密码: " + 取调试文本2 (最大展示数据尺寸, 密码) + "\r\n")
        加入文本 (展示内容, "3.领域: " + 取调试文本2 (最大展示数据尺寸, 领域) + "\r\n")
        加入文本 (展示内容, "4.身份验证方案: " + 取调试文本2 (最大展示数据尺寸, 身份验证方案) + "\r\n")
        加入文本 (展示内容, "5.域名: " + 取调试文本2 (最大展示数据尺寸, 域名) + "\r\n")
        加入文本 (展示内容, "6.端口: " + 取调试文本2 (最大展示数据尺寸, 端口) + "\r\n")
        加入文本 (展示内容, "7.URL: " + 取调试文本2 (最大展示数据尺寸, URL))
    }

    # @begin
    # <> <include>
    # inline void SetInfo (PWINHTTP_CREDS_EX stInfo)
    # {
    #     this->ResetObject ();
    #     if (stInfo->lpszUserName) lpszUserName.SetText (stInfo->lpszUserName);
    #     if (stInfo->lpszPassword) lpszPassword.SetText (stInfo->lpszPassword);
    #     if (stInfo->lpszRealm) lpszRealm.SetText (stInfo->lpszRealm);
    #     dwAuthScheme = (INT)stInfo->dwAuthScheme;
    #     if (stInfo->lpszHostName) lpszHostName.SetText (stInfo->lpszHostName);
    #     dwPort = (INT)stInfo->dwPort;
    #     if (stInfo->lpszUrl) lpszUrl.SetText (stInfo->lpszUrl);
    # }
    # inline PWINHTTP_CREDS_EX GetInfo (PWINHTTP_CREDS_EX stInfo)
    # {
    #     ZeroMemory (stInfo, sizeof(WINHTTP_CREDS_EX));
    #     stInfo->lpszUserName = (LPSTR)lpszUserName.GetText ();
    #     stInfo->lpszPassword = (LPSTR)lpszPassword.GetText ();
    #     stInfo->lpszRealm    = (LPSTR)lpszRealm.GetText ();
    #     stInfo->dwAuthScheme = (DWORD)dwAuthScheme;
    #     stInfo->lpszHostName = (LPSTR)lpszHostName.GetText ();
    #     stInfo->dwPort       = (DWORD)dwPort;
    #     stInfo->lpszUrl      = (LPSTR)lpszUrl.GetText ();
    #     return stInfo;
    # }
    # <> </include>
    # @end
}

类 WinHTTP安全证书类 <公开 基础类 = 扩展对象类 注释 = "用于\"WinHTTP网络类.取选项_安全证书\"." 折叠 @文档 = "category = \"WinHTTP.辅助类\"">
{
    变量 过期日期 <公开 类型 = 长整数 注释 = "证书过期日期,10位时间戳" @输出名 = "ftExpiry">
    变量 生效日期 <公开 类型 = 长整数 注释 = "证书生效日期,10位时间戳" @输出名 = "ftStart">
    变量 颁发给 <公开 类型 = 文本型 注释 = "包含证书所有者的组织、站点和服务器的名称" @输出名 = "lpszSubjectInfo">
    变量 颁发者 <公开 类型 = 文本型 注释 = "包含证书颁发者的组织、站点和服务器的名称" @输出名 = "lpszIssuerInfo">
    变量 协议名称 <公开 类型 = 文本型 注释 = "安全连接的协议名称(目前无用,始终返回空)" @输出名 = "lpszProtocolName">
    变量 签名算法名称 <公开 类型 = 文本型 注释 = "证书的签名算法名称(目前无用,始终返回空)" @输出名 = "lpszSignatureAlgName">
    变量 加密算法名称 <公开 类型 = 文本型 注释 = "证书的加密算法名称(目前无用,始终返回空)" @输出名 = "lpszEncryptionAlgName">
    变量 密钥大小 <公开 类型 = 整数 注释 = "密钥的大小" @输出名 = "dwKeySize">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<WinHTTP安全证书类> 总共 7 个成员:\r\n"
        加入文本 (展示内容, "1.过期日期: " + 取调试文本2 (最大展示数据尺寸, 过期日期) + "\r\n")
        加入文本 (展示内容, "2.生效日期: " + 取调试文本2 (最大展示数据尺寸, 生效日期) + "\r\n")
        加入文本 (展示内容, "3.颁发给: " + 取调试文本2 (最大展示数据尺寸, 颁发给) + "\r\n")
        加入文本 (展示内容, "4.颁发者: " + 取调试文本2 (最大展示数据尺寸, 颁发者) + "\r\n")
        加入文本 (展示内容, "5.协议名称: " + 取调试文本2 (最大展示数据尺寸, 协议名称) + "\r\n")
        加入文本 (展示内容, "6.签名算法名称: " + 取调试文本2 (最大展示数据尺寸, 签名算法名称) + "\r\n")
        加入文本 (展示内容, "7.加密算法名称: " + 取调试文本2 (最大展示数据尺寸, 加密算法名称) + "\r\n")
        加入文本 (展示内容, "8.密钥大小: " + 取调试文本2 (最大展示数据尺寸, 密钥大小))
    }

    # @begin
    # <> <include>
    # inline void SetInfo (PWINHTTP_CERTIFICATE_INFO stInfo)
    # {
    #     this->ResetObject ();
    #     ftExpiry = ((INT64) stInfo->ftExpiry.dwLowDateTime | ((INT64) stInfo->ftExpiry.dwHighDateTime << 32)) / 10000000 - 11644473600;
    #     ftStart = ((INT64) stInfo->ftStart.dwLowDateTime | ((INT64) stInfo->ftStart.dwHighDateTime << 32)) / 10000000 - 11644473600;
    #     if (stInfo->lpszSubjectInfo) {
    #         lpszSubjectInfo.SetText (stInfo->lpszSubjectInfo);
    #         LocalFree (stInfo->lpszSubjectInfo);
    #     }
    #     if (stInfo->lpszIssuerInfo) {
    #         lpszIssuerInfo.SetText (stInfo->lpszIssuerInfo);
    #         LocalFree (&stInfo->lpszIssuerInfo);
    #     }
    #     if (stInfo->lpszProtocolName) {
    #         lpszProtocolName.SetText (stInfo->lpszProtocolName);
    #         LocalFree (stInfo->lpszProtocolName);
    #     }
    #     if (stInfo->lpszSignatureAlgName) {
    #         lpszSignatureAlgName.SetText (stInfo->lpszSignatureAlgName);
    #         LocalFree (stInfo->lpszSignatureAlgName);
    #     }
    #     if (stInfo->lpszEncryptionAlgName) {
    #         lpszEncryptionAlgName.SetText (stInfo->lpszEncryptionAlgName);
    #         LocalFree (stInfo->lpszEncryptionAlgName);
    #     }
    #     dwKeySize = (INT)stInfo->dwKeySize;
    # }
    # <> </include>
    # @end
}

类 WinHTTP请求状态信息类 <公开 基础类 = 扩展对象类 注释 = "用于\"WinHTTP网络类.取选项_请求状态\"."
        注释 = "最低系统要求为Windows 10 Version 1903." 折叠 @文档 = "category = \"WinHTTP.辅助类\"">
{
    变量 标志 <公开 类型 = 长整数 注释 = "为\"请求状态标志_WinHTTP\"中常量的位或组合值" @输出名 = "ullFlags">
    变量 索引 <公开 类型 = 整数 注释 = "表示之前通过共享连接发送了多少个请求" @输出名 = "ulIndex">
    变量 状态统计 <公开 类型 = 长整数数组类 注释 = "各成员的含义请参考\"请求状态索引_WinHTTP\"" @输出名 = "rgullStats">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<WinHTTP请求状态信息类> 总共 3 个成员:\r\n"
        加入文本 (展示内容, "1.标志: " + 取调试文本2 (最大展示数据尺寸, 标志) + "\r\n")
        加入文本 (展示内容, "2.索引: " + 取调试文本2 (最大展示数据尺寸, 索引) + "\r\n")
        加入文本 (展示内容, "4.状态统计: " + 取调试文本2 (最大展示数据尺寸, 状态统计))
    }

    # @begin
    # <> <include>
    # inline void SetInfo (PWINHTTP_REQUEST_STATS stInfo)
    # {
    #     this->ResetObject ();
    #     ullFlags = (INT64)stInfo->ullFlags;
    #     ulIndex = (INT)stInfo->ulIndex;
    #     rgullStats.data ().Copy ((const INT64*)&stInfo->rgullStats[0], (INT)stInfo->cStats);
    # }
    # <> </include>
    # @end
}

类 SecPkgContext_ConnectionInfo类 <公开 基础类 = 扩展对象类 注释 = "用于\"WinHTTP网络类.取选项_安全信息\"."
        注释 = "https://docs.microsoft.com/en-us/windows/win32/api/schannel/ns-schannel-secpkgcontext_connectioninfo"
        折叠 @文档 = "category = \"WinHTTP.辅助类\"">
{
    变量 协议 <公开 类型 = 整数 @输出名 = "dwProtocol">
    变量 密码算法 <公开 类型 = 整数 @输出名 = "aiCipher">
    变量 密码强度 <公开 类型 = 整数 @输出名 = "dwCipherStrength">
    变量 哈希算法 <公开 类型 = 整数 @输出名 = "aiHash">
    变量 哈希强度 <公开 类型 = 整数 @输出名 = "dwHashStrength">
    变量 密钥交换算法 <公开 类型 = 整数 @输出名 = "aiExch">
    变量 密钥交换强度 <公开 类型 = 整数 @输出名 = "dwExchStrength">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<SecPkgContext_ConnectionInfo类> 总共 7 个成员:\r\n"
        加入文本 (展示内容, "1.协议: " + 取调试文本2 (最大展示数据尺寸, 协议) + "\r\n")
        加入文本 (展示内容, "2.密码算法: " + 取调试文本2 (最大展示数据尺寸, 密码算法) + "\r\n")
        加入文本 (展示内容, "3.密码强度: " + 取调试文本2 (最大展示数据尺寸, 密码强度) + "\r\n")
        加入文本 (展示内容, "4.哈希算法: " + 取调试文本2 (最大展示数据尺寸, 哈希算法) + "\r\n")
        加入文本 (展示内容, "5.哈希强度: " + 取调试文本2 (最大展示数据尺寸, 哈希强度) + "\r\n")
        加入文本 (展示内容, "6.密钥交换算法: " + 取调试文本2 (最大展示数据尺寸, 密钥交换算法) + "\r\n")
        加入文本 (展示内容, "7.密钥交换强度: " + 取调试文本2 (最大展示数据尺寸, 密钥交换强度))
    }

    # @begin
    # <> <include>
    # inline void SetInfo (PSecPkgContext_ConnectionInfo stInfo)
    # {
    #     this->ResetObject ();
    #     dwProtocol = (INT)stInfo->dwProtocol;
    #     aiCipher = (INT)stInfo->aiCipher;
    #     dwCipherStrength = (INT)stInfo->dwCipherStrength;
    #     aiHash = (INT)stInfo->aiHash;
    #     dwHashStrength = (INT)stInfo->dwHashStrength;
    #     aiExch = (INT)stInfo->aiExch;
    #     dwExchStrength = (INT)stInfo->dwExchStrength;
    # }
    # <> </include>
    # @end
}

类 SecPkgContext_CipherInfo类 <公开 基础类 = 扩展对象类 注释 = "用于\"WinHTTP网络类.取选项_安全信息\"."
        注释 = "https://docs.microsoft.com/en-us/windows/win32/api/schannel/ns-schannel-secpkgcontext_cipherinfo"
        折叠 @文档 = "category = \"WinHTTP.辅助类\"">
{
    变量 版本 <公开 类型 = 整数 @输出名 = "dwVersion">
    变量 协议 <公开 类型 = 整数 @输出名 = "dwProtocol">
    变量 密码套件 <公开 类型 = 整数 @输出名 = "dwCipherSuite">
    变量 基本密码套件 <公开 类型 = 整数 @输出名 = "dwBaseCipherSuite">
    变量 密码套件文本 <公开 类型 = 文本型 @输出名 = "szCipherSuite">
    变量 密码 <公开 类型 = 文本型 @输出名 = "szCipher">
    变量 密码长度 <公开 类型 = 整数 @输出名 = "dwCipherLen">
    变量 密码块长度 <公开 类型 = 整数 @输出名 = "dwCipherBlockLen">
    变量 哈希 <公开 类型 = 文本型 @输出名 = "szHash">
    变量 哈希长度 <公开 类型 = 整数 @输出名 = "dwHashLen">
    变量 密钥交换 <公开 类型 = 文本型 @输出名 = "szExchange">
    变量 最小交换长度 <公开 类型 = 整数 @输出名 = "dwMinExchangeLen">
    变量 最大交换长度 <公开 类型 = 整数 @输出名 = "dwMaxExchangeLen">
    变量 证书 <公开 类型 = 文本型 @输出名 = "szCertificate">
    变量 密钥类型 <公开 类型 = 整数 @输出名 = "dwKeyType">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<SecPkgContext_CipherInfo类> 总共 14 个成员:\r\n"
        加入文本 (展示内容, "1.版本: " + 取调试文本2 (最大展示数据尺寸, 版本) + "\r\n")
        加入文本 (展示内容, "2.协议: " + 取调试文本2 (最大展示数据尺寸, 协议) + "\r\n")
        加入文本 (展示内容, "3.密码套件: " + 取调试文本2 (最大展示数据尺寸, 密码套件) + "\r\n")
        加入文本 (展示内容, "4.基本密码套件: " + 取调试文本2 (最大展示数据尺寸, 基本密码套件) + "\r\n")
        加入文本 (展示内容, "5.密码套件文本: " + 取调试文本2 (最大展示数据尺寸, 密码套件文本) + "\r\n")
        加入文本 (展示内容, "6.密码: " + 取调试文本2 (最大展示数据尺寸, 密码) + "\r\n")
        加入文本 (展示内容, "7.密码块长度: " + 取调试文本2 (最大展示数据尺寸, 密码块长度) + "\r\n")
        加入文本 (展示内容, "8.哈希: " + 取调试文本2 (最大展示数据尺寸, 哈希) + "\r\n")
        加入文本 (展示内容, "9.哈希长度: " + 取调试文本2 (最大展示数据尺寸, 哈希长度) + "\r\n")
        加入文本 (展示内容, "10.密钥交换: " + 取调试文本2 (最大展示数据尺寸, 密钥交换) + "\r\n")
        加入文本 (展示内容, "11.最小交换长度: " + 取调试文本2 (最大展示数据尺寸, 最小交换长度) + "\r\n")
        加入文本 (展示内容, "12.最大交换长度: " + 取调试文本2 (最大展示数据尺寸, 最大交换长度) + "\r\n")
        加入文本 (展示内容, "13.证书: " + 取调试文本2 (最大展示数据尺寸, 证书) + "\r\n")
        加入文本 (展示内容, "14.密钥类型: " + 取调试文本2 (最大展示数据尺寸, 密钥类型))
    }

    # @begin
    # <> <include>
    # inline void SetInfo (PSecPkgContext_CipherInfo stInfo)
    # {
    #     this->ResetObject ();
    #     dwVersion = (INT)stInfo->dwVersion;
    #     dwProtocol = (INT)stInfo->dwProtocol;
    #     dwCipherSuite = (INT)stInfo->dwCipherSuite;
    #     dwBaseCipherSuite = (INT)stInfo->dwBaseCipherSuite;
    #     if (stInfo->szCipherSuite) szCipherSuite.SetText (stInfo->szCipherSuite);
    #     if (stInfo->szCipher) szCipher.SetText (stInfo->szCipher);
    #     dwCipherLen = (INT)stInfo->dwCipherLen;
    #     dwCipherBlockLen = (INT)stInfo->dwCipherBlockLen;
    #     if (stInfo->szHash) szHash.SetText (stInfo->szHash);
    #     dwHashLen = (INT)stInfo->dwHashLen;
    #     if (stInfo->szExchange) szExchange.SetText (stInfo->szExchange);
    #     dwMinExchangeLen = (INT)stInfo->dwMinExchangeLen;
    #     dwMaxExchangeLen = (INT)stInfo->dwMaxExchangeLen;
    #     if (stInfo->szCertificate) szCertificate.SetText (stInfo->szCertificate);
    #     dwKeyType = (INT)stInfo->dwKeyType;
    # }
    # <> </include>
    # @end
}

类 WinHTTP安全信息类 <公开 基础类 = 扩展对象类 注释 = "用于\"WinHTTP网络类.取选项_安全信息\"." 折叠 @文档 = "category = \"WinHTTP.辅助类\"">
{
    变量 连接信息 <公开 类型 = SecPkgContext_ConnectionInfo类 @输出名 = "ConnectionInfo">
    变量 密文信息 <公开 类型 = SecPkgContext_CipherInfo类 注释 = "证书生效日期" @输出名 = "CipherInfo">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<WinHTTP安全信息类> 总共 2 个成员:\r\n"
        加入文本 (展示内容, "1.连接信息: " + 取调试文本2 (最大展示数据尺寸, 连接信息) + "\r\n")
        加入文本 (展示内容, "2.密文信息: " + 取调试文本2 (最大展示数据尺寸, 密文信息))
    }

    # @begin
    # <> <include>
    # inline void SetInfo (PWINHTTP_SECURITY_INFO stInfo)
    # {
    #     this->ResetObject ();
    #     ConnectionInfo.SetInfo (&stInfo->ConnectionInfo);
    #     CipherInfo.SetInfo (&stInfo->CipherInfo);
    # }
    # <> </include>
    # @end
}

类 WinHTTP异步结果类 <公开 基础类 = PIV指针模板 注释 = "用于WinHTTP的异步操作" 折叠 @文档 = "category = \"WinHTTP.辅助类\""
        @别名 = "LPWINHTTP_ASYNC_RESULT" @模板实现类 = "WinHTTP异步结果类">
{
    变量 返回值 <公开 类型 = 无符号整数 注释 = "请参考\"异步请求结果_WinHTTP\"中的常量" @输出名 = "dwResult">
    变量 错误码 <公开 类型 = 无符号整数 注释 = "异步函数的错误代码" @输出名 = "dwError">

    # @begin
    # <> <global>
    # <> <include>
    # static void PivDumpStr(CVolString &strDebug, INT nMaxDumpSize, LPWINHTTP_ASYNC_RESULT value)
    # {
    #     if (value != nullptr)
    #         strDebug.AddFormatText(L"<WinHTTP异步结果类> 总共 2 个成员:\r\n1.返回值: %u\r\n2.错误码: %u", value->dwResult, value->dwError);
    #     else
    #         strDebug.SetText(L"nullptr");
    # }
    # <> </include>
    # <> </global>
    # @end
}

类 WebSocket状态类 <公开 基础类 = 扩展对象类 注释 = "用于WebSocket的异步操作,最低系统要求为Windows 8" 折叠
        @文档 = "category = \"WinHTTP.辅助类\"">
{
    变量 传输字节数 <公开 类型 = 整数 @输出名 = "dwBytesTransferred">
    变量 错误码 <公开 类型 = 整数 注释 = "请参考\"缓冲区类型_WinHTTP\"中的常量" @输出名 = "eBufferType">

    方法 置数据 <公开 折叠 @嵌入式方法 = "">
    参数 结构体指针 <类型 = 变整数>
    {
        @ @sn<this>.SetInfo ((WINHTTP_WEB_SOCKET_STATUS*)@<结构体指针>)
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<WebSocket状态类> 总共 2 个成员:\r\n"
        加入文本 (展示内容, "1.传输字节数: " + 取调试文本2 (最大展示数据尺寸, 传输字节数) + "\r\n")
        加入文本 (展示内容, "2.错误码: " + 取调试文本2 (最大展示数据尺寸, 错误码))
    }

    # @begin
    # <> <include>
    # inline void SetInfo (WINHTTP_WEB_SOCKET_STATUS* stInfo)
    # {
    #     this->ResetObject ();
    #     dwBytesTransferred =  (INT)*stInfo->dwBytesTransferred;
    #     eBufferType =  (INT)stInfo->eBufferType;
    # }
    # <> </include>
    # @end
}

类 协议头键值对类 <公开 基础类 = 通用排序表模板 注释 = "文本到字节集哈希表" @文档 = "category = \"WinHTTP.辅助类\"" @模板实现类 = "文本型, 字节集类">

类 连接组类 <公开 基础类 = 扩展对象类 注释 = "用于\"WinHTTP网络类.取连接组状态\"." 注释 = "此为Windows 11新增的API,之前的系统不可用." 折叠
        @文档 = "category = \"WinHTTP.辅助类\"">
{
    变量 连接数量 <公开 类型 = 整数 @输出名 = "cConnections">
    变量 GUID组 <公开 类型 = 文本型 @输出名 = "guidGroup">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<连接组类> 总共 2 个成员:\r\n"
        加入文本 (展示内容, "1.连接数量: " + 取调试文本2 (最大展示数据尺寸, 连接数量) + "\r\n")
        加入文本 (展示内容, "2.GUID组: " + 取调试文本2 (最大展示数据尺寸, GUID组))
    }

    # @begin
    # <> <include>
    # inline void SetInfo (PWINHTTP_CONNECTION_GROUP stInfo)
    # {
    #     this->ResetObject ();
    #     cConnections = (INT)stInfo->cConnections;
    #     WCHAR acGUID [64];
    #     acGUID [0] = '\0';
    #     ::StringFromGUID2 (stInfo->guidGroup, acGUID, NUM_ELEMENTS_OF (acGUID));
    #     guidGroup.SetText (acGUID);
    # }
    # inline @sn<current_class> (PWINHTTP_CONNECTION_GROUP stInfo) : @sn<current_class>() { this->SetInfo(stInfo); }
    # <> </include>
    # @end
}

类 连接组数组类 <公开 基础类 = 对象数组模板类 注释 = "用于\"WinHTTP网络类.取连接组状态\"." 注释 = "此为Windows 11新增的API,之前的系统不可用."
        @文档 = "category = \"WinHTTP.辅助类\"" @模板实现类 = "连接组类">

类 主机连接组类 <公开 基础类 = 扩展对象类 注释 = "用于\"WinHTTP网络类.取连接组状态\"." 注释 = "此为Windows 11新增的API,之前的系统不可用." 折叠
        @文档 = "category = \"WinHTTP.辅助类\"">
{
    变量 主机名 <公开 类型 = 文本型 @输出名 = "pwszHost">
    变量 连接组数量 <公开 类型 = 整数 @输出名 = "cConnectionGroups">
    变量 连接组 <公开 类型 = 连接组数组类 @输出名 = "pConnectionGroups">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<主机连接组类> 总共 2 个成员:\r\n"
        加入文本 (展示内容, "1.主机名: " + 取调试文本2 (最大展示数据尺寸, 主机名) + "\r\n")
        加入文本 (展示内容, "2.连接组数量: " + 取调试文本2 (最大展示数据尺寸, 连接组数量) + "\r\n")
        加入文本 (展示内容, "3.连接组: " + 取调试文本2 (最大展示数据尺寸, 连接组))
    }
}

类 主机连接组数组类 <公开 基础类 = 对象数组模板类 注释 = "用于\"WinHTTP网络类.取连接组状态\"." 注释 = "此为Windows 11新增的API,之前的系统不可用."
        @文档 = "category = \"WinHTTP.辅助类\"" @模板实现类 = "主机连接组类">

# WinHTTP 常量 ===

类 访问类型_WinHTTP <公开 注释 = "用于\"WinHTTP网络类.初始化\"." 折叠 @文档 = "category = \"WinHTTP.常量类\"" @常量类 = 整数>
{
    常量 不使用代理 <公开 值 = @WINHTTP_ACCESS_TYPE_NO_PROXY 注释 = "不使用代理直接解析所有主机域名.">
    常量 默认代理 <公开 值 = @WINHTTP_ACCESS_TYPE_DEFAULT_PROXY 注释 = "从注册表中获取静态的代理设置.此类型不会继承浏览器的代理设置."
            注释 = "Windows 8.1及更高版本推荐使用\"自动代理\"." 注释 = "这里的代理配置由下列方式之一设置:" 注释 = " - proxycfg.exe"
            注释 = " - netsh.exe" 注释 = " - WinHttpSetDefaultProxyConfiguration">
    常量 命名代理 <公开 值 = @WINHTTP_ACCESS_TYPE_NAMED_PROXY 注释 = "将请求传递给代理,除非要解析的名称在代理跳过列表中."
            注释 = "本类型需要设置\"代理服务器\"和\"代理跳过列表\"参数.">
    常量 自动代理 <公开 值 = 4 注释 = "使用系统和各用户的代理设置来确定要使用的代理." 注释 = "注意: 仅在Windows 8.1及更高版本中受支持.">
}

类 请求方式_WinHTTP <公开 注释 = "用于\"WinHTTP网络类.打开请求\",包含了网页访问的请求方式." 折叠 @文档 = "category = \"WinHTTP.常量类\""
        @常量类 = 文本型>
{
    常量 GET <公开 值 = "GET">
    常量 POST <公开 值 = "POST">
    常量 HEAD <公开 值 = "HEAD">
    常量 PUT <公开 值 = "PUT">
    常量 OPTIONS <公开 值 = "OPTIONS">
    常量 DELETE <公开 值 = "DELETE">
    常量 TRACE <公开 值 = "TRACE">
    常量 CONNECT <公开 值 = "CONNECT">
    常量 PATCH <公开 值 = "PATCH">
}

类 URL操作_WinHTTP <公开 注释 = "用于\"WinHTTP网络类.拆分URL/创建URL\"." 折叠 @文档 = "category = \"WinHTTP.常量类\"">
{
    常量 URL解码 <公开 类型 = 整数 值 = @ICU_DECODE 注释 = "对URL的路径以后的部分进行URL解码,所有转义序列(%xx)将转换成字符."
            注释 = "不能和选项\"URL编码\"一起使用,且不能用于方法\"WinHTTP网络类.创建URL\".">
    常量 URL编码 <公开 类型 = 整数 值 = @ICU_ESCAPE 注释 = "对URL的路径以后部分进行URL编码,所有不安全的字符将转换成转义序列(%xx).">
    常量 拒绝用户密码 <公开 类型 = 整数 值 = @ICU_REJECT_USERPWD 注释 = "如果URL中含有用户名和密码等凭据信息,则拒绝进行拆分和创建,返回失败.">
}

类 请求标志_WinHTTP <公开 注释 = "用于\"WinHTTP网络类.打开请求\"." 折叠 @文档 = "category = \"WinHTTP.常量类\"">
{
    常量 安全连接 <公开 类型 = 整数 值 = @WINHTTP_FLAG_SECURE 注释 = "尝试使用SSL安全连接,HTTPS必须使用此标志.">
    常量 URL编码 <公开 类型 = 整数 值 = @WINHTTP_FLAG_ESCAPE_PERCENT 注释 = "将URL路径进行URL编码,所有不安全的字符都将转换为以%字符开头的转义序列."
            注释 = "默认情况下,除了百分百符号之外的所有不安全字符都将转换为转义序列.">
    常量 不使用编码 <公开 类型 = 整数 值 = @WINHTTP_FLAG_NULL_CODEPAGE 注释 = "假设URL路径中的宽字符都可以转换为有效的ANSI字符,不进行任何编码,"
            注释 = "此选项不会检查不安全的字符.">
    常量 忽略代理缓存 <公开 类型 = 整数 值 = @WINHTTP_FLAG_BYPASS_PROXY_CACHE 注释 = "此选项等同\"强制刷新\".">
    常量 强制刷新 <公开 类型 = 整数 值 = @WINHTTP_FLAG_REFRESH 注释 = "将请求转发给原始服务器,而不是从代理服务器发送资源的缓存版本."
            注释 = "使用此选项时会将\"Pragma: no-cache\"添加到请求头." 注释 = "如果使用HTTP/1.1,还会添加\"Cache-Control: no-cache\".">
    常量 禁止转义 <公开 类型 = 整数 值 = @WINHTTP_FLAG_ESCAPE_DISABLE 注释 = "不将URL路径的不安全字符转换为转义序列.">
    常量 不转义参数 <公开 类型 = 整数 值 = @WINHTTP_FLAG_ESCAPE_DISABLE_QUERY 注释 = "对URL的路径部分进行转义,但不转义URL的请求参数部分.">
}

类 请求头修改方式_WinHTTP <公开 注释 = "用于添加请求头的各种方法" 折叠 @文档 = "category = \"WinHTTP.常量类\"">
{
    常量 添加请求头 <公开 类型 = 整数 值 = @WINHTTP_ADDREQ_FLAG_ADD 注释 = "请求头不存在时添加,可与\"替换和删除\"一起使用.">
    常量 仅新建添加 <公开 类型 = 整数 值 = @WINHTTP_ADDREQ_FLAG_ADD_IF_NEW 注释 = "仅在添加的请求头不存在时才添加,否则将返回错误.">
    常量 合并请求头 <公开 类型 = 整数 值 = @WINHTTP_ADDREQ_FLAG_COALESCE 注释 = "合并同名的请求头,等同于\"以逗号合并\".">
    常量 以逗号合并 <公开 类型 = 整数 值 = @WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA
            注释 = "使用逗号合并同名的协议头,必须确保该协议头是以逗号分隔多个值."
            注释 = "例如: 将\"Accept: text/*\"跟\"Accept: audio/*\"一起添加,会产生协议头\"Accept: text/*, audio/*\".">
    常量 以分号合并 <公开 类型 = 整数 值 = @WINHTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON
            注释 = "使用分号合并同名的协议头,必须确保该协议头是以分号分隔多个值.">
    常量 替换和删除 <公开 类型 = 整数 值 = @WINHTTP_ADDREQ_FLAG_REPLACE 注释 = "替换或删除请求头.如果提供请求头的值不为空则将其替换."
            注释 = "如果提供的请求头为空且缓存中存在同名请求头,则将其删除.">
}

类 禁止功能标志_WinHTTP <公开 注释 = "用于\"WinHTTP网络类.置选项_禁止功能\"" 折叠 @文档 = "category = \"WinHTTP.常量类\"">
{
    常量 禁止Cookies <公开 类型 = 整数 值 = @WINHTTP_DISABLE_COOKIES
            注释 = "禁止将Cookie协议头添加到请求中,返回的Cookie也不会自动添加到Cookie数据库中.">
    常量 禁止重定向 <公开 类型 = 整数 值 = @WINHTTP_DISABLE_REDIRECTS 注释 = "禁止在发送请求时自动重定向.">
    常量 禁止自动身份验证 <公开 类型 = 整数 值 = @WINHTTP_DISABLE_AUTHENTICATION 注释 = "禁止自动身份验证.">
    常量 禁止保持活动 <公开 类型 = 整数 值 = @WINHTTP_DISABLE_KEEP_ALIVE 注释 = "禁止使用保持活动.">
}

类 自动代理标志_WinHTTP <公开 注释 = "用于\"WinHTTP自动代理选项类\"的参数\"标志\"." 折叠 @文档 = "category = \"WinHTTP.常量类\"">
{
    常量 自动检测 <公开 类型 = 整数 值 = 0x00000001 注释 = "尝试使用DHCP和DNS查询,在本地网络自动发现PAC文件的URL.">
    常量 配置URL <公开 类型 = 整数 值 = 0x00000002 注释 = "从\"WinHTTP自动代理选项类.自动配置URL\"参数中指定的URL下载PAC文件.">
    常量 维持域名大小写 <公开 类型 = 整数 值 = 0x00000004 注释 = "维持传递给PAC脚本的域名大小写,这是默认行为.">
    常量 小写域名 <公开 类型 = 整数 值 = 0x00000008 注释 = "将域名转换为小写再传递给PAC脚本.">
    常量 允许自动配置 <公开 类型 = 整数 值 = 0x00000100 注释 = "通过自动配置URL启用代理检测.">
    常量 允许静态配置 <公开 类型 = 整数 值 = 0x00000200 注释 = "通过静态配置URL启用代理检测.">
    常量 允许连接管理器 <公开 类型 = 整数 值 = 0x00000400 注释 = "通过连接管理器URL启用代理检测.">
    常量 在进程中运行 <公开 类型 = 整数 值 = 0x00010000 注释 = "在进程内执行Web代理自动发现(WPAD)协议,而不是委派给进程外可用的WinHTTP自动代理服务."
            注释 = "此标志必须与其他标志之一组合,此标志在传递给\"从URL获取代理EX\"时无效." 注释 = "请注意此标志已经过时.">
    常量 仅在进程外运行 <公开 类型 = 整数 值 = 0x00020000 注释 = "如果在进程外发现代理失败,默认情况下会回退到当前进程进行自动发现."
            注释 = "如果你不想出现此回退行为,可以设置本标志禁用它." 注释 = "此标志在传递给\"从URL获取代理EX\"时无效,注意此标志仅在Windows Server 2003上可用.">
    常量 禁止直接访问 <公开 类型 = 整数 值 = 0x00040000 注释 = "禁止此请求查询直接访问代理设置.">
    常量 进程缓存客户端 <公开 类型 = 整数 值 = 0x00080000 注释 = "禁止将域名查询到当前进程的代理缓存脚本执行结果中.">
    常量 进程缓存服务器 <公开 类型 = 整数 值 = 0x00100000 注释 = "禁止将域名查询到自动代理服务器的代理缓存脚本执行结果中.">
    常量 对结果排序 <公开 类型 = 整数 值 = 0x00400000 注释 = "根据代理速度从快到慢的方式对代理结果进行排序.">
}

类 协议头标志_WinHTTP <公开 注释 = "在WinHTTP网络类取协议头时使用." 折叠 @文档 = "category = \"WinHTTP.常量类\"" @常量类 = 整数>
{
    常量 MIME版本 <公开 值 = @WINHTTP_QUERY_MIME_VERSION 注释 = "MIME-Version: 表示使用的MIME的版本号,一般是1.0;">
    常量 内容类型 <公开 值 = @WINHTTP_QUERY_CONTENT_TYPE 注释 = "Content_Type(响应): 表示主体内容的媒体类型.">
    常量 内容传输编码 <公开 值 = @WINHTTP_QUERY_CONTENT_TRANSFER_ENCODING
            注释 = "Content-Transfer-Encoding: 传输过程中的内容编码格式.">
    常量 内容识别符 <公开 值 = @WINHTTP_QUERY_CONTENT_ID 注释 = "Content-Id(响应): 内容的唯一标识符.">
    常量 内容描述 <公开 值 = @WINHTTP_QUERY_CONTENT_DESCRIPTION 注释 = "Content-Description(响应): 内容的可选描述文本(已淘汰).">
    常量 内容长度 <公开 值 = @WINHTTP_QUERY_CONTENT_LENGTH 注释 = "Content-Length(响应): 实体主体部分的大小长度(字节).">
    常量 内容语言 <公开 值 = @WINHTTP_QUERY_CONTENT_LANGUAGE
            注释 = "Content-Language(响应): 告知客户端,实体主体使用的自然语言(指中文或英文等).">
    常量 允许方法 <公开 值 = @WINHTTP_QUERY_ALLOW 注释 = "Allow(响应): 服务器支持哪些请求方式(如GET、POST等).">
    常量 公开 <公开 值 = @WINHTTP_QUERY_PUBLIC 注释 = "Public: 接收此服务器上可用的HTTP谓词.">
    常量 日期 <公开 值 = @WINHTTP_QUERY_DATE 注释 = "Date(通用): 当前的GMT时间.">
    常量 过期时间 <公开 值 = @WINHTTP_QUERY_EXPIRES 注释 = "Expires(响应): 文档的过期时间,过期后不再缓存它.">
    常量 最后修改时间 <公开 值 = @WINHTTP_QUERY_LAST_MODIFIED 注释 = "Last-Modified(响应): 文档的最后改动时间.">
    常量 信息识别符 <公开 值 = @WINHTTP_QUERY_MESSAGE_ID 注释 = "Message-Id: 信息的唯一标识符.">
    常量 URI <公开 值 = @WINHTTP_QUERY_URI 注释 = "Uri: 接收部分或全部URI,通过这些URI可以识别请求URI资源.">
    常量 "//" <值 = @WINHTTP_QUERY_DERIVED_FROM 注释 = "(不再支持)">
    常量 "//" <值 = @WINHTTP_QUERY_COST 注释 = "(不再支持)">
    常量 链接 <公开 值 = @WINHTTP_QUERY_LINK 注释 = "Link: 链接(已淘汰)">
    常量 指令 <公开 值 = @WINHTTP_QUERY_PRAGMA
            注释 = "Pragma(通用): 包含实现特定的指令,最常用的是Pragma:no-cache,它的含义和Cache-Control:no-cache相同.">
    常量 HTTP版本 <公开 值 = @WINHTTP_QUERY_VERSION 注释 = "返回状态行的HTTP版本 [取响应头EX不可用]">
    常量 状态码 <公开 值 = @WINHTTP_QUERY_STATUS_CODE 注释 = "返回HTTP的状态码 [取响应头EX不可用]">
    常量 状态文本 <公开 值 = @WINHTTP_QUERY_STATUS_TEXT 注释 = "返回HTTP状态码的附加描述文本,比如200状态码是\"OK\". [取响应头EX不可用]">
    常量 所有标头 <公开 值 = @WINHTTP_QUERY_RAW_HEADERS 注释 = "返回所有标头,标头之间以\\0分隔.">
    常量 所有标头_换行 <公开 值 = @WINHTTP_QUERY_RAW_HEADERS_CRLF 注释 = "返回所有标头,标头之间以换行符分隔. [取响应头EX不可用]">
    常量 连接 <公开 值 = @WINHTTP_QUERY_CONNECTION 注释 = "Connection(通用): 指定是否需要持久连接.">
    常量 接受媒体 <公开 值 = @WINHTTP_QUERY_ACCEPT 注释 = "Accept(请求): 告诉服务器自己接受什么媒体类型.">
    常量 接受字符集 <公开 值 = @WINHTTP_QUERY_ACCEPT_CHARSET 注释 = "Accept-Charset(请求): 告诉服务器自己能接收的字符集.">
    常量 接受编码 <公开 值 = @WINHTTP_QUERY_ACCEPT_ENCODING 注释 = "Accept-Encoding(请求): 告诉服务器自己能接收的编码方法,通常指定压缩方法.">
    常量 接受语言 <公开 值 = @WINHTTP_QUERY_ACCEPT_LANGUAGE
            注释 = "Accept-Language(请求): 申明客户端能接收的语言. 中文是语言,中文有多种字符集,比如big5、gb2312、gbk.">
    常量 授权 <公开 值 = @WINHTTP_QUERY_AUTHORIZATION
            注释 = "Authorization(请求): 客户端接收到来自服务器的WWW-Authenticate响应时,用该头部来回应自己的身份验证信息给WEB服务器.">
    常量 内容编码 <公开 值 = @WINHTTP_QUERY_CONTENT_ENCODING 注释 = "Content_Encoding(响应): 告知客户端服务器对主体部分选用的内容编码方式.">
    常量 转发 <公开 值 = @WINHTTP_QUERY_FORWARDED 注释 = "Forwarder: 转发(已淘汰)">
    常量 寄件人 <公开 值 = @WINHTTP_QUERY_FROM 注释 = "From(请求): 告知服务器使用用户代理的用户的电子邮件地址.">
    常量 自日期以来已修改 <公开 值 = @WINHTTP_QUERY_IF_MODIFIED_SINCE
            注释 = "If-Modified-Since(请求): 请求对象在该字段指定的时间之后修改了,才会继续执行请求.">
    常量 重定向 <公开 值 = @WINHTTP_QUERY_LOCATION 注释 = "Location(响应): 重定向的地址,会引导客户端尝试访问新的地址.">
    常量 来源地址 <公开 值 = @WINHTTP_QUERY_ORIG_URI 注释 = "Orig-Uri: (已淘汰)">
    常量 来源 <公开 值 = @WINHTTP_QUERY_REFERER 注释 = "Referer(请求): 表示请求的URL是从哪个Web页面发起的.">
    常量 重试时间 <公开 值 = @WINHTTP_QUERY_RETRY_AFTER 注释 = "Retry-After(响应): 告知客户端应该在多久之后再次发送请求,可用GMT时间格式或秒数.">
    常量 服务器名 <公开 值 = @WINHTTP_QUERY_SERVER 注释 = "Server: 服务器名称,一般为HTTP服务器端应用程序的信息.">
    常量 标题 <公开 值 = @WINHTTP_QUERY_TITLE 注释 = "Title(响应): 标题(已淘汰)">
    常量 用户代理 <公开 值 = @WINHTTP_QUERY_USER_AGENT 注释 = "User-Agent(请求): 将创建请求的游览器和用户代理名称等信息传达给服务器.">
    常量 WWW身份验证 <公开 值 = @WINHTTP_QUERY_WWW_AUTHENTICATE 注释 = "WWW-Authenticate(响应): 将服务器所要求的认证信息发送给客户端.">
    常量 代理身份验证 <公开 值 = @WINHTTP_QUERY_PROXY_AUTHENTICATE
            注释 = "Proxy-Authenticate(响应): 将代理服务器所要求的认证信息发送给客户端.">
    常量 接受范围请求 <公开 值 = @WINHTTP_QUERY_ACCEPT_RANGES 注释 = "Accept-Ranges(响应): 客户端发起范围请求时,服务器用来告知自己是否支持范围请求.">
    常量 设置Cookie <公开 值 = @WINHTTP_QUERY_SET_COOKIE 注释 = "Set-Cookie(响应): 由服务器返回,用于设置和页面关联的Cookie.">
    常量 Cookie <公开 值 = @WINHTTP_QUERY_COOKIE 注释 = "Cookie(请求): 客户端发送到服务器的Cookies.">
    常量 请求方式 <公开 值 = @WINHTTP_QUERY_REQUEST_METHOD 注释 = "返回请求方式,如GET、POST.">
    常量 刷新时间 <公开 值 = @WINHTTP_QUERY_REFRESH 注释 = "Refresh(响应): 表示浏览器应该在多少时间之后刷新文档,以秒计(已淘汰).">
    常量 内容处置 <公开 值 = @WINHTTP_QUERY_CONTENT_DISPOSITION 注释 = "Content-Disposition(响应): 可用来设置文件下载对话框(已淘汰).">
    常量 经过时间 <公开 值 = @WINHTTP_QUERY_AGE 注释 = "Age(响应): 用来告知客户端,源服务器在多久前创建了响应,单位为秒.">
    常量 缓存机制 <公开 值 = @WINHTTP_QUERY_CACHE_CONTROL 注释 = "Cache-Control(通用): 指定请求和响应遵循的缓存机制.">
    常量 内容基点 <公开 值 = @WINHTTP_QUERY_CONTENT_BASE 注释 = "Content-Base: URI的基础地址,用来解析实体的相对URL.">
    常量 内容重定向 <公开 值 = @WINHTTP_QUERY_CONTENT_LOCATION
            注释 = "Content-Location(响应): 当返回的页面内容与实际请求的对象不同时,本字段返回重定向的页面地址.">
    常量 内容MD5 <公开 值 = @WINHTTP_QUERY_CONTENT_MD5 注释 = "Content-MD5(响应): 用于检查主体在传输过程中是否保持完整,以及确认传输到达.">
    常量 内容范围 <公开 值 = @WINHTTP_QUERY_CONTENT_RANGE 注释 = "Content-Range(响应): 范围请求时,告知客户端返回的是实体哪个部分.">
    常量 ETag <公开 值 = @WINHTTP_QUERY_ETAG 注释 = "ETag(响应): 服务器资源的实体标签,当资源发生改变时,ETag值也会更新.">
    常量 主机名 <公开 值 = @WINHTTP_QUERY_HOST 注释 = "Host(请求): 告知服务器,请求的资源所处的互联网主机名和端口号.">
    常量 匹配ETag <公开 值 = @WINHTTP_QUERY_IF_MATCH 注释 = "If-Match(请求): 参数值的ETag跟服务器一致时,才会继续执行请求.">
    常量 不匹配ETag <公开 值 = @WINHTTP_QUERY_IF_NONE_MATCH 注释 = "If-None-Match(请求): 参数值的ETag跟服务器不一致时,才会继续执行请求.">
    常量 范围请求 <公开 值 = @WINHTTP_QUERY_IF_RANGE 注释 = "If-Range(请求): 若字段值跟ETge值或更新日期时间一致,那么就作为范围请求处理.">
    常量 自日期以来未修改 <公开 值 = @WINHTTP_QUERY_IF_UNMODIFIED_SINCE
            注释 = "If-Unmodified-Since(请求): 请求对象在该字段指定的时间之后没有修改,才会继续执行请求.">
    常量 最大转发 <公开 值 = @WINHTTP_QUERY_MAX_FORWARDS 注释 = "Max-Forwards(请求): 服务器转发的最大次数.">
    常量 代理授权 <公开 值 = @WINHTTP_QUERY_PROXY_AUTHORIZATION
            注释 = "Proxy-Authorization(请求): 接受到从代理服务器发来的认证质询时,客户端会发送该请求以告知服务器认证所需要的信息.">
    常量 范围 <公开 值 = @WINHTTP_QUERY_RANGE 注释 = "Range(请求): 范围请求时,告知服务器请求指定范围的资源.">
    常量 传输编码 <公开 值 = @WINHTTP_QUERY_TRANSFER_ENCODING 注释 = "Transfer-Encoding(通用): 传输过程中的编码格式.">
    常量 升级 <公开 值 = @WINHTTP_QUERY_UPGRADE 注释 = "Upgrade(通用): 指定另一种可能完全不同的协议,比如从HTTP升级到WebSocket.">
    常量 VARY <公开 值 = @WINHTTP_QUERY_VARY 注释 = "Vary(响应): 可对缓存进行控制.源服务器会向代理服务器传达关于本地缓存使用方法的指令.">
    常量 经过 <公开 值 = @WINHTTP_QUERY_VIA 注释 = "Via(通用): 列出从客户端到OCS或者相反方向的响应经过了哪些代理服务器,他们用什么协议和版本发送的请求.">
    常量 警告 <公开 值 = @WINHTTP_QUERY_WARNING 注释 = "Warning(通用): 告知用户一些与缓存相关的的问题的警告.">
    常量 期望 <公开 值 = @WINHTTP_QUERY_EXPECT 注释 = "Expect(请求): 客户端用来告知服务器,期望出现的某种特定行为.">
    常量 代理连接 <公开 值 = @WINHTTP_QUERY_PROXY_CONNECTION 注释 = "Proxy-Connection: 代理持久连接.">
    常量 除非自日期以来已被修改 <公开 值 = @WINHTTP_QUERY_UNLESS_MODIFIED_SINCE
            注释 = "Unless-Modified-Since: 用来判断文件是否已被修改,用于断点续传.">
    常量 代理支持 <公开 值 = @WINHTTP_QUERY_PROXY_SUPPORT 注释 = "Proxy-Support:">
    常量 身份验证信息 <公开 值 = @WINHTTP_QUERY_AUTHENTICATION_INFO 注释 = "Authentication-Info:">
    常量 PassportURLs <公开 值 = @WINHTTP_QUERY_PASSPORT_URLS 注释 = "PassportURLs:">
    常量 Passport配置 <公开 值 = @WINHTTP_QUERY_PASSPORT_CONFIG 注释 = "Passport-Config:">
    常量 自定义 <公开 值 = @WINHTTP_QUERY_CUSTOM 注释 = "获取指定名称的标头,需要提供参数\"标头名称\",本标志可以获取常量中没包含的标头.">
}

类 SSL协议_WinHTTP <公开 注释 = "用于\"WinHTTP网络类.置选项_安全协议\"" 折叠 @文档 = "category = \"WinHTTP.常量类\"">
{
    常量 ALL <公开 类型 = 整数 值 = @WINHTTP_FLAG_SECURE_PROTOCOL_ALL 注释 = "可以使用SSL 2.0、SSL 3.0和TLS 1.0协议.">
    常量 SSL2 <公开 类型 = 整数 值 = @WINHTTP_FLAG_SECURE_PROTOCOL_SSL2 注释 = "可以使用SSL 2.0协议.">
    常量 SSL3 <公开 类型 = 整数 值 = @WINHTTP_FLAG_SECURE_PROTOCOL_SSL3 注释 = "可以使用SSL 3.0协议.">
    常量 TLS1 <公开 类型 = 整数 值 = @WINHTTP_FLAG_SECURE_PROTOCOL_TLS1 注释 = "可以使用TLS 1.0协议.">
    常量 TLS1_1 <公开 类型 = 整数 值 = @WINHTTP_FLAG_SECURE_PROTOCOL_TLS1_1 注释 = "可以使用TLS 1.1协议.">
    常量 TLS1_2 <公开 类型 = 整数 值 = @WINHTTP_FLAG_SECURE_PROTOCOL_TLS1_2 注释 = "可以使用TLS 1.2协议.">
    常量 TLS1_3 <公开 类型 = 整数 值 = 0x00002000 注释 = "可以使用TLS 1.3协议.">
}

类 安全标志_WinHTTP <公开 注释 = "用于\"WinHTTP网络类.置选项_安全标志\"" 折叠 @文档 = "category = \"WinHTTP.常量类\"">
{
    常量 忽略未知证书机构 <公开 类型 = 整数 值 = @SECURITY_FLAG_IGNORE_UNKNOWN_CA
            注释 = "允许无效的证书颁发机构.如果设置了此标志,则不会收到WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA回调.">
    常量 忽略无效证书日期 <公开 类型 = 整数 值 = @SECURITY_FLAG_IGNORE_CERT_DATE_INVALID
            注释 = "允许无效的证书日期,即过期或尚未生效的证书.如果设置了此标志,则不会收到WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID回调.">
    常量 忽略无效证书公用名 <公开 类型 = 整数 值 = @SECURITY_FLAG_IGNORE_CERT_CN_INVALID
            注释 = "允许在证书中使用无效的公用名;也就是说,指定的服务器名称与证书中的公用名不匹配.如果设置了此标志,则应用程序不会收到WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID回调.">
    常量 忽略错误使用证书 <公开 类型 = 整数 值 = @SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE 注释 = "允许使用非服务器证书(例如客户端证书)建立服务器的身份.">
    常量 忽略所有证书错误 <公开 类型 = 整数 值 = 0x00003300 注释 = "忽略以上所有的证书错误.">
    常量 安全传输 <公开 类型 = 整数 值 = @SECURITY_FLAG_SECURE 注释 = "使用安全传输,只能在\"取选项\"中返回.">
    常量 弱加密 <公开 类型 = 整数 值 = @SECURITY_FLAG_STRENGTH_WEAK 注释 = "使用弱加密(40位),只能在\"取选项\"中返回.">
    常量 中加密 <公开 类型 = 整数 值 = @SECURITY_FLAG_STRENGTH_MEDIUM 注释 = "使用中等加密(56位),只能在\"取选项\"中返回.">
    常量 强加密 <公开 类型 = 整数 值 = @SECURITY_FLAG_STRENGTH_STRONG 注释 = "使用强加密(128位),只能在\"取选项\"中返回.">
}

类 身份验证方案_WinHTTP <公开 注释 = "用于\"WinHTTP网络类.置凭据\"." 折叠 @文档 = "category = \"WinHTTP.常量类\"">
{
    常量 基本 <公开 类型 = 整数 值 = @WINHTTP_AUTH_SCHEME_BASIC 注释 = "使用基本身份验证.">
    常量 NTLM <公开 类型 = 整数 值 = @WINHTTP_AUTH_SCHEME_NTLM 注释 = "使用NTLM身份验证.">
    常量 Passport <公开 类型 = 整数 值 = @WINHTTP_AUTH_SCHEME_PASSPORT 注释 = "使用Passport身份验证.">
    常量 摘要 <公开 类型 = 整数 值 = @WINHTTP_AUTH_SCHEME_DIGEST 注释 = "使用摘要身份验证.">
    常量 协商 <公开 类型 = 整数 值 = @WINHTTP_AUTH_SCHEME_NEGOTIATE 注释 = "在NTLM和Kerberos身份验证之间进行选择.">
}

类 回调标志_WinHTTP <公开 注释 = "用于\"WinHTTP网络类.置状态回调\"." 折叠 @文档 = "category = \"WinHTTP.常量类\"" @常量类 = 整数>
{
    常量 全部状态完成 <公开 值 = @WINHTTP_CALLBACK_FLAG_ALL_COMPLETIONS 注释 = "在任何完成通知时激活.此标志指定使用读取或写入操作所需的所有通知."
            注释 = "有关完成操作的列表,请参阅\"回调状态标志_WinHTTP\".">
    常量 全部状态通知 <公开 值 = @WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS 注释 = "在任何状态更改通知(包括完成通知)时激活."
            注释 = "有关通知列表,请参阅\"回调状态标志_WinHTTP\".">
    常量 域名解析 <公开 值 = @WINHTTP_CALLBACK_FLAG_RESOLVE_NAME 注释 = "在开始和完成域名解析时激活.">
    常量 连接服务器 <公开 值 = @WINHTTP_CALLBACK_FLAG_CONNECT_TO_SERVER 注释 = "在开始并完成与服务器的连接时激活.">
    常量 检测代理 <公开 值 = @WINHTTP_CALLBACK_FLAG_DETECTING_PROXY 注释 = "在检测到代理服务器时激活.">
    常量 数据可用 <公开 值 = @WINHTTP_CALLBACK_FLAG_DATA_AVAILABLE 注释 = "在完成数据查询时激活.">
    常量 响应头可用 <公开 值 = @WINHTTP_CALLBACK_FLAG_HEADERS_AVAILABLE 注释 = "当响应头可获取时激活.">
    常量 接收数据完成 <公开 值 = @WINHTTP_CALLBACK_FLAG_READ_COMPLETE 注释 = "在完成数据接收操作时激活.">
    常量 请求错误 <公开 值 = @WINHTTP_CALLBACK_FLAG_REQUEST_ERROR 注释 = "在发生异步错误时激活.">
    常量 发送请求 <公开 值 = @WINHTTP_CALLBACK_FLAG_SEND_REQUEST 注释 = "在开始和完成调用\"发送请求/WinHttpSendRequest\"发送请求头时激活.">
    常量 发送请求完成 <公开 值 = @WINHTTP_CALLBACK_FLAG_SENDREQUEST_COMPLETE
            注释 = "当请求头已被\"发送请求/WinHttpSendRequest\"发送完成时激活.">
    常量 发送数据完成 <公开 值 = @WINHTTP_CALLBACK_FLAG_WRITE_COMPLETE 注释 = "在数据POST操作完成后激活.">
    常量 接收响应 <公开 值 = @WINHTTP_CALLBACK_FLAG_RECEIVE_RESPONSE 注释 = "在开始和完成从HTTP服务器接收资源时激活.">
    常量 关闭连接 <公开 值 = @WINHTTP_CALLBACK_FLAG_CLOSE_CONNECTION 注释 = "在开始和完成关闭HTTP连接时激活.">
    常量 句柄操作 <公开 值 = @WINHTTP_CALLBACK_FLAG_HANDLES 注释 = "在创建或关闭HINTERNET句柄时激活.">
    常量 重定向 <公开 值 = @WINHTTP_CALLBACK_FLAG_REDIRECT 注释 = "在重定向请求时激活.">
    常量 中间响应 <公开 值 = @WINHTTP_CALLBACK_FLAG_INTERMEDIATE_RESPONSE 注释 = "在从服务器接收到中间(100级)状态代码消息时激活.">
    常量 安全连接失败 <公开 值 = @WINHTTP_CALLBACK_FLAG_SECURE_FAILURE 注释 = "在安全连接(SSL)失败时激活.">
}

类 回调状态标志_WinHTTP <公开 注释 = "在\"状态回调方法\"中返回" 折叠 @文档 = "category = \"WinHTTP.常量类\"" @常量类 = 整数>
{
    常量 正在解析域名 <公开 值 = @WINHTTP_CALLBACK_STATUS_RESOLVING_NAME 注释 = "[1]正在查找服务器域名的IP地址."
            注释 = "状态信息指针: 所欲解析的域名(文本型指针)">
    常量 解析域名成功 <公开 值 = @WINHTTP_CALLBACK_STATUS_NAME_RESOLVED 注释 = "[2]成功找到服务器的IP地址."
            注释 = "状态信息指针: 服务器IP地址(文本型指针)">
    常量 正在连接服务器 <公开 值 = @WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER 注释 = "[4]正在连接到服务器."
            注释 = "状态信息指针: 服务器的IP地址(文本型指针)">
    常量 连接服务器成功 <公开 值 = @WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER 注释 = "[8]成功连接到服务器."
            注释 = "状态信息指针: 服务器的IP地址(文本型指针)">
    常量 正在发送请求 <公开 值 = @WINHTTP_CALLBACK_STATUS_SENDING_REQUEST 注释 = "[16]正在发送请求信息到服务器." 注释 = "状态信息: 空">
    常量 发送请求成功 <公开 值 = @WINHTTP_CALLBACK_STATUS_REQUEST_SENT 注释 = "[32]成功发送请求信息到服务器."
            注释 = "状态信息指针: 已发送数据的字节长度(整数指针)">
    常量 正在接收响应 <公开 值 = @WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE 注释 = "[64]正在等待服务器对请求的响应." 注释 = "状态信息: 空">
    常量 接收响应成功 <公开 值 = @WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED 注释 = "[128]成功接收服务器的响应."
            注释 = "状态信息指针: 已接收数据的字节长度(整数指针)">
    常量 正在关闭连接 <公开 值 = @WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION 注释 = "[256]正在关闭与服务器的连接." 注释 = "状态信息: 空">
    常量 关闭连接成功 <公开 值 = @WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED 注释 = "[512]成功关闭与服务器的连接." 注释 = "状态信息: 空">
    常量 创建句柄成功 <公开 值 = @WINHTTP_CALLBACK_STATUS_HANDLE_CREATED 注释 = "[1024]创建了一个网络句柄."
            注释 = "状态信息指针: 网络句柄(变整数指针)">
    常量 正在关闭句柄 <公开 值 = @WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING 注释 = "[2048]即将关闭一个网络句柄."
            注释 = "状态信息指针: 网络句柄(变整数指针)">
    常量 正在检测代理 <公开 值 = @WINHTTP_CALLBACK_STATUS_DETECTING_PROXY 注释 = "[4096]">
    常量 重定向 <公开 值 = @WINHTTP_CALLBACK_STATUS_REDIRECT
            注释 = "[16384]HTTP请求即将被自动重定向.你可以在此时接收重定向的响应头,或通过关闭句柄来取消重定向." 注释 = "状态信息指针: 重定向的新URL(文本型指针)">
    常量 中间响应 <公开 值 = @WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE 注释 = "[32768]接收到服务器的中间(100级)状态代码信息."
            注释 = "状态信息指针: 状态代码(整数指针)">
    常量 安全连接失败 <公开 值 = @WINHTTP_CALLBACK_STATUS_SECURE_FAILURE 注释 = "[65536]接收服务器的SSL证书时遇到错误."
            注释 = "状态信息指针: 标志(整数指针)">
    常量 响应头可用 <公开 值 = @WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE 注释 = "[131072]有可用\"取响应头\"获取的响应头."
            注释 = "状态信息: 空">
    常量 数据可用 <公开 值 = @WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE 注释 = "[262144]有可用\"接收数据\"方法获取的数据."
            注释 = "状态信息指针: 数据的字节长度(整数指针)">
    常量 接收数据完成 <公开 值 = @WINHTTP_CALLBACK_STATUS_READ_COMPLETE 注释 = "[524288]成功接收服务器的数据."
            注释 = "状态信息指针: 缓冲区(变整数指针); 状态信息长度: 接收的数据长度;" 注释 = "*当使用WebSocket时."
            注释 = "状态信息指针: 结构体指针,可用\"WebSocket状态类.置数据()\"获取; 状态信息长度: 结构体长度;">
    常量 发送数据完成 <公开 值 = @WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE 注释 = "[1048576]成功发送数据到服务器."
            注释 = "状态信息指针: 已发送数据的字节长度(整数指针);" 注释 = "*当使用WebSocket时."
            注释 = "状态信息指针: 结构体指针,可用\"WebSocket状态类.置数据()\"获取; 状态信息长度: 结构体长度">
    常量 请求错误 <公开 值 = @WINHTTP_CALLBACK_STATUS_REQUEST_ERROR 注释 = "[2097152]发送HTTP请求时发生错误."
            注释 = "状态信息指针: 可用\"WinHTTP异步结果类\"获取,其中的\"返回值\"成员请参考\"异步请求结果_WinHTTP\";">
    常量 发送请求完成 <公开 值 = @WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE 注释 = "[4194304]成功发送请求." 注释 = "状态信息: 空">
    常量 从URL取代理完成 <公开 值 = 0x01000000 注释 = "[16777216]在异步调用\"从URL获取代理EX\"完成时触发,然后可以调用\"接收数据\".">
    常量 WS关闭完成 <公开 值 = 0x02000000 注释 = "[33554432]通过调用\"关闭WebSocket\"关闭连接成功.">
    常量 WS停止完成 <公开 值 = 0x04000000 注释 = "[67108864]通过调用\"停止WebSocket\"停止连接成功.">
    常量 设置发送数据完成 <公开 值 = 0x10000000 注释 = "[268435456]">
    常量 设置接收数据完成 <公开 值 = 0x20000000 注释 = "[536870912]">
}

类 异步请求结果_WinHTTP <公开 注释 = "用于\"回调状态标志_WinHTTP.请求错误\"" 折叠 @文档 = "category = \"WinHTTP.常量类\"" @常量类 = 整数>
{
    常量 接收响应 <公开 值 = @API_RECEIVE_RESPONSE 注释 = "异步执行\"接收响应\"时发生错误.">
    常量 数据可用 <公开 值 = @API_QUERY_DATA_AVAILABLE 注释 = "异步执行\"取可用数据量\"时发生错误.">
    常量 接收数据 <公开 值 = @API_READ_DATA 注释 = "异步执行\"接收数据\"时发生错误.">
    常量 发送数据 <公开 值 = @API_WRITE_DATA 注释 = "异步执行\"发送数据\"时发生错误.">
    常量 发送请求 <公开 值 = @API_SEND_REQUEST 注释 = "异步执行\"发送请求\"时发生错误.">
    常量 从URL获取代理 <公开 值 = 6 注释 = "异步执行\"从URL获取代理\"时发生错误.">
}

类 重置代理_WinHTTP <公开 注释 = "用于\"WinHTTP网络类.重置自动代理\"" 折叠 @文档 = "category = \"WinHTTP.常量类\"">
{
    常量 重置状态 <公开 类型 = 整数 值 = 0x00000001 注释 = "强制刷新并重试当前网络上的非持久性代理信息.">
    常量 重置当前PAD <公开 类型 = 整数 值 = 0x00000002 注释 = "刷新当前网络的PAD(代理自动发现)信息.">
    常量 重置全部PAD <公开 类型 = 整数 值 = 0x00000004 注释 = "刷新所有网络的PAD(代理自动发现)信息">
    常量 重置脚本缓存 <公开 类型 = 整数 值 = 0x00000008 注释 = "刷新代理脚本的持久性HTTP缓存.">
    常量 重置全部 <公开 类型 = 整数 值 = 0x0000FFFF 注释 = "强制刷新并重试当前网络上的所有代理信息.">
    常量 重置并通知网络更改 <公开 类型 = 整数 值 = 0x00010000 注释 = "刷新当前代理信息并通知网络已更改.">
    常量 重置服务器 <类型 = 整数 值 = 0x00020000 注释 = "对自动代理服务而不是当前进程执行操作." 注释 = "\"重置自动代理\"的必须项,已添加在封装的方法中,无需用户传递.">
    常量 丢弃解析器 <公开 类型 = 整数 值 = 0x00040000 注释 = "丢弃代理解析器.">
}

类 缓冲区类型_WinHTTP <公开 注释 = "WebSocket发送和接收数据的缓冲区类型" 注释 = "WINHTTP_WEB_SOCKET_BUFFER_TYPE" 折叠
        @文档 = "category = \"WinHTTP.常量类\"">
{
    常量 完整消息 <公开 类型 = 整数 值 = 0 注释 = "缓冲区包含整个二进制消息或其最后一部分.">
    常量 片段消息 <公开 类型 = 整数 值 = 1 注释 = "缓冲区仅包含二进制消息的一部分.">
    常量 完整UTF8 <公开 类型 = 整数 值 = 2 注释 = "缓冲区包含整个UTF-8消息或其最后一部分.">
    常量 片段UTF8 <公开 类型 = 整数 值 = 3 注释 = "缓冲区仅包含UTF-8消息的一部分.">
    常量 关闭帧 <公开 类型 = 整数 值 = 4 注释 = "服务器发送了一个关闭帧." 注释 = "客户端关闭连接时应使用\"停止WebSocket\"和\"关闭WebSocket\".">
}

类 关闭状态码_WinHTTP <公开 注释 = "WebSocket关闭连接的状态码" 注释 = "WINHTTP_WEB_SOCKET_CLOSE_STATUS" 折叠
        @文档 = "category = \"WinHTTP.常量类\"">
{
    常量 成功关闭 <公开 类型 = 短整数 值 = 1000 注释 = "连接已成功关闭">
    常量 端点终止 <公开 类型 = 短整数 值 = 1001 注释 = "对等端点离开,正在终止连接.">
    常量 协议错误 <公开 类型 = 短整数 值 = 1002 注释 = "发生了协议错误">
    常量 无效数据 <公开 类型 = 短整数 值 = 1003 注释 = "接收到对等端点的无效数据.">
    常量 消息为空 <公开 类型 = 短整数 值 = 1005 注释 = "关闭消息为空">
    常量 连接中止 <公开 类型 = 短整数 值 = 1006 注释 = "连接已中止">
    常量 无效负载 <公开 类型 = 短整数 值 = 1007 注释 = "负载无效">
    常量 违反策略 <公开 类型 = 短整数 值 = 1008 注释 = "消息违反了终端的策略">
    常量 消息太大 <公开 类型 = 短整数 值 = 1009 注释 = "发送的消息太大而无法处理">
    常量 不支持扩展 <公开 类型 = 短整数 值 = 1010 注释 = "客户端期望服务器协商一个或多个扩展,但服务器未在WebSocket握手的响应消息中返回这些扩展.">
    常量 服务器错误 <公开 类型 = 短整数 值 = 1011 注释 = "意外情况使服务器无法实现请求">
    常量 安全握手错误 <公开 类型 = 短整数 值 = 1015 注释 = "TLS握手无法完成">
}

类 请求状态标志_WinHTTP <公开 注释 = "用于\"WinHTTP请求状态信息类\",最低系统要求为Windows 10 Version 1903." 折叠
        @文档 = "category = \"WinHTTP.常量类\"">
{
    常量 TCP快速打开 <公开 类型 = 整数 值 = 0x00000001 注释 = "发生了TCP快速打开">
    常量 TLS会话恢复 <公开 类型 = 整数 值 = 0x00000002 注释 = "发生了TLS会话恢复">
    常量 TLS错误启动 <公开 类型 = 整数 值 = 0x00000004 注释 = "发生了TLS错误启动">
    常量 代理TLS会话恢复 <公开 类型 = 整数 值 = 0x00000008 注释 = "代理连接发生了TLS会话恢复">
    常量 代理TLS错误启动 <公开 类型 = 整数 值 = 0x00000010 注释 = "代理连接发生了TLS错误启动">
    常量 第一个请求 <公开 类型 = 整数 值 = 0x00000020 注释 = "这是连接的第一个请求">
}

类 请求状态索引_WinHTTP <公开 注释 = "用于\"WinHTTP请求状态信息类\",最低系统要求为Windows 10 Version 1903."
        注释 = "WINHTTP_REQUEST_STAT_ENTRY" 折叠 @文档 = "category = \"WinHTTP.常量类\"">
{
    常量 连接失败次数 <公开 类型 = 整数 值 = 0 注释 = "建立连接期间连接失败的次数">
    常量 代理失败次数 <公开 类型 = 整数 值 = 1 注释 = "建立连接期间代理连接失败的次数">
    常量 TLS握手客户端支线1大小 <公开 类型 = 整数 值 = 2 注释 = "TLS握手第一支线的客户端数据的大小">
    常量 TLS握手服务器支线1大小 <公开 类型 = 整数 值 = 3 注释 = "TLS握手第一支线的服务器数据的大小">
    常量 TLS握手客户端支线2大小 <公开 类型 = 整数 值 = 4 注释 = "TLS握手的第二支线的客户端数据的大小">
    常量 TLS握手服务器支线2大小 <公开 类型 = 整数 值 = 5 注释 = "TLS握手的第二支线的服务器数据的大小">
    常量 请求头大小 <公开 类型 = 整数 值 = 6 注释 = "请求头的大小">
    常量 请求头压缩大小 <公开 类型 = 整数 值 = 7 注释 = "请求头的压缩大小">
    常量 响应头大小 <公开 类型 = 整数 值 = 8 注释 = "响应头的大小">
    常量 响应头压缩大小 <公开 类型 = 整数 值 = 9 注释 = "响应头的压缩大小">
    常量 正文大小 <公开 类型 = 整数 值 = 10 注释 = "响应正文的大小">
    常量 正文压缩大小 <公开 类型 = 整数 值 = 11 注释 = "响应正文的压缩大小">
    常量 代理TLS握手客户端支线1大小 <公开 类型 = 整数 值 = 12 注释 = "代理TLS握手的第一支线的客户端数据的大小">
    常量 代理TLS握手服务器支线1大小 <公开 类型 = 整数 值 = 13 注释 = "代理TLS握手的第一支线的服务器数据的大小">
    常量 代理TLS握手客户端支线2大小 <公开 类型 = 整数 值 = 14 注释 = "代理TLS握手的第二支线的客户端数据的大小">
    常量 代理TLS握手服务器支线2大小 <公开 类型 = 整数 值 = 15 注释 = "代理TLS握手的第二支线的服务器数据的大小">
}

类 请求次数索引_WinHTTP <公开 注释 = "用于\"WinHTTP网络类.取选项_请求次数\",最低系统要求为Windows 10 Version 1903."
        注释 = "WINHTTP_REQUEST_TIME_ENTRY" 折叠 @文档 = "category = \"WinHTTP.常量类\"">
{
    常量 代理检测开始 <公开 类型 = 整数 值 = 0 注释 = "代理检测的开始时间">
    常量 代理检测结束 <公开 类型 = 整数 值 = 1 注释 = "代理检测的结束时间">
    常量 获取连接开始 <公开 类型 = 整数 值 = 2 注释 = "获取连接的开始时间">
    常量 等待连接结束 <公开 类型 = 整数 值 = 3 注释 = "等待可用连接的结束时间">
    常量 获取连接结束 <公开 类型 = 整数 值 = 4 注释 = "获取连接的结束时间">
    常量 域名解析开始 <公开 类型 = 整数 值 = 5 注释 = "域名解析的开始时间">
    常量 域名解析结束 <公开 类型 = 整数 值 = 6 注释 = "域名解析的结束时间">
    常量 连接建立开始 <公开 类型 = 整数 值 = 7 注释 = "连接建立的开始时间">
    常量 连接建立结束 <公开 类型 = 整数 值 = 8 注释 = "连接建立的结束时间">
    常量 TLS握手客户端支线1开始 <公开 类型 = 整数 值 = 9 注释 = "TLS握手第1支线的客户端开始时间">
    常量 TLS握手客户端支线1结束 <公开 类型 = 整数 值 = 10 注释 = "TLS握手第1支线的客户端结束时间">
    常量 TLS握手客户端支线2开始 <公开 类型 = 整数 值 = 11 注释 = "TLS握手第2支线的客户端开始时间">
    常量 TLS握手客户端支线2结束 <公开 类型 = 整数 值 = 12 注释 = "TLS握手第2支线的客户端结束时间">
    常量 TLS握手客户端支线3开始 <公开 类型 = 整数 值 = 13 注释 = "TLS握手第3支线的客户端开始时间">
    常量 TLS握手客户端支线3结束 <公开 类型 = 整数 值 = 14 注释 = "TLS握手第3支线的客户端结束时间">
    常量 等待流开始 <公开 类型 = 整数 值 = 15 注释 = "等待可用流的开始时间">
    常量 等待流结束 <公开 类型 = 整数 值 = 16 注释 = "等待可用流的结束时间">
    常量 发送请求开始 <公开 类型 = 整数 值 = 17 注释 = "发送请求的开始时间">
    常量 发送请求头压缩开始 <公开 类型 = 整数 值 = 18 注释 = "发送请求头压缩的开始时间">
    常量 发送请求头压缩结束 <公开 类型 = 整数 值 = 19 注释 = "发送请求头压缩的结束时间">
    常量 发送请求头结束 <公开 类型 = 整数 值 = 20 注释 = "发送请求头的结束时间">
    常量 发送请求结束 <公开 类型 = 整数 值 = 21 注释 = "发送请求的结束时间">
    常量 接收响应开始 <公开 类型 = 整数 值 = 22 注释 = "接收响应的开始时间">
    常量 接收响应头压缩开始 <公开 类型 = 整数 值 = 23 注释 = "接收响应头压缩的开始时间">
    常量 接收响应头压缩结束 <公开 类型 = 整数 值 = 24 注释 = "接收响应头压缩的结束时间">
    常量 接收响应头结束 <公开 类型 = 整数 值 = 25 注释 = "接收响应头的结束时间">
    常量 接收响应正文解压缩增量 <公开 类型 = 整数 值 = 26 注释 = "接收响应正文解压缩的开始和结束时间之间的增量">
    常量 接收响应结束 <公开 类型 = 整数 值 = 27 注释 = "接收响应的结束时间">
    常量 代理隧道开始 <公开 类型 = 整数 值 = 28 注释 = "建立代理隧道的开始时间">
    常量 代理隧道结束 <公开 类型 = 整数 值 = 29 注释 = "建立代理隧道的结束时间">
    常量 代理TLS握手客户端支线1开始 <公开 类型 = 整数 值 = 30 注释 = "代理TLS握手第1支线的客户端开始时间">
    常量 代理TLS握手客户端支线1结束 <公开 类型 = 整数 值 = 31 注释 = "代理TLS握手第1支线的客户端结束时间">
    常量 代理TLS握手客户端支线2开始 <公开 类型 = 整数 值 = 32 注释 = "代理TLS握手第2支线的客户端开始时间">
    常量 代理TLS握手客户端支线2结束 <公开 类型 = 整数 值 = 33 注释 = "代理TLS握手第2支线的客户端结束时间">
    常量 代理TLS握手客户端支线3开始 <公开 类型 = 整数 值 = 34 注释 = "代理TLS握手第3支线的客户端开始时间">
    常量 代理TLS握手客户端支线3结束 <公开 类型 = 整数 值 = 35 注释 = "代理TLS握手第3支线的客户端结束时间">

    #
}
