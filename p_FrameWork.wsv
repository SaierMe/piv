<火山程序 类型 = "通常" 版本 = 1 />

包 火山.ImGui <注释 = "例程下载: https://saier.lanzoul.com/b016cwvle">

# ImGui窗口 (已高度封装,更简单易用)

类 IM_窗口模板类 <注释 = "提供了ImGui窗口共同的成员变量和定义事件." 注释 = "\"模板类型1\"为所使用的渲染器类型" 折叠 @模板基础类 = 真>
{
    变量 渲染器 <公开 类型 = 模板类型1 注释 = "当前使用的渲染器实例">
    变量 背景颜色 <公开 类型 = ImVec4 注释 = "x=红色; y=绿色; z=蓝色; w=Alpha" x = 0.45 y = 0.55 z = 0.60 w = 1.00>

    方法 创建完毕 <公开 定义事件 类型 = 整数 注释 = "当GLFW窗口创建完毕后发送此事件,用于对GLFW进行额外的设置." 注释 = "注意: 此时ImGui尚未初始化,请勿调用相关命令.">

    方法 初始化配置 <公开 定义事件 类型 = 整数 注释 = "在ImGui窗口显示之前发送一次此事件,用于设置ImGui的IO和字体等参数."
            返回值注释 = "返回1表示使用浅色样式,2为经典样式,其他任意值为默认的深色样式." 折叠>
    参数 IO <类型 = ImGuiIO类 注释 = "ImGui的输入输出结构">
    参数 字体图集 <类型 = IM字体图集类 注释 = "请在此添加字体(默认未添加任何字体,未添加中文字体将无法显示汉字).">

    方法 准备渲染 <公开 定义事件 类型 = 整数 注释 = "在ImGui开始渲染前发送一次此事件,可用于加载图片(部分渲染器不能在其他位置加载图片).">
    参数 样式配置 <类型 = IM样式类 注释 = "ImGui的样式配置">

    方法 即将渲染 <公开 定义事件 类型 = 整数 注释 = "当ImGui帧数据被渲染前发送此事件,请在本事件内设计ImGui的界面布局." 注释 = "注意:"
            注释 = "  1. 本事件前后已经内部处理好新建帧和渲染等操作,你只需设计布局即可." 注释 = "  2. ImGUI默认开启垂直同步,帧速率跟显示器的刷新率一致.比如刷新率为为60Hz,"
            注释 = "将每秒触发本事件60次,因此在此进行耗时操作将导致帧速率降低和界面卡顿,如有必要," 注释 = "请另开线程执行耗时操作."
            注释 = "  3. 因为本事件的执行频率足够高,所以键鼠输入等事件也可以在此一起处理.">

    方法 渲染结束 <公开 定义事件 类型 = 整数 注释 = "在ImGui停止渲染后发送一次此事件,可用于释放资源.">

    方法 尺寸被改变 <公开 定义事件 类型 = 整数 注释 = "当本窗口的尺寸被改变后发送此事件" 折叠>
    参数 宽度 <类型 = 整数 注释 = "改变后的窗口宽度">
    参数 高度 <类型 = 整数 注释 = "改变后的窗口高度">

    方法 位置被改变 <公开 定义事件 类型 = 整数 注释 = "当本窗口的位置被改变后发送此事件" 折叠>
    参数 左边位置 <类型 = 整数 注释 = "改变后的窗口左边在屏幕上的横向坐标位置">
    参数 顶边位置 <类型 = 整数 注释 = "改变后的窗口左边在屏幕上的纵向坐标位置">

    方法 最小化被改变 <公开 定义事件 类型 = 整数 注释 = "当本窗口改变最小化状态发送此事件" 折叠>
    参数 是否最小化 <类型 = 逻辑型 注释 = "是否为最小化状态(Win32和SDL2窗口下本参数始终为真)">

    方法 最大化被改变 <公开 定义事件 类型 = 整数 注释 = "当本窗口改变最大化状态发送此事件" 折叠>
    参数 是否最大化 <类型 = 逻辑型 注释 = "是否为最大化状态(Win32和SDL2窗口下本参数始终为真)">

    方法 文件被拖放 <公开 定义事件 类型 = 整数 注释 = "当文件被拖放到本窗口上后,将发送本事件." 折叠>
    参数 所拖放文件 <类型 = 文本数组类 注释 = "提供所有被拖放到本组件上的文件名,数组成员数必定大于0.">

    方法 将被销毁 <公开 定义事件 类型 = 整数 注释 = "当本窗口被销毁前发送此事件">

    方法 图标 <公开 属性写 注释 = "设置显示在本窗口左上角的图标" 折叠>
    参数 所欲设置的图标 <类型 = 图标资源 注释 = "  本参数提供具体所欲设置的图标,如果该资源值为\"空资源.空图标\"" 注释 = "或载入失败,则将使用默认图标.">
    {
        @ HICON hIcon = reinterpret_cast<HICON>(g_objVolApp.LoadResImage(VRIT_ICON, @<所欲设置的图标>));
        @ if (hIcon) {
        @     ::SendMessage(m_hwnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
        @     ::SendMessage(m_hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        @ }
    }

    方法 图标对象 <公开 属性写 注释 = "设置显示在本窗口左上角的图标" 折叠>
    参数 所欲设置的图标 <类型 = 图标对象类 注释 = "  本参数提供具体所欲设置的图标对象."
            注释 = "  注意: 在窗口存在期间必须保证本图标对象不被释放(可以将此对象保存在窗口类的成员变量中)," 注释 = "否则所置入图标将失效.">
    {
        @ HICON hIcon = reinterpret_cast<HICON>(@<所欲设置的图标>.GetGDIHandle());
        @ if (hIcon) {
        @     ::SendMessage(m_hwnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
        @     ::SendMessage(m_hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        @ }
    }

    方法 隐藏任务栏图标 <公开 属性写 注释 = "是否将本窗口的图标从任务栏中删除" 折叠 "">
    参数 是否隐藏 <类型 = 逻辑型>
    {
        @ if (m_hwnd == NULL) return;
        @ if (this->TaskbarInit()) {
        @     if (@<是否隐藏>)
        @         this->m_pTaskbarList->DeleteTab(m_hwnd);
        @     else
        @         this->m_pTaskbarList->AddTab(m_hwnd);
        @ }
    }

    # ---
    # @begin
    # <> <include>
    # HWND m_hwnd = NULL;
    # ITaskbarList* m_pTaskbarList = nullptr;
    # BOOL TaskbarInit() {
    #     if (!this->m_pTaskbarList) {
    #         HRESULT hr = ::CoCreateInstance(CLSID_TaskbarList, NULL, CLSCTX_INPROC_SERVER, IID_ITaskbarList, (LPVOID*)&this->m_pTaskbarList);
    #         if (SUCCEEDED(hr)) { return SUCCEEDED(this->m_pTaskbarList->HrInit()); }
    #     }
    #     return TRUE;
    # }
    # void @an<_OnCleanupExtra>() {
    #     if (this->m_pTaskbarList){
    #         this->m_pTaskbarList->Release();
    #         this->m_pTaskbarList = nullptr;
    #     }
    # }
    # <> </include>
    # @end
}

类 IM_Win32窗口 <公开 基础类 = IM_窗口模板类 注释 = "  基于Windows API的ImGui窗口,本模板类已经处理好ImGui创建和销毁的"
        注释 = "各种复杂流程,你只需要在\"即将绘制\"事件中完成界面的布局,就能完成" 注释 = "一个简单的ImGui窗口."
        注释 = "  \"模板类型1\"为所使用的渲染器类型,支持以下的渲染器:" 注释 = "   IM_DX9渲染器   IM_DX10渲染器     IM_DX11渲染器"
        注释 = "   IM_DX12渲染器  Im_OpenGL3渲染器" 折叠 @模板基础类 = 真 @文档 = "category = \"窗口框架\"">
{
    变量 改变后宽度 <类型 = 整数 值 = 0 @输出名 = "m_ResizeWidth">
    变量 改变后高度 <类型 = 整数 值 = 0 @输出名 = "m_ResizeHeight">

    方法 创建主窗口 <公开 类型 = 逻辑型 注释 = "创建本窗口类的对象并将其作为程序的主窗口." 注释 = "注意:"
            注释 = "  1. 程序中必须存在且只能存在一个主窗口,调用本方法后,主窗口将被设置为本窗口;" 注释 = "  2. 主窗口必须在程序的\"启动类\"中存在成员变量定义,避免其在程序退出前被释放,"
            注释 = "否则将可能导致程序运行时崩溃." 注释 = "  3. 本方法内实现了消息循环,直到窗口关闭或创建失败才会返回." 返回值注释 = "返回是否成功" 折叠 @禁止流程检查 = 真>
    参数 标题 <类型 = 文本型 注释 = "提供所创建窗口的标题">
    参数 宽度 <类型 = 整数 注释 = "提供所创建窗口的宽度" @默认值 = 0x80000000>
    参数 高度 <类型 = 整数 注释 = "提供所创建窗口的高度" @默认值 = 0x80000000>
    参数 窗口类名 <类型 = 文本型 注释 = "提供所创建窗口的窗口类名,该名称的类将会在窗口创建时自动登记到Windows系统中." @默认值 = "ImGuiWinClass">
    参数 透明帧缓冲区 <类型 = 逻辑型 注释 = "是否启用透明帧缓冲区,通过Alpha通道将窗口内容(不包括标题栏和边框)与背景合成," 注释 = "实现透明背景."
            注释 = "注意: DX9和DX12暂时不支持本参数" @默认值 = 假>
    {
        @ if (m_window != NULL) return TRUE;
        @ m_wc.cbSize = sizeof(WNDCLASSEXW);
        @ m_wc.style = CS_OWNDC;
        @ m_wc.lpfnWndProc = WndProc;
        @ m_wc.cbClsExtra = 0;
        @ m_wc.cbWndExtra = 0;
        @ m_wc.hInstance = ::GetModuleHandleW(nullptr);
        @ m_wc.hIcon = ::LoadIconW(m_wc.hInstance, MAKEINTRESOURCEW(_VOL_USER_APP_ICON_RES_ID));
        @ m_wc.hCursor = nullptr;
        @ m_wc.hbrBackground = nullptr;
        @ m_wc.lpszMenuName = nullptr;
        @ m_wc.lpszClassName = @<窗口类名>.GetText();
        @ m_wc.hIconSm = ::LoadIconW(m_wc.hInstance, MAKEINTRESOURCEW(_VOL_USER_APP_ICON_RES_ID));
        @ if (::RegisterClassExW(&m_wc) == 0) return FALSE;
        关注屏幕DPI (真)
        宽度 = 乘于屏幕DPI (宽度)
        高度 = 乘于屏幕DPI (高度)
        @ m_window = ::CreateWindowExW(0, m_wc.lpszClassName, @<标题>.GetText(), WS_OVERLAPPEDWINDOW, 0x80000000, 0x80000000, @<宽度>, @<高度>, nullptr, nullptr, m_wc.hInstance, this);
        变量 窗口句柄 <类型 = 变整数>
        变量 字体图集 <类型 = IM字体图集类>
        变量 IO <类型 = ImGuiIO类>
        变量 样式 <类型 = IM样式类>
        @ if (m_window == NULL) goto Fail;
        @ m_hwnd = m_window;
        @ if (@<透明帧缓冲区>) ImGui_ImplWin32_EnableAlphaCompositing(m_window);
        @ @<窗口句柄> = reinterpret_cast<INT_P>(m_window);
        如果 (渲染器.创建设备 (窗口句柄) == 假)
        {
            渲染器.释放设备 (窗口句柄)
            @ goto Fail;
        }
        @ ::ShowWindow(m_window, SW_SHOWDEFAULT);
        @ ::UpdateWindow(m_window);
        本对象.创建完毕 ()
        ImGui.检查版本 ()
        ImGui.置当前上下文 (ImGui.创建上下文 ())
        IO = ImGui.取IO ()
        IO.字体全局缩放 = (单精度小数)取屏幕DPI ()
        IO.标志 = 连续位或 (IO.标志, IM配置标志.键盘导航, IM配置标志.游戏手柄导航, IM配置标志.启用停靠, IM配置标志.启用视口)
        字体图集 = ImGui.取字体图集 ()
        分支判断 (初始化配置 (IO, 字体图集))
        {
            分支 (1)
            {
                ImGui.浅色样式 ()
            }
            分支 (2)
            {
                ImGui.经典样式 ()
            }
            默认分支 ()
            {
                ImGui.深色样式 ()
            }
        }
        样式 = ImGui.取样式 ()
        如果 (位与 (IO.标志, IM配置标志.启用视口) != 0)
        {
            样式.窗口圆角 = 0.0
            样式.颜色 (IM颜色标识符.窗口背景).w = 1.0
        }
        如果 (字体图集.是否已生成 () == 假)
        {
            字体图集.生成 ()
        }
        如果 (渲染器.渲染器类型 == 0)
        {
            IM_Win32平台.初始化 (窗口句柄)
        }
        否则
        {
            IM_Win32平台.初始化_OpenGL (窗口句柄)
        }
        如果 (渲染器.初始化 () == 假)
        {
            IM_Win32平台.关闭 ()
            ImGui.销毁上下文 ()
            @ goto Fail;
        }
        渲染器.准备 ()
        本对象.准备渲染 (样式)
        @ MSG msg;
        @ RECT rt;
        判断循环 (真)
        {
            @ while (::PeekMessageW(&msg, nullptr, 0U, 0U, PM_REMOVE))
            @ {
            @     ::TranslateMessage(&msg);
            @     ::DispatchMessageW(&msg);
            @ }
            @ if (msg.message == WM_QUIT) break;
            @ if (::GetClientRect(m_window, &rt))
            @ {
            @     @<改变后宽度> = rt.right - rt.left;
            @     @<改变后高度> = rt.bottom - rt.top;
            @ }
            如果 (改变后宽度 != 0 && 改变后高度 != 0)
            {
                渲染器.新建帧 ()
                IM_Win32平台.新建帧 ()
                ImGui.新建帧 ()
                渲染器.重置尺寸 (改变后宽度, 改变后高度)
                本对象.即将渲染 ()
                渲染器.渲染 (背景颜色)
            }
            否则
            {
                延时 (50)  // 窗口不显示时,增加延时以减少CPU占用
            }
        }
        // 清理数据
        本对象.渲染结束 ()
        渲染器.关闭 ()
        IM_Win32平台.关闭 ()
        ImGui.销毁上下文 ()
        渲染器.释放设备 (窗口句柄)
        @ ::DestroyWindow(m_window);
        @ m_window = NULL;
        @ ::UnregisterClassW(m_wc.lpszClassName, m_wc.hInstance);
        @ ::PostQuitMessage(0); // 投递退出消息
        @ return TRUE;
        @ Fail:
        @ if (m_window) { ::DestroyWindow(m_window); m_window = NULL; }
        @ if (m_wc.lpszClassName != nullptr) { ::UnregisterClassW(m_wc.lpszClassName, m_wc.hInstance); }
        @ memset(&m_wc, 0, sizeof(WNDCLASSEXW));
        @ return FALSE;
    }

    方法 关闭窗口 <公开 注释 = "尝试关闭本窗口." 注释 = "注意: 本方法被调用后窗口不会被立即关闭,而会延迟等待到下一次消息循环时才会关闭." 折叠>
    {
        @ if (m_window != NULL)
        @     ::DestroyWindow(m_window);
    }

    方法 取窗口句柄 <公开 类型 = 变整数 注释 = "返回本窗口的句柄,如果尚未创建或创建失败,则返回0." 注释 = "注意: 返回的是Win32窗口句柄,可以使用Win32的API进行操作." 折叠
            @嵌入式方法 = "">
    {
        @ reinterpret_cast<INT_P>(@sn<this>.m_window)
    }

    方法 处理事件 <公开 折叠>
    {
        @ MSG msg;
        @ while (::PeekMessageW(&msg, nullptr, 0U, 0U, PM_NOREMOVE) && msg.message != WM_QUIT)
        @ {
        @     if (::GetMessage (&msg, NULL, 0, 0) <= 0)
        @         break;
        @     ::TranslateMessage(&msg);
        @     ::DispatchMessageW(&msg);
        @ }
    }

    方法 取窗口尺寸 <公开 注释 = "获取本窗口的当前宽度和高度" 折叠>
    参数 返回宽度 <类型 = 整数 注释 = "必须提供变量" @视窗.后缀文本 = "&">
    参数 返回高度 <类型 = 整数 注释 = "必须提供变量" @视窗.后缀文本 = "&">
    {
        @ if (m_window == NULL) return;
        @ RECT rt;
        @ if (::GetWindowRect(m_window, &rt)) {
        @    @<返回宽度> = rt.right - rt.left;
        @    @<返回高度> = rt.bottom - rt.top;
        @ }
    }

    方法 置窗口尺寸 <公开 注释 = "设置本窗口的宽度和高度" 折叠>
    参数 宽度值 <类型 = 整数>
    参数 高度值 <类型 = 整数>
    {
        @ if (m_window != NULL)
        @     ::SetWindowPos(m_window, NULL, 0, 0, @<宽度值>, @<高度值>, (SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER));
    }

    方法 取窗口位置 <公开 注释 = "获取本窗口的当前位置" 折叠>
    参数 顶边位置 <类型 = 整数 注释 = "必须提供变量" @视窗.后缀文本 = "&">
    参数 左边位置 <类型 = 整数 注释 = "必须提供变量" @视窗.后缀文本 = "&">
    {
        @ if (m_window == NULL) return;
        @ RECT rt;
        @ if (::GetWindowRect(m_window, &rt)) {
        @    @<顶边位置> = rt.top;
        @    @<左边位置> = rt.left;
        @ }
    }

    方法 置窗口位置 <公开 注释 = "设置本窗口的位置" 折叠>
    参数 顶边位置 <类型 = 整数>
    参数 左边位置 <类型 = 整数>
    {
        @ if (m_window != NULL)
        @     ::SetWindowPos(m_window, NULL, @<左边位置>, @<顶边位置>, 0, 0, (SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER));
    }

    方法 获取焦点 <公开 注释 = "将当前输入焦点设置到窗口上" 折叠 @嵌入式方法 = "">
    {
        @ ::SetFocus(@sn<this>.m_window)
    }

    # 属性

    方法 左边 <公开 属性读 类型 = 整数 注释 = "返回本窗口的左边位置(有些问题,待修正)" 折叠 @禁止流程检查 = 真>
    {
        @ if (m_window != NULL) {
        @     RECT rt;
        @     if (::GetWindowRect(m_window, &rt))
        @         return rt.left;
        @ }
        @ return 0;
    }

    方法 左边 <公开 属性写 注释 = "设置本窗口的左边位置" 折叠>
    参数 所欲设置的位置 <类型 = 整数>
    {
        @ if (m_window != NULL)
        @ {
        @     RECT rt;
        @     ::GetWindowRect(m_window, &rt);
        @     ::SetWindowPos(m_window, NULL, @<所欲设置的位置>, rt.top, 0, 0, (SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER));
        @ }
    }

    方法 顶边 <公开 属性读 类型 = 整数 注释 = "返回本窗口的顶边位置(有些问题,待修正)" 折叠 @禁止流程检查 = 真>
    {
        @ if (m_window != NULL) {
        @     RECT rt;
        @     if (::GetWindowRect(m_window, &rt))
        @         return rt.top;
        @ }
        @ return 0;
    }

    方法 顶边 <公开 属性写 注释 = "设置本窗口的顶边位置" 折叠>
    参数 所欲设置的位置 <类型 = 整数>
    {
        @ if (m_window != NULL)
        @ {
        @     RECT rt;
        @     ::GetWindowRect(m_window, &rt);
        @     ::SetWindowPos(m_window, NULL, rt.left, @<所欲设置的位置>, 0, 0, (SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER));
        @ }
    }

    方法 宽度 <公开 属性读 类型 = 整数 注释 = "返回本窗口的宽度" 折叠 @禁止流程检查 = 真>
    {
        @ if (m_window != NULL) {
        @     RECT rt;
        @     if (::GetWindowRect(m_window, &rt))
        @         return rt.right - rt.left;
        @ }
        @ return 0;
    }

    方法 宽度 <公开 属性写 注释 = "设置本窗口的宽度" 折叠>
    参数 所欲设置的宽度 <类型 = 整数>
    {
        @ if (m_window != NULL)
        @ {
        @     RECT rt;
        @     ::GetWindowRect(m_window, &rt);
        @     ::SetWindowPos(m_window, NULL, 0, 0, @<所欲设置的宽度>, rt.bottom - rt.top, (SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER));
        @ }
    }

    方法 高度 <公开 属性读 类型 = 整数 注释 = "返回本窗口的高度" 折叠 @禁止流程检查 = 真>
    {
        @ if (m_window != NULL) {
        @     RECT rt;
        @     if (::GetWindowRect(m_window, &rt))
        @         return rt.bottom - rt.top;
        @ }
        @ return 0;
    }

    方法 高度 <公开 属性写 注释 = "设置本窗口的高度" 折叠>
    参数 所欲设置的高度 <类型 = 整数>
    {
        @ if (m_window != NULL)
        @ {
        @     RECT rt;
        @     ::GetWindowRect(m_window, &rt);
        @     ::SetWindowPos(m_window, NULL, 0, 0, rt.right - rt.left, @<所欲设置的高度>, (SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER));
        @ }
    }

    方法 标题 <公开 属性读 类型 = 文本型 注释 = "返回本窗口的当前标题文本" 折叠 @禁止流程检查 = 真>
    {
        @ if (m_window != NULL)
        @ {
        @     CVolString strCaption;
        @     strCaption.SetLength(::GetWindowTextLengthW(m_window));
        @     ::GetWindowTextW(m_window, strCaption.GetText(), strCaption.GetLength());
        @     return strCaption;
        @ }
        @ return _CT("");
    }

    方法 标题 <公开 属性写 注释 = "设置本窗口的当前标题文本" 折叠>
    参数 所欲设置的标题 <类型 = 文本型 注释 = "提供所欲设置的标题文本">
    {
        @ if (m_window != NULL)
        @     ::SetWindowTextW(m_window, @<所欲设置的标题>.GetText());
    }

    方法 显示边框 <公开 属性读 类型 = 逻辑型 注释 = "返回窗口是否显示标题栏和边框" 折叠 @禁止流程检查 = 真>
    {
        @ LONG_PTR lStyle = ::GetWindowLongPtrW(m_window, GWL_STYLE);
        @ return (lStyle & WS_CAPTION);
    }

    方法 显示边框 <公开 属性写 注释 = "设置是否显示窗口的标题栏和边框" 折叠>
    参数 是否显示 <类型 = 逻辑型>
    {
        @ LONG_PTR lStyle = ::GetWindowLongPtrW(m_window, GWL_STYLE);
        @ if (!@<是否显示>)
        @     lStyle = lStyle & ~(WS_CAPTION | WS_SIZEBOX);
        @ else
        @     lStyle = lStyle | WS_CAPTION | WS_SIZEBOX;
        @ ::SetWindowLongPtrW(m_window, GWL_STYLE, lStyle);
        @ ::SetWindowPos(m_window, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);
    }

    方法 可视 <公开 属性读 类型 = 逻辑型 注释 = "返回本窗口当前是否可视" 折叠 @嵌入式方法 = "">
    {
        @ ::IsWindowVisible(@sn<this>.m_window)
    }

    方法 可视 <公开 属性写 注释 = "设置本窗口当前是否可视,注意会连任务栏图标一起隐藏." 折叠>
    参数 是否可视 <类型 = 逻辑型 注释 = "指定本组件是否可视">
    {
        @ ::ShowWindow(m_window, @<是否可视> ? SW_SHOW : SW_HIDE);
    }

    # ---
    # @begin
    # <> <include>
    # WNDCLASSEXW m_wc = {0};
    # HWND m_window = NULL;
    # static LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    #     static @sn<current_class>* pThis;
    #     if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam))
    #         return 1;
    #     switch (msg)
    #     {
    #     case WM_CREATE:
    #         if (pThis == nullptr)
    #             pThis = reinterpret_cast<@sn<current_class>*>(reinterpret_cast<CREATESTRUCTW*>(lParam)->lpCreateParams);
    #         return 0;
    #     case WM_SIZE:
    #         if (pThis != nullptr)
    #         {
    #             if (wParam == SIZE_MINIMIZED) {
    #                 pThis->@<最小化被改变>(TRUE);
    #             } else if (wParam == SIZE_MAXIMIZED) {
    #                 pThis->@<最大化被改变>(TRUE);
    #             } else {
    #                 pThis->m_ResizeWidth = static_cast<SHORT>(lParam);
    #                 pThis->m_ResizeHeight = static_cast<INT>(lParam >> 16);
    #                 pThis->@<尺寸被改变>(pThis->m_ResizeWidth, pThis->m_ResizeHeight);
    #             }
    #         }
    #         break;
    #     case WM_MOVE:
    #         if (pThis != nullptr)
    #             pThis->@<位置被改变>(static_cast<SHORT>(lParam), static_cast<INT>(lParam >> 16));
    #         break;
    #     case WM_SYSCOMMAND:
    #         if ((wParam & 0xfff0) == SC_KEYMENU) // Disable ALT application menu
    #             return 0;
    #         break;
    #     case WM_DESTROY:
    #         if (pThis != nullptr)
    #             pThis->@<将被销毁>();
    #         ::PostQuitMessage(0);
    #         return 0;
    #     case 0x02E0: // WM_DPICHANGED
    #         if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_DpiEnableScaleViewports) {
    #             const RECT* suggested_rect = reinterpret_cast<const RECT*>(lParam);
    #             ::SetWindowPos(hWnd, nullptr, suggested_rect->left, suggested_rect->top, suggested_rect->right - suggested_rect->left, suggested_rect->bottom - suggested_rect->top, SWP_NOZORDER | SWP_NOACTIVATE);
    #         }
    #         break;
    #     }
    #     return ::DefWindowProcW(hWnd, msg, wParam, lParam);
    # }
    # <> </include>
    # @end
    # ---
}

类 IM_GLFW窗口 <公开 基础类 = IM_窗口模板类 注释 = "  基于GLFW的ImGui窗口,本模板类已经处理好ImGui创建和销毁的各种复杂"
        注释 = "流程,你只需要在\"即将绘制\"事件中完成界面的布局,就能完成一个简单的" 注释 = "ImGui窗口." 注释 = "  \"模板类型1\"为所使用的渲染器类型,支持以下的渲染器:"
        注释 = "  Im_OpenGL3渲染器  IM_Vulkan渲染器" 折叠 @模板基础类 = 真 @文档 = "category = \"窗口框架\"">
{
    方法 创建主窗口 <公开 类型 = 逻辑型 注释 = "创建本窗口类的对象并将其作为程序的主窗口." 注释 = "注意:"
            注释 = "  1. 程序中必须存在且只能存在一个主窗口,调用本方法后,主窗口将被设置为本窗口;" 注释 = "  2. 主窗口必须在程序的\"启动类\"中存在成员变量定义,避免其在程序退出前被释放,"
            注释 = "否则将可能导致程序运行时崩溃." 注释 = "  3. 本方法内实现了消息循环,直到窗口关闭或创建失败,本方法才会返回." 返回值注释 = "返回是否成功" 折叠 @禁止流程检查 = 真>
    参数 标题 <类型 = 文本型 注释 = "提供所创建窗口的标题">
    参数 宽度 <类型 = 整数 注释 = "提供所创建窗口的宽度" @默认值 = 1280>
    参数 高度 <类型 = 整数 注释 = "提供所创建窗口的高度" @默认值 = 720>
    参数 全屏模式 <类型 = 逻辑型 注释 = "默认为窗口模式,如果设置为真,将在主显示器中进入全屏模式," 注释 = "如果想在其他显示器中全屏显示,请在创建主窗口前执行\"置当前显示器\"."
            @默认值 = 假>
    参数 透明帧缓冲区 <类型 = 逻辑型 注释 = "是否启用透明帧缓冲区." 注释 = "通过Alpha通道将窗口内容(不包括标题栏和边框)与背景合成,实现透明背景." @默认值 = 假>
    {
        @ if (m_window) return FALSE;
        如果 (渲染器.渲染器类型 == 1)
        {
            @ glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
            @ glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
            @ glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
        }
        否则 (渲染器.渲染器类型 == 2)
        {
            @ glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
        }
        @ glfwWindowHint(GLFW_SCALE_TO_MONITOR, GLFW_TRUE);
        @ glfwWindowHint(GLFW_TRANSPARENT_FRAMEBUFFER, @<透明帧缓冲区>);
        @ m_window = glfwCreateWindow(@<宽度>, @<高度>, PivW2U{@<标题>}.GetText(), @<全屏模式> ? m_monitor : nullptr, nullptr);
        @ if (!m_window) return FALSE;
        @ m_hwnd = glfwGetWin32Window(m_window);
        @ HICON hIcon = ::LoadIconW(::GetModuleHandle(NULL), MAKEINTRESOURCEW(_VOL_USER_APP_ICON_RES_ID));
        @ if (hIcon) {
        @     ::SendMessage(m_hwnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
        @     ::SendMessage(m_hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        @ }
        变量 窗口句柄 <类型 = 变整数>
        @ @<窗口句柄> = reinterpret_cast<INT_P>(m_window);
        如果 (渲染器.渲染器类型 == 1)
        {
            @ glfwMakeContextCurrent(m_window);
            @ glfwSwapInterval(1); // 启用垂直同步
            如果 (渲染器.加载_GLFW (0) == 假)
            {
                返回 (假)
            }
        }
        否则 (渲染器.渲染器类型 == 2)
        {
            如果 (渲染器.加载_GLFW (窗口句柄) == 假)
            {
                返回 (假)
            }
        }
        // 设置回调
        @ glfwSetWindowUserPointer(m_window, this);
        @ glfwSetWindowPosCallback(m_window, glfw_pos_callback);
        @ glfwSetWindowSizeCallback(m_window, glfw_size_callback);
        @ glfwSetWindowCloseCallback(m_window, glfw_close_callback);
        @ glfwSetWindowIconifyCallback(m_window, glfw_iconify_callback);
        @ glfwSetWindowMaximizeCallback(m_window, glfw_maximize_callback);
        @ glfwSetDropCallback(m_window, glfw_drop_callback);
        本对象.创建完毕 ()
        ImGui.检查版本 ()
        ImGui.置当前上下文 (ImGui.创建上下文 ())
        变量 IO <类型 = ImGuiIO类>
        变量 样式 <类型 = IM样式类>
        变量 字体图集 <类型 = IM字体图集类>
        IO = ImGui.取IO ()
        IO.标志 = 连续位或 (IO.标志, IM配置标志.键盘导航, IM配置标志.游戏手柄导航, IM配置标志.启用停靠, IM配置标志.启用视口)
        关注屏幕DPI (真)
        IO.字体全局缩放 = (单精度小数)取屏幕DPI ()
        字体图集 = ImGui.取字体图集 ()
        分支判断 (初始化配置 (IO, 字体图集))
        {
            分支 (1)
            {
                ImGui.浅色样式 ()
            }
            分支 (2)
            {
                ImGui.经典样式 ()
            }
            默认分支 ()
            {
                ImGui.深色样式 ()
            }
        }
        样式 = ImGui.取样式 ()
        // 启用视口后调整WindowRounding/WindowBg,使平台窗口看起来与常规窗口相同
        如果 (位与 (IO.标志, IM配置标志.启用视口) != 0)
        {
            样式.窗口圆角 = 0.0
            样式.颜色 (IM颜色标识符.窗口背景).w = 1.0
        }
        如果 (字体图集.是否已生成 () == 假)
        {
            字体图集.生成 ()
        }
        如果 (渲染器.渲染器类型 == 1)
        {
            IM_GLFW平台.初始化_OpenGL (窗口句柄, 真)
            如果 (渲染器.初始化 () == 假)
            {
                IM_GLFW平台.关闭 ()
                ImGui.销毁上下文 ()
                返回 (假)
            }
        }
        否则 (渲染器.渲染器类型 == 2)
        {
            IM_GLFW平台.初始化_Vulkan (窗口句柄, 真)
            如果 (渲染器.初始化 () == 假)
            {
                IM_GLFW平台.关闭 ()
                ImGui.销毁上下文 ()
                返回 (假)
            }
        }
        本对象.准备渲染 (样式)
        // 消息循环
        判断循环 (_是否需要退出 () == 假)
        {
            @ glfwPollEvents();
            // 界面布局
            渲染器.新建帧 ()
            IM_GLFW平台.新建帧 ()
            ImGui.新建帧 ()
            本对象.即将渲染 ()
            // 渲染
            渲染器.渲染_GLFW (窗口句柄, 背景颜色)
        }
        // 清理数据
        本对象.渲染结束 ()
        渲染器.关闭 ()
        IM_GLFW平台.关闭 ()
        ImGui.销毁上下文 ()
        渲染器.清理 ()
        @ glfwDestroyWindow(m_window);
        @ m_window = nullptr;
        @ ::PostQuitMessage(0); // 投递退出消息
        @ return TRUE;
    }

    方法 关闭窗口 <公开 注释 = "尝试关闭本窗口." 注释 = "注意: 本方法被调用后窗口不会被立即关闭,而会延迟等待到下一次消息循环时才会关闭." 折叠 @嵌入式方法 = "">
    {
        @ glfwSetWindowShouldClose(@sn<this>.m_window, 1)
    }

    方法 取窗口句柄 <公开 类型 = 变整数 注释 = "返回本窗口的句柄,如果尚未创建或创建失败,则返回0." 注释 = "注意: 返回的是Win32窗口句柄,可以使用Win32的API进行操作." 折叠
            @嵌入式方法 = "">
    {
        @ reinterpret_cast<INT_P>(@sn<this>.m_hwnd)
    }

    方法 取窗口对象指针 <公开 类型 = 变整数 注释 = "返回当前GLFW窗口的对象指针,如果尚未创建或创建失败,则返回0." 折叠 @嵌入式方法 = "">
    {
        @ reinterpret_cast<INT_P>(@sn<this>.m_window)
    }

    方法 最小化 <公开 注释 = "将本窗口最小化到任务栏图标" 折叠 @嵌入式方法 = "">
    {
        @ glfwIconifyWindow(@sn<this>.m_window)
    }

    方法 最大化 <公开 注释 = "将本窗口设置为最大化" 折叠 @嵌入式方法 = "">
    {
        @ glfwMaximizeWindow(@sn<this>.m_window)
    }

    方法 还原窗口 <公开 注释 = "将本窗口还原到原来的尺寸" 折叠 @嵌入式方法 = "">
    {
        @ glfwRestoreWindow(@sn<this>.m_window)
    }

    方法 获取焦点 <公开 注释 = "将当前输入焦点设置到本窗口上" 折叠 @嵌入式方法 = "">
    {
        @ glfwFocusWindow(@sn<this>.m_window)
    }

    方法 取窗口尺寸 <公开 注释 = "获取本窗口的当前宽度和高度" 折叠 @嵌入式方法 = "">
    参数 宽度 <类型 = 整数 @需求类型 = 可写入变量>
    参数 高度 <类型 = 整数 @需求类型 = 可写入变量>
    {
        @ glfwGetWindowSize(@sn<this>.m_window, &@<宽度>, &@<高度>)
    }

    方法 置窗口尺寸 <公开 注释 = "设置本窗口的宽度和高度" 折叠 @嵌入式方法 = "">
    参数 宽度 <类型 = 整数>
    参数 高度 <类型 = 整数>
    {
        @ glfwSetWindowSize(@sn<this>.m_window, @<宽度>, @<高度>)
    }

    方法 限制窗口尺寸 <公开 注释 = "限制本窗口的宽度和高度,只能在限制的范围内调整大小" 折叠 @嵌入式方法 = "">
    参数 最小宽度 <类型 = 整数>
    参数 最大宽度 <类型 = 整数>
    参数 最小高度 <类型 = 整数>
    参数 最大高度 <类型 = 整数>
    {
        @ glfwSetWindowSizeLimits(@sn<this>.m_window, @<最小宽度>, @<最大宽度>, @<最小高度>, @<最大高度>)
    }

    方法 取窗口位置 <公开 注释 = "获取本窗口的当前位置" 折叠 @嵌入式方法 = "">
    参数 顶边位置 <类型 = 整数 @需求类型 = 可写入变量>
    参数 左边位置 <类型 = 整数 @需求类型 = 可写入变量>
    {
        @ glfwGetWindowPos(@sn<this>.m_window, &@<左边位置>, &@<顶边位置>)
    }

    方法 置窗口位置 <公开 注释 = "设置本窗口的位置" 折叠 @嵌入式方法 = "">
    参数 顶边位置 <类型 = 整数>
    参数 左边位置 <类型 = 整数>
    {
        @ glfwSetWindowPos(@sn<this>.m_window, @<左边位置>, @<顶边位置>)
    }

    方法 _是否需要退出 <类型 = 逻辑型 折叠 @嵌入式方法 = "">
    {
        @ glfwWindowShouldClose(@sn<this>.m_window)
    }

    # 属性

    方法 左边 <公开 属性读 类型 = 整数 注释 = "返回本窗口的左边位置" 折叠 @禁止流程检查 = 真>
    {
        @ if (m_window != nullptr) {
        @     int left;
        @     glfwGetWindowPos(m_window, &left, nullptr);
        @     return left;
        @ }
        @ return 0;
    }

    方法 左边 <公开 属性写 注释 = "设置本窗口的左边位置" 折叠>
    参数 所欲设置的位置 <类型 = 整数>
    {
        @ if (m_window != nullptr) {
        @     int top;
        @     glfwGetWindowPos(m_window, nullptr, &top);
        @     glfwSetWindowPos(m_window, @<所欲设置的位置>, top);
        @ }
    }

    方法 顶边 <公开 属性读 类型 = 整数 注释 = "返回本窗口的顶边位置" 折叠 @禁止流程检查 = 真>
    {
        @ if (m_window != nullptr) {
        @     int top;
        @     glfwGetWindowPos(m_window, nullptr, &top);
        @     return top;
        @ }
        @ return 0;
    }

    方法 顶边 <公开 属性写 注释 = "设置本窗口的顶边位置" 折叠>
    参数 所欲设置的位置 <类型 = 整数>
    {
        @ if (m_window != nullptr) {
        @     int left;
        @     glfwGetWindowPos(m_window, &left, nullptr);
        @     glfwSetWindowPos(m_window, left, @<所欲设置的位置>);
        @ }
    }

    方法 宽度 <公开 属性读 类型 = 整数 注释 = "返回本窗口的宽度" 折叠 @禁止流程检查 = 真>
    {
        @ if (m_window != nullptr) {
        @     int width;
        @     glfwGetWindowSize(m_window, &width, NULL);
        @     return width;
        @ }
        @ return 0;
    }

    方法 宽度 <公开 属性写 注释 = "设置本窗口的宽度" 折叠>
    参数 所欲设置的宽度 <类型 = 整数>
    {
        @ if (m_window != nullptr) {
        @     int hight;
        @     glfwGetWindowSize(m_window, nullptr, &hight);
        @     glfwSetWindowSize(m_window, @<所欲设置的宽度>, hight);
        @ }
    }

    方法 高度 <公开 属性读 类型 = 整数 注释 = "返回本窗口的高度" 折叠 @禁止流程检查 = 真>
    {
        @ if (m_window != nullptr) {
        @     int hight;
        @     glfwGetWindowSize(m_window, NULL, &hight);
        @     return hight;
        @ }
        @ return 0;
    }

    方法 高度 <公开 属性写 注释 = "设置本窗口的高度" 折叠>
    参数 所欲设置的高度 <类型 = 整数>
    {
        @ if (m_window != nullptr) {
        @     int width;
        @     glfwGetWindowSize(m_window, &width, nullptr);
        @     glfwSetWindowSize(m_window, width, @<所欲设置的高度>);
        @ }
    }

    方法 标题 <公开 属性写 注释 = "设置本窗口的当前标题文本" 折叠>
    参数 所欲设置标题 <类型 = 文本型 注释 = "提供所欲设置的标题文本">
    {
        @ glfwSetWindowTitle(m_window, PivW2U{@<所欲设置标题>}.GetText());
    }

    方法 显示边框 <公开 属性读 类型 = 逻辑型 注释 = "返回窗口是否显示标题栏和边框" 折叠 @禁止流程检查 = 真>
    {
        @ return glfwGetWindowAttrib(m_window, GLFW_DECORATED);
    }

    方法 显示边框 <公开 属性写 注释 = "设置是否显示窗口的标题栏和边框" 折叠>
    参数 是否显示 <类型 = 逻辑型>
    {
        @ glfwSetWindowAttrib(m_window, GLFW_DECORATED, @<是否显示>);
    }

    方法 可视 <公开 属性读 类型 = 逻辑型 注释 = "返回本窗口当前是否可视" 折叠 @禁止流程检查 = 真>
    {
        @ return glfwGetWindowAttrib(m_window, GLFW_VISIBLE);
    }

    方法 可视 <公开 属性写 注释 = "设置本窗口当前是否可视,注意会连任务栏图标一起隐藏." 折叠>
    参数 是否可视 <类型 = 逻辑型 注释 = "指定本组件是否可视">
    {
        @ @<是否可视> ? glfwShowWindow(m_window) : glfwHideWindow(m_window);
    }

    方法 窗口透明度 <公开 属性读 类型 = 单精度小数 注释 = "返回本窗口(包括标题栏和边框)的整体透明度,如果系统不支持窗口透明度将始终返回1" 折叠 @禁止流程检查 = 真>
    {
        @ return glfwGetWindowOpacity(m_window, GLFW_VISIBLE);
    }

    方法 窗口透明度 <公开 属性写 注释 = "设置本窗口(包括标题栏和边框)的整体透明度" 折叠>
    参数 透明度 <类型 = 单精度小数 注释 = "请提供0.0f-1.0f之间的值,即完全透明到完全不透明.">
    {
        @ glfwSetWindowOpacity(m_window, @<透明度>);
    }

    方法 置于顶层 <公开 属性读 类型 = 逻辑型 注释 = "返回本窗口当前是否已置于顶层" 折叠 @禁止流程检查 = 真>
    {
        @ return glfwGetWindowAttrib(m_window, GLFW_FLOATING);
    }

    方法 置于顶层 <公开 属性写 注释 = "设置本窗口是否置于顶层" 折叠>
    参数 是否置于顶层 <类型 = 逻辑型 注释 = "指定本窗口是否置于顶层">
    {
        @ glfwSetWindowAttrib(m_window, GLFW_FLOATING, @<是否置于顶层>);
    }

    方法 透明帧缓冲区 <公开 属性读 类型 = 逻辑型 注释 = "返回本窗口是否已启用透明帧缓冲区,如果系统不支持将始终返回假." 折叠 @禁止流程检查 = 真>
    {
        @ return glfwGetWindowAttrib(m_window, GLFW_TRANSPARENT_FRAMEBUFFER);
    }

    # ---
    # @begin
    # <> <include>
    # static void @an<_sOnBeforeAppInit>() {
    #     glfwSetErrorCallback(glfw_error_callback);
    #     glfwInit();
    # }
    # static void @an<_sOnAfterAppExit>() { glfwTerminate(); }
    # // 成员变量
    # GLFWwindow* m_window = nullptr;
    # GLFWmonitor* m_monitor = glfwGetPrimaryMonitor();
    # ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 0.60f);
    # // Callback
    # static void glfw_error_callback(int error, const char* description) {
    #     PIVDEBUG("S", CVolString().Format(L"GLFW Error %d: %s\n", error, PivU2W(description).GetText()).GetText());
    # }
    # static void glfw_pos_callback(GLFWwindow* window, int xpos, int ypos) {
    #     reinterpret_cast<@sn<current_class>*>(glfwGetWindowUserPointer(window))->@<位置被改变>(xpos, ypos);
    # }
    # static void glfw_size_callback(GLFWwindow* window, int width, int height) {
    #     reinterpret_cast<@sn<current_class>*>(glfwGetWindowUserPointer(window))->@<尺寸被改变>(width, height);
    # }
    # static void glfw_close_callback(GLFWwindow* window) {
    #     reinterpret_cast<@sn<current_class>*>(glfwGetWindowUserPointer(window))->@<将被销毁>();
    # }
    # static void glfw_iconify_callback(GLFWwindow* window, int iconified) {
    #     reinterpret_cast<@sn<current_class>*>(glfwGetWindowUserPointer(window))->@<最小化被改变>(iconified);
    # }
    # static void glfw_maximize_callback(GLFWwindow* window, int maximized) {
    #     reinterpret_cast<@sn<current_class>*>(glfwGetWindowUserPointer(window))->@<最大化被改变>(maximized);
    # }
    # static void glfw_drop_callback(GLFWwindow* window, int path_count, const char* paths[]);
    # <> </include>
    # void @sn<current_class>::glfw_drop_callback(GLFWwindow* window, int path_count, const char* paths[]) {
    #     @dt<文本数组类> aryFileNames;
    #     for (int i = 0; i < path_count; i++) {
    #         aryFileNames.data().Add(PivU2W{paths[i]}.GetText());
    #     }
    #     reinterpret_cast<@sn<current_class>*>(glfwGetWindowUserPointer(window))->@<文件被拖放>(aryFileNames);
    # }
    # @end
    # ---
}

类 IM_SDL2窗口 <公开 基础类 = IM_窗口模板类 注释 = "  基于SDL2的ImGui窗口,本模板类已经处理好ImGui创建和销毁的各种复杂"
        注释 = "流程,你只需要在\"即将绘制\"事件中完成界面的布局,就能完成一个简单的" 注释 = "ImGui窗口." 注释 = "  \"模板类型1\"为所使用的渲染器类型,支持以下的渲染器:"
        注释 = "  IM_DX9渲染器   IM_DX10渲染器     IM_DX11渲染器" 注释 = "  IM_DX12渲染器  Im_OpenGL3渲染器  IM_Vulkan渲染器" 折叠
        @模板基础类 = 真 @文档 = "category = \"窗口框架\"">
{
    方法 创建主窗口 <公开 类型 = 逻辑型 注释 = "创建本窗口类的对象并将其作为程序的主窗口." 注释 = "注意:"
            注释 = "  1. 程序中必须存在且只能存在一个主窗口,调用本方法后,主窗口将被设置为本窗口;" 注释 = "  2. 主窗口必须在程序的\"启动类\"中存在成员变量定义,避免其在程序退出前被释放,"
            注释 = "否则将可能导致程序运行时崩溃." 注释 = "  3. 本方法内实现了消息循环,直到窗口关闭或创建失败,本方法才会返回." 返回值注释 = "返回是否成功" 折叠 @禁止流程检查 = 真>
    参数 标题 <类型 = 文本型 注释 = "提供所创建窗口的标题">
    参数 宽度 <类型 = 整数 注释 = "提供所创建窗口的宽度" @默认值 = 1280>
    参数 高度 <类型 = 整数 注释 = "提供所创建窗口的高度" @默认值 = 720>
    参数 全屏模式 <类型 = 逻辑型 注释 = "默认为窗口模式,如果设置为真,将以设置的宽度和高度进入全屏模式" @默认值 = 假>
    参数 "// 透明帧缓冲区" <类型 = 逻辑型 注释 = "是否启用透明帧缓冲区." 注释 = "通过Alpha通道将窗口内容(不包括标题栏和边框)与背景合成,实现透明背景." @默认值 = 假>
    {
        @ if (m_window) return FALSE;
        @ uint32_t window_flags = SDL_WINDOW_RESIZABLE | SDL_WINDOW_INPUT_FOCUS | SDL_WINDOW_MOUSE_FOCUS | SDL_WINDOW_ALLOW_HIGHDPI;
        @ if (@<全屏模式>) window_flags |= SDL_WINDOW_FULLSCREEN;
        如果 (渲染器.渲染器类型 == 1)
        {
            @ window_flags |= SDL_WINDOW_OPENGL;
            @ SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);
            @ SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
            @ SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
            @ SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
            @ SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
            @ SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);
            @ SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
            // @ SDL_SetHint(SDL_HINT_IME_SHOW_UI, "1");
        }
        否则 (渲染器.渲染器类型 == 2)
        {
            @ window_flags |= SDL_WINDOW_VULKAN;
        }
        关注屏幕DPI (真)
        宽度 = 乘于屏幕DPI (宽度)
        高度 = 乘于屏幕DPI (高度)
        @ m_window = SDL_CreateWindow(PivW2U{@<标题>}.GetText(), SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, @<宽度>, @<高度>, window_flags);
        @ if (!m_window) return FALSE;
        @ SDL_SysWMinfo info{0};
        @ if (SDL_GetWindowWMInfo(m_window, &info) == SDL_TRUE)
        @     m_hwnd = info.info.win.window;
        变量 窗口句柄 <类型 = 变整数>
        @ @<窗口句柄> = reinterpret_cast<INT_P>(m_window);
        如果 (渲染器.渲染器类型 == 1)
        {
            @ gl_context = SDL_GL_CreateContext(m_window);
            @ SDL_GL_MakeCurrent(m_window, gl_context);
            @ SDL_GL_SetSwapInterval(1); // 启用垂直同步
        }
        如果 (渲染器.加载_SDL (窗口句柄) == 假)
        {
            渲染器.清理 ()
            返回 (假)
        }
        本对象.创建完毕 ()
        ImGui.检查版本 ()
        ImGui.置当前上下文 (ImGui.创建上下文 ())
        变量 字体图集 <类型 = IM字体图集类>
        变量 IO <类型 = ImGuiIO类>
        变量 样式 <类型 = IM样式类>
        IO = ImGui.取IO ()
        IO.标志 = 连续位或 (IO.标志, IM配置标志.键盘导航, IM配置标志.游戏手柄导航, IM配置标志.启用停靠, IM配置标志.启用视口)
        IO.字体全局缩放 = (单精度小数)取屏幕DPI ()
        字体图集 = ImGui.取字体图集 ()
        分支判断 (初始化配置 (IO, 字体图集))
        {
            分支 (1)
            {
                ImGui.浅色样式 ()
            }
            分支 (2)
            {
                ImGui.经典样式 ()
            }
            默认分支 ()
            {
                ImGui.深色样式 ()
            }
        }
        样式 = ImGui.取样式 ()
        如果 (位与 (IO.标志, IM配置标志.启用视口) != 0)
        {
            样式.窗口圆角 = 0.0
            样式.颜色 (IM颜色标识符.窗口背景).w = 1.0
        }
        如果 (字体图集.是否已生成 () == 假)
        {
            字体图集.生成 ()
        }
        如果 (渲染器.渲染器类型 == 1)
        {
            @ ImGui_ImplSDL2_InitForOpenGL(m_window, gl_context);
        }
        否则 (渲染器.渲染器类型 == 2)
        {
            IM_SDL2平台.初始化_Vulkan (窗口句柄)
        }
        否则 (渲染器.渲染器类型 == 0)
        {
            IM_SDL2平台.初始化_D3D (窗口句柄)
        }
        如果 (渲染器.初始化 () == 假)
        {
            渲染器.清理 ()
            IM_SDL2平台.关闭 ()
            ImGui.销毁上下文 ()
            返回 (假)
        }
        本对象.准备渲染 (样式)
        // 消息循环
        变量 完成 <类型 = 逻辑型 值 = 假>
        判断循环 (取反 (完成))
        {
            @ SDL_Event event;
            @ while (SDL_PollEvent(&event))
            @ {
            @     ImGui_ImplSDL2_ProcessEvent(&event);
            @     if (event.type == SDL_QUIT) { this->@<将被销毁>(); @<完成> = TRUE; }
            @     if (event.window.windowID == SDL_GetWindowID(m_window) && event.type == SDL_WINDOWEVENT)
            @     {
            @         switch (event.window.event)
            @         {
            @         case SDL_WINDOWEVENT_CLOSE: { @<完成> = TRUE; break; }
            @         case SDL_WINDOWEVENT_RESIZED: { @<渲染器.重置尺寸>(event.window.data1, event.window.data2); this->@<尺寸被改变>(event.window.data1, event.window.data2); break; }
            @         case SDL_WINDOWEVENT_MOVED: { this->@<位置被改变>(event.window.data1, event.window.data2);  break;}
            @         case SDL_WINDOWEVENT_MINIMIZED: { this->@<最小化被改变>(TRUE);  break;}
            @         case SDL_WINDOWEVENT_MAXIMIZED: { this->@<最大化被改变>(TRUE);  break;}
            @         }
            @     }
            @ }
            // 界面布局
            渲染器.新建帧 ()
            IM_SDL2平台.新建帧 ()
            ImGui.新建帧 ()
            本对象.即将渲染 ()
            // 渲染
            渲染器.渲染_SDL (窗口句柄, 背景颜色)
        }
        // 清理数据
        本对象.渲染结束 ()
        渲染器.关闭 ()
        IM_SDL2平台.关闭 ()
        ImGui.销毁上下文 ()
        渲染器.清理 ()
        @ SDL_GL_DeleteContext(gl_context);
        @ SDL_DestroyWindow(m_window);
        @ m_window = nullptr;
        @ ::PostQuitMessage(0); // 投递退出消息
        @ return TRUE;
    }

    方法 关闭窗口 <公开 注释 = "尝试关闭本窗口." 注释 = "注意: 本方法被调用后窗口不会被立即关闭,而会延迟等待到下一次消息循环时才会关闭." 折叠>
    {
        @ SDL_Event _event {0};
        @ _event.type = SDL_QUIT;
        @ SDL_PushEvent(&_event);
    }

    方法 取窗口句柄 <公开 类型 = 变整数 注释 = "返回本窗口的句柄,如果尚未创建或创建失败,则返回0." 注释 = "注意: 返回的是Win32窗口句柄,可以使用Win32的API进行操作." 折叠
            @嵌入式方法 = "">
    {
        @ reinterpret_cast<INT_P>(@sn<this>.m_hwnd)
    }

    方法 取窗口对象指针 <公开 类型 = 变整数 注释 = "返回本SDL窗口的对象指针,如果尚未创建或创建失败,则返回0." 折叠 @嵌入式方法 = "">
    {
        @ reinterpret_cast<INT_P>(@sn<this>.m_window)
    }

    方法 最小化 <公开 注释 = "将本窗口最小化到任务栏图标" 折叠 @嵌入式方法 = "">
    {
        @ SDL_MinimizeWindow(@sn<this>.m_window)
    }

    方法 最大化 <公开 注释 = "将本窗口设置为最大化" 折叠 @嵌入式方法 = "">
    {
        @ SDL_MaximizeWindow(@sn<this>.m_window)
    }

    方法 还原窗口 <公开 注释 = "将本窗口还原到原来的尺寸" 折叠 @嵌入式方法 = "">
    {
        @ SDL_RestoreWindow(@sn<this>.m_window)
    }

    方法 获取焦点 <公开 注释 = "将当前输入焦点设置到本窗口上" 折叠 @嵌入式方法 = "">
    {
        @ SDL_SetWindowInputFocus(@sn<this>.m_window)
    }

    方法 取窗口尺寸 <公开 注释 = "获取本窗口的当前宽度和高度" 折叠 @嵌入式方法 = "">
    参数 宽度 <类型 = 整数 @需求类型 = 可写入变量>
    参数 高度 <类型 = 整数 @需求类型 = 可写入变量>
    {
        @ SDL_GetWindowSize(@sn<this>.m_window, &@<宽度>, &@<高度>)
    }

    方法 置窗口尺寸 <公开 注释 = "设置本窗口的宽度和高度" 折叠 @嵌入式方法 = "">
    参数 宽度 <类型 = 整数>
    参数 高度 <类型 = 整数>
    {
        @ SDL_SetWindowSize(@sn<this>.m_window, @<宽度>, @<高度>)
    }

    方法 取窗口位置 <公开 注释 = "获取本窗口的当前位置" 折叠 @嵌入式方法 = "">
    参数 顶边位置 <类型 = 整数 @需求类型 = 可写入变量>
    参数 左边位置 <类型 = 整数 @需求类型 = 可写入变量>
    {
        @ SDL_GetWindowPosition(@sn<this>.m_window, &@<左边位置>, &@<顶边位置>)
    }

    方法 置窗口位置 <公开 注释 = "设置本窗口的位置" 折叠 @嵌入式方法 = "">
    参数 顶边位置 <类型 = 整数>
    参数 左边位置 <类型 = 整数>
    {
        @ SDL_SetWindowPosition(@sn<this>.m_window, @<左边位置>, @<顶边位置>)
    }

    方法 限制窗口尺寸 <公开 注释 = "限制本窗口的宽度和高度,只能在限制的范围内调整大小" 折叠>
    参数 最小宽度 <类型 = 整数>
    参数 最大宽度 <类型 = 整数>
    参数 最小高度 <类型 = 整数>
    参数 最大高度 <类型 = 整数>
    {
        @ SDL_SetWindowMinimumSize(m_window, @<最小宽度>, @<最小高度>);
        @ SDL_SetWindowMaximumSize(m_window, @<最大宽度>, @<最大高度>);
    }

    # 属性

    方法 左边 <公开 属性读 类型 = 整数 注释 = "返回本窗口的左边位置" 折叠 @禁止流程检查 = 真>
    {
        @ if (m_window != nullptr) {
        @     int left;
        @     SDL_GetWindowPosition(m_window, &left, nullptr);
        @     return left;
        @ }
        @ return 0;
    }

    方法 左边 <公开 属性写 注释 = "设置本窗口的左边位置" 折叠>
    参数 所欲设置的位置 <类型 = 整数>
    {
        @ if (m_window != nullptr) {
        @     int top;
        @     SDL_GetWindowPosition(m_window, nullptr, &top);
        @     SDL_SetWindowPosition(m_window, @<所欲设置的位置>, top);
        @ }
    }

    方法 顶边 <公开 属性读 类型 = 整数 注释 = "返回本窗口的顶边位置" 折叠 @禁止流程检查 = 真>
    {
        @ if (m_window != nullptr) {
        @     int top;
        @     SDL_GetWindowPosition(m_window, nullptr, &top);
        @     return top;
        @ }
        @ return 0;
    }

    方法 顶边 <公开 属性写 注释 = "设置本窗口的顶边位置" 折叠>
    参数 所欲设置的位置 <类型 = 整数>
    {
        @ if (m_window != nullptr) {
        @     int left;
        @     SDL_GetWindowPosition(m_window, &left, nullptr);
        @     SDL_SetWindowPosition(m_window, left, @<所欲设置的位置>);
        @ }
    }

    方法 宽度 <公开 属性读 类型 = 整数 注释 = "返回本窗口的宽度" 折叠 @禁止流程检查 = 真>
    {
        @ if (m_window != nullptr) {
        @     int width;
        @     SDL_GetWindowSize(m_window, &width, NULL);
        @     return width;
        @ }
        @ return 0;
    }

    方法 宽度 <公开 属性写 注释 = "设置本窗口的宽度" 折叠>
    参数 所欲设置的宽度 <类型 = 整数>
    {
        @ if (m_window != nullptr) {
        @     int hight;
        @     SDL_GetWindowSize(m_window, nullptr, &hight);
        @     SDL_SetWindowSize(m_window, @<所欲设置的宽度>, hight);
        @ }
    }

    方法 高度 <公开 属性读 类型 = 整数 注释 = "返回本窗口的高度" 折叠 @禁止流程检查 = 真>
    {
        @ if (m_window != nullptr) {
        @     int hight;
        @     SDL_GetWindowSize(m_window, NULL, &hight);
        @     return hight;
        @ }
        @ return 0;
    }

    方法 高度 <公开 属性写 注释 = "设置本窗口的高度" 折叠>
    参数 所欲设置的高度 <类型 = 整数>
    {
        @ if (m_window != nullptr) {
        @     int width;
        @     SDL_GetWindowSize(m_window, &width, nullptr);
        @     SDL_SetWindowSize(m_window, width, @<所欲设置的高度>);
        @ }
    }

    方法 标题 <公开 属性读 类型 = 文本型 注释 = "返回本窗口的当前标题文本" 折叠 @禁止流程检查 = 真>
    {
        @ return *PivU2Ws{SDL_GetWindowTitle(m_window)};
    }

    方法 标题 <公开 属性写 注释 = "设置本窗口的当前标题文本" 折叠>
    参数 所欲设置的标题 <类型 = 文本型 注释 = "提供所欲设置的标题文本">
    {
        @ SDL_SetWindowTitle(m_window, PivW2U{@<所欲设置的标题>}.GetText());
    }

    方法 显示边框 <公开 属性读 类型 = 逻辑型 注释 = "返回窗口是否显示标题栏和边框" 折叠 @禁止流程检查 = 真>
    {
        @ return (SDL_GetWindowFlags(m_window) & SDL_WINDOW_BORDERLESS) == 0;
    }

    方法 显示边框 <公开 属性写 注释 = "设置是否显示窗口的标题栏和边框" 折叠>
    参数 是否显示 <类型 = 逻辑型>
    {
        @ SDL_SetWindowBordered(m_window, static_cast<SDL_bool>(@<是否显示>));
    }

    方法 可视 <公开 属性读 类型 = 逻辑型 注释 = "返回本窗口当前是否可视" 折叠 @禁止流程检查 = 真>
    {
        @ return (SDL_GetWindowFlags(m_window) & SDL_WINDOW_SHOWN) != 0;
    }

    方法 可视 <公开 属性写 注释 = "设置本窗口当前是否可视,注意会连任务栏图标一起隐藏." 折叠>
    参数 是否可视 <类型 = 逻辑型 注释 = "指定本组件是否可视">
    {
        @ if (@<是否可视>)
        @     SDL_ShowWindow(m_window);
        @ else
        @     SDL_HideWindow(m_window);
    }

    方法 置于顶层 <公开 属性读 类型 = 逻辑型 注释 = "返回本窗口当前是否已置于顶层" 折叠 @禁止流程检查 = 真>
    {
        @ return (SDL_GetWindowFlags(m_window) & SDL_WINDOW_ALWAYS_ON_TOP) != 0;
    }

    方法 置于顶层 <公开 属性写 注释 = "设置本窗口是否置于顶层" 折叠>
    参数 是否置于顶层 <类型 = 逻辑型 注释 = "指定本窗口是否置于顶层">
    {
        @ SDL_SetWindowAlwaysOnTop(m_window, static_cast<SDL_bool>(@<是否置于顶层>));
    }

    方法 窗口透明度 <公开 属性读 类型 = 单精度小数 注释 = "返回本窗口(包括标题栏和边框)的整体透明度,如果系统不支持窗口透明度将始终返回1" 折叠 @禁止流程检查 = 真>
    {
        @ float out_opacity = 1.0f;
        @ SDL_GetWindowOpacity(m_window, &out_opacity);
        @ return out_opacity;
    }

    方法 窗口透明度 <公开 属性写 注释 = "设置本窗口(包括标题栏和边框)的整体透明度" 折叠>
    参数 透明度 <类型 = 单精度小数 注释 = "请提供0.0f-1.0f之间的值,即完全透明到完全不透明.">
    {
        @ SDL_SetWindowOpacity(m_window, @<透明度>);
    }

    # ---
    # @begin
    # <> <include>
    # SDL_Window* m_window = nullptr;
    # SDL_GLContext gl_context = nullptr;
    # static void @an<_sOnBeforeAppInit>() {
    #     if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_GAMECONTROLLER) != 0) {
    #         HWND hParentWnd = NULL;
    # #ifdef _AFX
    #         CWinApp* pWinApp = AfxGetApp();
    #         if (pWinApp != NULL) hParentWnd = pWinApp->m_pMainWnd->GetSafeHwnd ();
    # #endif
    #         if (hParentWnd == NULL) hParentWnd = ::GetActiveWindow();
    #         if (hParentWnd == NULL) hParentWnd = ::GetDesktopWindow();
    #         ::MessageBoxW(hParentWnd, L"初始化SDL引擎失败，即将退出应用程序!", L"错误", MB_OK | MB_ICONERROR | MB_SYSTEMMODAL | MB_TASKMODAL);
    #         exit(0);
    #     }
    # }
    # static void @an<_sOnAfterAppExit>() { SDL_Quit(); }
    # <> </include>
    # @end
    # ---
}

类 IM_后端模板类 <公开 注释 = "专门给火山的 MFC/WTL 窗口使用,使用时必须调用\"初始化()\"." 注释 = "\"模板类型1\"为所使用的渲染器类型,支持以下的渲染器:"
        注释 = "  IM_DX9渲染器   IM_DX10渲染器    IM_DX11渲染器" 注释 = "  IM_DX12渲染器  IM_OpenGL渲染器  IM_Vulkan渲染器"
        注释 = "注意: 使用本模板的实现类,必须配置\"MFC界面基本类\"或\"WTL界面基本类\"." 折叠 @模板基础类 = 真>
{
    变量 渲染器 <公开 类型 = 模板类型1 注释 = "需要更改渲染器时改动此处的变量类型">
    变量 背景颜色 <公开 类型 = ImVec4 注释 = "x=红色; y=绿色; z=蓝色; w=Alpha" x = 0.45 y = 0.55 z = 0.60 w = 1.00>
    变量 _退出循环 <类型 = 同步事件类 注释 = "退出消息循环线程">
    变量 _IM窗口句柄 <类型 = 变整数 注释 = "ImGui的窗口句柄">
    变量 _前窗口过程 <静态 类型 = 变整数>
    变量 _渲染处理器 <类型 = 高级主线程处理器 注释 = "高级主线程处理器">

    方法 类_初始化 <折叠>
    {
        ImGui.检查版本 ()
    }

    方法 类_清理 <折叠>
    {
        释放 ()
    }

    方法 取窗口句柄 <公开 类型 = 变整数 注释 = "返回当前所绑定的Win32窗口句柄,如果尚未初始化或初始化失败,则返回0." 折叠>
    {
        返回 (_IM窗口句柄)
    }

    方法 初始化 <公开 类型 = 逻辑型 注释 = "将指定的窗口句柄绑定到ImGui并完成初始化" 折叠>
    参数 窗口句柄 <类型 = 变整数>
    {
        如果 (_IM窗口句柄 != 0)
        {
            返回 (真)  // 不要重复初始化
        }
        如果 (窗口句柄 == 0)
        {
            返回 (假)
        }
        _IM窗口句柄 = 窗口句柄
        如果 (渲染器.创建设备 (_IM窗口句柄) == 假)
        {
            渲染器.释放设备 (_IM窗口句柄)
            _IM窗口句柄 = 0
            返回 (假)
        }
        _前窗口过程 = 窗口操作类.置窗口属性值 (_IM窗口句柄, -4, 取静态方法地址 (_窗口过程))
        ImGui.置当前上下文 (ImGui.创建上下文 ())
        变量 IO <类型 = ImGuiIO类>
        变量 字体图集 <类型 = IM字体图集类>
        变量 样式 <类型 = IM样式类>
        IO = ImGui.取IO ()
        IO.标志 = 连续位或 (IO.标志, IM配置标志.键盘导航, IM配置标志.游戏手柄导航, IM配置标志.启用停靠, IM配置标志.启用视口)
        关注屏幕DPI (真)
        ImGui.取IO ().字体全局缩放 = (单精度小数)取屏幕DPI ()
        字体图集 = ImGui.取字体图集 ()
        样式 = ImGui.取样式 ()
        分支判断 (初始化配置 (IO, 字体图集))
        {
            分支 (1)
            {
                ImGui.浅色样式 ()
            }
            分支 (2)
            {
                ImGui.经典样式 ()
            }
            默认分支 ()
            {
                ImGui.深色样式 ()
            }
        }
        如果 (位与 (IO.标志, IM配置标志.启用视口) != 0)
        {
            样式.窗口圆角 = 0.0
            样式.颜色 (IM颜色标识符.窗口背景).w = 1.0
        }
        如果 (字体图集.是否已生成 () == 假)
        {
            字体图集.生成 ()
        }
        如果 (渲染器.渲染器类型 == 0)
        {
            IM_Win32平台.初始化 (_IM窗口句柄)
        }
        否则
        {
            IM_Win32平台.初始化_OpenGL (_IM窗口句柄)
        }
        如果 (渲染器.初始化 () == 假)
        {
            IM_Win32平台.关闭 ()
            _IM窗口句柄 = 0
            返回 (假)
        }
        渲染器.准备 ()
        本对象.准备渲染 (样式)
        _退出循环.重置 ()
        线程对象类.启动动态线程 (本对象, "mainloop", _IM窗口句柄)
        返回 (真)
    }

    方法 释放 <公开 注释 = "释放ImGui和设备,窗口销毁时会自动释放,你也可以手动释放以重新初始化ImGui." 折叠>
    {
        _退出循环.放行 ()
        如果 (_IM窗口句柄 != 0)
        {
            渲染器.关闭 ()
            IM_Win32平台.关闭 ()
            ImGui.销毁上下文 ()
            渲染器.释放设备 (_IM窗口句柄)
            窗口操作类.置窗口属性值 (_IM窗口句柄, -4, _前窗口过程)
            _IM窗口句柄 = 0
        }
    }

    方法 _窗口过程 <静态 类型 = 变整数 折叠>
    参数 窗口句柄 <类型 = 变整数>
    参数 消息值 <类型 = 整数>
    参数 消息参数1 <类型 = 变整数>
    参数 消息参数2 <类型 = 变整数>
    {
        如果 (IM_Win32平台.消息处理 (窗口句柄, 消息值, 消息参数1, 消息参数2))
        {
            返回 (1)
        }
        返回 (窗口操作类.调用窗口过程 (_前窗口过程, 窗口句柄, 消息值, 消息参数1, 消息参数2))
    }

    方法 _消息循环 <类型 = 整数 折叠 @输出名 = "mainloop" @强制输出 = 真>
    参数 窗口句柄_ <类型 = 变整数>
    {
        判断循环 (_退出循环.限时等待 (0) == 假)
        {
            变量 _宽度 <静态 类型 = 整数>
            变量 _高度 <静态 类型 = 整数>
            @ static RECT rt;
            @ if (::GetClientRect(reinterpret_cast<HWND>(@<窗口句柄_>), &rt))
            @ {
            @     @<_宽度> = rt.right - rt.left;
            @     @<_高度> = rt.bottom - rt.top;
            @ }
            如果 (_宽度 != 0 && _高度 != 0)
            {
                _渲染处理器.发送通知 (0, _宽度, _高度)
            }
            否则
            {
                延时 (50)  // 窗口不显示时,增加延时以减少CPU占用
            }
        }
        返回 (0)
    }

    方法 高级主线程处理器_接收到通知 <接收事件 类型 = 整数 注释 = "在其它线程中调用本对象的\"发送通知\"/\"投递通知\"方法后,本事件将被触发."
            注释 = "本事件的接收方法将始终在程序的UI主线程中执行." 注释 = "本事件中的参数值为调用\"发送通知\"/\"投递通知\"方法时所提供的对应参数值."
            返回值注释 = "如果本事件由\"发送通知\"方法调用触发,事件处理方法的返回值将返回到\"发送通知\"方法的调用方." 折叠>
    参数 来源对象 <类型 = 高级主线程处理器 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    参数 通知码 <类型 = 变整数>
    参数 参数1 <类型 = 变整数>
    参数 参数2 <类型 = 变整数>
    参数 参数对象 <类型 = 对象包装类 注释 = "包装中为发送/投递通知时所提供对象的复制对象,如果未提供则为空(\"参数对象.是否为空\"方法返回真).">
    {
        如果 (来源对象 == _渲染处理器)
        {
            渲染器.重置尺寸 ((整数)参数1, (整数)参数2)
            渲染器.新建帧 ()
            IM_Win32平台.新建帧 ()
            ImGui.新建帧 ()
            本对象.即将渲染 ()
            渲染器.渲染 (背景颜色)
        }
        返回 (1)
    }

    方法 初始化配置 <公开 定义事件 类型 = 整数 注释 = "在ImGui窗口显示之前发送一次此事件,用于设置ImGui的IO和字体等参数."
            返回值注释 = "返回1表示使用浅色样式,2为经典样式,其他任意值为默认的深色样式." 折叠>
    参数 IO <类型 = ImGuiIO类 注释 = "ImGui的输入输出结构">
    参数 字体图集 <类型 = IM字体图集类 注释 = "请在此添加字体(默认未添加任何字体,未添加中文字体将无法显示汉字).">

    方法 准备渲染 <公开 定义事件 类型 = 整数 注释 = "在ImGui开始渲染前发送一次此事件,可用于加载图片(部分渲染器不能在其他位置加载图片)." 折叠>
    参数 样式配置 <类型 = IM样式类 注释 = "ImGui的样式配置">

    方法 即将渲染 <公开 定义事件 类型 = 整数 注释 = "当ImGui帧数据被渲染前发送此事件,请在本事件内设计ImGui的界面布局." 注释 = "注意:"
            注释 = "  1. 本事件前后已经内部处理好新建帧和渲染等操作,你只需设计布局即可." 注释 = "  2. ImGUI的默认帧速率为60fps,即每秒触发本事件60次,因此在此进行耗时操作将"
            注释 = "导致帧速率降低和界面卡顿,如有必要,请另开线程执行耗时操作." 注释 = "  3. 因为本事件的执行频率足够高,所以键鼠输入等事件也可以在此一起处理.">
}

#
