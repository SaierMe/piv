<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv" @视窗.外部头文件 = "src\\detail\\piv_base.hpp">

类 标准调用类 <公开 折叠 折叠2 @文档 = "category = \"标准库\"" @别名 = "//" @类用途 = 访问静态成员 @别名类型 = 本地类>
{
    方法 调用函数指针 <公开 静态 注释 = "调用所指定的函数指针,所调用函数的调用约定必须为__cdecl" 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 注释 = "提供所欲调用类静态方法的地址,该地址可以使用\"取静态方法地址\"方法获取." "">
    参数 返回值类型 <注释 = "  该返回值数据类型必须与被调用方法的返回值数据类型保持一致," 注释 = "否则将导致不可意料的问题." @需求类型 = 数据类型 @匹配类型 = 通用型
            @返回值类型 = 0>
    参数 调用参数表 <注释 = "  调用参数表的格式务必和被调用方法的参数表一致,否则将导致不" 注释 = "可意料的问题." @可扩展 = "" @匹配类型 = 通用型>
    {
        @ ((@<返回值类型>(__cdecl *)(@pdt_list<调用参数表>))@<函数指针>)(@<调用参数表>)
    }

    方法 调用函数指针无返回 <公开 静态 注释 = "调用所指定的函数指针,所调用函数的调用约定必须为__cdecl" 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 注释 = "提供所欲调用类静态方法的地址,该地址可以使用\"取静态方法地址\"方法获取.">
    参数 调用参数表 <注释 = "调用参数表的格式务必和被调用方法的参数表一致,否则将导致不可意料的问题." @可扩展 = "" @匹配类型 = 通用型>
    {
        @ ((void (__cdecl *)(@pdt_list<调用参数表>))@<函数指针>)(@<调用参数表>)
    }

    方法 调用函数指针无参数 <公开 静态 注释 = "调用所指定的函数指针,所调用函数的调用约定必须为__cdecl" 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 注释 = "提供所欲调用类静态方法的地址,该地址可以使用\"取静态方法地址\"方法获取.">
    参数 返回值类型 <注释 = "  该返回值数据类型必须与被调用方法的返回值数据类型保持一致," 注释 = "否则将导致不可意料的问题." @需求类型 = 数据类型 @匹配类型 = 通用型
            @返回值类型 = 0>
    {
        @ ((@<返回值类型>(__cdecl *)())@<函数指针>)()
    }

    方法 调用函数指针无参数及无返回 <公开 静态 注释 = "调用所指定的函数指针." 注释 = "由于无参数和无返回值,应该是不限制调用约定." 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 "">
    {
        @ ((void(__cdecl *)())@<函数指针>)()
    }

    方法 调用函数指针无返回stdcall <公开 静态 注释 = "调用所指定的函数指针,等同于视窗基本类的\"调用无返回值静态方法\"." 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 注释 = "提供所欲调用类静态方法的地址,该地址可以使用\"取静态方法地址\"方法获取.">
    参数 调用参数表 <注释 = "调用参数表的格式务必和被调用方法的参数表一致,否则将导致不可意料的问题." @可扩展 = "" @匹配类型 = 通用型>
    {
        @ ((void(CALLBACK *)(@pdt_list<调用参数表>))@<函数指针>)(@<调用参数表>)
    }

    方法 调用函数指针stdcall <公开 静态 注释 = "调用所指定的函数指针,等同于视窗基本类的\"调用静态方法\"." 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 注释 = "提供所欲调用静态方法的地址,该地址可以使用\"取静态方法地址\"方法获取." "">
    参数 返回值类型 <注释 = "  该返回值数据类型必须与被调用方法的返回值数据类型保持一致," 注释 = "否则将导致不可意料的问题." @需求类型 = 数据类型 @匹配类型 = 通用型
            @返回值类型 = 0>
    参数 调用参数表 <注释 = "  调用参数表的格式务必和被调用方法的参数表一致,否则将导致不" 注释 = "可意料的问题." @可扩展 = "" @匹配类型 = 通用型>
    {
        @ ((@<返回值类型>(CALLBACK *)(@pdt_list<调用参数表>))@<函数指针>)(@<调用参数表>)
    }
}

# 集合容器 基础模板 ====

类 标准集合基础 <公开 注释 = "封装了集合容器的基本操作,请勿直接使用本类." 注释 = "  模板类型1: 集合的键类型" 折叠 @文档 = "category = \"数据处理.键值表模板\""
        @别名 = "//" @别名类型 = 本地类 @模板基础类 = 真>
{
    方法 创建 <公开 静态 类型 = 标准集合基础 注释 = "从一个或多个值创建一个集合对象" 折叠 @嵌入式方法 = "">
    参数 欲添加成员 <类型 = 模板类型1 @可扩展 = "">
    {
        @ @dt<标准集合基础>{@<欲添加成员>}
    }

    方法 初始化 <公开 静态 注释 = "从一个或多个值初始化本集合" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准集合基础>
    参数 欲添加成员 <类型 = 模板类型1 @可扩展 = "">
    {
        @ @<本容器> = {@<欲添加成员>}
    }

    方法 取成员数 <公开 静态 类型 = 整数 注释 = "返回本集合中已有成员的数目" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准集合基础>
    {
        @ static_cast<INT>(@<本容器>.size())
    }

    方法 是否存在 <公开 静态 类型 = 逻辑型 注释 = "返回所指定的值是否已经存在" 折叠 @禁止流程检查 = 真>
    参数 本容器 <类型 = 标准集合基础>
    参数 所欲检查的值 <类型 = 模板类型1>
    {
        @ return (@<本容器>.find(@<所欲检查的值>) != @<本容器>.end());
    }

    方法 清空 <公开 静态 注释 = "清除本集合中的所有内容" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准集合基础>
    {
        @ @<本容器>.clear()
    }

    方法 交换 <公开 静态 注释 = "交换两个集合中的数据" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准集合基础>
    参数 所欲交换的集合 <类型 = 标准集合基础>
    {
        @ @<本容器>.swap(@<所欲交换的集合>)
    }

    方法 是否为空 <公开 静态 类型 = 逻辑型 注释 = "返回本集合是否为空" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准集合基础>
    {
        @ @<本容器>.empty()
    }

    方法 取指定值数目 <公开 静态 类型 = 整数 注释 = "返回指定成员值在本哈希集中的记录数目" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准集合基础>
    参数 欲检查的值 <类型 = 模板类型1>
    {
        @ static_cast<INT>(@<本容器>.count(@<欲检查的值>))
    }

    方法 枚举循环 <公开 静态 注释 = "  启动一个循环来正向枚举本集合中的每一个成员,在循环中可以调用" 注释 = "\"取枚举值\"方法来获取当前所枚举到的成员值." 折叠
            @嵌入式方法 = "name = piv_set_iter\r\nhas_loop_body = true">
    参数 本容器 <类型 = 标准集合基础>
    {
        @ auto& @sn<rand_name0> = @<本容器>;
        @ for (auto& __piv_set_iter = @sn<rand_name0>.begin(); __piv_set_iter != @sn<rand_name0>.end(); __piv_set_iter++)
    }

    方法 逆向枚举循环 <公开 静态 注释 = "  启动一个循环来逆向枚举本集合中的每一个成员,在循环中可以调用" 注释 = "\"取枚举值\"方法来获取当前所枚举到的成员值." 折叠
            @嵌入式方法 = "name = piv_set_riter\r\nhas_loop_body = true">
    参数 本容器 <类型 = 标准集合基础>
    {
        @ auto& @sn<rand_name0> = @<本容器>;
        @ for (auto& __piv_set_iter = @sn<rand_name0>.rbegin(); __piv_set_iter != @sn<rand_name0>.rend(); __piv_set_iter++)
    }

    方法 取枚举值 <公开 静态 类型 = 模板类型1 注释 = "  只能在本类的\"枚举循环\"/\"逆向枚举循环\"语句的子语句体中使用,用作取回当前所枚举到的成员值,"
            注释 = "如果有多层本类或本类继承类的\"枚举循环\"/\"逆向枚举循环\"嵌套,本方法将返回最近层\"枚举循环\"/" 注释 = "\"逆向枚举循环\"所枚举到的成员值." 折叠
            @嵌入式方法 = "parent = \"piv_set_iter, piv_set_riter\"">
    参数 本容器 <类型 = 标准集合基础>
    {
        @ *__piv_set_iter
    }

    # 集合操作

    方法 是否包含 <公开 静态 类型 = 逻辑型 注释 = "判断本集合是否含有另一个集合的所有成员." 注释 = "例: {1, 2, 3, 4} 包含 {1, 3} = 真" 折叠 @禁止流程检查 = 真>
    参数 本容器 <类型 = 标准集合基础>
    参数 欲判断的集合 <类型 = 标准集合基础 注释 = "所欲判断是否被完整包含的集合">
    {
        @ return std::includes(@<本容器>.cbegin(), @<本容器>.cend(),
        @     @<欲判断的集合>.cbegin(), @<欲判断的集合>.cend(),
        @     @<本容器>.key_comp());
    }

    方法 求并集 <公开 静态 注释 = "求本集合与另一个集合的并集." 注释 = "返回的结果集合包含两个集合的所有成员."
            注释 = "例: {1, 3, 5} 并集 {2, 4} = {1, 2, 3, 4, 5}" 折叠>
    参数 本容器 <类型 = 标准集合基础>
    参数 欲计算的集合 <类型 = 标准集合基础 注释 = "所欲计算的另一个集合">
    参数 结果集合 <类型 = 标准集合基础 注释 = "返回的结果保存在此集合中">
    {
        @ std::set_union(@<本容器>.cbegin(), @<本容器>.cend(),
        @     @<欲计算的集合>.cbegin(), @<欲计算的集合>.cend(),
        @     std::inserter(@<结果集合>, @<结果集合>.end()),
        @     @<本容器>.key_comp());
    }

    方法 求交集 <公开 静态 注释 = "求本集合与另一个集合的交集." 注释 = "返回的结果集合仅包含在两个集合都能找到的成员."
            注释 = "例: {1, 3, 5} 交集 {1, 3} = {1, 3}" 折叠>
    参数 本容器 <类型 = 标准集合基础>
    参数 欲计算的集合 <类型 = 标准集合基础 注释 = "所欲计算的另一个集合">
    参数 结果集合 <类型 = 标准集合基础 注释 = "返回的结果保存在此集合中">
    {
        @ std::set_intersection(@<本容器>.cbegin(), @<本容器>.cend(),
        @     @<欲计算的集合>.cbegin(), @<欲计算的集合>.cend(),
        @     std::inserter(@<结果集合>, @<结果集合>.end()),
        @     @<本容器>.key_comp());
    }

    方法 求差集 <公开 静态 注释 = "求本集合与另一个集合的差集." 注释 = "返回的结果集合复制了本集合未在另一个集合找到的成员."
            注释 = "例: {1, 3, 5} 差集 {2, 3} = {1, 5}" 折叠>
    参数 本容器 <类型 = 标准集合基础>
    参数 欲计算的集合 <类型 = 标准集合基础 注释 = "所欲计算的另一个集合">
    参数 结果集合 <类型 = 标准集合基础 注释 = "返回的结果保存在此集合中">
    {
        @ std::set_difference(@<本容器>.cbegin(), @<本容器>.cend(),
        @     @<欲计算的集合>.cbegin(), @<欲计算的集合>.cend(),
        @     std::inserter(@<结果集合>, @<结果集合>.end()),
        @     @<本容器>.key_comp());
    }

    方法 求对称差 <公开 静态 注释 = "求本集合与另一个集合的对称差." 注释 = "返回的结果集合剔除了在两个集合都能找到的成员."
            注释 = "例: {1, 3, 5} 对称差 {2, 3} = {1, 2, 5}" 折叠>
    参数 本容器 <类型 = 标准集合基础>
    参数 欲计算的集合 <类型 = 标准集合基础 注释 = "所欲计算的另一个集合">
    参数 结果集合 <类型 = 标准集合基础 注释 = "返回的结果保存在此集合中">
    {
        @ std::set_symmetric_difference(@<本容器>.cbegin(), @<本容器>.cend(),
        @     @<欲计算的集合>.cbegin(), @<欲计算的集合>.cend(),
        @     std::inserter(@<结果集合>, @<结果集合>.end()),
        @     @<本容器>.key_comp());
    }
}

类 唯一值集合模板 <公开 基础类 = 标准集合基础 注释 = "封装了唯一值集合容器的基本操作,请勿直接使用本类." 注释 = "  模板类型1: 集合的键类型" 折叠
        @文档 = "category = \"数据处理.键值表模板\"" @模板基础类 = 真>
{
    方法 插入 <公开 静态 类型 = 逻辑型 注释 = "插入一个值进集合中" 返回值注释 = "如果所指定值已经存在返回假,否则返回真." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 唯一值集合模板>
    参数 所欲插入的值 <类型 = 模板类型1>
    {
        @ @<本容器>.insert(@<所欲插入的值>).second
    }

    方法 插入并返回成员 <公开 静态 类型 = 模板类型1 注释 = "插入一个值进集合中,并返回所插入的值." 注释 = "注意: 集合的键不能修改,所以返回的是拷贝值."
            返回值注释 = "如果所指定值已经存在返回则返回先前值." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 唯一值集合模板>
    参数 所欲插入的值 <类型 = 模板类型1>
    {
        @ *@<本容器>.insert(@<所欲插入的值>).first
    }

    方法 置入 <公开 静态 类型 = 逻辑型 注释 = "在集合中原位构造一个值,相比\"插入\"可以避免不必要的复制或移动操作." 返回值注释 = "如果所指定值已经存在返回则返回先前值" 折叠
            @嵌入式方法 = "">
    参数 本容器 <类型 = 唯一值集合模板>
    参数 所欲插入的值 <类型 = 模板类型1>
    {
        @ @<本容器>.emplace(@<所欲插入的值>).second
    }

    方法 置入并返回成员 <公开 静态 类型 = 模板类型1 注释 = "在集合中原位构造一个值,并返回所置入的值." 注释 = "相比\"插入\"可以避免不必要的复制或移动操作."
            注释 = "注意: 集合的键不能修改,所以返回的是拷贝值." 返回值注释 = "如果所指定值已经存在返回假,否则返回真." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 唯一值集合模板>
    参数 所欲插入的值 <类型 = 模板类型1>
    {
        @ *@<本容器>.emplace(@<所欲插入的值>).first
    }

    方法 删除 <公开 静态 类型 = 逻辑型 注释 = "删除所指定的值,返回其是否存在." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 唯一值集合模板>
    参数 所欲删除的值 <类型 = 模板类型1>
    {
        @ (@<本容器>.erase(@<所欲删除的值>) > 0)
    }
}

类 多值集合模板 <公开 基础类 = 标准集合基础 注释 = "封装了多值(非独有)集合容器的基本操作,请勿直接使用本类." 注释 = "  模板类型1: 集合的键类型" 折叠
        @文档 = "category = \"数据处理.键值表模板\"" @模板基础类 = 真>
{
    方法 插入 <公开 静态 注释 = "插入一个值进集合中,允许记录重复的值." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 多值集合模板>
    参数 所欲插入的值 <类型 = 模板类型1>
    {
        @ @<本容器>.insert(@<所欲插入的值>)
    }

    方法 插入并返回成员 <公开 静态 类型 = 模板类型1 注释 = "插入一个值进集合中,并返回所插入的值,允许记录重复的值." 注释 = "注意: 集合的键不能修改,所以返回的是拷贝值." 折叠
            @嵌入式方法 = "">
    参数 本容器 <类型 = 多值集合模板>
    参数 所欲插入的值 <类型 = 模板类型1>
    {
        @ *@<本容器>.insert(@<所欲插入的值>)
    }

    方法 置入 <公开 静态 注释 = "在集合中原位构造一个值,相比\"插入\"可以避免不必要的复制或移动操作." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 多值集合模板>
    参数 所欲插入的值 <类型 = 模板类型1>
    {
        @ @<本容器>.emplace(@<所欲插入的值>)
    }

    方法 置入并返回成员 <公开 静态 类型 = 模板类型1 注释 = "在集合中原位构造一个值,并返回所置入的值." 注释 = "相比\"插入\"可以避免不必要的复制或移动操作."
            注释 = "注意: 集合的键不能修改,所以返回的是拷贝值." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 多值集合模板>
    参数 所欲插入的值 <类型 = 模板类型1>
    {
        @ *@<本容器>.emplace(@<所欲插入的值>)
    }

    方法 删除 <公开 静态 类型 = 逻辑型 注释 = "删除所有满足条件的值,并返回删除的值数量." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 多值集合模板>
    参数 所欲删除的值 <类型 = 模板类型1>
    {
        @ static_cast<INT>(@<本容器>.erase(@<所欲删除的值>))
    }

    方法 取值计数 <公开 静态 类型 = 整数 注释 = "返回指定成员值在本哈希集中的记录数目" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 多值集合模板>
    参数 欲检查的值 <类型 = 模板类型1>
    {
        @ static_cast<INT>(@<本容器>.count(@<欲检查的值>))
    }
}

# 排序集(std::set) ===

类 通用排序集模板 <公开 基础类 = 唯一值集合模板 注释 = "  排序集是一种有序容器,因为键的唯一性,天然具有去重功能." 注释 = "插入键时会通过红黑树比较大小,按照从小到大进行排序."
        注释 = "  模板类型1: 集合的元素类型,提供的类型必须支持小于操作符<" @文档 = "category = \"数据处理.键值表模板\""
        @视窗.外部头文件 = "<set>\r\n<algorithm>" @别名 = "std::set<模板类型1>" @模板基础类 = 真>

# 排序集 实现类 ---

类 字节排序集 <公开 基础类 = 通用排序集模板 注释 = "可以对插入的字节值进行去重和从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "字节">

类 字符排序集 <公开 基础类 = 通用排序集模板 注释 = "可以对插入的字符值进行去重和从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "字符">

类 整数排序集 <公开 基础类 = 通用排序集模板 注释 = "可以对插入的整数值进行去重和从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "整数">

类 变整数排序集 <公开 基础类 = 通用排序集模板 注释 = "可以对插入的变整数值进行去重和从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "变整数">

类 长整数排序集 <公开 基础类 = 通用排序集模板 注释 = "可以对插入的长整数值进行去重和从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "长整数">

类 小数排序集 <公开 基础类 = 通用排序集模板 注释 = "可以对插入的小数值进行去重和从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "小数">

类 文本排序集 <公开 基础类 = 通用排序集模板 注释 = "可以对插入的文本进行去重和从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "文本型">

类 大小写无关排序集模板 <公开 基础类 = 唯一值集合模板 注释 = "可以不区分大小写地对插入的文本进行去重和从小到大的排序" 注释 = "模板类型1(仅支持以下类型):" 注释 = "  - 文本型"
        注释 = "  - 标准文本类W  标准文本类U  标准文本类A" 注释 = "  - 文本视图类W  文本视图类U  文本视图类A" @文档 = "category = \"数据处理.排序集\""
        @视窗.外部头文件 = "<set>\r\n<algorithm>" @别名 = "std::set<模板类型1, piv::ci_less<模板类型1>>" @模板基础类 = 真>

类 大小写无关文本排序集 <公开 基础类 = 大小写无关排序集模板 注释 = "可以不区分大小写地对插入的文本进行去重和从小到大的排序" @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "文本型">

类 标准文本排序集W <公开 基础类 = 通用排序集模板 注释 = "可以对插入的文本进行去重和从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "标准文本类W">

类 标准文本排序集U <公开 基础类 = 通用排序集模板 注释 = "可以对插入的文本进行去重和从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "标准文本类U">

类 标准文本排序集A <公开 基础类 = 通用排序集模板 注释 = "可以对插入的文本进行去重和从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "标准文本类A">

类 文本视图排序集W <公开 基础类 = 通用排序集模板 注释 = "可以对插入的文本进行去重和从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "文本视图类W">

类 文本视图排序集U <公开 基础类 = 通用排序集模板 注释 = "可以对插入的文本进行去重和从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "文本视图类U">

类 文本视图排序集A <公开 基础类 = 通用排序集模板 注释 = "可以对插入的文本进行去重和从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "文本视图类A">

# 多值排序集(std::multiset) ===

类 通用多值排序集模板 <公开 基础类 = 多值集合模板 注释 = "  多值排序集是一种有序容器,允许多个键有等价的值." 注释 = "插入键时会通过红黑树比较大小,按照从小到大进行排序."
        注释 = "  模板类型1: 集合的元素类型,提供的类型必须支持小于操作符<" 注释 = "注意: 等同于核心库的\"多值哈希集模板类\"."
        @文档 = "category = \"数据处理.键值表模板\"" @视窗.外部头文件 = "<set>\r\n<algorithm>" @别名 = "std::multiset<模板类型1>"
        @模板基础类 = 真>

# 多值排序集 实现类 ---

类 字节多值排序集 <公开 基础类 = 通用多值排序集模板 注释 = "可以对插入的字节值进行从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "字节">

类 字符多值排序集 <公开 基础类 = 通用多值排序集模板 注释 = "可以对插入的字符值进行从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "字符">

类 整数多值排序集 <公开 基础类 = 通用多值排序集模板 注释 = "可以对插入的整数值进行从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "整数">

类 变整数多值排序集 <公开 基础类 = 通用多值排序集模板 注释 = "可以对插入的变整数值进行从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "变整数">

类 长整数多值排序集 <公开 基础类 = 通用多值排序集模板 注释 = "可以对插入的长整数值进行从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "长整数">

类 小数多值排序集 <公开 基础类 = 通用多值排序集模板 注释 = "可以对插入的小数值进行从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "小数">

类 文本多值排序集 <公开 基础类 = 通用多值排序集模板 注释 = "可以对插入的文本进行从小到大的排序" 折叠2 @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "文本型">

类 大小写无关多值排序集模板 <公开 基础类 = 多值集合模板 注释 = "多值排序集是一种有序容器,允许多个键有等价的值." 注释 = "插入键时会通过红黑树比较大小,按照从小到大进行排序."
        注释 = "本模板可以不区分大小写地对插入的文本进行从小到大的排序." 注释 = "模板类型1(仅支持以下类型):" 注释 = "  - 文本型"
        注释 = "  - 标准文本类W  标准文本类U  标准文本类A" 注释 = "  - 文本视图类W  文本视图类U  文本视图类A" 隐藏值属性 = "2"
        @文档 = "category = \"数据处理.排序集\"" @视窗.外部头文件 = "<set>\r\n<algorithm>"
        @别名 = "std::multiset<模板类型1, piv::ci_less<模板类型1>>" @模板基础类 = 真>

# 哈希集(std::unordered_set) ===

类 通用哈希集模板 <公开 基础类 = 唯一值集合模板 注释 = "  哈希集是一种无序容器,因为键的唯一性,天然具有去重功能." 注释 = "插入键时会计算键的哈希值,之后将键的哈希值作为下标,实现"
        注释 = "快速访问." 注释 = "  模板类型1: 集合的元素类型,提供的类型必须支持用std::hash计算哈希值," 注释 = "比如:"
        注释 = "  - 通用基本型   文本型       字节集类" 注释 = "  - 标准文本类W  标准文本类U  标准文本类A" 注释 = "  - 文本视图类W  文本视图类U  文本视图类A"
        @文档 = "category = \"数据处理.键值表模板\"" @视窗.外部头文件 = "<unordered_set>" @别名 = "std::unordered_set<模板类型1>"
        @模板基础类 = 真>

类 大小写无关哈希集模板 <公开 基础类 = 唯一值集合模板 注释 = "  哈希集是一种无序容器,因为键的唯一性,天然具有去重功能."
        注释 = "插入键时会计算键的哈希值,之后将键的哈希值作为下标,实现" 注释 = "快速访问." 注释 = "  本模板可以不区分键的大小写." 注释 = "  模板类型1,仅支持以下类型:"
        注释 = "  - 文本型" 注释 = "  - 标准文本类W  标准文本类U  标准文本类A" 注释 = "  - 文本视图类W  文本视图类U  文本视图类A" 隐藏值属性 = "2"
        @文档 = "category = \"数据处理.哈希集\"" @视窗.外部头文件 = "<unordered_set>"
        @别名 = "std::unordered_set<模板类型1, piv::ci_hash<模板类型1>, piv::ci_equal_to<模板类型1>>" @模板基础类 = 真>

# 哈希集 实现类---

类 字节集哈希集 <公开 基础类 = 通用哈希集模板 注释 = "  哈希集是一种无序容器,因为键的唯一性,天然具有去重功能." 注释 = "插入键时会计算键的哈希值,之后将键的哈希值作为下标,实现"
        注释 = "快速访问." @文档 = "category = \"数据处理.哈希集\"" @模板实现类 = "字节集类">

#
# 多值哈希集(std::unordered_multiset) ===

类 通用多值哈希集模板 <公开 基础类 = 多值集合模板 注释 = "  非独有哈希集是一种无序容器,允许多个键有等价的值." 注释 = "插入键时会计算键的哈希值,之后将键的哈希值作为下标,"
        注释 = "实现快速访问." 注释 = "  模板类型1: 集合的元素类型,提供的类型必须支持用" 注释 = "std::hash计算哈希值"
        注释 = "  - 通用基本型   文本型       字节集类" 注释 = "  - 标准文本类W  标准文本类U  标准文本类A" 注释 = "  - 文本视图类W  文本视图类U  文本视图类A"
        @文档 = "category = \"数据处理.键值表模板\"" @视窗.外部头文件 = "<unordered_set>\r\n<algorithm>"
        @别名 = "std::unordered_multiset<模板类型1>" @模板基础类 = 真>

类 大小写无关多值哈希集模板 <公开 基础类 = 多值集合模板 注释 = "  非独有哈希集是一种无序容器,允许多个键有等价的值." 注释 = "插入键时会计算键的哈希值,之后将键的哈希值作为下标,"
        注释 = "实现快速访问." 注释 = "  本模板可以不区分键的大小写." 注释 = "  模板类型1: 集合的元素类型,仅支持以下类型" 注释 = "  - 文本型"
        注释 = "  - 标准文本类W  标准文本类U  标准文本类A" 注释 = "  - 文本视图类W  文本视图类U  文本视图类A" 隐藏值属性 = "2"
        @文档 = "category = \"数据处理.哈希集\"" @视窗.外部头文件 = "<unordered_set>\r\n<algorithm>"
        @别名 = "std::unordered_multiset<CVolString, piv::ci_hash<CVolString>, piv::ci_equal_to<CVolString>>"
        @模板基础类 = 真>

# 多值哈希集 实现类 ---

类 字节集多值哈希集 <公开 基础类 = 通用多值哈希集模板 注释 = "  非独有哈希集是一种无序容器,允许多个键有等价的值." 注释 = "插入键时会计算键的哈希值,之后将键的哈希值作为下标,"
        注释 = "实现快速访问." @文档 = "category = \"数据处理.哈希集\"" @模板实现类 = "字节集类">

类 文本多值哈希集 <公开 基础类 = 通用多值哈希集模板 注释 = "  非独有哈希集是一种无序容器,允许多个键有等价的值." 注释 = "插入键时会计算键的哈希值,之后将键的哈希值作为下标,"
        注释 = "实现快速访问." @文档 = "category = \"数据处理.哈希集\"" @模板实现类 = "文本型">

# 键值表容器 基本操作====

类 标准键值对 <公开 折叠 折叠2 @文档 = "category = \"数据处理.键值对\"" @视窗.外部头文件 = "<utility>" @别名 = "//std::pair"
        @类用途 = 禁止创建对象 @别名类型 = 本地类 @全局类 = 真>
{
    方法 创建键值对 <公开 静态 类型 = 标准键值对 注释 = "根据提供的关键字和对应值,创建一组对应模板类型的键值对."
            注释 = "注: 只能在\"标准键值表\"的创建和初始化的参数中使用,请勿将返回值赋值给变量." @嵌入式方法 = "">
    参数 关键字 <注释 = "类型为\"标准键值表\"的\"模板类型1\"" @匹配类型 = 通用型>
    参数 对应值 <注释 = "类型为\"标准键值表\"的\"模板类型2\"" @匹配类型 = 通用型>
    {
        @ std::make_pair(@<关键字>, @<对应值>)
    }
}

类 标准键值对模板 <公开 注释 = "本模板类封装了C++标准键值对\"std::pair\"." 注释 = "  模板类型1: 为键值对的关键字" 注释 = "  模板类型2: 为键值对的对应值" 折叠
        @文档 = "category = \"数据处理.键值对\"" @视窗.外部头文件 = "<utility>" @别名 = "std::pair<模板类型1, 模板类型2>" @别名类型 = 本地类
        @模板基础类 = 真>
{
    方法 创建 <公开 静态 类型 = 标准键值对模板 注释 = "根据提供的关键字和对应值,创建一组键值对." 折叠 @嵌入式方法 = "">
    参数 关键字 <类型 = 模板类型1>
    参数 对应值 <类型 = 模板类型2>
    {
        @ std::pair<@dt<模板类型1>, @dt<模板类型2>>(@<关键字>, @<对应值>)
    }

    方法 初始化 <公开 静态 注释 = "使用关键字和对应值初始化键值对的内容" 折叠 @嵌入式方法 = "">
    参数 本键值对 <类型 = 标准键值对模板>
    参数 关键字 <类型 = 模板类型1>
    参数 对应值 <类型 = 模板类型2>
    {
        @ @<本键值对> = std::pair<@dt<模板类型1>, @dt<模板类型2>>(@<关键字>, @<对应值>)
    }

    方法 交换 <公开 静态 注释 = "交换两个键值对的内容" 折叠 @嵌入式方法 = "">
    参数 本键值对 <类型 = 标准键值对模板>
    参数 欲交换键值对 <类型 = 标准键值对模板>
    {
        @ @<本键值对>.swap(@<欲交换键值对>)
    }

    方法 是否相等 <公开 静态 类型 = 逻辑型 注释 = "比较两个键值对的内容是否相等" 折叠 @嵌入式方法 = "">
    参数 本键值对 <类型 = 标准键值对模板>
    参数 欲比较键值对 <类型 = 标准键值对模板>
    {
        @ @<本键值对> == @<欲比较键值对>
    }

    方法 键 <公开 静态 属性读 类型 = 模板类型1 注释 = "访问键值对的关键字" 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本键值对 <类型 = 标准键值对模板>
    {
        @ return @<本键值对>.first;
    }

    方法 键 <公开 静态 属性写 注释 = "设置键值对的关键字" 折叠>
    参数 本键值对 <类型 = 标准键值对模板>
    参数 关键字 <类型 = 模板类型1>
    {
        @ @<本键值对>.first = @<关键字>;
    }

    方法 值 <公开 静态 属性读 类型 = 模板类型2 注释 = "访问键值对的对应值" 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本键值对 <类型 = 标准键值对模板>
    {
        @ return @<本键值对>.second;
    }

    方法 值 <公开 静态 属性写 注释 = "设置键值对的对应值" 折叠>
    参数 本键值对 <类型 = 标准键值对模板>
    参数 对应值 <类型 = 模板类型2>
    {
        @ @<本键值对>.second = @<对应值>;
    }
}

类 标准键值表基础 <公开 注释 = "封装了键值表容器的基本操作,请勿直接使用本类." 注释 = "  模板类型1: 为键值表的关键字"
        注释 = "  模板类型2: 为键值表的对应值,支持所有类型(至少支持复制赋值)" 折叠 @文档 = "category = \"数据处理.键值表模板\"" @别名 = "//" @别名类型 = 本地类
        @模板基础类 = 真>
{
    方法 创建 <公开 静态 类型 = 标准键值表基础 注释 = "从一个或多个键值对创建一个键值表" 折叠 @嵌入式方法 = "">
    参数 初始列表 <类型 = 标准键值对 注释 = "请使用\"创建键值对(模板类型1, 模板类型2)\"插入一或多个键值对" @可扩展 = "">
    {
        @ @dt<标准键值表基础>{@<初始列表>}
    }

    方法 初始化 <公开 静态 注释 = "从一个或多个键值对初始化本键值表" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准键值表基础>
    参数 初始列表 <类型 = 标准键值对 注释 = "请使用\"创建键值对(模板类型1, 模板类型2)\"插入一或多个键值对" @可扩展 = "">
    {
        @ @<本容器> = {@<初始列表>}
    }

    方法 插入 <公开 静态 注释 = "插入一个键值对进键值表中,如果所指定关键字已经存在," 注释 = "则其所对应的先前值数据将被覆盖." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    参数 对应值 <类型 = 模板类型2 注释 = "提供关键字所对应的值">
    {
        @ @<本容器>[@<关键字>] = @<对应值>
    }

    方法 唯一性插入 <公开 静态 类型 = 逻辑型 注释 = "插入一个键值对进键值表中,如果所指定关键字已经存在,则返回失败." 返回值注释 = "所欲插入关键字如果不存在,则成功返回真,否则返回假."
            折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    参数 对应值 <类型 = 模板类型2 注释 = "提供关键字所对应的值">
    {
        @ @<本容器>.insert(std::pair<@dt<模板类型1>, @dt<模板类型2>>{@<关键字>, @<对应值>}).second
    }

    方法 构造成员 <公开 静态 类型 = 逻辑型 注释 = "在键值表中原位带参构造一个键值对." 注释 = "如果所指定关键字已经存在,则返回失败."
            注释 = "相比\"唯一性插入\",可以避免不必要的复制和移动操作." 返回值注释 = "所欲插入关键字如果不存在,则成功返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    参数 构造参数列表 <注释 = "\"模板类型2\"的构造参数表" @可扩展 = "" @匹配类型 = 通用型>
    {
        @ @<本容器>.emplace(std::piecewise_construct, std::forward_as_tuple(@<关键字>), std::forward_as_tuple(@<构造参数列表>)).second
    }

    方法 置入 <公开 静态 类型 = 逻辑型 注释 = "在键值表中原位构造一个键值对,如果所指定关键字已经存在,则返回失败." 注释 = "相比\"唯一性插入\",可以避免不必要的复制和移动操作."
            返回值注释 = "所欲插入关键字如果不存在,则成功返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    参数 对应值 <类型 = 模板类型2 注释 = "提供关键字所对应的值">
    {
        @ @<本容器>.emplace(std::piecewise_construct, std::forward_as_tuple(@<关键字>), std::forward_as_tuple(@<对应值>)).second
    }

    方法 置入并返回值 <公开 静态 类型 = 模板类型2 注释 = "在键值表中原位构造一个键值对,并返回值数据." 注释 = "如果所指定关键字已经存在,则返回先前的值."
            注释 = "相比\"唯一性插入\",可以避免不必要的复制和移动操作." 返回值注释 = "所欲插入关键字如果不存在,则成功返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    参数 对应值 <类型 = 模板类型2 注释 = "提供关键字所对应的值">
    {
        @ (@dt<模板类型2>&)@<本容器>.emplace(std::piecewise_construct, std::forward_as_tuple(@<关键字>), std::forward_as_tuple(@<对应值>)).first->second
    }

    方法 唯一性插入新值 <公开 静态 类型 = 逻辑型 注释 = "插入一个键值对进键值表中,如果所指定关键字已经存在,则返回失败."
            注释 = "注: 本方法无需提供\"对应值\",将自动使用\"模板类型2\"的默认值." 返回值注释 = "所欲插入关键字如果不存在,则成功返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ @<本容器>.emplace(std::piecewise_construct, std::forward_as_tuple(@<关键字>), std::forward_as_tuple()).second
    }

    方法 置入新值 <公开 静态 类型 = 逻辑型 注释 = "在键值表中原位构造一个键值对,如果所指定关键字已经存在,则返回失败."
            注释 = "注: 本方法无需提供\"对应值\",将自动使用\"模板类型2\"的默认值." 注释 = "相比\"唯一性插入新值\",可以避免不必要的复制和移动操作."
            返回值注释 = "所欲插入关键字如果不存在,则成功返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ @<本容器>.emplace(std::piecewise_construct, std::forward_as_tuple(@<关键字>), std::forward_as_tuple()).second
    }

    方法 置入并返回新值 <公开 静态 类型 = 模板类型2 注释 = "在键值表中原位构造一个键值对,并返回值数据." 注释 = "如果所指定关键字已经存在,则返回先前的值."
            注释 = "注: 本方法无需提供\"对应值\",将自动使用\"模板类型2\"的默认值." 注释 = "相比\"唯一性插入新值\",可以避免不必要的复制和移动操作."
            返回值注释 = "所欲插入关键字如果不存在,则成功返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ (@dt<模板类型2>&)@<本容器>.emplace(std::piecewise_construct, std::forward_as_tuple(@<关键字>), std::forward_as_tuple()).first->second
    }

    方法 取值 <公开 静态 类型 = 模板类型2 注释 = "  返回所指定关键字在本键值表中所对应值的参考,如果该关键字不存在,将新"
            注释 = "建一个数据类型为\"模板类型2\"的空值,并将其插入键值表中后返回." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ (@dt<模板类型2>&)@<本容器>[@<关键字>]
    }

    方法 取成员数 <公开 静态 类型 = 整数 注释 = "返回本键值表中已有键值对成员的数目" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准键值表基础>
    {
        @ static_cast<INT>(@<本容器>.size())
    }

    方法 是否存在 <公开 静态 类型 = 逻辑型 注释 = "返回所指定的关键字是否已经存在" 折叠 @禁止流程检查 = 真>
    参数 本容器 <类型 = 标准键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ return (@<本容器>.find(@<关键字>) != @<本容器>.end());
    }

    方法 删除 <公开 静态 类型 = 逻辑型 注释 = "删除所指定的键值对,返回是否存在所指定的关键字." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ (@<本容器>.erase(@<关键字>) > 0)
    }

    方法 清空 <公开 静态 注释 = "清除本键值表中的所有内容" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准键值表基础>
    {
        @ @<本容器>.clear()
    }

    方法 交换 <公开 静态 注释 = "交换两个键值表中的数据" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准键值表基础>
    参数 所欲交换的键值表 <类型 = 标准键值表基础>
    {
        @ @<本容器>.swap(@<所欲交换的键值表>)
    }

    方法 是否为空 <公开 静态 类型 = 逻辑型 注释 = "返回本键值表是否为空" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准键值表基础>
    {
        @ @<本容器>.empty()
    }

    方法 枚举循环 <公开 静态 注释 = "  启动一个循环来正向枚举本键值表中的每一个成员,在循环中可以调用" 注释 = "\"取枚举关键字\"/\"取枚举值\"方法来获取当前所枚举到键值对的关键字及"
            注释 = "其对应值." 折叠 @嵌入式方法 = "name = piv_map_iter\r\nhas_loop_body = true">
    参数 本容器 <类型 = 标准键值表基础>
    {
        @ auto& @sn<rand_name0> = @<本容器>;
        @ for (auto& __piv_map_iter = @sn<rand_name0>.begin(); __piv_map_iter != @sn<rand_name0>.end(); __piv_map_iter++)
    }

    方法 逆向枚举循环 <公开 静态 注释 = "  启动一个循环来逆向枚举本键值表中的每一个成员,在循环中可以调用" 注释 = "\"取枚举关键字\"/\"取枚举值\"方法来获取当前所枚举到键值对的关键字及"
            注释 = "其对应值." 折叠 @嵌入式方法 = "name = piv_map_riter\r\nhas_loop_body = true">
    参数 本容器 <类型 = 标准键值表基础>
    {
        @ auto& @sn<rand_name0> = @<本容器>;
        @ for (auto& __piv_map_iter = @sn<rand_name0>->rbegin(); __piv_map_iter != @sn<rand_name0>->rend(); __piv_map_iter++)
    }

    方法 取枚举关键字 <公开 静态 类型 = 模板类型1 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前所枚举到键值对"
            注释 = "成员的关键字,如果有多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回最近" 注释 = "层\"枚举循环\"所枚举到键值对成员的关键字." 折叠
            @嵌入式方法 = "parent = \"piv_map_iter, piv_map_riter\"">
    参数 本容器 <类型 = 标准键值表基础>
    {
        @ (@dt<模板类型1>)__piv_map_iter->first
    }

    方法 取枚举值 <公开 静态 类型 = 模板类型2 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前所枚举到键值对"
            注释 = "成员的值,如果有多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回最近层" 注释 = "\"枚举循环\"所枚举到键值对成员的值." 折叠
            @嵌入式方法 = "parent = \"piv_map_iter, piv_map_riter\"">
    参数 本容器 <类型 = 标准键值表基础>
    {
        @ __piv_map_iter->second
    }
}

类 标准多值键值表基础 <公开 注释 = "封装了多值键值表容器的基本操作,请勿直接使用本类." 注释 = "  模板类型1: 为键值表的关键字"
        注释 = "  模板类型2: 为键值表的对应值,支持所有类型(至少支持复制赋值)" 折叠 @文档 = "category = \"数据处理.键值表模板\"" @别名 = "//" @别名类型 = 本地类
        @模板基础类 = 真>
{
    方法 创建 <公开 静态 类型 = 标准多值键值表基础 注释 = "从一个或多个键值对创建一个键值表" 折叠 @嵌入式方法 = "">
    参数 初始列表 <类型 = 标准键值对 注释 = "请使用\"创建键值对(模板类型1, 模板类型2)\"插入一或多个键值对" @可扩展 = "">
    {
        @ @dt<标准多值键值表基础>{@<初始列表>}
    }

    方法 初始化 <公开 静态 注释 = "从一个或多个键值对初始化本键值表" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准多值键值表基础>
    参数 初始列表 <类型 = 标准键值对 注释 = "请使用\"创建键值对(模板类型1, 模板类型2)\"插入一或多个键值对" @可扩展 = "">
    {
        @ @<本容器> = {@<初始列表>}
    }

    方法 插入 <公开 静态 注释 = "插入一个键值对进键值表中,如果所指定关键字已经存在,则插入对应的新值." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准多值键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    参数 对应值 <类型 = 模板类型2 注释 = "提供关键字所对应的值">
    {
        @ @<本容器>.insert(std::pair<@dt<模板类型1>, @dt<模板类型2>>{@<关键字>, @<对应值>})
    }

    方法 置入 <公开 静态 注释 = "在键值表中原位构造一个键值对,如果所指定关键字已经存在,则插入对应的新值." 注释 = "相比\"插入\",可以避免不必要的复制和移动操作." 折叠
            @嵌入式方法 = "">
    参数 本容器 <类型 = 标准多值键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    参数 对应值 <类型 = 模板类型2 注释 = "提供关键字所对应的值">
    {
        @ @<本容器>.emplace(std::piecewise_construct, std::forward_as_tuple(@<关键字>), std::forward_as_tuple(@<对应值>))
    }

    方法 置入并返回值 <公开 静态 类型 = 模板类型2 注释 = "在键值表中原位构造一个键值对,并返回值数据." 注释 = "如果所指定关键字已经存在,则返回先前的值."
            注释 = "相比\"唯一性插入\",可以避免不必要的复制和移动操作." 返回值注释 = "所欲插入关键字如果不存在,则成功返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准多值键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    参数 对应值 <类型 = 模板类型2 注释 = "提供关键字所对应的值">
    {
        @ (@dt<模板类型2>&)@<本容器>.emplace(std::piecewise_construct, std::forward_as_tuple(@<关键字>), std::forward_as_tuple(@<对应值>))->second
    }

    方法 唯一性插入新值 <公开 静态 注释 = "插入一个键值对进键值表中,如果所指定关键字已经存在,则插入对应的新值."
            注释 = "注: 本方法无需提供\"对应值\",将自动使用\"模板类型2\"的默认值." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准多值键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ @<本容器>.emplace(std::piecewise_construct, std::forward_as_tuple(@<关键字>), std::forward_as_tuple())
    }

    方法 置入新值 <公开 静态 注释 = "在键值表中原位构造一个键值对,如果所指定关键字已经存在,则插入对应的新值."
            注释 = "注: 本方法无需提供\"对应值\",将自动使用\"模板类型2\"的默认值." 注释 = "相比\"唯一性插入新值\",可以避免不必要的复制和移动操作." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准多值键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ @<本容器>.emplace(std::piecewise_construct, std::forward_as_tuple(@<关键字>), std::forward_as_tuple())
    }

    方法 置入并返回新值 <公开 静态 类型 = 模板类型2 注释 = "在键值表中原位构造一个键值对,并返回值数据." 注释 = "如果所指定关键字已经存在,则插入并返回新值."
            注释 = "注: 本方法无需提供\"对应值\",将自动使用\"模板类型2\"的默认值." 注释 = "相比\"唯一性插入新值\",可以避免不必要的复制和移动操作."
            返回值注释 = "所欲插入关键字如果不存在,则成功返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准多值键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ (@dt<模板类型2>&)@<本容器>.emplace(std::piecewise_construct, std::forward_as_tuple(@<关键字>), std::forward_as_tuple())->second
    }

    方法 取值数量 <公开 静态 类型 = 整数 注释 = "返回指定关键字的值数量" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准多值键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ static_cast<INT>(@<本容器>.count(@<关键字>))
    }

    方法 取成员数 <公开 静态 类型 = 整数 注释 = "返回本键值表中已有键值对成员的数目" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准多值键值表基础>
    {
        @ static_cast<INT>(@<本容器>.size())
    }

    方法 是否存在 <公开 静态 类型 = 逻辑型 注释 = "返回所指定的关键字是否已经存在" 折叠 @禁止流程检查 = 真>
    参数 本容器 <类型 = 标准多值键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ return (@<本容器>.find(@<关键字>) != @<本容器>.end());
    }

    方法 删除 <公开 静态 类型 = 整数 注释 = "删除与关键字匹配的所有成员值,返回所删除的值数量." 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准多值键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ (INT)@<本容器>.erase(@<关键字>)
    }

    方法 删除指定值 <公开 静态 类型 = 整数 注释 = "删除指定关键字的所有指定值" 折叠 "">
    参数 本容器 <类型 = 标准多值键值表基础>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    参数 值 <类型 = 模板类型2 注释 = "提供欲删除的值">
    {
        @ (INT)@<本容器>.erase(@<关键字>)
        @ for (auto it = @<本容器>.begin(); it != @<本容器>.end();) {
        @     if (it->first == @<关键字> && it->second == @<值>)
        @         it = @<本容器>.erase(it);
        @     else
        @         it++;
        @ }
    }

    方法 清空 <公开 静态 注释 = "清除本键值表中的所有内容" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准多值键值表基础>
    {
        @ @<本容器>.clear()
    }

    方法 交换 <公开 静态 注释 = "交换两个键值表中的数据" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准多值键值表基础>
    参数 所欲交换的键值表 <类型 = 标准多值键值表基础>
    {
        @ @<本容器>.swap(@<所欲交换的键值表>)
    }

    方法 是否为空 <公开 静态 类型 = 逻辑型 注释 = "返回本键值表是否为空" 折叠 @嵌入式方法 = "">
    参数 本容器 <类型 = 标准多值键值表基础>
    {
        @ @<本容器>.empty()
    }

    方法 枚举循环 <公开 静态 注释 = "  启动一个循环来正向枚举本键值表中的每一个成员,在循环中可以调用" 注释 = "\"取枚举关键字\"/\"取枚举值\"方法来获取当前所枚举到键值对的关键字及"
            注释 = "其对应值." 折叠 隐藏值属性 = "0" @嵌入式方法 = "name = piv_multimap_iter\r\nhas_loop_body = true">
    参数 本容器 <类型 = 标准多值键值表基础>
    {
        @ auto& @sn<rand_name0> = @<本容器>;
        @ for (auto& __piv_multimap_iter = @sn<rand_name0>.begin(); __piv_multimap_iter != @sn<rand_name0>.end(); __piv_multimap_iter++)
    }

    方法 逆向枚举循环 <公开 静态 注释 = "  启动一个循环来逆向枚举本键值表中的每一个成员,在循环中可以调用" 注释 = "\"取枚举关键字\"/\"取枚举值\"方法来获取当前所枚举到键值对的关键字及"
            注释 = "其对应值." 折叠 隐藏值属性 = "0" @嵌入式方法 = "name = piv_multimap_riter\r\nhas_loop_body = true">
    参数 本容器 <类型 = 标准多值键值表基础>
    {
        @ auto& @sn<rand_name0> = @<本容器>;
        @ for (auto& __piv_multimap_iter = @sn<rand_name0>->rbegin(); __piv_multimap_iter != @sn<rand_name0>->rend(); __piv_multimap_iter++)
    }

    方法 取枚举关键字 <公开 静态 类型 = 模板类型1 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前所枚举到键值对"
            注释 = "成员的关键字,如果有多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回最近" 注释 = "层\"枚举循环\"所枚举到键值对成员的关键字." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "parent = \"piv_multimap_iter, piv_multimap_riter\"">
    参数 本容器 <类型 = 标准多值键值表基础>
    {
        @ (@dt<模板类型1>)__piv_multimap_iter.first
    }

    方法 取枚举值 <公开 静态 类型 = 模板类型2 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前所枚举到键值对"
            注释 = "成员的值,如果有多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回最近层" 注释 = "\"枚举循环\"所枚举到键值对成员的值." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "parent = \"piv_multimap_iter, piv_multimap_riter\"">
    参数 本容器 <类型 = 标准多值键值表基础>
    {
        @ __piv_multimap_iter.second
    }
}

# 排序表(std::map) ===

类 通用排序表模板 <公开 基础类 = 标准键值表基础 注释 = "  排序表是一种有序的键值表,因为键的唯一性,天然具有去重功能."
        注释 = "插入键值对时会通过红黑树比较键的大小,按照从小到大进行排序." 注释 = "  模板类型1: 为键值表的关键字,提供的类型必须支持小于操作符<"
        注释 = "  模板类型2: 为键值表的对应值,支持所有类型(至少支持复制赋值)" @文档 = "category = \"数据处理.键值表模板\"" @视窗.外部头文件 = "<map>"
        @别名 = "std::map<模板类型1, 模板类型2>" @模板基础类 = 真>

类 大小写无关排序表模板 <公开 基础类 = 标准键值表基础 注释 = "  排序表是一种有序的键值表,因为键的唯一性,天然具有去重功能."
        注释 = "插入键值对时会通过红黑树比较键的大小,按照从小到大进行排序." 注释 = "  模板类型1: 为键值表的关键字,仅支持以下类型:" 注释 = "  - 文本型"
        注释 = "  - 标准文本类W  标准文本类U  标准文本类A" 注释 = "  - 文本视图类W  文本视图类U  文本视图类A"
        注释 = "  模板类型2: 为键值表的对应值,支持所有类型(至少支持复制赋值)" 隐藏值属性 = "2" @文档 = "category = \"数据处理.键值表模板\""
        @视窗.外部头文件 = "<map>" @别名 = "std::map<模板类型1, 模板类型2, piv::ci_less<模板类型1>>" @模板基础类 = 真>

# 多值排序表(std::multimap) ===

类 通用多值排序表模板 <公开 基础类 = 标准多值键值表基础 注释 = "  多值排序表是一种有序的键值表,因为键的唯一性,天然具有去重功能."
        注释 = "插入键值对时会通过红黑树比较键的大小,按照从小到大进行排序." 注释 = "  本表允许一个关键字拥有多个对应值."
        注释 = "  模板类型1: 为键值表的关键字,提供的类型必须支持小于操作符<" 注释 = "  模板类型2: 为键值表的对应值,支持所有类型(至少支持复制赋值)"
        @文档 = "category = \"数据处理.键值表模板\"" @视窗.外部头文件 = "<map>" @别名 = "std::multimap<模板类型1, 模板类型2>" @模板基础类 = 真>

类 大小写无关多值排序表模板 <公开 基础类 = 标准多值键值表基础 注释 = "  多值排序表是一种有序的键值表,因为键的唯一性,天然具有去重功能."
        注释 = "插入键值对时会通过红黑树比较键的大小,按照从小到大进行排序." 注释 = "  本表允许一个关键字拥有多个对应值."
        注释 = "  模板类型1: 为键值表的关键字,提供的类型必须支持小于操作符<" 注释 = "  模板类型2: 为键值表的对应值,支持所有类型(至少支持复制赋值)" 隐藏值属性 = "2"
        @文档 = "category = \"数据处理.键值表模板\"" @视窗.外部头文件 = "<map>"
        @别名 = "std::multimap<模板类型1, 模板类型2, piv::ci_less<模板类型1>>" @模板基础类 = 真>

# 哈希表(std::unordered_map) ===

类 通用哈希表模板 <公开 基础类 = 标准键值表基础 注释 = "  哈希表是一种无序的键值表,因为键的唯一性,天然具有去重功能."
        注释 = "插入键值对时会计算键的哈希值,之后将键的哈希值作为下标,实现" 注释 = "快速访问表元素的能力,当数据量比较大时,哈希表通常比\"排序表\"" 注释 = "要快一些."
        注释 = "  模板类型1: 为键值表的关键字,提供的类型必须支持==等于判断," 注释 = "以及能用std::hash计算哈希值(特别支持了文本型和字节集类)"
        注释 = "  模板类型2: 为键值表的对应值,支持所有类型(至少支持复制赋值)" @文档 = "category = \"数据处理.键值表模板\""
        @视窗.外部头文件 = "<unordered_map>" @别名 = "std::unordered_map<模板类型1, 模板类型2>" @模板基础类 = 真>

类 大小写无关哈希表模板 <公开 基础类 = 标准键值表基础 注释 = "  本模板插入和寻找键值对时,不区分文本键的英文大小写."
        注释 = "  哈希表是一种无序的键值表,因为键的唯一性,天然具有去重功能." 注释 = "插入键值对时会计算键的哈希值,之后将键的哈希值作为下标,实现"
        注释 = "快速访问表元素的能力,当数据量比较大时,哈希表通常比\"排序表\"" 注释 = "要快一些." 注释 = "  模板类型1: 为键值表的关键字,仅支持类型: 文本型"
        注释 = "  模板类型2: 为键值表的对应值,支持所有类型(至少支持复制赋值)" 隐藏值属性 = "2" @文档 = "category = \"数据处理.键值表模板\""
        @视窗.外部头文件 = "<unordered_map>"
        @别名 = "std::unordered_map<模板类型1, 模板类型2, piv::ci_hash<模板类型1>, piv::ci_equal_to<模板类型1>>" @模板基础类 = 真>

# 多值哈希表(std::unordered_multimap) ===

类 通用多值哈希表模板 <公开 基础类 = 标准多值键值表基础 注释 = "  多值哈希表是一种无序的键值表,因为键的唯一性,天然具有去重功能."
        注释 = "插入键值对时会计算键的哈希值,之后将键的哈希值作为下标,实现" 注释 = "快速访问表元素的能力,当数据量比较大时,哈希表通常比\"排序表\"" 注释 = "要快一些."
        注释 = "  本表允许一个关键字拥有多个对应值." 注释 = "  模板类型1: 为键值表的关键字,提供的类型必须支持==等于判断,"
        注释 = "以及能用std::hash计算哈希值(特别支持了文本型和字节集类)" 注释 = "  模板类型2: 为键值表的对应值,支持所有类型(至少支持复制赋值)" 隐藏值属性 = "2"
        @文档 = "category = \"数据处理.键值表模板\"" @视窗.外部头文件 = "<unordered_map>"
        @别名 = "std::unordered_multimap<模板类型1, 模板类型2>" @模板基础类 = 真>

类 大小写无关多值哈希表模板 <公开 基础类 = 标准多值键值表基础 注释 = "  本模板插入和寻找键值对时,不区分文本键的英文大小写."
        注释 = "  多值哈希表是一种无序的键值表,因为键的唯一性,天然具有去重功能." 注释 = "插入键值对时会计算键的哈希值,之后将键的哈希值作为下标,实现"
        注释 = "快速访问表元素的能力,当数据量比较大时,哈希表通常比\"排序表\"" 注释 = "要快一些." 注释 = "  本表允许一个关键字拥有多个对应值."
        注释 = "  模板类型1: 为键值表的关键字,仅支持类型: 文本型" 注释 = "  模板类型2: 为键值表的对应值,支持所有类型(至少支持复制赋值)" 隐藏值属性 = "2"
        @文档 = "category = \"数据处理.键值表模板\"" @视窗.外部头文件 = "<unordered_map>"
        @别名 = "std::unordered_multimap<模板类型1, 模板类型2, piv::ci_hash<模板类型1>, piv::ci_equal_to<模板类型1>>"
        @模板基础类 = 真>

# 标准队列 std::queue ====

类 标准队列模板 <公开 注释 = "通用队列类,用作基本类型填充." 注释 = "  模板类型1: 成员数据类型" 折叠 @文档 = "category = \"数据处理.队列\""
        @视窗.外部头文件 = "<queue>" @别名 = "std::queue<模板类型1>" @别名类型 = 本地类 @模板基础类 = 真>
{
    方法 创建 <公开 静态 类型 = 标准队列模板 注释 = "从一个或多个初始值创建一个队列" 折叠 @嵌入式方法 = "">
    参数 初始列表 <类型 = 模板类型1 注释 = "提供一或多个初始成员值" @可扩展 = "">
    {
        @ @dt<标准队列模板>{@<初始列表>}
    }

    方法 初始化 <公开 静态 注释 = "将一个或多个初始值赋值到本队列中" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准队列模板>
    参数 初始列表 <类型 = 模板类型1 注释 = "提供一或多个初始成员值" @可扩展 = "">
    {
        @ @<本队列> = {@<初始列表>}
    }

    方法 压入 <公开 静态 注释 = "在本队列的尾部添加指定成员" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准队列模板>
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的值">
    {
        @ @<本队列>.push(@<值>)
    }

    方法 压入新成员 <公开 静态 注释 = "在本队列的尾部原位构造新成员" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准队列模板>
    {
        @ @<本队列>.emplace()
    }

    方法 构造到尾部 <公开 静态 注释 = "在本队列的尾部原位带参构造新成员." 注释 = "注: 模板类型1必须具有带参构造函数." 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准队列模板>
    参数 构造参数 <注释 = "提供模板类型1的带参构造函数" @匹配类型 = 所有类型 @可扩展 = "">
    {
        @ @<本队列>.emplace(@<构造参数>)
    }

    方法 弹出 <公开 静态 注释 = "删除本队列中第一个成员" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准队列模板>
    {
        @ @<本队列>.pop()
    }

    方法 是否为空 <公开 静态 类型 = 逻辑型 注释 = "判断本队列是否为空队列" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准队列模板>
    {
        @ @<本队列>.empty()
    }

    方法 取成员数 <公开 静态 类型 = 整数 注释 = "返回本队列中已有成员的数目" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准队列模板>
    {
        @ (INT)@<本队列>.size()
    }

    方法 取首成员 <公开 静态 类型 = 模板类型1 注释 = "取出本队列中的第一个成员" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准队列模板>
    {
        @ (@dt<模板类型1>&)@<本队列>.front()
    }

    方法 取尾成员 <公开 静态 类型 = 模板类型1 注释 = "取出本队列中最末尾的一个成员." 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准队列模板>
    {
        @ (@dt<模板类型1>&)@<本队列>.back()
    }

    方法 交换 <公开 静态 注释 = "交换两个队列中的数据." 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准队列模板>
    参数 所欲交换的队列 <类型 = 标准队列模板>
    {
        @ @<本队列>.swap(@<所欲交换的队列>)
    }

    方法 清空 <公开 静态 注释 = "清除本队列中的所有成员内容" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准队列模板>
    {
        @ @<本队列>.clear()
    }
}

# 标准双端队列 std::deque ====

类 标准双端队列模板 <公开 注释 = "通用双端队列类,用作基本类型填充." 注释 = "  模板类型1: 成员数据类型" 折叠 @文档 = "category = \"数据处理.双端队列\""
        @视窗.外部头文件 = "<deque>" @别名 = "std::deque<模板类型1>" @别名类型 = 本地类 @模板基础类 = 真>
{
    方法 创建 <公开 静态 类型 = 标准双端队列模板 注释 = "从一个或多个初始值创建一个队列" 折叠 @嵌入式方法 = "">
    参数 初始列表 <类型 = 模板类型1 注释 = "提供一或多个初始成员值" @可扩展 = "">
    {
        @ @dt<标准双端队列模板>{@<初始列表>}
    }

    方法 初始化 <公开 静态 注释 = "将一个或多个初始值赋值到本队列中" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准双端队列模板>
    参数 初始列表 <类型 = 模板类型1 注释 = "提供一或多个初始成员值" @可扩展 = "">
    {
        @ @<本队列> = {@<初始列表>}
    }

    方法 压入到首部 <公开 静态 注释 = "在本队列的首部添加指定成员" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准双端队列模板>
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的值">
    {
        @ @<本队列>.push_front(@<值>)
    }

    方法 压入到尾部 <公开 静态 注释 = "在本队列的尾部添加指定成员" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准双端队列模板>
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的值">
    {
        @ @<本队列>.push_back(@<值>)
    }

    方法 构造到首部 <公开 静态 注释 = "在本队列的首部原位带参构造新成员." 注释 = "注: 模板类型1必须具有带参构造函数." 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准双端队列模板>
    参数 构造参数 <注释 = "提供模板类型1的带参构造函数" @匹配类型 = 所有类型 @可扩展 = "">
    {
        @ @<本队列>.emplace_front(@<构造参数>)
    }

    方法 构造到尾部 <公开 静态 注释 = "在本队列的尾部原位带参构造新成员." 注释 = "注: 模板类型1必须具有带参构造函数." 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准双端队列模板>
    参数 构造参数 <注释 = "提供模板类型1的带参构造函数" @匹配类型 = 所有类型 @可扩展 = "">
    {
        @ @<本队列>.emplace_back(@<构造参数>)
    }

    方法 插入 <公开 静态 类型 = 整数 注释 = "插入指定成员到本队列中指定索引位置" 返回值注释 = "返回所插入成员在本队列中的索引位置(如插入个数大于1则返回首个插入成员的位置)." 折叠
            @禁止流程检查 = 真>
    参数 本队列 <类型 = 标准双端队列模板>
    参数 插入索引位置 <类型 = 整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于本队列的成员数目.">
    参数 所欲插入的成员 <类型 = 模板类型1 注释 = "提供所欲插入的成员值">
    参数 所欲插入的个数 <类型 = 整数 注释 = "本次所欲插入该成员的个数" @默认值 = 1>
    {
        @ std::deque<@dt<模板类型1>>::iterator retPos = @<本队列>.insert(@<本队列>.begin() + @<插入索引位置>, @<所欲插入的个数>, @<所欲插入的成员>);
        @ return (INT)(retPos - @<本队列>.begin());
    }

    方法 插入新成员 <公开 静态 注释 = "在本队列的指定索引位置原位构造新成员,并返回插入的新成员." 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准双端队列模板>
    参数 插入索引位置 <类型 = 整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于本队列的成员数目.">
    {
        @ (@dt<模板类型1>&)*@<本队列>.emplace(@<本队列>.begin() + @<插入索引位置>)
    }

    方法 置入 <公开 静态 注释 = "在本队列的指定索引位置原位构造新成员,并返回插入的新成员." 注释 = "注: 模板类型1必须具有带参构造函数." 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准双端队列模板>
    参数 插入索引位置 <类型 = 整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于本队列的成员数目.">
    参数 构造参数 <注释 = "提供模板类型1的带参构造函数" @匹配类型 = 所有类型 @可扩展 = "">
    {
        @ (@dt<模板类型1>&)*@<本队列>.emplace(@<本队列>.begin() + @<插入索引位置>, @<构造参数>)
    }

    方法 删除 <公开 静态 注释 = "删除本队列中指定索引位置处的成员" 折叠>
    参数 本队列 <类型 = 标准双端队列模板>
    参数 删除索引位置 <类型 = 整数 注释 = "提供所欲删除的成员索引位置,必须大于等于0且小于等于本队列的成员数目.">
    {
        @ @<本队列>.erase(@<本队列>.begin() + @<删除索引位置>);
    }

    方法 弹出首部 <公开 静态 注释 = "删除本队列中第一个成员" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准双端队列模板>
    {
        @ @<本队列>.pop_front()
    }

    方法 弹出尾部 <公开 静态 注释 = "删除本队列中最后一个成员" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准双端队列模板>
    {
        @ @<本队列>.pop_back()
    }

    方法 是否为空 <公开 静态 类型 = 逻辑型 注释 = "判断本队列是否为空队列" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准双端队列模板>
    {
        @ @<本队列>.empty()
    }

    方法 取成员数 <公开 静态 类型 = 整数 注释 = "返回本队列中已有成员的数目" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准双端队列模板>
    {
        @ (INT)@<本队列>.size()
    }

    方法 取首成员 <公开 静态 类型 = 模板类型1 注释 = "取出本队列中的第一个成员" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准双端队列模板>
    {
        @ (@dt<模板类型1>&)@<本队列>.front()
    }

    方法 取尾成员 <公开 静态 类型 = 模板类型1 注释 = "取出本队列中最末尾的一个成员." 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准双端队列模板>
    {
        @ (@dt<模板类型1>&)@<本队列>.back()
    }

    方法 取成员 <公开 静态 类型 = 模板类型1 注释 = "取出本队列中的指定索引位置处的成员." 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准双端队列模板>
    参数 索引位置 <类型 = 整数 注释 = "提供所欲获取成员在本队列中所处的索引位置.">
    {
        @ (@dt<模板类型1>&)@<本队列>[@<索引位置>]
    }

    方法 交换 <公开 静态 注释 = "交换两个队列中的数据." 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准双端队列模板>
    参数 所欲交换的队列 <类型 = 标准双端队列模板>
    {
        @ @<本队列>.swap(@<所欲交换的队列>)
    }

    方法 枚举循环 <公开 静态 注释 = "  启动一个循环来正向枚举本队列中的每一个成员,在循环中可以调用" 注释 = "\"取枚举值\"方法来获取当前所枚举到的成员值." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = piv_deque_iter\r\nhas_loop_body = true">
    参数 本队列 <类型 = 标准双端队列模板>
    {
        @ std::deque<@dt<模板类型1>>& @sn<rand_name0> = @<本队列>;
        @ for (std::deque<@dt<模板类型1>>::iterator _vdequeitr = @sn<rand_name0>.begin(); _vdequeitr != @sn<rand_name0>.end(); _vdequeitr++)
    }

    方法 逆向枚举循环 <公开 静态 注释 = "  启动一个循环来逆向枚举本队列中的每一个成员,在循环中可以调用" 注释 = "\"取枚举值\"方法来获取当前所枚举到的成员值." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = piv_deque_riter\r\nhas_loop_body = true">
    参数 本队列 <类型 = 标准双端队列模板>
    {
        @ std::deque<@dt<模板类型1>>& @sn<rand_name0> = @<本队列>;
        @ for (std::deque<@dt<模板类型1>>::reverse_iterator _vdequeitr = @sn<rand_name0>.rbegin(); _vdequeitr != @sn<rand_name0>.rend(); _vdequeitr++)
    }

    方法 取枚举值 <公开 静态 类型 = 模板类型1 注释 = "  只能在本类的\"枚举循环\"/\"逆向枚举循环\"语句的子语句体中使用,用作取回当前所枚举到的成员值,"
            注释 = "如果有多层本类或本类继承类的\"枚举循环\"/\"逆向枚举循环\"嵌套,本方法将返回最近层\"枚举循环\"/" 注释 = "\"逆向枚举循环\"所枚举到的成员值." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "parent = \"piv_deque_iter, piv_deque_riter\"">
    参数 本队列 <类型 = 标准双端队列模板>
    {
        @ (@dt<模板类型1>&)*_vdequeitr
    }

    方法 清空 <公开 静态 注释 = "清除本队列中的所有成员内容" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准双端队列模板>
    {
        @ @<本队列>.clear()
    }

    方法 释放空闲内存 <公开 静态 注释 = "释放本队列中未使用的内存" 折叠 @嵌入式方法 = "">
    参数 本队列 <类型 = 标准双端队列模板>
    {
        @ @<本队列>.shrink_to_fit()
    }
}
