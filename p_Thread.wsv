<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv">

类 代码执行辅助 <公开 折叠 折叠2 @视窗.外部头文件 = "<functional>" @全局类 = 真 @类用途 = 禁止创建对象 @输出名 = "PivExecuteHelper">
{
    方法 提交到主线程 <公开 静态 注释 = "将本方法子语句体的代码提交到UI主线程中执行." 注释 = "注意:" 注释 = "  1. 本方法会阻塞当前线程,直到主线程执行完子语句体中的代码;"
            注释 = "  2. 主线程可能不会立即执行提交的代码;" 注释 = "  3. 需要UI的消息循环,在\"控制台程序\"等没有界面的程序中无法正常工作;" 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_loop_body = true\r\nbody_header = \"{\"\r\nbody_tail=\"}}, 0, nullptr);\"">
    {
        @ @sn<current_class_def>::PivNoticeReceiver::get_inst().Notify(0, (INT_P)&std::function<void()>{[&]()
    }

    方法 推迟执行 <公开 静态 注释 = "登记本语句子语句体中的所有代码为需要等待延迟执行的代码." 注释 = "所登记的代码(本方法调用语句的子语句体)不会被立即执行,将延迟到如下时刻被自动执行:"
            注释 = "  1. 该延迟执行语句所处方法返回到其调用方时;" 注释 = "  2. 该语句离开作用域时(因此别在子语句体里使用本方法);"
            注释 = "如果多次调用本方法登记了多段被延迟执行的代码,将按照先进后出(最先调用的最后执行)的顺序自动执行." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = defer\r\nhas_body = true\r\nbody_header = \"{\"\r\nbody_tail = \"});\""
            @视窗.外部头文件 = "<memory>">
    参数 指针参数 <@匹配类型 = 通用整数型>
    {
        @ std::shared_ptr<void> @sn<rand_name0>((void*)@<指针参数>, [=](void* pDeferPram)
    }

    方法 取推迟执行参数 <公开 静态 折叠 隐藏值属性 = "0" @嵌入式方法 = "parent = defer">
    参数 数据类型 <@匹配类型 = 通用型 @需求类型 = 数据类型 @返回值类型 = 0>
    {
        @ *(@<数据类型>*)pDeferPram
    }

    # @begin
    # <> <include>
    # class PivNoticeReceiver : public IVolNoticeReceiver
    # {
    # private:
    #     PivNoticeReceiver() {}
    #     virtual INT_P OnNotify(INT_P npCode, INT_P npParam1, INT_P npParam2) override {
    #         (*reinterpret_cast<std::function<void()>*>(npParam1))();
    #         return 0;
    #     }
    # public:
    #     static PivNoticeReceiver& get_inst() {
    #         static PivNoticeReceiver inst;
    #         return inst;
    #     }
    # };
    # static void @an<_sOnBeforeAppInit>() { PivNoticeReceiver::get_inst(); }
    # <> </include>
    # @end
}

# 推荐 ===

类 线程池对象类 <公开 基础类 = PIV对象类 注释 = "现代C++的线程池." 注释 = "  1. 使用高效的ICOP异步模型,队列式执行线程任务;"
        注释 = "  2. 使用C++11的std::thread线程库,功能更强大;" 注释 = "  3. 支持投递任意参数格式的线程函数;"
        注释 = "  4. 支持投递类的动态方法,无需通过\"接收事件\"调用类的动态成员;" 注释 = "  5. 退出程序时线程对象会被强制结束,不会窗口关掉了还在跑;" 折叠
        @文档 = "category = \"多线程\"" @视窗.外部头文件 = "src\\piv_threadpool.hpp" @视窗.后缀文本 = "public PivThreadPoolPro">
{
    方法 创建 <公开 类型 = 逻辑型 注释 = "创建线程池,必须成功创建后才能使用其他方法." 返回值注释 = "返回是否创建成功,重复创建亦返回真." 折叠 @嵌入式方法 = "">
    参数 线程数量 <类型 = 整数 注释 = "最大同时工作的线程数量,小于等于0为(CPU逻辑核心数 + 1)."
            注释 = "  - I/O密集型建议: CPU核数 * (1 + (I/O耗时 / CPU耗时))" 注释 = "  - 计算密集型建议: CPU核数 + 1" @默认值 = 0>
    {
        @ @sn<this>.CreateThreadPool(@<线程数量>)
    }

    方法 销毁 <公开 类型 = 逻辑型 注释 = "  销毁线程池,释放线程池占用的所有资源." 注释 = "  注意: 销毁线程池不会强制结束仍在运行的线程,请在线程的耗时或"
            注释 = "死循环中调用本对象的方法\"是否需要退出\",一旦发现该方法返回真," 注释 = "必须尽快结束\"任务回调\"/\"对象任务回调\"事件的执行."
            注释 = "  类清理时会自动销毁,如果线程池实例定义在窗口的成员变量中,必须" 注释 = "在窗口即将销毁时执行销毁线程池." 返回值注释 = "成功或已经销毁返回真,失败返回假."
            返回值注释 = "失败原因包括: 线程池正在创建或正在销毁." 折叠 @嵌入式方法 = "">
    参数 是否强制销毁 <类型 = 逻辑型 注释 = "假=正常销毁,等待任务执行完毕后返回;" 注释 = "真=强制销毁,不等待执行中的任务,清空后续的队列任务后立即返回." @默认值 = 假>
    参数 最长等待时间 <类型 = 整数 注释 = "此参数只对非强制销毁有效,单位为毫秒;" 注释 = "-1为一直等待所有任务完成,否则到了超时时间会清空任务并返回." @默认值 = -1>
    {
        @ @sn<this>.DestroyThreadPool(@<是否强制销毁>, @<最长等待时间>)
    }

    方法 暂停 <公开 类型 = 逻辑型 注释 = "停止执行新的任务,当前正在执行的任务不会被暂停." 返回值注释 = "返回是否暂停成功,线程池的不在工作状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.SuspendThreadPool()
    }

    方法 继续 <公开 类型 = 逻辑型 注释 = "继续执行线程池任务" 返回值注释 = "返回是否继续成功,线程池的不在暂停状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ResumeThreadPool()
    }

    方法 投递静态方法 <公开 类型 = 逻辑型 注释 = "将静态方法投递到线程池中,线程池将按投递顺序执行任务."
            注释 = "  1. 可以投递任意参数和返回值格式的静态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;"
            返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" 注释 = "默认将提交的参数按值复制,如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ @sn<this>.PostTask(&@<静态方法>, @<参数列表>)
    }

    方法 投递动态方法 <公开 类型 = 逻辑型 注释 = "将类实例的动态方法投递到线程池中,线程池将按投递顺序执行任务."
            注释 = "  1. 可以投递任意参数和返回值格式的类动态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 动态方法可以直接调用类实例的其他动态成员变量和方法;"
            注释 = "  5. 如果关联的对象实例被销毁,线程将异常结束(不影响线程池的运作);" 注释 = "  6. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;"
            返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供动态方法所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    参数 参数列表 <注释 = "参数表的格式务必和类成员方法的参数表一致;" 注释 = "默认将提交的参数按值复制,如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ @sn<this>.PostTask(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>, @<参数列表>)
    }

    方法 投递无参数静态方法 <公开 类型 = 逻辑型 注释 = "将无参数的静态方法投递到线程池中,线程池将按投递顺序执行任务." 注释 = "  1. 只能投递关联无参数的静态方法;"
            注释 = "  2. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;" 返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠
            @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    {
        @ @sn<this>.PostTask(&@<静态方法>)
    }

    方法 投递无参数动态方法 <公开 类型 = 逻辑型 注释 = "将无参数的类动态方法投递到线程池中,线程池将按投递顺序执行任务." 注释 = "  1. 只能投递关联无参数的类动态方法;"
            注释 = "  2. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 注释 = "  3. 如果关联的对象实例被销毁,线程将异常结束(不影响线程池的运作);"
            注释 = "  4. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;" 返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠
            @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供动态方法所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    {
        @ @sn<this>.PostTask(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>)
    }

    方法 投递无参数无返回值动态方法 <公开 类型 = 逻辑型 注释 = "将无参数的类动态方法投递到线程池中,线程池将按投递顺序执行任务." 注释 = "  1. 只能投递关联无参数及无返回值的类动态方法;"
            注释 = "  2. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 注释 = "  3. 如果关联的对象实例被销毁,线程将异常结束(不影响线程池的运作);"
            注释 = "  4. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;" 返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠
            @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供动态方法所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 动态方法 <注释 = "提供所欲线程执行的类动态方法." 注释 = "注意: 方法不需要设置输出名,但必须是无参数和无返回值." @匹配方法 = "无参数无返回值方法">
    {
        @ @sn<this>.PostTask(&@pdt<对象实例>::@<动态方法>, &@<对象实例>)
    }

    方法 无参数无返回值方法

    方法 投递任务 <公开 类型 = 逻辑型 注释 = "将函数对象投递到线程池中,线程池将按投递顺序执行任务." 返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠
            @嵌入式方法 = "">
    参数 函数对象 <类型 = 通用函数对象 注释 = "所欲投递到线程池执行的函数对象,可以调用下列方法创建:" 注释 = "- 绑定静态方法   绑定无参数静态方法"
            注释 = "- 绑定动态方法   绑定无参数动态方法" 注释 = "- 绑定函数指针   绑定无参数函数指针" 注释 = "- 绑定函数指针2  绑定无参数函数指针2">
    {
        @ @sn<this>.PostTask2(@<函数对象>)
    }

    方法 清空任务 <公开 类型 = 逻辑型 注释 = "清空已投递的队列任务,将队列任务占用的内存释放." 返回值注释 = "返回是否开始清空任务,线程池不在正常工作和暂停状态时始终返回假." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ClearTask()
    }

    方法 是否需要退出 <公开 类型 = 逻辑型 注释 = "检查线程任务是否需要尽快退出." 注释 = "  1. 本方法返回真则表示正在销毁线程池,必须尽快结束线程任务;"
            注释 = "  2. 如果未退出死循环中的线程,则线程池资源不会得到释放,线程" 注释 = "也会一直运行下去,直到进程结束;" 折叠 @嵌入式方法 = "">
    参数 最大检查等待时间 <类型 = 整数 注释 = "指定检查线程池销毁通知(由\"销毁\"方法发出)的最大等待时间," 注释 = "单位为毫秒,为0表示不等待,为-1表示一直等待." @默认值 = 0>
    {
        @ @sn<this>.IsNeedExit(@<最大检查等待时间>)
    }

    方法 调整线程池 <公开 类型 = 逻辑型 注释 = "调整线程池的容量(同时工作线程数量)." 注释 = "若新线程数量比原来大,会立即改变工作线程数量;"
            注释 = "若新线程数量比原来小,则需要等之前投递的任务全部完成,才会改变工作线程数量;" 返回值注释 = "返回是否成功调整线程池容量,线程池未创建、正在销毁或正在调整线程池时返回假." 折叠
            @嵌入式方法 = "">
    参数 新线程数量 <类型 = 整数 注释 = "最大同时工作的线程数量,小于等于0为(CPU核心数 + 1)." @默认值 = 0>
    {
        @ @sn<this>.SetThreadPoolCapacity(@<新线程数量>)
    }

    方法 CPU核心数 <公开 属性读 类型 = 整数 注释 = "获取CPU的逻辑核心数量(如支持超线程的16核CPU,返回32)." 返回值注释 = "成功返回CPU逻辑核心数,失败时始终返回1." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.GetProcessorsCount()
    }

    方法 现行线程数 <公开 属性读 类型 = 整数 注释 = "获取线程池当前的工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCount()
    }

    方法 线程池容量 <公开 属性读 类型 = 整数 注释 = "获取线程池的最大工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCapacity()
    }

    方法 执行任务数 <公开 属性读 类型 = 整数 注释 = "获取正在执行的任务数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetWorkerTaskCount()
    }

    方法 队列任务数 <公开 属性读 类型 = 长整数 注释 = "获取等待处理的任务数量,超过长整数最大值后将从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetQueueTaskCount()
    }

    方法 已完成任务数 <公开 属性读 类型 = 长整数 注释 = "获取已完成的任务数量,超过长整数最大值后将从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetComplateTaskCount()
    }

    方法 空闲线程数 <公开 属性读 类型 = 整数 注释 = "获取空闲的线程数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetFreeThreadsCount()
    }

    方法 工作状态 <公开 属性读 类型 = 整数 注释 = "获取线程池的工作状态" 返回值注释 = "0=未启动;1=正在销毁;2=正在创建;3=正在工作;4=调整线程池;5=暂停中;6=正在清空任务"
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadPoolState()
    }

    方法 是否空闲 <公开 属性读 类型 = 逻辑型 注释 = "判断线程池是否处于彻底空闲状态,没有任何任务在执行." 返回值注释 = "真为空闲,假为繁忙,线程池未创建也返回真." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ThreadPoolIsFree()
    }
}

类 线程对象类 <公开 基础类 = PIV对象类 注释 = "线程对象(std::thread)的全局操作函数." 注释 = " 1. 退出程序时线程对象会被强制结束,不会窗口关掉了还在跑;" 折叠
        @文档 = "category = \"多线程\"" @视窗.外部头文件 = "<thread>" @全局类 = 真>
{
    方法 启动静态线程 <公开 静态 注释 = "创建一个与静态方法关联的线程对象,然后立即分离并非阻塞执行线程函数."
            注释 = "  1. 可以关联任意参数和返回值格式的静态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;" 折叠
            @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ std::thread(&@<静态方法>, @<参数列表>).detach()
    }

    方法 启动无参数静态线程 <公开 静态 注释 = "创建一个与静态方法关联的线程对象,然后立即分离并非阻塞执行线程函数." 注释 = "  1. 只能关联无参数的静态方法;"
            注释 = "  2. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;" 折叠 @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    {
        @ std::thread(&@<静态方法>).detach()
    }

    方法 启动动态线程 <公开 静态 注释 = "创建一个与类实例的动态方法关联的线程对象,然后立即分离并非阻塞执行线程函数."
            注释 = "  1. 可以关联任意参数和返回值格式的类动态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;"
            注释 = "  5. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 注释 = "  6. 如果关联的对象实例被销毁,线程将异常结束(不影响整个进程的运作);" 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    参数 参数列表 <注释 = "参数列表的格式务必和所提供动态方法的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ std::thread(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>, @<参数列表>).detach()
    }

    方法 启动无参数动态线程 <公开 静态 注释 = "创建一个与类实例的动态方法关联的线程对象,然后立即分离并非阻塞执行线程函数." 注释 = "  1. 只能关联无参数的类动态方法;"
            注释 = "  2. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 注释 = "  3. 如果关联的对象实例被销毁,线程将异常结束(不影响整个进程的运作);"
            注释 = "  4. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;" 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    {
        @ std::thread(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>).detach()
    }

    方法 启动无参数无返回值动态线程 <公开 静态 注释 = "创建一个与类实例的动态方法关联的线程对象,然后立即分离并非阻塞执行线程函数." 注释 = "  1. 只能关联无参数及无返回值的类动态方法;"
            注释 = "  2. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 注释 = "  3. 如果关联的对象实例被销毁,线程将异常结束(不影响整个进程的运作);"
            注释 = "  4. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;" 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 动态方法 <注释 = "提供所欲线程执行的类动态方法." 注释 = "注意: 方法不需要设置输出名,但必须是无参数和无返回值." @匹配方法 = "无参数无返回值方法">
    {
        @ std::thread(&@pdt<对象实例>::@<动态方法>, &@<对象实例>).detach()
    }

    方法 引用 <公开 静态 注释 = "包装线程对象的参数,将它变成\"引用传递\"(std::ref)." 注释 = "  1. 线程对象默认按值复制参数,包装后线程参数和外部变量"
            注释 = "指向同一个数据,修改后结果互相同步;" 注释 = "  2. 请确保所包装变量的生命周期,不能在线程结束前被释放;" 折叠 @嵌入式方法 = "">
    参数 所欲包装参数 <@匹配类型 = 所有类型 @返回值类型 = 0>
    {
        @ std::ref(@<所欲包装参数>)
    }

    方法 常引用 <公开 静态 注释 = "包装线程对象的参数,将它变成\"常引用传递\"(std::cref)." 注释 = "  1. 线程对象默认按值复制参数,包装后线程参数和外部变量"
            注释 = "指向同一个数据,但线程内不能修改参数值;" 注释 = "  2. 请确保所包装变量的生命周期,不能在线程结束前被释放;"
            注释 = "  3. 火山的方法默认为引用传递,除非你知道如何修改参数的传递" 注释 = "方式,否则不应使用本方法;" 折叠 @嵌入式方法 = "">
    参数 所欲包装参数 <@匹配类型 = 所有类型 @返回值类型 = 0>
    {
        @ std::cref(@<所欲包装参数>)
    }

    方法 让出调度 <公开 静态 注释 = "使当前线程让渡出自己的CPU时间片,由运行态变为就绪态." 注释 = "当前线程什么时候再被调度运行,完全取决于系统的调度."
            注释 = "在低效的死循环中重复调用本方法,可以减少线程占用CPU资源." 折叠 @嵌入式方法 = "">
    {
        @ std::this_thread::yield()
    }

    方法 无参数无返回值方法
}

类 标准线程对象 <公开 基础类 = PIV对象类 注释 = "线程对象(std::thread)的封装类." 注释 = "  1. 线程对象不可复制赋值;"
        注释 = "  2. 退出程序时线程对象会被强制结束,不会窗口关掉了还在跑;" 折叠 @文档 = "category = \"多线程\"" @视窗.外部头文件 = "<thread>">
{
    方法 关联函数对象 <公开 类型 = 逻辑型 注释 = "将本线程对象与函数对象关联,关联后会立即执行线程(有系统调度的延迟)." 注释 = "关联后需要调用\"分离/加入\",以释放线程资源;" 折叠
            @嵌入式方法 = "">
    参数 函数对象 <类型 = 通用函数对象 注释 = "所欲关联的函数对象,可以调用下列方法创建:" 注释 = "- 绑定静态方法   绑定无参数静态方法"
            注释 = "- 绑定动态方法   绑定无参数动态方法" 注释 = "- 绑定函数指针   绑定无参数函数指针" 注释 = "- 绑定函数指针2  绑定无参数函数指针2">
    {
        @ @sn<this>.Assign(@<函数对象>)
    }

    方法 关联静态方法 <公开 类型 = 逻辑型 注释 = "将本线程对象与静态方法关联,关联后会立即执行线程(有系统调度的延迟)."
            注释 = "  1. 可以关联任意参数和返回值格式的静态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 关联后需要调用\"分离/加入\",以释放线程资源;"
            返回值注释 = "返回是否关联成功,如果线程对象不为空将返回假." 折叠 @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ @sn<this>.Assign(&@<静态方法>, @<参数列表>)
    }

    方法 关联动态方法 <公开 类型 = 逻辑型 注释 = "将本线程对象与类动态方法关联,关联后会立即执行线程(有系统调度的延迟)."
            注释 = "  1. 可以关联任意参数和返回值格式的类动态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 动态方法可以直接调用类实例的其他动态成员变量和方法;"
            注释 = "  5. 关联后需要调用\"分离/加入\",以释放线程资源;" 返回值注释 = "返回是否关联成功,如果线程对象不为空将返回假." 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    参数 参数列表 <注释 = "参数列表的格式务必和所提供动态方法的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ @sn<this>.Assign(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>, @<参数列表>)
    }

    方法 关联无参数静态方法 <公开 类型 = 逻辑型 注释 = "将本线程对象与无参数的静态方法关联,关联后会立即执行线程(有系统调度的延迟)." 注释 = "  1. 只能关联无参数的静态方法;"
            注释 = "  2. 关联后需要调用\"分离/加入\",以释放线程资源;" 返回值注释 = "返回是否关联成功,如果线程对象不为空将返回假." 折叠 @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    {
        @ @sn<this>.Assign(&@<静态方法>)
    }

    方法 关联无参数动态方法 <公开 类型 = 逻辑型 注释 = "将本线程对象与无参数的类动态方法关联,关联后会立即执行线程(有系统调度的延迟)." 注释 = "  1. 只能关联无参数的类动态方法;"
            注释 = "  2. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 注释 = "  3. 关联后需要调用\"分离/加入\",以释放线程资源;"
            返回值注释 = "返回是否关联成功,如果线程对象不为空将返回假." 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    {
        @ @sn<this>.Assign(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>)
    }

    方法 取线程句柄 <公开 类型 = 变整数 注释 = "返回线程对象内部的底层线程句柄,该句柄可以给\"等待多个事件\"或\"WaitForSingleObject\"使用." 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data().native_handle()
    }

    方法 是否可加入 <公开 类型 = 逻辑型 注释 = "返回当前的线程对象是否可以加入到当前线程(有可执行的线程函数)." 返回值注释 = "返回假表示线程对象是空的" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().joinable()
    }

    方法 加入 <公开 类型 = 逻辑型 注释 = "将线程对象加入到当前线程,会阻塞当前线程直到线程执行完毕." 注释 = "  1. 即使线程函数已实际执行完毕,仍需调用本方法;"
            注释 = "  2. 调用后线程对象将释放线程资源,变为空对象;" 返回值注释 = "线程对象为空时将直接返回假" 折叠 @禁止流程检查 = 真>
    {
        @ if (!data().joinable()) return FALSE;
        @ data().join();
        @ return TRUE;
    }

    方法 分离 <公开 类型 = 逻辑型 注释 = "将执行线程从线程对象中分离,成功后会立即返回真." 注释 = "  1. 分离后线程将独立执行,不再受线程对象管理;"
            注释 = "  2. 即使线程函数已实际执行完毕,仍需调用本方法;" 注释 = "  3. 调用后,线程对象将移交资源的所有权,变为空对象;" 返回值注释 = "线程对象为空时将直接返回假" 折叠
            @禁止流程检查 = 真>
    {
        @ if (!data().joinable()) return FALSE;
        @ data().detach();
        @ return TRUE;
    }

    方法 交换 <公开 注释 = "交换两个线程对象的执行线程" 折叠 @嵌入式方法 = "">
    参数 所欲交换的线程对象 <类型 = 标准线程对象>
    {
        @ @sn<this>.data().swap(@<所欲交换的线程对象>.data())
    }

    方法 硬件并发数 <公开 属性读 类型 = 整数 注释 = "返回硬件和平台支持的最大并发线程数" 折叠 @嵌入式方法 = "">
    {
        @ (INT)std::thread::hardware_concurrency()
    }

    # @begin
    # <> <include>
    # std::thread m_thread;
    # inline std::thread& data() { return m_thread; }
    # inline operator std::thread&() { return m_thread; }
    #
    # template <class Function, class... Args>
    # BOOL Assign(Function&& f, Args&&... args) {
    #     if (m_thread.joinable()) return FALSE;
    #     m_thread = std::move(std::thread(std::forward<Function>(f), std::forward<Args>(args)...));
    #     return TRUE;
    # }
    # <> </include>
    # @end
}

类 "// 标准线程对象" <公开 注释 = "线程对象(std::thread)的封装类." 注释 = "  1. 线程对象不可复制赋值;"
        注释 = "  2. 退出程序时线程对象会被强制结束,不会窗口关掉了还在跑;" 折叠 折叠2 @文档 = "category = \"多线程\"" @视窗.外部头文件 = "<thread>"
        @别名 = "std::thread" @别名类型 = 本地类 @强制依赖 = "PIV对象类">
{
    方法 关联函数对象 <公开 静态 类型 = 逻辑型 注释 = "将本线程对象与函数对象关联,关联后会立即执行线程(有系统调度的延迟)." 注释 = "关联后需要调用\"分离/加入\",以释放线程资源;"
            折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 标准线程对象>
    参数 函数对象 <类型 = 通用函数对象 注释 = "所欲关联的函数对象,可以调用下列方法创建:" 注释 = "- 绑定静态方法   绑定无参数静态方法"
            注释 = "- 绑定动态方法   绑定无参数动态方法" 注释 = "- 绑定函数指针   绑定无参数函数指针" 注释 = "- 绑定函数指针2  绑定无参数函数指针2">
    {
        @ @sn<current_class_def>::Assign(@<欲操作本对象>, @<函数对象>)
    }

    方法 关联静态方法 <公开 静态 类型 = 逻辑型 注释 = "将本线程对象与静态方法关联,关联后会立即执行线程(有系统调度的延迟)."
            注释 = "  1. 可以关联任意参数和返回值格式的静态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 关联后需要调用\"分离/加入\",以释放线程资源;"
            返回值注释 = "返回是否关联成功,如果线程对象不为空将返回假." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 标准线程对象>
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ @sn<current_class_def>::Assign(@<欲操作本对象>, &@<静态方法>, @<参数列表>)
    }

    方法 关联动态方法 <公开 静态 类型 = 逻辑型 注释 = "将本线程对象与类动态方法关联,关联后会立即执行线程(有系统调度的延迟)."
            注释 = "  1. 可以关联任意参数和返回值格式的类动态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 动态方法可以直接调用类实例的其他动态成员变量和方法;"
            注释 = "  5. 关联后需要调用\"分离/加入\",以释放线程资源;" 返回值注释 = "返回是否关联成功,如果线程对象不为空将返回假." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 标准线程对象>
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    参数 参数列表 <注释 = "参数列表的格式务必和所提供动态方法的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ @sn<current_class_def>::Assign(@<欲操作本对象>, &@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>, @<参数列表>)
    }

    方法 关联无参数静态方法 <公开 静态 类型 = 逻辑型 注释 = "将本线程对象与无参数的静态方法关联,关联后会立即执行线程(有系统调度的延迟)." 注释 = "  1. 只能关联无参数的静态方法;"
            注释 = "  2. 关联后需要调用\"分离/加入\",以释放线程资源;" 返回值注释 = "返回是否关联成功,如果线程对象不为空将返回假." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 标准线程对象>
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    {
        @ @sn<current_class_def>::Assign(@<欲操作本对象>, &@<静态方法>)
    }

    方法 关联无参数动态方法 <公开 静态 类型 = 逻辑型 注释 = "将本线程对象与无参数的类动态方法关联,关联后会立即执行线程(有系统调度的延迟)." 注释 = "  1. 只能关联无参数的类动态方法;"
            注释 = "  2. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 注释 = "  3. 关联后需要调用\"分离/加入\",以释放线程资源;"
            返回值注释 = "返回是否关联成功,如果线程对象不为空将返回假." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 标准线程对象>
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    {
        @ @sn<current_class_def>::Assign(@<欲操作本对象>, &@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>)
    }

    方法 取线程句柄 <公开 静态 类型 = 变整数 注释 = "返回线程对象内部的底层线程句柄,该句柄可以给\"等待多个事件\"或\"WaitForSingleObject\"使用." 折叠
            @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 标准线程对象>
    {
        @ (INT_P)@<欲操作本对象>.native_handle()
    }

    方法 是否可加入 <公开 静态 类型 = 逻辑型 注释 = "返回当前的线程对象是否可以加入到当前线程(有可执行的线程函数)." 返回值注释 = "返回假表示线程对象是空的" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 标准线程对象>
    {
        @ @<欲操作本对象>.joinable()
    }

    方法 加入 <公开 静态 类型 = 逻辑型 注释 = "将线程对象加入到当前线程,会阻塞当前线程直到线程执行完毕." 注释 = "  1. 即使线程函数已实际执行完毕,仍需调用本方法;"
            注释 = "  2. 调用后线程对象将释放线程资源,变为空对象;" 返回值注释 = "线程对象为空时将直接返回假" 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = 标准线程对象>
    {
        @ if (!@<欲操作本对象>.joinable()) return FALSE;
        @ @<欲操作本对象>.join();
        @ return TRUE;
    }

    方法 分离 <公开 静态 类型 = 逻辑型 注释 = "将执行线程从线程对象中分离,成功后会立即返回真." 注释 = "  1. 分离后线程将独立执行,不再受线程对象管理;"
            注释 = "  2. 即使线程函数已实际执行完毕,仍需调用本方法;" 注释 = "  3. 调用后,线程对象将移交资源的所有权,变为空对象;" 返回值注释 = "线程对象为空时将直接返回假" 折叠
            @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = 标准线程对象>
    {
        @ if (!@<欲操作本对象>.joinable()) return FALSE;
        @ @<欲操作本对象>.detach();
        @ return TRUE;
    }

    方法 交换 <公开 静态 注释 = "交换两个线程对象的执行线程" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 标准线程对象>
    参数 所欲交换的线程对象 <类型 = 标准线程对象>
    {
        @ @<欲操作本对象>.swap(@<所欲交换的线程对象>)
    }

    方法 硬件并发数 <公开 静态 属性读 类型 = 整数 注释 = "返回硬件和平台支持的最大并发线程数" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 标准线程对象>
    {
        @ (INT)std::thread::hardware_concurrency()
    }

    # @begin
    # <> <include>
    # template <class Function, class... Args>
    # static BOOL Assign(std::thread& thd, Function&& f, Args&&... args) {
    #     if (thd.joinable()) return FALSE;
    #     thd = std::move(std::thread(std::forward<Function>(f), std::forward<Args>(args)...));
    #     return TRUE;
    # }
    # <> </include>
    # @end
}

类 异步线程类 <公开 基础类 = PIV对象类 注释 = "异步对象(std::async)的封装类;" 注释 = "跟线程对象相比,可以延迟线程执行,以及通过\"未来对象\"获取异步线程的返回值."
        折叠 @文档 = "category = \"多线程\"" @视窗.外部头文件 = "<future>" @全局类 = 真>
{
    方法 启动异步对象 <公开 静态 注释 = "创建一个与函数对象关联的异步对象,然后立即分离并非阻塞执行线程函数." 折叠 @嵌入式方法 = "">
    参数 是否立即执行 <类型 = 逻辑型 注释 = "是否立即执行异步线程,为假将延迟执行,直到未来对象执行\"等待/取值\"才开始执行." @默认值 = 真>
    参数 未来值对象 <注释 = "必须为\"未来对象模板类\"的模板实现类,比如\"未来整数类\";" 注释 = "其中\"模板类型1\"必须跟\"静态方法\"的返回值类型一致;"
            注释 = "如果方法没有返回值,请使用\"未来空值类\";" @匹配类型 = 通用类>
    参数 函数对象 <类型 = 通用函数对象 注释 = "所欲异步执行的函数对象,可以调用下列方法创建:" 注释 = "- 绑定静态方法   绑定无参数静态方法"
            注释 = "- 绑定动态方法   绑定无参数动态方法" 注释 = "- 绑定函数指针   绑定无参数函数指针" 注释 = "- 绑定函数指针2  绑定无参数函数指针2">
    {
        @ @<未来值对象> = std::async(@<是否立即执行> ? std::launch::async : (std::launch::async | std::launch::deferred), @<函数对象>)
    }

    方法 启动静态异步 <公开 静态 注释 = "创建一个与静态方法关联的异步对象,然后立即分离并非阻塞执行线程函数."
            注释 = "  1. 可以关联任意参数和返回值格式的静态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 折叠 @嵌入式方法 = "">
    参数 是否立即执行 <类型 = 逻辑型 注释 = "是否立即执行异步线程,为假将延迟执行,直到未来对象执行\"等待/取值\"才开始执行." @默认值 = 真>
    参数 未来值对象 <注释 = "必须为\"未来对象模板类\"的模板实现类,比如\"未来整数类\";" 注释 = "其中\"模板类型1\"必须跟\"静态方法\"的返回值类型一致;"
            注释 = "如果方法没有返回值,请使用\"未来空值类\";" @匹配类型 = 通用类>
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法,提供的方法必须具有返回值." @匹配方法 = "">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ @<未来值对象> = std::async(@<是否立即执行> ? std::launch::async : (std::launch::async | std::launch::deferred), &@<静态方法>, @<参数列表>)
    }

    方法 启动动态异步 <公开 静态 注释 = "创建一个与类动态方法关联的异步对象,然后立即分离并非阻塞执行线程函数."
            注释 = "  1. 可以关联任意参数和返回值格式的类动态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 动态方法可以直接调用类实例的其他动态成员变量和方法;"
            注释 = "  5. 如果关联的对象实例被销毁,线程将异常结束(不影响整个进程的运作);" 折叠 @嵌入式方法 = "">
    参数 是否立即执行 <类型 = 逻辑型 注释 = "是否立即执行异步线程,为假将延迟执行,直到未来对象执行\"等待/取值\"才开始执行." @默认值 = 真>
    参数 未来值对象 <注释 = "必须为\"未来对象模板类\"的模板实现类,比如\"未来整数类\";" 注释 = "其中\"模板类型1\"必须跟\"静态方法\"的返回值类型一致;"
            注释 = "如果方法没有返回值,请使用\"未来空值类\";" @匹配类型 = 通用类>
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ @<未来值对象> = std::async(@<是否立即执行> ? std::launch::async : (std::launch::async | std::launch::deferred), &@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>, @<参数列表>)
    }

    方法 启动无参数静态异步 <公开 静态 注释 = "创建一个与静态方法关联的异步对象,然后立即分离并非阻塞执行线程函数." 注释 = "  1. 只能关联无参数的静态方法;" 折叠 @嵌入式方法 = "">
    参数 是否立即执行 <类型 = 逻辑型 注释 = "是否立即执行异步线程,为假将延迟执行,直到未来对象执行\"等待/取值\"才开始执行." @默认值 = 真>
    参数 未来值对象 <注释 = "必须为\"未来对象模板类\"的模板实现类,比如\"未来整数类\";" 注释 = "其中\"模板类型1\"必须跟\"静态方法\"的返回值类型一致;"
            注释 = "如果方法没有返回值,请使用\"未来空值类\";" @匹配类型 = 通用类>
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法,提供的方法必须具有返回值." @匹配方法 = "">
    {
        @ @<未来值对象> = std::async(@<是否立即执行> ? std::launch::async : (std::launch::async | std::launch::deferred), &@<静态方法>)
    }

    方法 启动无参数动态异步 <公开 静态 注释 = "创建一个与类动态方法关联的异步对象,然后立即分离并非阻塞执行线程函数." 注释 = "  1. 只能关联无参数的类动态方法;"
            注释 = "  2. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 注释 = "  3. 如果关联的对象实例被销毁,线程将异常结束(不影响整个进程的运作);" 折叠 @嵌入式方法 = "">
    参数 是否立即执行 <类型 = 逻辑型 注释 = "是否立即执行异步线程,为假将延迟执行,直到未来对象执行\"等待/取值\"才开始执行." @默认值 = 真>
    参数 未来值对象 <注释 = "必须为\"未来对象模板类\"的模板实现类,比如\"未来整数类\";" 注释 = "其中\"模板类型1\"必须跟\"静态方法\"的返回值类型一致;"
            注释 = "如果方法没有返回值,请使用\"未来空值类\";" @匹配类型 = 通用类>
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    {
        @ @<未来值对象> = std::async(@<是否立即执行> ? std::launch::async : (std::launch::async | std::launch::deferred), &@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>)
    }
}

# 函数对象 ---

类 通用函数对象 <公开 注释 = "函数对象(std::function)的封装类:" 注释 = " 1. 内部类型固定为std::function<void()>,因此它只能接受无参数的函数对象;"
        注释 = " 2. 如果绑定函数时使用了\"占位符_n\",请勿赋值到本函数对象变量;" 注释 = " 3. 绑定函数等操作请使用\"函数对象辅助类\"的全局方法;" 折叠
        @文档 = "category = \"多线程\"" @视窗.外部头文件 = "<functional>" @别名 = "std::function<void()>" @别名类型 = 本地类
        @全局类 = 真 @强制依赖 = "PIV对象类">
{
    方法 是否有效 <公开 静态 类型 = 逻辑型 注释 = "返回本对象是否存储了可调用的函数对象" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 通用函数对象>
    {
        @ !!@<欲操作本对象>
    }

    方法 调用函数 <公开 静态 注释 = "调用本对象的可调用函数对象,std::function<void()>类型专用;" 折叠>
    参数 欲操作本对象 <类型 = 通用函数对象>
    {
        @ if (@<欲操作本对象>) { @<欲操作本对象>(); }
    }
}

类 函数对象类 <公开 注释 = "函数对象(std::function)的全局绑定方法:" 注释 = "  1. 本类全部为全局方法,直接调用即可;"
        注释 = "  2. 如果绑定函数时使用了\"占位符_n\",请勿将返回值赋值到函数对象类变量;" 折叠 @文档 = "category = \"多线程\"" @全局类 = 真 @禁止创建对象 = 真
        @强制依赖 = "通用函数对象">
{
    方法 绑定静态方法 <公开 静态 类型 = 通用函数对象 注释 = "将任意格式的静态方法绑定到函数对象中并返回."
            注释 = "  1. 可以绑定任意参数和返回值格式的静态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到函数对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 折叠 @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲绑定的类静态方法名称" @匹配方法 = "">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" @可扩展 = "" @匹配类型 = 通用型>
    {
        @ std::bind(&@<静态方法>, @<参数列表>)
    }

    方法 绑定动态方法 <公开 静态 类型 = 通用函数对象 注释 = "将任意格式的类动态方法绑定到函数对象中并返回."
            注释 = "  1. 可以绑定任意参数和返回值格式的类动态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到函数对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供类动态方法所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲绑定的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    参数 参数列表 <注释 = "参数列表的格式务必和所提供动态方法的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ std::bind(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>, @<参数列表>)
    }

    方法 绑定无参数静态方法 <公开 静态 类型 = 通用函数对象 注释 = "将无参数的静态方法绑定到函数对象中并返回." 折叠 @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲绑定的类静态方法名称" @匹配方法 = "">
    {
        @ std::bind(&@<静态方法>)
    }

    方法 绑定无参数动态方法 <公开 静态 类型 = 通用函数对象 注释 = "将无参数的类动态方法绑定到函数对象中并返回." 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供类动态方法所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲绑定的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    {
        @ std::bind(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>)
    }

    方法 绑定无参数无返回值动态方法 <公开 静态 类型 = 通用函数对象 注释 = "将无参数及无返回值的类动态方法绑定到函数对象中并返回." 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供类动态方法所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 动态方法 <注释 = "提供所欲绑定的类动态方法." 注释 = "注意: 方法不需要设置输出名,但必须是无参数和无返回值." @匹配方法 = "无参数无返回值方法">
    {
        @ std::bind(&@pdt<对象实例>::@<动态方法>, &@<对象实例>)
    }

    方法 绑定函数指针 <公开 静态 类型 = 通用函数对象 注释 = "将任意格式的函数指针绑定到函数对象中并返回." 注释 = "注: 调用约定为stdcall" 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 注释 = "提供所欲绑定的函数指针">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" @可扩展 = "" @匹配类型 = 通用型>
    {
        @ std::bind(((void (CALLBACK *) (@pdt_list<参数列表>))@<函数指针>), @<参数列表>)
    }

    方法 绑定无参数函数指针 <公开 静态 类型 = 通用函数对象 注释 = "将无参数的函数指针绑定到函数对象中并返回." 注释 = "注: 调用约定为stdcall" 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 注释 = "提供所欲绑定的函数指针">
    {
        @ std::bind(((void (CALLBACK *) ())@<函数指针>))
    }

    方法 绑定函数指针2 <公开 静态 类型 = 通用函数对象 注释 = "将任意格式的函数指针绑定到函数对象中并返回." 注释 = "注: 调用约定为cdecl" 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 注释 = "提供所欲绑定的函数指针">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" @可扩展 = "" @匹配类型 = 通用型>
    {
        @ std::bind(((void (CDECL *) (@pdt_list<参数列表>))@<函数指针>), @<参数列表>)
    }

    方法 绑定无参数函数指针2 <公开 静态 类型 = 通用函数对象 注释 = "将无参数的函数指针绑定到函数对象中并返回." 注释 = "注: 调用约定为cdecl" 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 注释 = "提供所欲绑定的函数指针">
    {
        @ std::bind(((void (CDECL *) ())@<函数指针>))
    }

    方法 无参数无返回值方法

    # 占位符 ---

    方法 占位符_1 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_1
    }

    方法 占位符_2 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_2
    }

    方法 占位符_3 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_3
    }

    方法 占位符_4 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_4
    }

    方法 占位符_5 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_5
    }

    方法 占位符_6 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_6
    }

    方法 占位符_7 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_7
    }

    方法 占位符_8 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_8
    }

    方法 占位符_9 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_9
    }

    方法 占位符_10 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_10
    }

    方法 占位符_11 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_11
    }

    方法 占位符_12 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_12
    }

    方法 占位符_13 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_13
    }

    方法 占位符_14 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_14
    }

    方法 占位符_15 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_15
    }

    方法 占位符_16 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_16
    }

    方法 占位符_17 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_17
    }

    方法 占位符_18 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_18
    }

    方法 占位符_19 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_19
    }

    方法 占位符_20 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_20
    }
}

# 互斥 ---

类 互斥对象类 <公开 基础类 = PIV对象类 注释 = "互斥锁对象(std::mutex)的封装类." 注释 = "  1. 互斥对象不可复制赋值;"
        注释 = "  2. \"互斥自动锁\"方法可自动加锁/解锁;" 折叠 @文档 = "category = \"多线程.互斥\"" @视窗.外部头文件 = "<mutex>" @全局类 = 真>
{
    方法 互斥自动锁 <公开 静态 注释 = "创建一个互斥自动锁对象(std::lock_guard),它将接收指定互斥锁的所有权."
            注释 = "创建后会立即在当前线程加锁,直到离开作用域后自动销毁对象并解锁." 注释 = "注: 本方法可以避免死锁,推荐用来替代互斥锁对象的\"加锁/解锁\"操作." 折叠 @嵌入式方法 = "">
    参数 所欲操作互斥锁 <类型 = 互斥对象类 注释 = "提供要在当前线程上锁的互斥锁对象(std::mutex)">
    {
        @ std::lock_guard<std::mutex> @sn<rand_name0>(@<所欲操作互斥锁>)
    }

    方法 加锁 <公开 注释 = "将本互斥锁加锁,如果本锁当前已经被另一线程锁住,则进入等待状态." 注释 = "注: 建议使用\"互斥自动锁\"以避免死锁." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().lock()
    }

    方法 尝试加锁 <公开 类型 = 逻辑型 注释 = "尝试将本互斥锁加锁,如果能够成功加锁,则加锁后返回真." 注释 = "如果不能(譬如已经被其它线程锁住)则立即返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().try_lock()
    }

    方法 "// 限时尝试加锁" <公开 类型 = 逻辑型 注释 = "尝试将本互斥锁加锁,若能在指定时间内成功加锁返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 延迟时间 <类型 = 长整数 注释 = "单位为毫秒">
    {
        @ @sn<this>.data().try_lock_for(std::chrono::milliseconds(@<延迟时间>))
    }

    方法 解锁 <公开 注释 = "如果先前加锁成功,解开此锁,以允许其它线程加锁成功." 注释 = "注: 建议使用\"互斥自动锁\"以避免死锁." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().unlock()
    }

    方法 取互斥锁句柄 <公开 类型 = 变整数 注释 = "返回互斥锁的底层句柄" 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data().native_handle()
    }

    # @begin
    # <> <include>
    # std::mutex m_mutex;
    # inline std::mutex& data() { return m_mutex; }
    # inline operator std::mutex&() { return m_mutex; }
    # <> </include>
    # @end
}

类 "// 互斥对象类" <公开 注释 = "互斥锁对象(std::mutex)的封装类." 注释 = "  1. 互斥对象不可复制赋值;" 注释 = "  2. \"互斥自动锁\"方法可自动加锁/解锁;"
        折叠 @文档 = "category = \"多线程.互斥\"" @视窗.外部头文件 = "<mutex>" @别名 = "std::mutex" @别名类型 = 本地类
        @强制依赖 = "PIV对象类">
{
    方法 互斥自动锁 <公开 静态 注释 = "创建一个互斥自动锁对象(std::lock_guard),它将接收指定互斥锁的所有权."
            注释 = "创建后会立即在当前线程加锁,直到离开作用域后自动销毁对象并解锁." 注释 = "注: 本方法可以避免死锁,推荐用来替代互斥锁对象的\"加锁/解锁\"操作." 折叠 @嵌入式方法 = "">
    参数 所欲操作互斥锁 <类型 = 互斥对象类 注释 = "提供要在当前线程上锁的互斥锁对象(std::mutex)">
    {
        @ std::lock_guard<std::mutex> @sn<rand_name0>(@<所欲操作互斥锁>)
    }

    方法 加锁 <公开 静态 注释 = "将本互斥锁加锁,如果本锁当前已经被另一线程锁住,则进入等待状态." 注释 = "注: 建议使用\"互斥自动锁\"以避免死锁." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 互斥对象类>
    {
        @ @<欲操作本对象>.lock()
    }

    方法 尝试加锁 <公开 静态 类型 = 逻辑型 注释 = "尝试将本互斥锁加锁,如果能够成功加锁,则加锁后返回真." 注释 = "如果不能(譬如已经被其它线程锁住)则立即返回假." 折叠
            @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 互斥对象类>
    {
        @ @<欲操作本对象>.try_lock()
    }

    方法 "// 限时尝试加锁" <公开 静态 类型 = 逻辑型 注释 = "尝试将本互斥锁加锁,若能在指定时间内成功加锁返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 互斥对象类>
    参数 延迟时间 <类型 = 长整数 注释 = "单位为毫秒">
    {
        @ @<欲操作本对象>.try_lock_for(std::chrono::milliseconds(@<延迟时间>))
    }

    方法 解锁 <公开 静态 注释 = "如果先前加锁成功,解开此锁,以允许其它线程加锁成功." 注释 = "注: 建议使用\"互斥自动锁\"以避免死锁." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 互斥对象类>
    {
        @ @<欲操作本对象>.unlock()
    }

    方法 取互斥锁句柄 <公开 静态 类型 = 变整数 注释 = "返回互斥锁的底层句柄" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 互斥对象类>
    {
        @ (INT_P)@<欲操作本对象>.native_handle()
    }
}

类 "// 互斥对象管理" <公开 注释 = "提供全局方法\"互斥自动锁\",可自动加锁/解锁." 折叠 @文档 = "category = \"多线程.互斥.辅助类\"" @全局类 = 真>
{
    方法 互斥自动锁 <公开 静态 注释 = "创建一个互斥自动锁对象(std::lock_guard),它将接收指定互斥锁的所有权."
            注释 = "创建后会立即在当前线程加锁,直到离开作用域后自动销毁对象并解锁." 注释 = "注: 本方法可以避免死锁,推荐用来替代互斥锁对象的\"加锁/解锁\"操作." @嵌入式方法 = "">
    参数 所欲操作互斥锁 <类型 = 互斥对象类 注释 = "提供要在当前线程上锁的互斥锁对象(std::mutex)">
    {
        @ std::lock_guard<std::mutex> @sn<rand_name0>(@<所欲操作互斥锁>)
    }
}

类 唯一互斥锁类 <公开 注释 = "std::unique_lock<std::mutex>的封装类" 注释 = "跟\"互斥自动锁\"一样,本类比直接使用互斥对象类更安全,"
        注释 = "关联互斥对象后立即加锁,并在析构时自动解锁;" 注释 = "跟\"互斥自动锁\"相比,本类还可以手动加锁和解锁;" 折叠 @文档 = "category = \"多线程.互斥\""
        @视窗.外部头文件 = "<mutex>" @别名 = "std::unique_lock<std::mutex>" @别名类型 = 本地类 @强制依赖 = "PIV对象类">
{
    方法 关联互斥 <公开 静态 注释 = "关联互斥对象,并锁定关联的互斥对象,如果关联互斥已经被另一线程锁住,则进入等待状态." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 唯一互斥锁类>
    参数 所欲关联的锁 <类型 = 互斥对象类>
    {
        @ @<欲操作本对象> = std::unique_lock<std::mutex>(@<所欲关联的锁>)
    }

    方法 加锁 <公开 静态 注释 = "锁定关联的互斥对象,如果关联互斥已经被另一线程锁住,则进入等待状态." 折叠>
    参数 欲操作本对象 <类型 = 唯一互斥锁类>
    {
        @ if (@<欲操作本对象>.owns_lock()) { @<欲操作本对象>.lock(); }
    }

    方法 尝试加锁 <公开 静态 类型 = 逻辑型 注释 = "尝试锁定关联的互斥对象,如果能够成功加锁,则加锁后返回真." 注释 = "如果不能(譬如已经被其它线程锁住)则立即返回假." 折叠
            @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = 唯一互斥锁类>
    {
        @ return (@<欲操作本对象>.owns_lock()) ? @<欲操作本对象>.try_lock() : FALSE;
    }

    方法 "// 限时尝试加锁" <公开 静态 类型 = 逻辑型 注释 = "尝试锁定关联的互斥对象,若能在指定时间内成功加锁返回真,否则返回假." 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = 唯一互斥锁类>
    参数 延迟时间 <类型 = 长整数 注释 = "单位为毫秒">
    {
        @ return (@<欲操作本对象>.owns_lock()) ? @<欲操作本对象>.try_lock_for(std::chrono::milliseconds(@<延迟时间>)) : FALSE;
    }

    方法 解锁 <公开 静态 注释 = "解锁关联互斥对象并释放所有权,以允许其它线程加锁成功." 折叠>
    参数 欲操作本对象 <类型 = 唯一互斥锁类>
    {
        @ if (@<欲操作本对象>.owns_lock()) { @<欲操作本对象>.unlock(); }
    }

    方法 是否有效 <公开 静态 类型 = 逻辑型 注释 = "检查本类是否占有锁定的互斥对象(即是否调用了\"关联互斥\")" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 唯一互斥锁类>
    {
        @ @<欲操作本对象>.owns_lock()
    }

    方法 释放 <公开 静态 注释 = "解除与互斥对象的关联,本操作不会将互斥对象加锁或解锁." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 唯一互斥锁类>
    {
        @ @<欲操作本对象>.release()
    }
}

类 条件变量类 <公开 注释 = "能用于阻塞一个或多个线程,直至另一线程修改共享条件变量并通知." 折叠 @文档 = "category = \"多线程.互斥\""
        @视窗.外部头文件 = "<condition_variable>" @别名 = "std::condition_variable" @别名类型 = 本地类 @强制依赖 = "PIV对象类">
{
    方法 通知一个 <公开 静态 注释 = "通知一个等待中的线程解除阻塞,本方法不需要在互斥锁中使用." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 条件变量类>
    {
        @ @<欲操作本对象>.notify_one()
    }

    方法 通知所有 <公开 静态 注释 = "通知所有等待中的线程解除阻塞,本方法不需要在互斥锁中使用." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 条件变量类>
    {
        @ @<欲操作本对象>.notify_all()
    }

    方法 等待 <公开 静态 注释 = "阻塞当前线程,直到条件变量被唤醒;" 注释 = "注意: 本方法必须在\"唯一互斥锁类\"已加锁状态下使用;" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 条件变量类>
    参数 互斥锁 <类型 = 唯一互斥锁类 注释 = "提供的\"唯一互斥锁类\"必须已\"关联互斥\"并处于加锁状态">
    {
        @ @<欲操作本对象>.wait(@<互斥锁>)
    }

    方法 限时等待 <公开 静态 类型 = 逻辑型 注释 = "阻塞当前线程,直到条件变量被唤醒,或到达指定时长后解除阻塞." 注释 = "如果在延迟时间内条件变量被唤醒将返回真,否则返回假."
            注释 = "注意: 本方法必须在\"唯一互斥锁类\"已加锁状态下使用;" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 条件变量类>
    参数 互斥锁 <类型 = 唯一互斥锁类 注释 = "提供的\"唯一互斥锁类\"必须已\"关联互斥\"并处于加锁状态">
    参数 延迟时间 <类型 = 长整数 注释 = "单位为毫秒">
    {
        @ (@<欲操作本对象>.wait_for(@<互斥锁>, std::chrono::milliseconds(@<延迟时间>)) == std::cv_status::no_timeout)
    }
}

# 异步赋值对象 ---

类 未来对象模板类 <公开 注释 = "共享未来对象(std::shared_future)可以获取异步对象和承诺对象的值." 注释 = "  1. 共享未来对象可复制多个副本指向同一个共享状态;"
        注释 = "  2. \"模板类型1\"为所欲封装的数据类型;" 折叠 @文档 = "category = \"多线程.辅助类.未来对象\"" @模板基础类 = 真
        @别名 = "std::shared_future<模板类型1>" @别名类型 = 本地类 @强制依赖 = "异步线程类">
{
    方法 取值 <公开 静态 类型 = 逻辑型 注释 = "首先检查是否有共享状态,无共享状态时直接返回假;" 注释 = "有效则一直等待直到未来对象拥有合法的结果,然后获取结果并返回真;"
            注释 = "执行后将释放任何的共享状态,\"是否有效\"将返回假." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 未来对象模板类>
    参数 未来值 <类型 = 模板类型1 @需求类型 = 可写入变量>
    {
        @ @sn<current_class_def>::GetValue(@<欲操作本对象>, @<未来值>)
    }

    方法 等待 <公开 静态 类型 = 逻辑型 注释 = "首先检查是否有共享状态,无共享状态时直接返回假;" 注释 = "有效则一直等待,直到未来对象拥有合法的结果,返回然后真;" 折叠
            @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = 未来对象模板类>
    {
        @ if (!@<欲操作本对象>.valid()) { return FALSE; }
        @ @<欲操作本对象>.wait();
        @ return TRUE;
    }

    方法 限时等待 <公开 静态 类型 = 逻辑型 注释 = "首先检查是否有共享状态,无共享状态时直接返回假;" 注释 = "有效则等待指定的时间,如果在限时内未来对象拥有合法的结果,则返回真,否则返回假;"
            折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = 未来对象模板类>
    参数 延迟时间 <类型 = 长整数 注释 = "单位为毫秒">
    {
        @ if (!@<欲操作本对象>.valid()) return FALSE;
        @ return @<欲操作本对象>.wait_for(std::chrono::milliseconds(@<延迟时间>)) == std::future_status::ready;
    }

    方法 是否有效 <公开 静态 类型 = 逻辑型 注释 = "检查未来对象是否有效(拥有共享状态)." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 未来对象模板类>
    {
        @ @<欲操作本对象>.valid()
    }

    # @begin
    # <> <include>
    # template <typename T>
    # static BOOL GetValue(std::shared_future<T>& future, T& value) {
    #     if (!future.valid()) { return FALSE; }
    #     value = future.get();
    #     return TRUE;
    # }
    # <> </include>
    # @end
}

类 承诺对象模板类 <公开 注释 = "提供一个承诺(std::promise),表示在某个时间点一定会有一个值或一个异常被设置."
        注释 = "  1. 本模板使用共享智能指针封装,可复制多个副本指向同一个承诺对象;" 注释 = "  2. \"模板类型1\"为所欲封装的数据类型;" 折叠
        @文档 = "category = \"多线程.辅助类.承诺对象\"" @模板基础类 = 真 @别名 = "std::shared_ptr<std::promise<模板类型1>>"
        @别名类型 = 本地类 @强制依赖 = "异步线程类">
{
    方法 取未来对象 <公开 静态 类型 = 逻辑型 注释 = "获取与承诺的结果关联的未来对象;" 注释 = "成功返回真,如果承诺对象没有共享状态或已经获取未来对象则返回假;" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 承诺对象模板类>
    参数 未来对象 <注释 = "提供用来获取结果的未来对象;" 注释 = "提供的变量必须为\"未来对象模板类\"的模板实现类;" 注释 = "而且它的\"模板类型1\"必须跟承诺对象的模板实现类一致;"
            @匹配类型 = 通用类>
    {
        @ @sn<current_class_def>::GetFuture(@<欲操作本对象>, @<未来对象>)
    }

    方法 置值 <公开 静态 类型 = 逻辑型 注释 = "原子存储值到共享状态,然后立即令共享状态就绪,使未来对象可以取值;" 注释 = "成功返回真,如果承诺对象没有共享状态或已经存储值则返回假;" 折叠
            @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = 承诺对象模板类>
    参数 值 <类型 = 模板类型1 注释 = "提供所欲设置的值">
    {
        @ try {
        @     if (!@<欲操作本对象>)
        @         @<欲操作本对象>.reset(new std::promise<@dt<模板类型1>>);
        @     @<欲操作本对象>->set_value(@<值>);
        @     return TRUE;
        @ } catch (const std::future_error& e) {
        @     (void)e;
        @     PIVDEBUG("S", CVolString(e.what()).GetText());
        @     return FALSE;
        @ }
    }

    方法 线程退出时置值 <公开 静态 类型 = 逻辑型 注释 = "原子存储值到共享状态,但不立即令共享状态就绪,而是等当前线程退出后再令状态就绪."
            注释 = "成功返回真,如果承诺对象没有共享状态或已经存储值则返回假;" 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = 承诺对象模板类>
    参数 值 <类型 = 模板类型1 注释 = "提供所欲设置的值">
    {
        @ try {
        @     if (!@<欲操作本对象>)
        @         @<欲操作本对象>.reset(new std::promise<@dt<模板类型1>>);
        @     @<欲操作本对象>->set_value_at_thread_exit(@<值>);
        @     return TRUE;
        @ } catch (const std::future_error& e) {
        @     (void)e;
        @     PIVDEBUG("S", CVolString(e.what()).GetText());
        @     return FALSE;
        @ }
    }

    方法 交换 <公开 静态 注释 = "交换两个承诺对象" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 承诺对象模板类>
    参数 所欲交换的对象 <类型 = 承诺对象模板类>
    {
        @ @<欲操作本对象>.swap(@<所欲交换的对象>)
    }

    # @begin
    # <> <include>
    # template <typename T>
    # static BOOL GetFuture(std::shared_ptr<std::promise<T>>& promise, std::shared_future<T>& future) {
    #     try {
    #         if (!promise)
    #             promise.reset(new std::promise<T>);
    #         future = promise->get_future();
    #         return TRUE;
    #     } catch (const std::future_error& e) {
    #         (void)e;
    #         PIVDEBUG("S", CVolString(e.what()).GetText());
    #         return FALSE;
    #     }
    # }
    # <> </include>
    # @end
}

# 常用未来对象类 ---

类 未来空值类 <公开 注释 = "void类型的特化" 注释 = "共享未来对象可以获取异步对象和承诺对象的值" 折叠 @文档 = "category = \"多线程.辅助类.未来对象\""
        @别名 = "std::shared_future<void>" @别名类型 = 本地类 @强制依赖 = "异步线程类">
{
    方法 取值 <公开 静态 类型 = 逻辑型 注释 = "首先检查是否有共享状态,无共享状态时直接返回假;" 注释 = "有效则一直等待直到未来对象拥有合法的结果,然后返回真;"
            注释 = "执行后将释放任何的共享状态,\"是否有效\"将返回假." 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = 未来空值类>
    {
        @ if (!@<欲操作本对象>.valid()) return FALSE;
        @ @<欲操作本对象>.get();
        @ return TRUE;
    }

    方法 等待 <公开 静态 类型 = 逻辑型 注释 = "首先检查是否有共享状态,无共享状态时直接返回假;" 注释 = "有效则一直等待,直到未来对象拥有合法的结果,返回然后真;" 折叠
            @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = 未来空值类>
    {
        @ if (!@<欲操作本对象>.valid()) return FALSE;
        @ @<欲操作本对象>.wait();
        @ return TRUE;
    }

    方法 限时等待 <公开 静态 类型 = 逻辑型 注释 = "首先检查是否有共享状态,无共享状态时直接返回假;" 注释 = "有效则等待指定的时间,如果在限时内未来对象拥有合法的结果,则返回真,否则返回假;"
            折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = 未来空值类>
    参数 延迟时间 <类型 = 长整数 注释 = "单位为毫秒">
    {
        @ if (!@<欲操作本对象>.valid()) return FALSE;
        @ return @<欲操作本对象>.wait_for(std::chrono::milliseconds(@<延迟时间>)) == std::future_status::ready;
    }

    方法 是否有效 <公开 静态 类型 = 逻辑型 注释 = "检查未来对象是否有效(拥有共享状态)." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 未来空值类>
    {
        @ @<欲操作本对象>.valid()
    }
}

类 未来整数类 <公开 基础类 = 未来对象模板类 注释 = "共享未来对象可以获取异步对象和承诺对象的值" @文档 = "category = \"多线程.辅助类.未来对象\""
        @模板实现类 = "整数">

类 未来长整数类 <公开 基础类 = 未来对象模板类 注释 = "共享未来对象可以获取异步对象和承诺对象的值" @文档 = "category = \"多线程.辅助类.未来对象\""
        @模板实现类 = "长整数">

类 未来小数类 <公开 基础类 = 未来对象模板类 注释 = "共享未来对象可以获取异步对象和承诺对象的值" @文档 = "category = \"多线程.辅助类.未来对象\""
        @模板实现类 = "小数">

类 未来逻辑类 <公开 基础类 = 未来对象模板类 注释 = "共享未来对象可以获取异步对象和承诺对象的值" @文档 = "category = \"多线程.辅助类.未来对象\""
        @模板实现类 = "逻辑型">

类 未来文本类 <公开 基础类 = 未来对象模板类 注释 = "共享未来对象可以获取异步对象和承诺对象的值" @文档 = "category = \"多线程.辅助类.未来对象\""
        @模板实现类 = "文本型">

类 未来字节集类 <公开 基础类 = 未来对象模板类 注释 = "共享未来对象可以获取异步对象和承诺对象的值" @文档 = "category = \"多线程.辅助类.未来对象\""
        @模板实现类 = "字节集类">

# 常用承诺对象类 ---

类 承诺空值类 <公开 注释 = "void类型的特化,用于发出共享信号" 注释 = "配合\"未来空值类\"使用" 注释 = "提供一个承诺,表示在某个时间点一定会有一个值或一个异常被设置." 折叠
        @文档 = "category = \"多线程.辅助类.承诺对象\"" @别名 = "std::shared_ptr<std::promise<void>>" @别名类型 = 本地类
        @强制依赖 = "异步线程类">
{
    方法 取未来对象 <公开 静态 类型 = 逻辑型 注释 = "获取与承诺的结果关联的未来对象;" 注释 = "成功返回真,如果承诺对象没有共享状态或已经获取未来对象则返回假;" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 承诺空值类>
    参数 未来对象 <类型 = 未来空值类 注释 = "提供用来获取结果的未来对象;" 注释 = "提供的变量必须为\"未来对象模板类\"的模板实现类;"
            注释 = "而且它的\"模板类型1\"必须跟承诺对象的模板实现类一致;">
    {
        @ @sn<current_class_def>::GetFuture(@<欲操作本对象>, @<未来对象>)
    }

    方法 置值 <公开 静态 类型 = 逻辑型 注释 = "令共享状态就绪,使未来对象可以取值;" 注释 = "成功返回真,如果承诺对象没有共享状态或共享状态已就绪则返回假;" 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = 承诺空值类>
    {
        @ try {
        @     if (!@<欲操作本对象>)
        @         @<欲操作本对象>.reset(new std::promise<void>);
        @     @<欲操作本对象>->set_value();
        @     return TRUE;
        @ } catch (const std::future_error& e) {
        @     (void)e;
        @     PIVDEBUG("S", CVolString(e.what()).GetText());
        @     return FALSE;
        @ }
    }

    方法 线程退出时置值 <公开 静态 类型 = 逻辑型 注释 = "等当前线程退出后令状态就绪." 注释 = "成功返回真,如果承诺对象没有共享状态或共享状态已就绪则返回假;" 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = 承诺空值类>
    {
        @ try {
        @     if (!@<欲操作本对象>)
        @         @<欲操作本对象>.reset(new std::promise<void>);
        @     @<欲操作本对象>->set_value_at_thread_exit();
        @     return TRUE;
        @ } catch (const std::future_error& e) {
        @     (void)e;
        @     PIVDEBUG("S", CVolString(e.what()).GetText());
        @     return FALSE;
        @ }
    }

    方法 交换 <公开 静态 注释 = "交换两个承诺对象" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 承诺空值类>
    参数 所欲交换的对象 <类型 = 承诺空值类>
    {
        @ @<欲操作本对象>.swap(@<所欲交换的对象>)
    }

    # @begin
    # <> <include>
    # static BOOL GetFuture(std::shared_ptr<std::promise<void>>& promise, std::shared_future<void>& future) {
    #     try {
    #         if (!promise)
    #             promise.reset(new std::promise<void>);
    #         future = promise->get_future();
    #         return TRUE;
    #     } catch (const std::future_error& e) {
    #         (void)e;
    #         PIVDEBUG("S", CVolString(e.what()).GetText());
    #         return FALSE;
    #     }
    # }
    # <> </include>
    # @end
}

类 承诺整数类 <公开 基础类 = 承诺对象模板类 注释 = "提供一个承诺,表示在某个时间点一定会有一个值或一个异常被设置." @文档 = "category = \"多线程.辅助类.承诺对象\""
        @模板实现类 = "整数">

类 承诺长整数类 <公开 基础类 = 承诺对象模板类 注释 = "提供一个承诺,表示在某个时间点一定会有一个值或一个异常被设置." @文档 = "category = \"多线程.辅助类.承诺对象\""
        @模板实现类 = "长整数">

类 承诺小数类 <公开 基础类 = 承诺对象模板类 注释 = "提供一个承诺,表示在某个时间点一定会有一个值或一个异常被设置." @文档 = "category = \"多线程.辅助类.承诺对象\""
        @模板实现类 = "小数">

类 承诺逻辑类 <公开 基础类 = 承诺对象模板类 注释 = "提供一个承诺,表示在某个时间点一定会有一个值或一个异常被设置." @文档 = "category = \"多线程.辅助类.承诺对象\""
        @模板实现类 = "逻辑型">

类 承诺文本类 <公开 基础类 = 承诺对象模板类 注释 = "提供一个承诺,表示在某个时间点一定会有一个值或一个异常被设置." @文档 = "category = \"多线程.辅助类.承诺对象\""
        @模板实现类 = "文本型">

类 承诺字节集类 <公开 基础类 = 承诺对象模板类 注释 = "提供一个承诺,表示在某个时间点一定会有一个值或一个异常被设置." @文档 = "category = \"多线程.辅助类.承诺对象\""
        @模板实现类 = "字节集类">

类 承诺对象包装类 <公开 基础类 = 承诺对象模板类 注释 = "提供一个承诺,表示在某个时间点一定会有一个值或一个异常被设置." @文档 = "category = \"多线程.辅助类.承诺对象\""
        @模板实现类 = "对象包装类">

# 过时 ===

类 线程池类 <公开 注释 = "功能强、效率快、高稳定、无内存和句柄泄漏的线程池." 注释 = "  1. 使用高效的ICOP异步模型,队列式执行线程任务;"
        注释 = "  2. 使用Windows API的线程函数,兼容性良好;" 注释 = "  3. 线程的回调函数在\"接收事件\"中执行,可以调用类的动态成员;"
        注释 = "  4. 耗时和死循环的线程必须退出,否则窗口关掉了还在跑;" 折叠 @文档 = "category = \"多线程\"" @视窗.外部头文件 = "src\\piv_thread.hpp"
        @视窗.后缀文本 = "public PivThreadPool">
{
    方法 启动线程 <公开 类型 = 逻辑型 注释 = "  启动一个线程,请在接收事件\"对象任务回调\"中编写回调方法." 注释 = "  本方法不归线程池管理,可独立使用,线程句柄在执行完毕后自动关闭,"
            注释 = "因此每次启动都是一个新线程." 返回值注释 = "成功返回真,失败返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户对象 <类型 = 对象类 注释 = "使用自定义的对象类,可以传递使用任意数量和类型的参数给线程池." 注释 = "将创建用户对象的副本,因此可以直接使用局部变量." @默认值 = 空对象>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    参数 是否等待线程执行完毕 <类型 = 逻辑型 注释 = "指定本方法是否一直等待线程执行完毕后才会返回" @默认值 = 假>
    参数 初始堆栈大小 <类型 = 整数 注释 = "线程的堆栈初始大小,单位字节." 注释 = "应为内存页大小(一般为4096)的倍数,最小2页,系统会向上舍入到最近的值."
            注释 = "为0表示使用默认堆栈保留尺寸(1MB)." @默认值 = 0>
    参数 优先级 <类型 = 线程优先级 注释 = "提供线程的优先级别" @默认值 = 线程优先级.通常>
    {
        @ return StartThread(this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadObjWorkerProc), @<用户标记>,
        @     @<用户对象>, @<用户数据>, @<是否等待线程执行完毕>, @<初始堆栈大小>, static_cast<INT>(@<优先级>));
    }

    方法 创建 <公开 类型 = 逻辑型 注释 = "创建线程池,必须成功创建后才能使用其他方法." 返回值注释 = "返回是否创建成功,重复创建亦返回真." 折叠 @嵌入式方法 = "">
    参数 线程数量 <类型 = 整数 注释 = "最大同时工作的线程数量,小于等于0为(CPU逻辑核心数 + 1)."
            注释 = "  - I/O密集型建议: CPU核数 * (1 + (I/O耗时 / CPU耗时))" 注释 = "  - 计算密集型建议: CPU核数 + 1" @默认值 = 0>
    参数 初始堆栈大小 <类型 = 整数 注释 = "线程的堆栈初始大小,单位字节." 注释 = "应为内存页大小(一般为4096)的倍数,最小2页,系统会向上舍入到最近的值."
            注释 = "为0表示使用默认堆栈保留尺寸(1MB)." @默认值 = 0>
    参数 优先级 <类型 = 线程优先级 注释 = "提供线程的优先级别." @默认值 = 线程优先级.通常>
    参数 是否初始化COM <类型 = 逻辑型 注释 = "  是否在线程池内部自动执行COM初始化和清理." 注释 = "  多线程中使用COM对象必须执行COM初始化,由于本线程池是一个线程队列执行"
            注释 = "多个任务,不太适合在\"任务回调/对象任务回调\"事件中进行初始化.如果你需要" 注释 = "使用COM对象,请将本参数设置为\"真\"." @默认值 = 假>
    {
        @ @sn<this>.CreateThreadPool(@<线程数量>, @<初始堆栈大小>, static_cast<INT>(@<优先级>), @<是否初始化COM>)
    }

    方法 销毁 <公开 类型 = 逻辑型 注释 = "销毁线程池,释放线程池占用的所有资源." 注释 = "  1. 销毁线程池不会强制结束仍在运行的线程,请在线程的耗时或"
            注释 = "死循环中调用本对象的方法\"是否需要退出\",一旦发现该方法返回真," 注释 = "必须尽快结束\"任务回调\"/\"对象任务回调\"事件的执行."
            注释 = "  2. 类清理时会自动销毁,如果线程池实例定义在窗口的成员变量中," 注释 = "必须在窗口即将销毁时执行销毁线程池." 返回值注释 = "成功或已经销毁返回真,失败返回假."
            返回值注释 = "失败原因包括: 线程池正在创建或正在销毁." 折叠 @嵌入式方法 = "">
    参数 是否强制销毁 <类型 = 逻辑型 注释 = "假=正常销毁,等待任务执行完毕后返回;" 注释 = "真=强制销毁,不等待执行中的任务,清空后续的队列任务后立即返回." @默认值 = 假>
    参数 最长等待时间 <类型 = 整数 注释 = "此参数只对非强制销毁有效,单位为毫秒." 注释 = "-1为一直等待所有任务完成,否则到了超时时间会清空任务并返回." @默认值 = -1>
    {
        @ @sn<this>.DestroyThreadPool(@<是否强制销毁>, @<最长等待时间>)
    }

    方法 暂停 <公开 类型 = 逻辑型 注释 = "停止执行新的任务,当前正在执行的任务不会被暂停." 返回值注释 = "返回是否暂停成功,线程池的不在工作状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.SuspendThreadPool()
    }

    方法 继续 <公开 类型 = 逻辑型 注释 = "继续执行线程池任务" 返回值注释 = "返回是否继续成功,线程池的不在暂停状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ResumeThreadPool()
    }

    方法 投递任务 <公开 类型 = 逻辑型 注释 = "投递线程任务到线程池中,投递后请在接收事件\"任务回调\"中编写线程方法." 注释 = "本方法只支持基本数值参数."
            返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户参数 <类型 = 长整数 @默认值 = 0>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    {
        @ return PostParamTask(this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadPoolWorkerProc),
        @     @<用户标记>, @<用户参数>, @<用户数据>);
    }

    方法 投递对象 <公开 类型 = 逻辑型 注释 = "  投递线程任务到线程池中,投递后请在接收事件\"对象任务回调\"中编写线程方法." 注释 = "本方法支持传递自定义对象类型,但请注意以下几点:"
            注释 = "  1. 会将投递的用户对象复制一份副本,副本的生命周期到回调任务结束后为止," 注释 = "因此可以直接投递局部变量."
            注释 = "  2. 用户对象经过复制,已经不等于原来的对象实例(指针值不一样)." 返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户对象 <类型 = 对象类 注释 = "使用自定义的对象类,可以传递使用任意数量和类型的参数给线程池." 注释 = "将创建用户对象的副本,因此可以直接使用局部变量." @默认值 = 空对象>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    {
        @ return PostObjectTask(this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadPoolObjWorkerProc),
        @     @<用户标记>, @<用户对象>, @<用户数据>);
    }

    方法 清空任务 <公开 类型 = 逻辑型 注释 = "清空已投递的队列任务,将队列任务占用的内存释放." 返回值注释 = "返回是否开始清空任务,线程池不在正常工作和暂停状态时始终返回假." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ClearTask()
    }

    方法 任务回调 <公开 定义事件 类型 = 整数 注释 = "线程池\"投递任务\"的回调函数,请在本事件内写线程方法." 返回值注释 = "返回值无意义" 折叠>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途.">
    参数 用户参数 <类型 = 长整数>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针且以后不再使用的话,建议在本事件结束前释放掉,以避免内存泄漏.">

    方法 对象任务回调 <公开 定义事件 类型 = 整数 注释 = "  线程池\"投递对象\"的回调函数,请在本事件内写线程方法." 注释 = "传入的用户对象会在本次任务结束后自动释放."
            返回值注释 = "返回值无意义" 折叠>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途.">
    参数 用户对象 <类型 = 对象类 注释 = "  用户投递的自定义对象,请自行强制到原来的对象类型再使用,如:" 注释 = "  1. 对象变量 = (自定义对象)用户对象"
            注释 = "  2. ((自定义对象)用户对象).成员" 注释 = "  方法1会将用户对象强制转换类型后复制到新变量,这会略增加内存的占用;"
            注释 = "  方法2不会创建新的对象实例,但写起来比较麻烦.">
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针且以后不再使用的话,建议在本事件结束前释放掉,以避免内存泄漏.">

    方法 是否需要退出 <公开 类型 = 逻辑型 注释 = "检查线程任务是否需要尽快退出." 注释 = "  1. 本方法只能在本对象\"任务回调\"/\"对象任务回调\"事件中执行"
            注释 = "  2. 本方法返回真则表示正在销毁线程池,必须尽快结束线程任务;" 注释 = "  3. 如果线程未及时结束,则线程池乃至程序可能要等线程执行完毕"
            注释 = "才会彻底结束,如果线程内有死循环,可能将永远不会自己结束;" 返回值注释 = "返回线程是否需要尽快退出." 折叠 @嵌入式方法 = "">
    参数 最大检查等待时间 <类型 = 整数 注释 = "指定检查线程池销毁通知(由\"销毁\"方法发出)的最大等待时间," 注释 = "单位为毫秒,为0表示不等待,为-1表示一直等待." @默认值 = 0>
    {
        @ @sn<this>.IsNeedExit(@<最大检查等待时间>)
    }

    方法 调整线程池 <公开 类型 = 逻辑型 注释 = "动态调整线程池的容量(同时工作线程数量)." 注释 = "若新线程数量比原来大,会立即改变工作线程数量;"
            注释 = "若新线程数量比原来小,则需要等之前投递的任务全部完成,才会改变工作线程数量;" 返回值注释 = "返回是否成功调整线程池容量,线程池未创建、正在销毁或正在调整线程池时返回假." 折叠
            @嵌入式方法 = "">
    参数 新线程数量 <类型 = 整数 注释 = "最大同时工作的线程数量,小于等于0为(CPU核心数 + 1)." @默认值 = 0>
    {
        @ @sn<this>.SetThreadPoolCapacity(@<新线程数量>)
    }

    方法 CPU核心数 <公开 属性读 类型 = 整数 注释 = "获取CPU的逻辑核心数量(如支持超线程的16核CPU,返回32)." 返回值注释 = "成功返回CPU逻辑核心数,失败时始终返回1." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.GetProcessorsCount()
    }

    方法 现行线程数 <公开 属性读 类型 = 整数 注释 = "获取线程池当前的工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCount()
    }

    方法 线程池容量 <公开 属性读 类型 = 整数 注释 = "获取线程池的最大工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCapacity()
    }

    方法 执行任务数 <公开 属性读 类型 = 整数 注释 = "获取正在执行的任务数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetWorkerTaskCount()
    }

    方法 队列任务数 <公开 属性读 类型 = 长整数 注释 = "获取等待处理的任务数量" 返回值注释 = "超过无符号整数最大值(4294967295)后从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetQueueTaskCount()
    }

    方法 已完成任务数 <公开 属性读 类型 = 长整数 注释 = "获取已完成的任务数量" 返回值注释 = "超过无符号整数最大值(4294967295)后从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetComplateTaskCount()
    }

    方法 空闲线程数 <公开 属性读 类型 = 整数 注释 = "获取空闲的线程数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetFreeThreadsCount()
    }

    方法 工作状态 <公开 属性读 类型 = 整数 注释 = "获取线程池的工作状态" 返回值注释 = "0=未启动;1=正在销毁;2=正在创建;3=正在工作;4=调整线程池;5=暂停中;6=正在清空任务"
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadPoolState()
    }

    方法 是否空闲 <公开 属性读 类型 = 逻辑型 注释 = "判断线程池是否处于彻底空闲状态,没有任何任务在执行." 返回值注释 = "真为空闲,假为繁忙,线程池未创建也返回真." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ThreadPoolIsFree()
    }

    # ---
    # @begin
    # <> <include>
    # static INT CALLBACK ThreadPoolWorkerProc(@sn<current_class>* pThis, @sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     return pThis->@<任务回调>(lpThreadParam->nUserMark, lpThreadParam->lUserParam, lpThreadParam->lpUserData);
    # }
    # static INT CALLBACK ThreadPoolObjWorkerProc(@sn<current_class>* pThis, @sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     return pThis->@<对象任务回调>(lpThreadParam->nUserMark, *lpThreadParam->lpUserObj, lpThreadParam->lpUserData);
    # }
    # static INT CALLBACK ThreadObjWorkerProc(@sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     ((@sn<current_class>*)lpThreadParam->lpThis)->@<对象任务回调> (lpThreadParam->nUserMark, *lpThreadParam->lpUserObj, lpThreadParam->lpUserData);
    #     delete lpThreadParam;
    #     return 0;
    # }
    # <> </include>
    # @end
    # ---
}

类 线程池类EX <公开 注释 = "带动态调整线程池容量,功能强、效率快、高稳定、无内存和句柄泄漏的线程池." 注释 = "  1. 使用高效的ICOP异步模型,队列式执行线程任务;"
        注释 = "  2. 使用Windows API的线程函数,兼容性良好;" 注释 = "  3. 线程的回调函数在\"接收事件\"中执行,可以调用类的动态成员;"
        注释 = "  4. 耗时和死循环的线程必须退出,否则窗口关掉了还在跑;" 注释 = "  5. 支持按需调节线程池的执行线程数;" 折叠 @文档 = "category = \"多线程\""
        @视窗.外部头文件 = "src\\piv_thread.hpp" @视窗.后缀文本 = "public PivThreadPoolEx">
{
    方法 启动线程 <公开 类型 = 逻辑型 注释 = "  启动一个线程,请在接收事件\"对象任务回调\"中编写回调方法." 注释 = "  本方法不归线程池管理,可独立使用,线程句柄在执行完毕后自动关闭,"
            注释 = "因此每次启动都是一个新线程." 返回值注释 = "成功返回真,失败返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户对象 <类型 = 对象类 注释 = "使用自定义的对象类,可以传递使用任意数量和类型的参数给线程池." 注释 = "将创建用户对象的副本,因此可以直接使用局部变量." @默认值 = 空对象>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    参数 是否等待线程执行完毕 <类型 = 逻辑型 注释 = "指定本方法是否一直等待线程执行完毕后才会返回" @默认值 = 假>
    参数 初始堆栈大小 <类型 = 整数 注释 = "线程的堆栈初始大小,单位字节." 注释 = "应为内存页大小(一般为4096)的倍数,最小2页,系统会向上舍入到最近的值."
            注释 = "为0表示使用默认堆栈保留尺寸(1MB)." @默认值 = 0>
    参数 优先级 <类型 = 线程优先级 注释 = "提供线程的优先级别" @默认值 = 线程优先级.通常>
    {
        @ return StartThread(this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadObjWorkerProc), @<用户标记>,
        @     @<用户对象>, @<用户数据>, @<是否等待线程执行完毕>, @<初始堆栈大小>, static_cast<INT>(@<优先级>));
    }

    方法 创建 <公开 类型 = 逻辑型 注释 = "创建线程池,必须成功创建后才能使用其他方法." 返回值注释 = "返回是否创建成功,重复创建亦返回真." 折叠 @嵌入式方法 = "">
    参数 最小线程数 <类型 = 整数 注释 = "最小同时工作的线程数,默认为5,不得小于1." @默认值 = 5>
    参数 最大线程数 <类型 = 整数 注释 = "最大同时工作的线程数量,默认为20.小于等于0为(CPU逻辑核心数 + 1)." 注释 = "无论如何,最终值会自动调整为大于等于(最小线程数+2)."
            @默认值 = 20>
    参数 动态线程周期 <类型 = 整数 注释 = "动态线程的检测周期时间,单位毫秒.默认为5000ms(5秒),最低100ms."
            注释 = "一个周期时间后,如果队列任务过多将动态增加工作线程,直到达到最大线程数." 注释 = "如果任务过少则自动回收动态线程." @默认值 = 5000>
    参数 初始堆栈大小 <类型 = 整数 注释 = "线程的堆栈初始大小,单位字节." 注释 = "应为内存页大小(一般为4096)的倍数,最小2页,系统会向上舍入到最近的值."
            注释 = "为0表示使用默认堆栈保留尺寸(1MB)." @默认值 = 0>
    参数 优先级 <类型 = 线程优先级 注释 = "提供线程的优先级别." @默认值 = 线程优先级.通常>
    参数 是否初始化COM <类型 = 逻辑型 注释 = "  是否在线程池内部自动执行COM初始化和清理." 注释 = "  多线程中使用COM对象必须执行COM初始化,由于本线程池是一个线程队列执行"
            注释 = "多个任务,不太适合在\"任务回调/对象任务回调\"事件中进行初始化.如果你需要" 注释 = "使用COM对象,请将本参数设置为\"真\"." @默认值 = 假>
    {
        @ @sn<this>.CreateThreadPool(@<最小线程数>, @<最大线程数>, @<动态线程周期>, @<初始堆栈大小>, static_cast<INT>(@<优先级>), @<是否初始化COM>)
    }

    方法 销毁 <公开 类型 = 逻辑型 注释 = "销毁线程池,释放线程池占用的所有资源." 注释 = "  1. 销毁线程池不会强制结束仍在运行的线程,请在线程的耗时或"
            注释 = "死循环中调用本对象的方法\"是否需要退出\",一旦发现该方法返回真," 注释 = "必须尽快结束\"任务回调\"/\"对象任务回调\"事件的执行."
            注释 = "  2. 类清理时会自动销毁,如果线程池实例定义在窗口的成员变量中," 注释 = "必须在窗口即将销毁时执行销毁线程池." 返回值注释 = "成功或已经销毁返回真,失败返回假."
            返回值注释 = "失败原因包括: 线程池正在创建或正在销毁." 折叠 @嵌入式方法 = "">
    参数 是否强制销毁 <类型 = 逻辑型 注释 = "假=正常销毁,等待任务执行完毕后返回;" 注释 = "真=强制销毁,不等待执行中的任务,清空后续的队列任务后立即返回." @默认值 = 假>
    参数 最长等待时间 <类型 = 整数 注释 = "此参数只对非强制销毁有效,单位为毫秒." 注释 = "-1为一直等待所有任务完成,否则到了超时时间会清空任务并返回." @默认值 = -1>
    {
        @ @sn<this>.DestroyThreadPool(@<是否强制销毁>, @<最长等待时间>)
    }

    方法 暂停 <公开 类型 = 逻辑型 注释 = "停止执行新的任务,当前正在执行的任务不会被暂停." 返回值注释 = "返回是否暂停成功,线程池的不在工作状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.SuspendThreadPool()
    }

    方法 继续 <公开 类型 = 逻辑型 注释 = "继续执行线程池任务" 返回值注释 = "返回是否继续成功,线程池的不在暂停状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ResumeThreadPool()
    }

    方法 投递任务 <公开 类型 = 逻辑型 注释 = "投递线程任务到线程池中,投递后请在接收事件\"任务回调\"中编写线程方法." 注释 = "本方法只支持基本数值参数."
            返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户参数 <类型 = 长整数 @默认值 = 0>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    {
        @ return PostParamTask(this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadPoolWorkerProc),
        @     @<用户标记>, @<用户参数>, @<用户数据>);
    }

    方法 投递对象 <公开 类型 = 逻辑型 注释 = "  投递线程任务到线程池中,投递后请在接收事件\"对象任务回调\"中编写线程方法." 注释 = "本方法支持传递自定义对象类型,但请注意以下几点:"
            注释 = "  1. 会将投递的用户对象复制一份副本,副本的生命周期到回调任务结束后为止," 注释 = "因此可以直接投递局部变量."
            注释 = "  2. 用户对象经过复制,已经不等于原来的对象实例(指针值不一样)." 返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户对象 <类型 = 对象类 注释 = "使用自定义的对象类,可以传递使用任意数量和类型的参数给线程池." 注释 = "将创建用户对象的副本,因此可以直接使用局部变量." @默认值 = 空对象>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    {
        @ return PostObjectTask(this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadPoolObjWorkerProc),
        @     @<用户标记>, @<用户对象>, @<用户数据>);
    }

    方法 清空任务 <公开 类型 = 逻辑型 注释 = "清空已投递的队列任务,将队列任务占用的内存释放." 返回值注释 = "返回是否开始清空任务,线程池不在正常工作和暂停状态时始终返回假." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ClearTask()
    }

    方法 任务回调 <公开 定义事件 类型 = 整数 注释 = "线程池\"投递任务\"的回调函数,请在本事件内写线程方法." 返回值注释 = "返回值无意义" 折叠>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途.">
    参数 用户参数 <类型 = 长整数>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针且以后不再使用的话,建议在本事件结束前释放掉,以避免内存泄漏.">

    方法 对象任务回调 <公开 定义事件 类型 = 整数 注释 = "  线程池\"投递对象\"的回调函数,请在本事件内写线程方法." 注释 = "传入的用户对象会在本次任务结束后自动释放."
            返回值注释 = "返回值无意义" 折叠>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途.">
    参数 用户对象 <类型 = 对象类 注释 = "  用户投递的自定义对象,请自行强制到原来的对象类型再使用,如:" 注释 = "  1. 对象变量 = (自定义对象)用户对象"
            注释 = "  2. ((自定义对象)用户对象).成员" 注释 = "  方法1会将用户对象强制转换类型后复制到新变量,这会略增加内存的占用;"
            注释 = "  方法2不会创建新的对象实例,但写起来比较麻烦.">
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针且以后不再使用的话,建议在本事件结束前释放掉,以避免内存泄漏.">

    方法 是否需要退出 <公开 类型 = 逻辑型 注释 = "检查线程任务是否需要尽快退出." 注释 = "  1. 本方法只能在本对象\"任务回调\"/\"对象任务回调\"事件中执行"
            注释 = "  2. 本方法返回真则表示正在销毁线程池,必须尽快结束线程任务;" 注释 = "  3. 如果线程未及时结束,则线程池乃至程序可能要等线程执行完毕"
            注释 = "才会彻底结束,如果线程内有死循环,可能将永远不会自己结束;" 返回值注释 = "返回线程是否需要尽快退出." 折叠 @嵌入式方法 = "">
    参数 最大检查等待时间 <类型 = 整数 注释 = "指定检查线程池销毁通知(由\"销毁\"方法发出)的最大等待时间," 注释 = "单位为毫秒,为0表示不等待,为-1表示一直等待." @默认值 = 0>
    {
        @ @sn<this>.IsNeedExit(@<最大检查等待时间>)
    }

    方法 调整线程池 <公开 类型 = 逻辑型 注释 = "动态调整线程池的容量(同时工作线程数量)." 注释 = "若新线程数量比原来大,会立即改变工作线程数量;"
            注释 = "若新线程数量比原来小,则需要等之前投递的任务全部完成,才会改变工作线程数量;" 返回值注释 = "返回是否成功调整线程池容量,线程池未创建、正在销毁或正在调整线程池时返回假." 折叠
            @嵌入式方法 = "">
    参数 新线程数量 <类型 = 整数 注释 = "最大同时工作的线程数量,小于等于0为(CPU核心数 + 1)." @默认值 = 0>
    {
        @ @sn<this>.SetThreadPoolCapacity(@<新线程数量>)
    }

    方法 CPU核心数 <公开 属性读 类型 = 整数 注释 = "获取CPU的逻辑核心数量(如支持超线程的16核CPU,返回32)." 返回值注释 = "成功返回CPU逻辑核心数,失败时始终返回1." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.GetProcessorsCount()
    }

    方法 现行线程数 <公开 属性读 类型 = 整数 注释 = "获取线程池当前的工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCount()
    }

    方法 线程池容量 <公开 属性读 类型 = 整数 注释 = "获取线程池的最大工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCapacity()
    }

    方法 执行任务数 <公开 属性读 类型 = 整数 注释 = "获取正在执行的任务数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetWorkerTaskCount()
    }

    方法 队列任务数 <公开 属性读 类型 = 长整数 注释 = "获取等待处理的任务数量" 返回值注释 = "超过无符号整数最大值(4294967295)后从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetQueueTaskCount()
    }

    方法 已完成任务数 <公开 属性读 类型 = 长整数 注释 = "获取已完成的任务数量" 返回值注释 = "超过无符号整数最大值(4294967295)后从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetComplateTaskCount()
    }

    方法 空闲线程数 <公开 属性读 类型 = 整数 注释 = "获取空闲的线程数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetFreeThreadsCount()
    }

    方法 工作状态 <公开 属性读 类型 = 整数 注释 = "获取线程池的工作状态" 返回值注释 = "0=未启动;1=正在销毁;2=正在创建;3=正在工作;4=调整线程池;5=暂停中;6=正在清空任务"
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadPoolState()
    }

    方法 是否空闲 <公开 属性读 类型 = 逻辑型 注释 = "判断线程池是否处于彻底空闲状态,没有任何任务在执行." 返回值注释 = "真为空闲,假为繁忙,线程池未创建也返回真." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ThreadPoolIsFree()
    }

    方法 动态线程周期 <公开 属性读 类型 = 整数 注释 = "获取动态调整线程的检测周期(单位毫秒)." 注释 = "一个周期时间后,如果队列任务过多将动态增加工作线程,直到达到最大线程数."
            注释 = "如果任务过少则自动回收动态线程." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetCycleMs()
    }

    方法 动态线程周期 <公开 属性写 注释 = "设置动态调整线程的检测周期." 注释 = "一个周期时间后,如果队列任务过多将动态增加工作线程,直到达到最大线程数."
            注释 = "如果任务过少则自动回收动态线程." 折叠>
    参数 新的周期 <类型 = 整数 注释 = "动态线程的检测周期时间,单位毫秒,最低100ms.">
    {
        @ @sn<current_class_def>::SetCycleMs(@<新的周期>);
    }

    # ---
    # @begin
    # <> <include>
    # static INT CALLBACK ThreadPoolWorkerProc(@sn<current_class>* pThis, @sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     return pThis->@<任务回调>(lpThreadParam->nUserMark, lpThreadParam->lUserParam, lpThreadParam->lpUserData);
    # }
    # static INT CALLBACK ThreadPoolObjWorkerProc(@sn<current_class>* pThis, @sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     return pThis->@<对象任务回调>(lpThreadParam->nUserMark, *lpThreadParam->lpUserObj, lpThreadParam->lpUserData);
    # }
    # static INT CALLBACK ThreadObjWorkerProc (@sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     ((@sn<current_class>*)lpThreadParam->lpThis)->@<对象任务回调> (lpThreadParam->nUserMark, *lpThreadParam->lpUserObj, lpThreadParam->lpUserData);
    #     delete lpThreadParam;
    #     return 0;
    # }
    # <> </include>
    # @end
    # ---
}

# 无锁队列模板 ====

类 无锁队列模板类 <公开 基础类 = PIV对象类 注释 = "支持多线程并发的多生产者、多消费者无锁队列." 注释 = " 1. 除非特别声明,本类的方法默认为线程安全;"
        注释 = " 2. 对象采用共享智能指针封装,拷贝赋值后仍指向同一队列数据;" 注释 = " 3. 默认初始分配1024个成员数的内存,若要重定义初始容量,请用\"重置队列\";"
        注释 = " 4. 出队不会释放内存,这意味着队列的内存占用只增不减;" 折叠 @文档 = "category = \"数据处理.队列.模板类\""
        @视窗.外部头文件 = "<user/piv/src/detail/concurrentqueue.h>" @模板基础类 = 真>
{
    方法 入队 <公开 类型 = 逻辑型 注释 = "在当前队列的尾部添加指定成员,返回是否成功." 注释 = "本方法将按需分配内存,仅在分配内存失败时返回假." 折叠 @嵌入式方法 = "">
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的成员">
    {
        @ @sn<this>.data().enqueue(@<值>)
    }

    方法 入队EX <公开 类型 = 逻辑型 注释 = "在当前队列的尾部添加指定成员,返回是否成功." 注释 = "本方法将按需分配内存,仅在分配内存失败时返回假." 折叠 @嵌入式方法 = "">
    参数 生产者令牌 <类型 = 生产者队列令牌 注释 = "提供由\"创建生产者令牌\"返回的令牌,使用令牌可以提升入队的速度.">
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的成员">
    {
        @ @sn<this>.data().enqueue(*@<生产者令牌>, @<值>)
    }

    方法 尝试入队 <公开 类型 = 逻辑型 注释 = "尝试在当前队列的尾部添加指定成员,返回是否成功." 注释 = "本方法不会重分配内存,没有可用空间将返回失败." 折叠 @嵌入式方法 = "">
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的成员">
    {
        @ @sn<this>.data().try_enqueue(@<值>)
    }

    方法 尝试入队EX <公开 类型 = 逻辑型 注释 = "尝试在当前队列的尾部添加指定成员,返回是否成功." 注释 = "本方法不会重分配内存,没有可用空间将返回失败." 折叠 @嵌入式方法 = "">
    参数 生产者令牌 <类型 = 生产者队列令牌 注释 = "提供由\"创建生产者令牌\"返回的令牌,使用令牌可以提升入队的速度.">
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的成员">
    {
        @ @sn<this>.data().try_enqueue(*@<生产者令牌>, @<值>)
    }

    方法 批量入队 <公开 类型 = 逻辑型 注释 = "在当前队列的尾部添加指定数量的多个成员,返回是否成功." 注释 = "本方法将按需分配内存,仅在分配内存失败时返回假." 折叠 @嵌入式方法 = "">
    参数 首成员 <类型 = 模板类型1 注释 = "提供所欲批量添加的首成员变量;" 注释 = "所欲批量入队的多个成员必须是连续内存中的数据." @需求类型 = 可写入变量>
    参数 入队数量 <类型 = 整数 注释 = "所欲添加的成员数量">
    {
        @ @sn<this>.data().enqueue_bulk(&@<首成员>, static_cast<size_t>(@<入队数量>))
    }

    方法 批量入队EX <公开 类型 = 逻辑型 注释 = "在当前队列的尾部添加指定数量的多个成员,返回是否成功." 注释 = "本方法将按需分配内存,仅在分配内存失败时返回假." 折叠
            @嵌入式方法 = "">
    参数 生产者令牌 <类型 = 生产者队列令牌 注释 = "提供由\"创建生产者令牌\"返回的令牌,使用令牌可以提升入队的速度.">
    参数 首成员 <类型 = 模板类型1 注释 = "提供所欲批量添加的首成员变量;" 注释 = "所欲批量入队的多个成员必须是连续内存中的数据." @需求类型 = 可写入变量>
    参数 入队数量 <类型 = 整数 注释 = "所欲添加的成员数量">
    {
        @ @sn<this>.data().enqueue_bulk(*@<生产者令牌>, &@<首成员>, static_cast<size_t>(@<入队数量>))
    }

    方法 尝试批量入队 <公开 类型 = 逻辑型 注释 = "尝试在当前队列的尾部添加指定数量的成员,返回是否成功." 注释 = "本方法不会重分配内存,没有可用空间将返回失败." 折叠 @嵌入式方法 = "">
    参数 首成员 <类型 = 模板类型1 注释 = "提供所欲批量添加的首成员变量;" 注释 = "所欲批量入队的多个成员必须是连续内存中的数据." @需求类型 = 可写入变量>
    参数 入队数量 <类型 = 整数 注释 = "所欲添加的成员数量">
    {
        @ @sn<this>.data().try_enqueue_bulk(&@<首成员>, static_cast<size_t>(@<入队数量>))
    }

    方法 尝试批量入队EX <公开 类型 = 逻辑型 注释 = "尝试在当前队列的尾部添加指定数量的成员,返回是否成功." 注释 = "本方法不会重分配内存,没有可用空间将返回失败." 折叠
            @嵌入式方法 = "">
    参数 生产者令牌 <类型 = 生产者队列令牌 注释 = "提供由\"创建生产者令牌\"返回的令牌,使用令牌可以提升入队的速度.">
    参数 首成员 <类型 = 模板类型1 注释 = "提供所欲批量添加的首成员变量;" 注释 = "所欲批量入队的多个成员必须是连续内存中的数据." @需求类型 = 可写入变量>
    参数 入队数量 <类型 = 整数 注释 = "所欲添加的成员数量">
    {
        @ @sn<this>.data().try_enqueue_bulk(*@<生产者令牌>, &@<首成员>, static_cast<size_t>(@<入队数量>))
    }

    # ---

    方法 出队 <公开 类型 = 逻辑型 注释 = "获取并删除队列的第一个成员,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 弹出值 <类型 = 模板类型1 注释 = "提供用来获取所弹出成员的变量" @需求类型 = 可写入变量>
    {
        @ @sn<this>.data().try_dequeue(@<弹出值>)
    }

    方法 出队EX <公开 类型 = 逻辑型 注释 = "获取并删除队列的第一个成员,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 消费者令牌 <类型 = 消费者队列令牌 注释 = "提供由\"创建消费者令牌\"返回的令牌,使用令牌可以提升出队的速度.">
    参数 弹出值 <类型 = 模板类型1 注释 = "提供用来获取所弹出成员的变量" @需求类型 = 可写入变量>
    {
        @ @sn<this>.data().try_dequeue(*@<消费者令牌>, @<弹出值>)
    }

    方法 批量出队 <公开 类型 = 逻辑型 注释 = "获取并删除队列中指定数量的成员,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 首成员 <类型 = 模板类型1 注释 = "提供用于获取批量出队数据的,连续内存数据的首成员变量.." @需求类型 = 可写入变量>
    参数 出队数量 <类型 = 整数 注释 = "所欲出队的成员数量">
    {
        @ @sn<this>.data().try_dequeue_bulk(&@<首成员>, static_cast<size_t>(@<出队数量>))
    }

    方法 批量出队EX <公开 类型 = 逻辑型 注释 = "获取并删除队列中指定数量的成员,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 消费者令牌 <类型 = 消费者队列令牌 注释 = "提供由\"创建消费者令牌\"返回的令牌,使用令牌可以提升出队的速度.">
    参数 首成员 <类型 = 模板类型1 注释 = "提供用于获取批量出队数据的,连续内存数据的首成员变量.." @需求类型 = 可写入变量>
    参数 出队数量 <类型 = 整数 注释 = "所欲出队的成员数量">
    {
        @ @sn<this>.data().try_dequeue_bulk(*@<消费者令牌>, &@<首成员>, static_cast<size_t>(@<出队数量>))
    }

    # ---

    方法 重置队列 <公开 注释 = "释放当前队列并创建一个新队列." 注释 = "本方法非线程安全." 折叠 @嵌入式方法 = "">
    参数 初始容量 <类型 = 整数 注释 = "队列创建时分配对应成员数的内存" @默认值 = 1024>
    {
        @ @sn<this>.init(static_cast<size_t>(@<初始容量>))
    }

    方法 取成员数 <公开 类型 = 整数 注释 = "返回本队列中已有成员的数目." 注释 = "注意: 返回的是一个估计值,只有队列未在执行入队和出队操作时,返回的数值才准确." 折叠
            @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data().size_approx()
    }

    方法 交换 <公开 注释 = "交换两个队列中的数据,本方法非线程安全." 折叠 @嵌入式方法 = "">
    参数 所欲交换的队列 <类型 = 无锁队列模板类>
    {
        @ @sn<this>.data().swap(@<所欲交换的队列>.data())
    }

    方法 创建生产者令牌 <公开 类型 = 生产者队列令牌 注释 = "创建一个仅在当前线程中使用的生产者令牌,用于入队的EX版方法." 注释 = "使用令牌可以显著提升入队的速度." 折叠
            @嵌入式方法 = "">
    {
        @ @dt<生产者队列令牌>{new moodycamel::ProducerToken(@sn<this>.data())}
    }

    方法 创建消费者令牌 <公开 类型 = 消费者队列令牌 注释 = "创建一个仅在当前线程中使用的消费者令牌,用于出队的EX版方法." 注释 = "使用令牌可以显著提升出队的速度." 折叠
            @嵌入式方法 = "">
    {
        @ @dt<消费者队列令牌>{new moodycamel::ConsumerToken(@sn<this>.data())}
    }

    # @begin
    # <> <include>
    # using Item_t = std::remove_pointer<@dt<模板类型1> *>::type;
    # std::shared_ptr<moodycamel::ConcurrentQueue<Item_t>> m_queue;
    # inline void init(size_t capacity = 1024) { m_queue.reset(new moodycamel::ConcurrentQueue<Item_t>(capacity)); }
    # inline moodycamel::ConcurrentQueue<Item_t>& data() { return *m_queue; }
    # @sn<current_class> (@sn<current_class>&& rhs) { m_queue = std::move(rhs.m_queue); }
    # inline void @an<_OnInitExtra>() { if (!m_queue) { init(1024); } }
    # inline BOOL @an<_IsSelfEqualExtra>(const @sn<current_class>& objCompare) const { return (m_queue == objCompare.m_queue); }
    # inline void @an<_CopySelfFromExtra>(const @sn<current_class>& objCopyFrom) { m_queue = objCopyFrom.m_queue; }
    # inline @sn<current_class>& operator= (@sn<current_class>&& rhs) { m_queue = std::move(rhs.m_queue); return *this; }
    # <> </include>
    # @end
}

类 无锁阻塞队列模板类 <公开 基础类 = PIV对象类 注释 = "支持多线程并发的多生产者、多消费者无锁阻塞队列." 注释 = " 1. 除非特别声明,本类的方法默认为线程安全;"
        注释 = " 2. 对象采用共享智能指针封装,拷贝赋值后仍指向同一队列数据;" 注释 = " 3. 默认初始分配192个成员数的内存,若要重定义初始容量,请用\"重置队列\";"
        注释 = " 4. 出队不会释放内存,这意味着队列的内存占用只增不减;" 注释 = " 5. 在\"无锁队列\"的基础上增加了会阻塞当前线程的出队方法;" 折叠
        @文档 = "category = \"数据处理.队列.模板类\"" @视窗.外部头文件 = "<user/piv/src/detail/blockingconcurrentqueue.h>"
        @模板基础类 = 真>
{
    方法 入队 <公开 类型 = 逻辑型 注释 = "在当前队列的尾部添加指定成员,返回是否成功." 注释 = "本方法将按需分配内存,仅在分配内存失败时返回假." 折叠 @嵌入式方法 = "">
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的成员">
    {
        @ @sn<this>.data().enqueue(@<值>)
    }

    方法 入队EX <公开 类型 = 逻辑型 注释 = "在当前队列的尾部添加指定成员,返回是否成功." 注释 = "本方法将按需分配内存,仅在分配内存失败时返回假." 折叠 @嵌入式方法 = "">
    参数 生产者令牌 <类型 = 生产者队列令牌 注释 = "提供由\"创建生产者令牌\"返回的令牌,使用令牌可以提升入队的速度.">
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的成员">
    {
        @ @sn<this>.data().enqueue(*@<生产者令牌>, @<值>)
    }

    方法 尝试入队 <公开 类型 = 逻辑型 注释 = "尝试在当前队列的尾部添加指定成员,返回是否成功." 注释 = "本方法不会重分配内存,没有可用空间将返回失败." 折叠 @嵌入式方法 = "">
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的成员">
    {
        @ @sn<this>.data().try_enqueue(@<值>)
    }

    方法 尝试入队EX <公开 类型 = 逻辑型 注释 = "尝试在当前队列的尾部添加指定成员,返回是否成功." 注释 = "本方法不会重分配内存,没有可用空间将返回失败." 折叠 @嵌入式方法 = "">
    参数 生产者令牌 <类型 = 生产者队列令牌 注释 = "提供由\"创建生产者令牌\"返回的令牌,使用令牌可以提升入队的速度.">
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的成员">
    {
        @ @sn<this>.data().try_enqueue(*@<生产者令牌>, @<值>)
    }

    方法 批量入队 <公开 类型 = 逻辑型 注释 = "在当前队列的尾部添加指定数量的成员,返回是否成功." 注释 = "本方法将按需分配内存,仅在分配内存失败时返回假." 折叠 @嵌入式方法 = "">
    参数 首成员 <类型 = 模板类型1 注释 = "提供所欲批量添加的首成员变量;" 注释 = "所欲批量入队的多个成员必须是连续内存中的数据." @需求类型 = 可写入变量>
    参数 入队数量 <类型 = 整数 注释 = "所欲添加的成员数量">
    {
        @ @sn<this>.data().enqueue_bulk(&@<首成员>, static_cast<size_t>(@<入队数量>))
    }

    方法 批量入队EX <公开 类型 = 逻辑型 注释 = "在当前队列的尾部添加指定数量的成员,返回是否成功." 注释 = "本方法将按需分配内存,仅在分配内存失败时返回假." 折叠 @嵌入式方法 = "">
    参数 生产者令牌 <类型 = 生产者队列令牌 注释 = "提供由\"创建生产者令牌\"返回的令牌,使用令牌可以提升入队的速度.">
    参数 首成员 <类型 = 模板类型1 注释 = "提供所欲批量添加的首成员变量;" 注释 = "所欲批量入队的多个成员必须是连续内存中的数据." @需求类型 = 可写入变量>
    参数 入队数量 <类型 = 整数 注释 = "所欲添加的成员数量">
    {
        @ @sn<this>.data().enqueue_bulk(*@<生产者令牌>, &@<首成员>, static_cast<size_t>(@<入队数量>))
    }

    方法 尝试批量入队 <公开 类型 = 逻辑型 注释 = "尝试在当前队列的尾部添加指定数量的成员,返回是否成功." 注释 = "本方法不会重分配内存,没有可用空间将返回失败." 折叠 @嵌入式方法 = "">
    参数 首成员 <类型 = 模板类型1 注释 = "提供所欲批量添加的首成员变量;" 注释 = "所欲批量入队的多个成员必须是连续内存中的数据." @需求类型 = 可写入变量>
    参数 入队数量 <类型 = 整数 注释 = "所欲添加的成员数量">
    {
        @ @sn<this>.data().try_enqueue_bulk(&@<首成员>, static_cast<size_t>(@<入队数量>))
    }

    方法 尝试批量入队EX <公开 类型 = 逻辑型 注释 = "尝试在当前队列的尾部添加指定数量的多个成员,返回是否成功." 注释 = "本方法不会重分配内存,没有可用空间将返回失败." 折叠
            @嵌入式方法 = "">
    参数 生产者令牌 <类型 = 生产者队列令牌 注释 = "提供由\"创建生产者令牌\"返回的令牌,使用令牌可以提升入队的速度.">
    参数 首成员 <类型 = 模板类型1 注释 = "提供所欲批量添加的首成员变量;" 注释 = "所欲批量入队的多个成员必须是连续内存中的数据." @需求类型 = 可写入变量>
    参数 入队数量 <类型 = 整数 注释 = "所欲添加的成员数量">
    {
        @ @sn<this>.data().try_enqueue_bulk(*@<生产者令牌>, &@<首成员>, static_cast<size_t>(@<入队数量>))
    }

    # ---

    方法 出队 <公开 类型 = 逻辑型 注释 = "获取并删除队列的第一个成员,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 弹出值 <类型 = 模板类型1 注释 = "提供用来获取所弹出成员的变量" @需求类型 = 可写入变量>
    {
        @ @sn<this>.data().try_dequeue(@<弹出值>)
    }

    方法 出队EX <公开 类型 = 逻辑型 注释 = "获取并删除队列的第一个成员,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 消费者令牌 <类型 = 消费者队列令牌 注释 = "提供由\"创建消费者令牌\"返回的令牌,使用令牌可以提升出队的速度.">
    参数 弹出值 <类型 = 模板类型1 注释 = "提供用来获取所弹出成员的变量" @需求类型 = 可写入变量>
    {
        @ @sn<this>.data().try_dequeue(@<消费者令牌>, @<弹出值>)
    }

    方法 批量出队 <公开 类型 = 逻辑型 注释 = "获取并删除队列中指定数量的成员,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 首成员 <类型 = 模板类型1 注释 = "提供用于获取批量出队数据的,连续内存数据的首成员变量." @需求类型 = 可写入变量>
    参数 出队数量 <类型 = 整数 注释 = "所欲出队的成员数量">
    {
        @ @sn<this>.data().try_dequeue_bulk(&@<首成员>, static_cast<size_t>(@<出队数量>))
    }

    方法 批量出队EX <公开 类型 = 逻辑型 注释 = "获取并删除队列中指定数量的成员,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 消费者令牌 <类型 = 消费者队列令牌 注释 = "提供由\"创建消费者令牌\"返回的令牌,使用令牌可以提升出队的速度.">
    参数 首成员 <类型 = 模板类型1 注释 = "提供用于获取批量出队数据的,连续内存数据的首成员变量.." @需求类型 = 可写入变量>
    参数 出队数量 <类型 = 整数 注释 = "所欲出队的成员数量">
    {
        @ @sn<this>.data().try_dequeue_bulk(*@<消费者令牌>, &@<首成员>, static_cast<size_t>(@<出队数量>))
    }

    # ---

    方法 重置队列 <公开 注释 = "释放当前队列并创建一个新队列." 注释 = "本方法非线程安全." 折叠 @嵌入式方法 = "">
    参数 初始容量 <类型 = 整数 注释 = "队列创建时分配对应成员数的内存" @默认值 = 1024>
    {
        @ @sn<this>.init(static_cast<size_t>(@<初始容量>))
    }

    方法 取成员数 <公开 类型 = 整数 注释 = "返回本队列中已有成员的数目." 注释 = "注意: 返回的是一个估计值,只有队列未在执行入队和出队操作时,返回的数值才准确." 折叠
            @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data().size_approx()
    }

    方法 交换 <公开 注释 = "交换两个队列中的数据,本方法非线程安全." 折叠 @嵌入式方法 = "">
    参数 所欲交换的队列 <类型 = 无锁阻塞队列模板类>
    {
        @ @sn<this>.data().swap(@<所欲交换的队列>.data())
    }

    方法 创建生产者令牌 <公开 类型 = 生产者队列令牌 注释 = "创建一个仅在当前线程中使用的生产者令牌,用于入队的EX版方法." 注释 = "使用令牌可以显著提升入队的速度." 折叠
            @嵌入式方法 = "">
    {
        @ @dt<生产者队列令牌>{new moodycamel::ProducerToken(@sn<this>.data())}
    }

    方法 创建消费者令牌 <公开 类型 = 消费者队列令牌 注释 = "创建一个仅在当前线程中使用的消费者令牌,用于出队的EX版方法." 注释 = "使用令牌可以显著提升出队的速度." 折叠
            @嵌入式方法 = "">
    {
        @ @dt<消费者队列令牌>{new moodycamel::ConsumerToken(@sn<this>.data())}
    }

    # ---

    方法 等待出队 <公开 注释 = "阻塞当前线程,直到有可出队的成员,然后将它出队." 折叠 @嵌入式方法 = "">
    参数 弹出值 <类型 = 模板类型1 注释 = "提供用来获取所弹出成员的变量" @需求类型 = 可写入变量>
    {
        @ @sn<this>.data().wait_dequeue(@<弹出值>)
    }

    方法 等待出队EX <公开 注释 = "阻塞当前线程,直到有可出队的成员,然后将它出队." 折叠 @嵌入式方法 = "">
    参数 消费者令牌 <类型 = 消费者队列令牌 注释 = "提供由\"创建消费者令牌\"返回的令牌,使用令牌可以提升出队的速度.">
    参数 弹出值 <类型 = 模板类型1 注释 = "提供用来获取所弹出成员的变量" @需求类型 = 可写入变量>
    {
        @ @sn<this>.data().wait_dequeue(*@<消费者令牌>, @<弹出值>)
    }

    方法 限时出队 <公开 类型 = 逻辑型 注释 = "阻塞当前线程直到有可出队的成员或超过了指定的微秒时间." 注释 = "有可出队成员时将它出队并返回真,超时则返回假." 折叠 @嵌入式方法 = "">
    参数 弹出值 <类型 = 模板类型1 注释 = "提供用来获取所弹出成员的变量" @需求类型 = 可写入变量>
    参数 最大等待时间 <类型 = 长整数 注释 = "指定所欲等待的最多微秒数,小于0表示无限等待." 注释 = "1秒=1,000,000微秒">
    {
        @ @sn<this>.data().wait_dequeue_timed(@<弹出值>, @<最大等待时间>)
    }

    方法 限时出队EX <公开 类型 = 逻辑型 注释 = "阻塞当前线程直到有可出队的成员或超过了指定的微秒时间." 注释 = "有可出队成员时将它出队并返回真,超时则返回假." 折叠 @嵌入式方法 = "">
    参数 消费者令牌 <类型 = 消费者队列令牌 注释 = "提供由\"创建消费者令牌\"返回的令牌,使用令牌可以提升出队的速度.">
    参数 弹出值 <类型 = 模板类型1 注释 = "提供用来获取所弹出成员的变量" @需求类型 = 可写入变量>
    参数 最大等待时间 <类型 = 长整数 注释 = "指定所欲等待的最多微秒数,小于0表示无限等待." 注释 = "1秒=1,000,000微秒">
    {
        @ @sn<this>.data().wait_dequeue_timed(*@<消费者令牌>, @<弹出值>, @<最大等待时间>)
    }

    方法 等待批量出队 <公开 类型 = 整数 注释 = "阻塞当前线程,直到出队了一或多个成员,返回实际出队的成员数(必定大于1)." 折叠 @嵌入式方法 = "">
    参数 首成员 <类型 = 模板类型1 注释 = "提供用于获取批量出队数据的,连续内存数据的首成员变量." @需求类型 = 可写入变量>
    参数 最大出队数 <类型 = 整数 注释 = "所欲出队的最大成员数目">
    {
        @ (INT)@sn<this>.data().wait_dequeue_bulk(&@<首成员>, static_cast<size_t>(@<最大出队数>))
    }

    方法 等待批量出队EX <公开 类型 = 整数 注释 = "阻塞当前线程,直到出队了一或多个成员,返回实际出队的成员数(必定大于1)." 折叠 @嵌入式方法 = "">
    参数 消费者令牌 <类型 = 消费者队列令牌 注释 = "提供由\"创建消费者令牌\"返回的令牌,使用令牌可以提升出队的速度.">
    参数 首成员 <类型 = 模板类型1 注释 = "提供用于获取批量出队数据的,连续内存数据的首成员变量." @需求类型 = 可写入变量>
    参数 最大出队数 <类型 = 整数 注释 = "所欲出队的最大成员数目">
    {
        @ (INT)@sn<this>.data().wait_dequeue_bulk(*@<消费者令牌>, &@<首成员>, static_cast<size_t>(@<最大出队数>))
    }

    方法 限时批量出队 <公开 类型 = 整数 注释 = "尝试将多个成员从队列中出队,返回实际出队的成员数(不大于指定的\"最大出队数\")."
            注释 = "如果在指定的微秒时间内没有出队任何成员,则返回0." 折叠 @嵌入式方法 = "">
    参数 首成员 <类型 = 模板类型1 注释 = "提供用于获取批量出队数据的,连续内存数据的首成员变量." @需求类型 = 可写入变量>
    参数 最大出队数 <类型 = 整数 注释 = "所欲出队的最大成员数目">
    参数 最大等待时间 <类型 = 长整数 注释 = "指定所欲等待的最多微秒数,小于0表示无限等待." 注释 = "1秒=1,000,000微秒">
    {
        @ (INT)@sn<this>.data().wait_dequeue_bulk_timed(&@<首成员>, static_cast<size_t>(@<最大出队数>), @<最大等待时间>)
    }

    方法 限时批量出队EX <公开 类型 = 整数 注释 = "尝试将多个成员从队列中出队,返回实际出队的成员数(不大于指定的\"最大出队数\")."
            注释 = "如果在指定的微秒时间内没有出队任何成员,则返回0." 折叠 @嵌入式方法 = "">
    参数 消费者令牌 <类型 = 消费者队列令牌 注释 = "提供由\"创建消费者令牌\"返回的令牌,使用令牌可以提升出队的速度.">
    参数 首成员 <类型 = 模板类型1 注释 = "提供用于获取批量出队数据的,连续内存数据的首成员变量." @需求类型 = 可写入变量>
    参数 最大出队数 <类型 = 整数 注释 = "所欲出队的最大成员数目">
    参数 最大等待时间 <类型 = 长整数 注释 = "指定所欲等待的最多微秒数,小于0表示无限等待." 注释 = "1秒=1,000,000微秒">
    {
        @ (INT)@sn<this>.data().wait_dequeue_bulk_timed(*@<消费者令牌>, &@<首成员>, static_cast<size_t>(@<最大出队数>), @<最大等待时间>)
    }

    # ---
    # @begin
    # <> <include>
    # using Item_t = std::remove_pointer<@dt<模板类型1> *>::type;
    # std::shared_ptr<moodycamel::BlockingConcurrentQueue<Item_t>> m_queue;
    # inline void init(size_t capacity = 192) { m_queue.reset(new moodycamel::BlockingConcurrentQueue<Item_t>(capacity)); }
    # inline moodycamel::BlockingConcurrentQueue<Item_t>& data() { return *m_queue; }
    # @sn<current_class> (@sn<current_class>&& rhs) { m_queue = std::move(rhs.m_queue); }
    # inline void @an<_OnInitExtra>() { if (!m_queue) { init(192); } }
    # inline BOOL @an<_IsSelfEqualExtra>(const @sn<current_class>& objCompare) const { return (m_queue == objCompare.m_queue); }
    # inline void @an<_CopySelfFromExtra>(const @sn<current_class>& objCopyFrom) { m_queue = objCopyFrom.m_queue; }
    # inline @sn<current_class>& operator= (@sn<current_class>&& rhs) { m_queue = std::move(rhs.m_queue); return *this; }
    # <> </include>
    # @end
}

类 生产者队列令牌 <公开 注释 = "本类必须定义变量并赋值后才能使用,例:" 注释 = "生产者令牌 = XX无锁队列类.创建生产者令牌()" 折叠
        @文档 = "category = \"数据处理.队列.辅助类\"" @别名 = "std::unique_ptr<moodycamel::ProducerToken>" @别名类型 = 本地类
        @强制依赖 = "整数无锁队列类">
{
    方法 交换 <公开 静态 注释 = "将本令牌与另一个令牌交换" 折叠>
    参数 欲操作本对象 <类型 = 生产者队列令牌>
    参数 欲交换的对象 <类型 = 生产者队列令牌>
    {
        @ @<欲操作本对象>.swap(@<欲交换的对象>)
    }
}

类 消费者队列令牌 <公开 注释 = "本类必须定义变量并赋值后才能使用,例:" 注释 = "消费者令牌 = XX无锁队列类.创建消费者令牌()" 折叠
        @文档 = "category = \"数据处理.队列.辅助类\"" @别名 = "std::unique_ptr<moodycamel::ConsumerToken>" @别名类型 = 本地类
        @强制依赖 = "整数无锁队列类">
{
    方法 交换 <公开 静态 注释 = "将本令牌与另一个令牌交换" 折叠>
    参数 欲操作本对象 <类型 = 消费者队列令牌>
    参数 欲交换的对象 <类型 = 消费者队列令牌>
    {
        @ @<欲操作本对象>.swap(@<欲交换的对象>)
    }
}

类 读写队列模板类 <公开 基础类 = PIV对象类 注释 = "支持单生产者线程、单消费者线程的无锁读写队列." 注释 = " 1. 只能单个生产者线程入队,以及单个消费者线程出队;"
        注释 = " 2. 对象采用共享智能指针封装,拷贝赋值后仍指向同一队列数据;" 注释 = " 3. 队列默认初始分配15个成员数的内存,若要自定义初始容量,请用\"重置队列\";"
        注释 = " 4. 出队不会释放内存,这意味着队列的内存占用只增不减;" 折叠 @文档 = "category = \"数据处理.队列.模板类\"" @模板基础类 = 真
        @视窗.外部头文件 = "<user/piv/src/detail/readerwriterqueue.h>">
{
    方法 入队 <公开 类型 = 逻辑型 注释 = "在当前队列的尾部添加指定成员,返回是否成功." 注释 = "注: 仅生产者线程安全." 返回值注释 = "本方法将按需分配内存,仅在分配内存失败时返回假."
            折叠 @嵌入式方法 = "">
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的成员">
    {
        @ @sn<this>.data().enqueue(@<值>)
    }

    方法 尝试入队 <公开 类型 = 逻辑型 注释 = "尝试在当前队列的尾部添加指定成员,返回是否成功." 注释 = "注: 仅生产者线程安全."
            返回值注释 = "本方法不会重分配内存,没有可用空间将返回假." 折叠 @嵌入式方法 = "">
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的成员">
    {
        @ @sn<this>.data().try_enqueue(@<值>)
    }

    # ---

    方法 出队 <公开 类型 = 逻辑型 注释 = "获取并删除队列的第一个成员,返回是否成功." 注释 = "注: 仅消费者线程安全." 折叠 @嵌入式方法 = "">
    参数 弹出值 <类型 = 模板类型1 注释 = "提供用来获取所弹出成员的变量" @需求类型 = 可写入变量>
    {
        @ @sn<this>.data().try_dequeue(@<弹出值>)
    }

    # ---

    方法 重置队列 <公开 注释 = "释放当前队列并创建一个新队列." 注释 = "本方法非线程安全." 折叠 @嵌入式方法 = "">
    参数 初始容量 <类型 = 整数 注释 = "队列创建时分配对应成员数的内存" @默认值 = 15>
    {
        @ @sn<this>.init(static_cast<size_t>(@<初始容量>))
    }

    方法 取成员数 <公开 类型 = 整数 注释 = "返回本队列中已有成员的数目." 注释 = "注意: 返回的是一个估计值,只有队列未在执行入队和出队操作时,返回的数值才准确." 折叠
            @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data().size_approx ()
    }

    方法 取最大容量 <公开 类型 = 变整数 注释 = "返回在不重分配内存的情况下,当前队列能入队的最大成员数." 注释 = "随着不断\"入队\"产生内存分配,返回值也会随之递增." 折叠
            @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data().max_capacity ()
    }

    # ---

    方法 读数据 <公开 类型 = 变整数 注释 = "返回队列首成员的指针,如果队列为空则返回0." 注释 = "注: 仅消费者线程安全." 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data().peek()
    }

    方法 弹出 <公开 类型 = 逻辑型 注释 = "从队列中删除首个成员而不获取它的值,如果队列为空则返回假." 注释 = "注: 仅消费者线程安全." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().pop()
    }

    # @begin
    # <> <include>
    # using Item_t = std::remove_pointer<@dt<模板类型1> *>::type;
    # std::shared_ptr<moodycamel::ReaderWriterQueue<Item_t>> m_queue;
    # inline void init(size_t capacity = 15) { m_queue.reset(new moodycamel::ReaderWriterQueue<Item_t>(capacity)); }
    # inline moodycamel::ReaderWriterQueue<Item_t>& data() { return *m_queue; }
    # @sn<current_class> (@sn<current_class>&& rhs) { m_queue = std::move(rhs.m_queue); }
    # inline void @an<_OnInitExtra>() { if (!m_queue) { init(15); } }
    # inline BOOL @an<_IsSelfEqualExtra>(const @sn<current_class>& objCompare) const { return (m_queue == objCompare.m_queue); }
    # inline void @an<_CopySelfFromExtra>(const @sn<current_class>& objCopyFrom) { m_queue = objCopyFrom.m_queue; }
    # inline @sn<current_class>& operator= (@sn<current_class>&& rhs) { m_queue = std::move(rhs.m_queue); return *this; }
    # <> </include>
    # @end
}

类 读写阻塞队列模板类 <公开 基础类 = PIV对象类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞队列." 注释 = " 1. 只能单个生产者线程入队,以及单个消费者线程出队;"
        注释 = " 2. 对象采用共享智能指针封装,拷贝赋值后仍指向同一队列数据;" 注释 = " 3. 队列默认初始分配15个成员数的内存,若要自定义初始容量,请用\"重置队列\";"
        注释 = " 4. 出队不会释放内存,这意味着队列的内存占用只增不减;" 注释 = " 5. 在\"读写队列\"的基础上增加了会阻塞当前线程的出队方法;" 折叠
        @文档 = "category = \"数据处理.队列.模板类\"" @模板基础类 = 真 @视窗.外部头文件 = "<user/piv/src/detail/readerwriterqueue.h>">
{
    方法 入队 <公开 类型 = 逻辑型 注释 = "在当前队列的尾部添加指定成员,返回是否成功." 注释 = "注: 仅生产者线程安全." 返回值注释 = "本方法将按需分配内存,仅在分配内存失败时返回假."
            折叠 @嵌入式方法 = "">
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的成员">
    {
        @ @sn<this>.data().enqueue(@<值>)
    }

    方法 尝试入队 <公开 类型 = 逻辑型 注释 = "尝试在当前队列的尾部添加指定成员,返回是否成功." 注释 = "注: 仅生产者线程安全."
            返回值注释 = "本方法不会重分配内存,没有可用空间将返回失败." 折叠 @嵌入式方法 = "">
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的成员">
    {
        @ @sn<this>.data().try_enqueue(@<值>)
    }

    # ---

    方法 出队 <公开 类型 = 逻辑型 注释 = "获取并删除队列的第一个成员,返回是否成功." 注释 = "注: 仅消费者线程安全." 折叠 @嵌入式方法 = "">
    参数 弹出值 <类型 = 模板类型1 注释 = "提供用来获取所弹出成员的变量" @需求类型 = 可写入变量>
    {
        @ @sn<this>.data().try_dequeue(@<弹出值>)
    }

    方法 等待出队 <公开 注释 = "阻塞当前线程,直到有可出队的成员,然后将它出队." 注释 = "注: 仅消费者线程安全." 折叠 @嵌入式方法 = "">
    参数 弹出值 <类型 = 模板类型1 注释 = "提供用来获取所弹出成员的变量" @需求类型 = 可写入变量>
    {
        @ @sn<this>.data().wait_dequeue(@<弹出值>)
    }

    方法 限时出队 <公开 类型 = 逻辑型 注释 = "阻塞当前线程直到有可出队的成员或超过了指定的微秒时间." 注释 = "有可出队成员时将它出队并返回真,超时则返回假."
            注释 = "注: 仅消费者线程安全." 折叠 @嵌入式方法 = "">
    参数 弹出值 <类型 = 模板类型1 注释 = "提供用来获取所弹出成员的变量" @需求类型 = 可写入变量>
    参数 最大等待时间 <类型 = 长整数 注释 = "指定所欲等待的最多微秒数,小于0表示无限等待." 注释 = "1秒=1,000,000微秒">
    {
        @ @sn<this>.data().wait_dequeue_timed(@<弹出值>, @<最大等待时间>)
    }

    # ---

    方法 重置队列 <公开 注释 = "释放当前队列并创建一个新队列." 注释 = "本方法非线程安全." 折叠 @嵌入式方法 = "">
    参数 初始容量 <类型 = 整数 注释 = "队列创建时分配对应成员数的内存" @默认值 = 15>
    {
        @ @sn<this>.init(static_cast<size_t>(@<初始容量>))
    }

    方法 取成员数 <公开 类型 = 整数 注释 = "返回本队列中已有成员的数目." 注释 = "注意: 返回的是一个估计值,只有队列未在执行入队和出队操作时,返回的数值才准确." 折叠
            @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data().size_approx()
    }

    方法 取最大容量 <公开 类型 = 变整数 注释 = "返回在不重分配内存的情况下,当前队列能入队的最大成员数." 注释 = "随着不断\"入队\"产生内存分配,返回值也会随之递增." 折叠
            @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data().max_capacity ()
    }

    # ---

    方法 读数据 <公开 类型 = 变整数 注释 = "返回队列首成员的指针,如果队列为空则返回0." 注释 = "注: 仅消费者线程安全." 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data().peek()
    }

    方法 弹出 <公开 类型 = 逻辑型 注释 = "从队列中删除首个成员而不获取它的值,如果队列为空则返回假." 注释 = "注: 仅消费者线程安全." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().pop()
    }

    # @begin
    # <> <include>
    # using Item_t = std::remove_pointer<@dt<模板类型1> *>::type;
    # std::shared_ptr<moodycamel::BlockingReaderWriterQueue<Item_t>> m_queue;
    # inline void init(size_t capacity = 15) { m_queue.reset(new moodycamel::BlockingReaderWriterQueue<Item_t>(capacity)); }
    # inline moodycamel::BlockingReaderWriterQueue<Item_t>& data() { return *m_queue; }
    # @sn<current_class> (@sn<current_class>&& rhs) { m_queue = std::move(rhs.m_queue); }
    # inline void @an<_OnInitExtra>() { if (!m_queue) { init(15); } }
    # inline BOOL @an<_IsSelfEqualExtra>(const @sn<current_class>& objCompare) const { return (m_queue == objCompare.m_queue); }
    # inline void @an<_CopySelfFromExtra>(const @sn<current_class>& objCopyFrom) { m_queue = objCopyFrom.m_queue; }
    # inline @sn<current_class>& operator= (@sn<current_class>&& rhs) { m_queue = std::move(rhs.m_queue); return *this; }
    # <> </include>
    # @end
}

类 读写循环队列模板类 <公开 基础类 = PIV对象类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞循环队列." 注释 = " 1. 循环队列必须先\"创建\",才能调用其他方法;"
        注释 = " 2. 创建时决定的容量(环形缓冲区大小)不可后续更改;" 注释 = " 3. 只能单个生产者线程入队,以及单个消费者线程出队;"
        注释 = " 4. 对象采用共享智能指针封装,拷贝赋值后仍指向同一队列数据;" 折叠 @文档 = "category = \"数据处理.队列.模板类\"" @模板基础类 = 真
        @视窗.外部头文件 = "<user/piv/src/detail/readerwritercircularbuffer.h>">
{
    方法 创建 <公开 注释 = "创建一个新的循环队列,本方法非线程安全." 折叠 @嵌入式方法 = "">
    参数 容量 <类型 = 整数 注释 = "提供循环队列的最大成员数;" 注释 = "循环队列的环形缓冲区大小一旦确定就无法后续更改.">
    {
        @ @sn<this>.init(static_cast<size_t>(@<容量>))
    }

    方法 尝试入队 <公开 类型 = 逻辑型 注释 = "尝试在当前队列的尾部添加指定成员,返回是否成功." 注释 = "注: 仅生成者线程安全." 返回值注释 = "缓冲区没有可用空间时返回假" 折叠
            @嵌入式方法 = "">
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的成员">
    {
        @ @sn<this>.data().try_enqueue(@<值>)
    }

    方法 等待入队 <公开 注释 = "阻塞当前线程,直到循环队列有足够的空间完成入队." 注释 = "注: 仅生成者线程安全." 折叠 @嵌入式方法 = "">
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的成员" @需求类型 = 可写入变量>
    {
        @ @sn<this>.data().wait_enqueue(@<值>)
    }

    方法 限时入队 <公开 类型 = 逻辑型 注释 = "阻塞当前线程直到有足够的空间可以完成入队,或超过了指定的微秒时间." 注释 = "注: 仅生成者线程安全."
            返回值注释 = "入队成功返回真,超时则返回假." 折叠 @嵌入式方法 = "">
    参数 值 <类型 = 模板类型1 注释 = "提供所欲添加的成员">
    参数 最大等待时间 <类型 = 长整数 注释 = "指定所欲等待的最多微秒数,小于0表示无限等待." 注释 = "1秒=1,000,000微秒">
    {
        @ @sn<this>.data().wait_enqueue_timed(@<值>, @<最大等待时间>)
    }

    # ---

    方法 出队 <公开 类型 = 逻辑型 注释 = "获取并删除队列的第一个成员,返回是否成功." 注释 = "注: 仅消费者线程安全." 返回值注释 = "循环队列为空时返回假" 折叠 @嵌入式方法 = "">
    参数 弹出值 <类型 = 模板类型1 注释 = "提供用来获取所弹出成员的变量" @需求类型 = 可写入变量>
    {
        @ @sn<this>.data().try_dequeue(@<弹出值>)
    }

    方法 等待出队 <公开 注释 = "阻塞当前线程,直到有可出队的成员,然后将它出队." 注释 = "注: 仅消费者线程安全." 折叠 @嵌入式方法 = "">
    参数 弹出值 <类型 = 模板类型1 注释 = "提供用来获取所弹出成员的变量" @需求类型 = 可写入变量>
    {
        @ @sn<this>.data().wait_dequeue(@<弹出值>)
    }

    方法 限时出队 <公开 类型 = 逻辑型 注释 = "阻塞当前线程直到有可出队的成员,或超过了指定的微秒时间." 注释 = "注: 仅消费者线程安全."
            返回值注释 = "有可出队成员时将它出队并返回真,超时则返回假." 折叠 @嵌入式方法 = "">
    参数 弹出值 <类型 = 模板类型1 注释 = "提供用来获取所弹出成员的变量" @需求类型 = 可写入变量>
    参数 最大等待时间 <类型 = 长整数 注释 = "指定所欲等待的最多微秒数,小于0表示无限等待." 注释 = "1秒=1,000,000微秒">
    {
        @ @sn<this>.data().wait_dequeue_timed(@<弹出值>, @<最大等待时间>)
    }

    # ---

    方法 取成员数 <公开 类型 = 整数 注释 = "返回本循环队列中已有成员的数目." 注释 = "注意: 返回的是一个估计值,只有队列未在执行入队和出队操作时,返回的数值才准确." 折叠
            @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data().size_approx()
    }

    方法 取最大容量 <公开 类型 = 变整数 注释 = "返回循环队列能入队的最大成员数,该值不会变化." 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data().max_capacity ()
    }

    方法 交换 <公开 注释 = "交换两个循环队列中的数据,本方法非线程安全." 折叠 @嵌入式方法 = "">
    参数 所欲交换的队列 <类型 = 读写循环队列模板类>
    {
        @ @sn<this>.data().swap(@<所欲交换的队列>.data())
    }

    # ---

    方法 读数据 <公开 类型 = 变整数 注释 = "返回循环队列首成员的指针,如果队列为空则返回0." 注释 = "注: 仅消费者线程安全." 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data().peek()
    }

    方法 尝试弹出 <公开 类型 = 逻辑型 注释 = "尝试从循环队列中删除首成员而不获取它的值,如果队列为空则返回假." 注释 = "注: 仅消费者线程安全." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().try_pop()
    }

    # @begin
    # <> <include>
    # using Item_t = std::remove_pointer<@dt<模板类型1> *>::type;
    # std::shared_ptr<moodycamel::BlockingReaderWriterCircularBuffer<Item_t>> m_queue;
    # inline void init(size_t capacity) { m_queue.reset(new moodycamel::BlockingReaderWriterCircularBuffer<Item_t>(capacity)); }
    # inline moodycamel::BlockingReaderWriterCircularBuffer<Item_t>& data() {
    #     ASSERT(m_queue != nullptr); // 循环队列必须先"创建"才能调用其他方法
    #     return *m_queue;
    # }
    # @sn<current_class> (@sn<current_class>&& rhs) { m_queue = std::move(rhs.m_queue); }
    # inline BOOL @an<_IsSelfEqualExtra>(const @sn<current_class>& objCompare) const { return (m_queue == objCompare.m_queue); }
    # inline void @an<_CopySelfFromExtra>(const @sn<current_class>& objCopyFrom) { m_queue = objCopyFrom.m_queue; }
    # inline @sn<current_class>& operator= (@sn<current_class>&& rhs) { m_queue = std::move(rhs.m_queue); return *this; }
    # <> </include>
    # @end
}

# 无锁队列类型 ---

类 字节集无锁队列类 <公开 基础类 = 无锁队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁队列." @文档 = "category = \"数据处理.队列.无锁队列\""
        @模板实现类 = "字节集类">

类 文本无锁队列类 <公开 基础类 = 无锁队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁队列." 注释 = "注意: 请勿在批量入队和批量出队中使用\"文本数组类\"的成员,"
        注释 = "因为文本数组类取出的成员并非连续内存,建议使用\"文本标准数组类\"" 注释 = "或基本数组." @文档 = "category = \"数据处理.队列.无锁队列\""
        @模板实现类 = "文本型">

类 字节无锁队列类 <公开 基础类 = 无锁队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁队列." @文档 = "category = \"数据处理.队列.无锁队列\""
        @模板实现类 = "字节">

类 短整数无锁队列类 <公开 基础类 = 无锁队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁队列." @文档 = "category = \"数据处理.队列.无锁队列\""
        @模板实现类 = "短整数">

类 字符无锁队列类 <公开 基础类 = 无锁队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁队列." @文档 = "category = \"数据处理.队列.无锁队列\""
        @模板实现类 = "字符">

类 整数无锁队列类 <公开 基础类 = 无锁队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁队列." @文档 = "category = \"数据处理.队列.无锁队列\""
        @模板实现类 = "整数">

类 变整数无锁队列类 <公开 基础类 = 无锁队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁队列." @文档 = "category = \"数据处理.队列.无锁队列\""
        @模板实现类 = "变整数">

类 长整数无锁队列类 <公开 基础类 = 无锁队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁队列." @文档 = "category = \"数据处理.队列.无锁队列\""
        @模板实现类 = "长整数">

类 单精度小数无锁队列类 <公开 基础类 = 无锁队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁队列." @文档 = "category = \"数据处理.队列.无锁队列\""
        @模板实现类 = "单精度小数">

类 小数无锁队列类 <公开 基础类 = 无锁队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁队列." @文档 = "category = \"数据处理.队列.无锁队列\""
        @模板实现类 = "小数">

类 逻辑型无锁队列类 <公开 基础类 = 无锁队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁队列." @文档 = "category = \"数据处理.队列.无锁队列\""
        @模板实现类 = "逻辑型">

# 无锁阻塞队列类型 ---

类 字节集无锁阻塞队列类 <公开 基础类 = 无锁阻塞队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁阻塞队列." @文档 = "category = \"数据处理.队列.无锁阻塞队列\""
        @模板实现类 = "字节集类">

类 文本无锁阻塞队列类 <公开 基础类 = 无锁阻塞队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁阻塞队列." 注释 = "注意: 请勿在批量入队和批量出队中使用\"文本数组类\"的成员,"
        注释 = "因为文本数组类取出的成员并非连续内存,建议使用\"文本标准数组类\"" 注释 = "或基本数组." @文档 = "category = \"数据处理.队列.无锁阻塞队列\""
        @模板实现类 = "文本型">

类 字节无锁阻塞队列类 <公开 基础类 = 无锁阻塞队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁阻塞队列." @文档 = "category = \"数据处理.队列.无锁阻塞队列\""
        @模板实现类 = "字节">

类 短整数无锁阻塞队列类 <公开 基础类 = 无锁阻塞队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁阻塞队列." @文档 = "category = \"数据处理.队列.无锁阻塞队列\""
        @模板实现类 = "短整数">

类 字符无锁阻塞队列类 <公开 基础类 = 无锁阻塞队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁阻塞队列." @文档 = "category = \"数据处理.队列.无锁阻塞队列\""
        @模板实现类 = "字符">

类 整数无锁阻塞队列类 <公开 基础类 = 无锁阻塞队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁阻塞队列." @文档 = "category = \"数据处理.队列.无锁阻塞队列\""
        @模板实现类 = "整数">

类 变整数无锁阻塞队列类 <公开 基础类 = 无锁阻塞队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁阻塞队列." @文档 = "category = \"数据处理.队列.无锁阻塞队列\""
        @模板实现类 = "变整数">

类 长整数无锁阻塞队列类 <公开 基础类 = 无锁阻塞队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁阻塞队列." @文档 = "category = \"数据处理.队列.无锁阻塞队列\""
        @模板实现类 = "长整数">

类 单精度小数无锁阻塞队列类 <公开 基础类 = 无锁阻塞队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁阻塞队列."
        @文档 = "category = \"数据处理.队列.无锁阻塞队列\"" @模板实现类 = "单精度小数">

类 小数无锁阻塞队列类 <公开 基础类 = 无锁阻塞队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁阻塞队列." @文档 = "category = \"数据处理.队列.无锁阻塞队列\""
        @模板实现类 = "小数">

类 逻辑型无锁阻塞队列类 <公开 基础类 = 无锁阻塞队列模板类 注释 = "支持多线程并发的多生产者、多消费者无锁阻塞队列." @文档 = "category = \"数据处理.队列.无锁阻塞队列\""
        @模板实现类 = "逻辑型">

# 读写队列类型 ---

类 字节集读写队列类 <公开 基础类 = 读写队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写队列." @文档 = "category = \"数据处理.队列.读写队列\""
        @模板实现类 = "字节集类">

类 文本读写队列类 <公开 基础类 = 读写队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写队列." @文档 = "category = \"数据处理.队列.读写队列\""
        @模板实现类 = "文本型">

类 字节读写队列类 <公开 基础类 = 读写队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写队列." @文档 = "category = \"数据处理.队列.读写队列\""
        @模板实现类 = "字节">

类 短整数读写队列类 <公开 基础类 = 读写队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写队列." @文档 = "category = \"数据处理.队列.读写队列\""
        @模板实现类 = "短整数">

类 字符读写队列类 <公开 基础类 = 读写队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写队列." @文档 = "category = \"数据处理.队列.读写队列\""
        @模板实现类 = "字符">

类 整数读写队列类 <公开 基础类 = 读写队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写队列." @文档 = "category = \"数据处理.队列.读写队列\""
        @模板实现类 = "整数">

类 变整数读写队列类 <公开 基础类 = 读写队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写队列." @文档 = "category = \"数据处理.队列.读写队列\""
        @模板实现类 = "变整数">

类 长整数读写队列类 <公开 基础类 = 读写队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写队列." @文档 = "category = \"数据处理.队列.读写队列\""
        @模板实现类 = "长整数">

类 单精度小数读写队列类 <公开 基础类 = 读写队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写队列." @文档 = "category = \"数据处理.队列.读写队列\""
        @模板实现类 = "单精度小数">

类 小数读写队列类 <公开 基础类 = 读写队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写队列." @文档 = "category = \"数据处理.队列.读写队列\""
        @模板实现类 = "小数">

类 逻辑型读写队列类 <公开 基础类 = 读写队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写队列." @文档 = "category = \"数据处理.队列.读写队列\""
        @模板实现类 = "逻辑型">

# 读写阻塞队列类型 ---

类 字节集读写阻塞队列类 <公开 基础类 = 读写阻塞队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞队列." @文档 = "category = \"数据处理.队列.读写阻塞队列\""
        @模板实现类 = "字节集类">

类 文本读写阻塞队列类 <公开 基础类 = 读写阻塞队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞队列." @文档 = "category = \"数据处理.队列.读写阻塞队列\""
        @模板实现类 = "文本型">

类 字节读写阻塞队列类 <公开 基础类 = 读写阻塞队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞队列." @文档 = "category = \"数据处理.队列.读写阻塞队列\""
        @模板实现类 = "字节">

类 短整数读写阻塞队列类 <公开 基础类 = 读写阻塞队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞队列." @文档 = "category = \"数据处理.队列.读写阻塞队列\""
        @模板实现类 = "短整数">

类 字符读写阻塞队列类 <公开 基础类 = 读写阻塞队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞队列." @文档 = "category = \"数据处理.队列.读写阻塞队列\""
        @模板实现类 = "字符">

类 整数读写阻塞队列类 <公开 基础类 = 读写阻塞队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞队列." @文档 = "category = \"数据处理.队列.读写阻塞队列\""
        @模板实现类 = "整数">

类 变整数读写阻塞队列类 <公开 基础类 = 读写阻塞队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞队列." @文档 = "category = \"数据处理.队列.读写阻塞队列\""
        @模板实现类 = "变整数">

类 长整数读写阻塞队列类 <公开 基础类 = 读写阻塞队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞队列." @文档 = "category = \"数据处理.队列.读写阻塞队列\""
        @模板实现类 = "长整数">

类 单精度小数读写阻塞队列类 <公开 基础类 = 读写阻塞队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞队列."
        @文档 = "category = \"数据处理.队列.读写阻塞队列\"" @模板实现类 = "单精度小数">

类 小数读写阻塞队列类 <公开 基础类 = 读写阻塞队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞队列." @文档 = "category = \"数据处理.队列.读写阻塞队列\""
        @模板实现类 = "小数">

类 逻辑型读写阻塞队列类 <公开 基础类 = 读写阻塞队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞队列." @文档 = "category = \"数据处理.队列.读写阻塞队列\""
        @模板实现类 = "逻辑型">

# 读写循环队列类型

类 字节集循环队列类 <公开 基础类 = 读写循环队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞循环队列." @文档 = "category = \"数据处理.队列.读写循环队列\""
        @模板实现类 = "字节集类">

类 文本循环队列类 <公开 基础类 = 读写循环队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞循环队列." @文档 = "category = \"数据处理.队列.读写循环队列\""
        @模板实现类 = "文本型">

类 字节循环队列类 <公开 基础类 = 读写循环队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞循环队列." @文档 = "category = \"数据处理.队列.读写循环队列\""
        @模板实现类 = "字节">

类 短整数循环队列类 <公开 基础类 = 读写循环队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞循环队列." @文档 = "category = \"数据处理.队列.读写循环队列\""
        @模板实现类 = "短整数">

类 字符循环队列类 <公开 基础类 = 读写循环队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞循环队列." @文档 = "category = \"数据处理.队列.读写循环队列\""
        @模板实现类 = "字符">

类 整数循环队列类 <公开 基础类 = 读写循环队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞循环队列." @文档 = "category = \"数据处理.队列.读写循环队列\""
        @模板实现类 = "整数">

类 变整数循环队列类 <公开 基础类 = 读写循环队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞循环队列." @文档 = "category = \"数据处理.队列.读写循环队列\""
        @模板实现类 = "变整数">

类 长整数循环队列类 <公开 基础类 = 读写循环队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞循环队列." @文档 = "category = \"数据处理.队列.读写循环队列\""
        @模板实现类 = "长整数">

类 单精度小数循环队列类 <公开 基础类 = 读写循环队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞循环队列."
        @文档 = "category = \"数据处理.队列.读写循环队列\"" @模板实现类 = "单精度小数">

类 小数循环队列类 <公开 基础类 = 读写循环队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞循环队列." @文档 = "category = \"数据处理.队列.读写循环队列\""
        @模板实现类 = "小数">

类 逻辑型循环队列类 <公开 基础类 = 读写循环队列模板类 注释 = "支持单生产者线程、单消费者线程的无锁读写阻塞循环队列." @文档 = "category = \"数据处理.队列.读写循环队列\""
        @模板实现类 = "逻辑型">

#
