<火山程序 类型 = "通常" 版本 = 1 />

包 火山.ImGui <注释 = "例程下载: https://saier.lanzoul.com/b016cwvle"
        注释 = "ImGui 1.90.1 https://github.com/ocornut/imgui" @视窗.外部头文件 = "<piv_imgui.hpp>"
        @视窗.外部源文件 = "imgui\\imgui.cpp\r\nimgui\\imgui_draw.cpp\r\nimgui\\imgui_tables.cpp\r\nimgui\\imgui_widgets.cpp\r\nimgui\\imgui_demo.cpp\r\nimgui\\misc\\cpp\\imgui_stdlib.cpp"
        @视窗.头文件搜寻目录 = "imgui">

类 ImGui <公开 注释 = "ImGui是一个即时渲染UI,即每一帧都会重新计算布局和渲染,对CPU和GPU的占用比MFC/WTL高."
        注释 = "由于采用DirectX、OpenGL、Vulkan等引擎渲染界面，性能和图像质量都很高." 折叠>
{
    方法 检查版本 <公开 静态 注释 = "用于验证调用方代码和Dear ImGui编译版本之间的ABI兼容性" 折叠 @嵌入式方法 = "">
    {
        @ IMGUI_CHECKVERSION()
    }

    方法 "//高质量字体渲染" <公开 静态 @视窗.预定义宏 = "IMGUI_ENABLE_FREETYPE">

    # 上下文 | Context creation and access

    方法 创建上下文 <公开 静态 类型 = 变整数 注释 = "创建ImGUI上下文,并返回所创建的上下文指针." 折叠 @嵌入式方法 = "">
    {
        @ reinterpret_cast<INT_P>(ImGui::CreateContext())
    }

    方法 销毁上下文 <公开 静态 注释 = "销毁ImGUI上下文" 折叠 @嵌入式方法 = "">
    参数 上下文指针 <类型 = 变整数 注释 = "所欲销毁的上下文指针,0为当前上下文." @默认值 = 0>
    {
        @ ImGui::DestroyContext(reinterpret_cast<ImGuiContext*>(@<上下文指针>))
    }

    方法 取当前上下文 <公开 静态 类型 = 变整数 注释 = "返回当前的上下文指针" 返回值注释 = "ImGuiContext*" 折叠 @嵌入式方法 = "">
    {
        @ reinterpret_cast<INT_P>(ImGui::GetCurrentContext())
    }

    方法 置当前上下文 <公开 静态 注释 = "将指定的上下文指针设置为当前ImGUI上下文" 折叠 @嵌入式方法 = "">
    参数 上下文指针 <类型 = 变整数>
    {
        @ ImGui::SetCurrentContext(reinterpret_cast<ImGuiContext*>(@<上下文指针>))
    }

    方法 取字体图集 <公开 静态 类型 = IM字体图集类 折叠 @嵌入式方法 = "">
    {
        @ @dt<IM字体图集类>{ImGui::GetIO().Fonts}
    }

    # 主体 | Main

    方法 取IO <公开 静态 类型 = ImGuiIO类 注释 = "返回ImGui的IO结构体(鼠标/键盘/游戏手柄的输入、时间、各种配置选项和标志)" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImGuiIO类>{&ImGui::GetIO()}
    }

    方法 取样式 <公开 静态 类型 = IM样式类 注释 = "返回当前的样式配置" 折叠 @嵌入式方法 = "">
    {
        @ @dt<IM样式类>{ImGui::GetStyle()}
    }

    方法 新建帧 <公开 静态 注释 = "创建一个新的Dear ImGUI帧,然后在调用\"渲染/结束帧\"之前执行界面布局的相关命令." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::NewFrame()
    }

    方法 结束帧 <公开 静态 注释 = "结束当前帧,\"渲染\"会自动调用本方法,当你不需要渲染数据时可以单独调用本方法." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::EndFrame()
    }

    方法 渲染 <公开 静态 注释 = "结束当前帧并完成要绘制的数据,之后可以调用\"取渲染数据\"." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::Render()
    }

    方法 取渲染数据 <公开 静态 类型 = 变整数 注释 = "返回所渲染的数据,在执行\"渲染\"后到下一次\"新建帧\"之前可用." 返回值注释 = "ImDrawData*" 折叠
            @嵌入式方法 = "">
    {
        @ reinterpret_cast<INT_P>(ImGui::GetDrawData())
    }

    # 演示、调试、信息 | Demo, Debug, Information

    方法 显示演示窗口 <公开 静态 注释 = "显示ImGUI自带的演示窗口,可以在这个窗口中体验ImGui的基础功能." 折叠 @嵌入式方法 = "">
    参数 打开状态 <类型 = 逻辑型类 注释 = "本参数非将在窗口上显示一个关闭按钮,通过按钮关闭窗口后会将逻辑型设置为假." @默认值 = 空对象>
    {
        @ ImGui::ShowDemoWindow(piv::GetBaseDataPtr<bool*>(@<打开状态>))
    }

    方法 字体选择器 <公开 静态 注释 = "创建一个字体选择器组件" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在字体选择器旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    {
        @ ImGui::FontSelector(*PivAny2U{@<标签文本>})
    }

    方法 取版本名称 <公开 静态 类型 = 文本型 注释 = "返回ImGui的版本名称" 折叠 @嵌入式方法 = "">
    {
        @ @an<CVolString>{ImGui::GetVersion()}
    }

    # 样式 | Styles

    方法 深色样式 <公开 静态 注释 = "将ImGui的配色主题设置为深色样式(默认值)" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::StyleColorsDark()
    }

    方法 浅色样式 <公开 静态 注释 = "将ImGui的配色主题设置为浅色样式" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::StyleColorsLight()
    }

    方法 经典样式 <公开 静态 注释 = "将ImGui的配色主题设置为经典样式" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::StyleColorsClassic()
    }

    # 窗口 | Windows

    方法 创建窗口 <公开 静态 注释 = "创建一个窗口,然后可以在子语句体中添加组件." 注释 = "如果窗口已被折叠或被完全裁剪,则子语句体中的代码不会被执行."
            注释 = "注意: 本方法是\"窗口开端\"和\"窗口末端\"的结合体." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::End();\"">
    参数 窗口名称 <注释 = "提供窗口的标题名称;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 打开状态 <类型 = 逻辑型类 注释 = "本参数非空将在窗口上显示一个关闭按钮,通过按钮关闭窗口后会将本参数的逻辑值设置为假." @默认值 = 空对象>
    参数 窗口标志 <类型 = 整数 注释 = "请参考\"IM窗口标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM窗口标志.无>
    {
        @ if (ImGui::Begin(*PivAny2U{@<窗口名称>}, piv::GetBaseDataPtr<bool*>(@<打开状态>), static_cast<ImGuiWindowFlags>(@<窗口标志>)) == true)
    }

    方法 创建子窗口 <公开 静态 注释 = "在窗口中创建一个子窗口,然后可以在子语句体中添加组件,子窗口也可以嵌入自己的子窗口."
            注释 = "如果子窗口已被折叠或被完全裁剪,则子语句体中的代码不会被执行." 注释 = "注意: 本方法是\"子窗口开端\"和\"子窗口末端\"的结合体." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::EndChild();\"">
    参数 文本ID <注释 = "提供子窗口的文本ID(子窗口没有可显示的标签文本);" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 子窗口尺寸 <类型 = ImVec2 注释 = "提供子窗口的尺寸,等于0.0f: 使用剩余的主窗口大小; 大于0.0f: 使用固定大小; 小于0.0f: 使用剩余窗口大小减去绝对大小"
            @默认值 = 空对象>
    参数 子窗口标志 <类型 = 整数 注释 = "请参考\"IM子窗口标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM子窗口标志.无>
    参数 窗口标志 <类型 = 整数 注释 = "请参考\"IM窗口标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM窗口标志.无>
    {
        @ if (ImGui::BeginChild(*PivAny2U{@<文本ID>}, @<子窗口尺寸>, (ImGuiChildFlags)@<子窗口标志>, static_cast<ImGuiWindowFlags>(@<窗口标志>)) == true)
    }

    方法 窗口开端 <公开 静态 类型 = 逻辑型 注释 = "将窗口推送到堆栈并开始添加组件" 返回值注释 = "返回假表示窗口已被折叠或被完全裁剪,此时你可以省略往窗口中提交内容." 折叠
            @嵌入式方法 = "">
    参数 窗口名称 <注释 = "提供窗口的标题名称;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 打开状态 <类型 = 逻辑型类 注释 = "本参数非空将在窗口上显示一个关闭按钮,通过按钮关闭窗口后会将本参数的逻辑值设置为假." @默认值 = 空对象>
    参数 窗口标志 <类型 = 整数 注释 = "请参考\"IM窗口标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM窗口标志.无>
    {
        @ ImGui::Begin(*PivAny2U{@<窗口名称>}, piv::GetBaseDataPtr<bool*>(@<打开状态>), static_cast<ImGuiWindowFlags>(@<窗口标志>))
    }

    方法 窗口末端 <公开 静态 注释 = "从堆栈中弹出窗口,结束窗口的布局设计." 注释 = "无论\"窗口开端\"的返回值如何,都必须成对调用本方法." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::End()
    }

    方法 子窗口开端 <公开 静态 类型 = 逻辑型 注释 = "使用子窗口开始进入主窗口内独立的滚动/剪切区域,子窗口也可以嵌入自己的子窗口."
            返回值注释 = "返回假表示子窗口已被折叠或被完全裁剪,此时你可以省略往子窗口中提交内容." 折叠 @嵌入式方法 = "">
    参数 文本ID <注释 = "提供子窗口的文本ID(子窗口没有可显示的标签文本);" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 子窗口尺寸 <类型 = ImVec2 注释 = "提供子窗口的尺寸,等于0.0f: 使用剩余的主窗口大小; 大于0.0f: 使用固定大小; 小于0.0f: 使用剩余窗口大小减去绝对大小"
            @默认值 = 空对象>
    参数 子窗口标志 <类型 = 整数 注释 = "请参考\"IM子窗口标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM子窗口标志.无>
    参数 窗口标志 <类型 = 整数 注释 = "请参考\"IM窗口标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM窗口标志.无>
    {
        @ ImGui::BeginChild(*PivAny2U{@<文本ID>}, @<子窗口尺寸>, (ImGuiChildFlags)@<子窗口标志>, static_cast<ImGuiWindowFlags>(@<窗口标志>))
    }

    方法 子窗口末端 <公开 静态 注释 = "结束子窗口的布局设计." 注释 = "无论\"子窗口开端\"的返回值如何,都必须成对调用本方法." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::EndChild()
    }

    # 窗口实用程序 | Windows Utilities

    方法 窗口是否首次显示 <公开 静态 类型 = 逻辑型 注释 = "返回当前窗口是否为首次显示状态(第一次显示窗口或从隐藏切换到显示状态)" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsWindowAppearing()
    }

    方法 窗口是否折叠 <公开 静态 类型 = 逻辑型 注释 = "返回当前窗口是否为折叠状态" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsWindowCollapsed()
    }

    方法 窗口可有焦点 <公开 静态 类型 = 逻辑型 注释 = "返回当前窗口是否具有焦点" 折叠 @嵌入式方法 = "">
    参数 焦点标志 <类型 = 整数 @默认值 = IM焦点标志.无>
    {
        @ ImGui::IsWindowFocused(static_cast<ImGuiHoveredFlags>(@<焦点标志>))
    }

    方法 窗口可有悬停 <公开 静态 类型 = 逻辑型 注释 = "返回当前窗口是否有鼠标悬停" 折叠 @嵌入式方法 = "">
    参数 悬停标志 <类型 = 整数 @默认值 = IM悬停标志.无>
    {
        @ ImGui::IsWindowHovered(static_cast<ImGuiHoveredFlags>(@<悬停标志>))
    }

    方法 取窗口绘制列表 <公开 静态 类型 = IM绘制列表类 注释 = "获取与当前窗口关联的绘制列表,可以附加你自己绘制的基本图形." 折叠 @嵌入式方法 = "">
    {
        @ @dt<IM绘制列表类>{ImGui::GetWindowDrawList()}
    }

    方法 取窗口DPI缩放 <公开 静态 类型 = 单精度小数 注释 = "返回与当前窗口视口关联的DPI缩放" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetWindowDpiScale()
    }

    方法 取窗口位置 <公开 静态 类型 = ImVec2 注释 = "返回当前窗口的位置" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetWindowPos()}
    }

    方法 取窗口尺寸 <公开 静态 类型 = ImVec2 注释 = "返回当前窗口的尺寸" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetWindowSize()}
    }

    方法 取窗口宽度 <公开 静态 类型 = 单精度小数 注释 = "返回当前窗口的宽度" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetWindowWidth()
    }

    方法 取窗口高度 <公开 静态 类型 = 单精度小数 注释 = "返回当前窗口的高度" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetWindowHeight()
    }

    方法 取窗口视口 <公开 静态 类型 = IM视口类 注释 = "返回与当前窗口关联的视口" 折叠 @嵌入式方法 = "">
    {
        @ @dt<IM视口类>{ImGui::GetWindowViewport()}
    }

    # 窗口操作 | Window manipulation

    方法 置下一窗口位置 <公开 静态 注释 = "设置下一个窗口的位置,请在\"窗口/窗口开端\"之前调用." 折叠 @嵌入式方法 = "">
    参数 窗口位置 <类型 = ImVec2>
    参数 执行条件 <类型 = IM执行条件 @默认值 = IM执行条件.无>
    参数 窗口中心点 <类型 = ImVec2 注释 = "提供窗口的中心点位置,(0.5,0.5)为中间." @默认值 = 空对象>
    {
        @ ImGui::SetNextWindowPos(@<窗口位置>, static_cast<ImGuiCond>(@<执行条件>), @<窗口中心点>)
    }

    方法 置下一窗口尺寸 <公开 静态 注释 = "设置下一个窗口的尺寸,请在\"窗口/窗口开端\"之前调用."
            注释 = "set axis to 0.0f to force an auto-fit on this axis. call before Begin()" 折叠 @嵌入式方法 = "">
    参数 窗口尺寸 <类型 = ImVec2>
    参数 执行条件 <类型 = IM执行条件 @默认值 = IM执行条件.无>
    {
        @ ImGui::SetNextWindowSize(@<窗口尺寸>, static_cast<ImGuiCond>(@<执行条件>))
    }

    方法 置下一窗口尺寸限制 <公开 静态 注释 = "设置下一个窗口的尺寸限制,请在\"窗口/窗口开端\"之前调用."
            注释 = "use -1,-1 on either X/Y axis to preserve the current size. Sizes will be rounded down."
            注释 = "Use callback to apply non-trivial programmatic constraints." 折叠 @嵌入式方法 = "">
    参数 最小尺寸 <类型 = ImVec2>
    参数 最大尺寸 <类型 = ImVec2>
    {
        @ ImGui::SetNextWindowSizeConstraints(@<最小尺寸>, @<最大尺寸>, nullptr, nullptr)
    }

    方法 置下一窗口内容尺寸 <公开 静态 注释 = "设置下一个窗口的内容尺寸,请在\"窗口/窗口开端\"之前调用."
            注释 = "内容尺寸即可滚动的客户区,滚动条控制的区域,不包括窗口装饰(标题栏、菜单栏等)和窗口填充." 折叠 @嵌入式方法 = "">
    参数 内容尺寸 <类型 = ImVec2 注释 = "将轴设置为0.0f以使其保持自动">
    {
        @ ImGui::SetNextWindowContentSize(@<内容尺寸>)
    }

    方法 置下一窗口折叠状态 <公开 静态 注释 = "设置下一个窗口的折叠状态,请在\"窗口/窗口开端\"之前调用." 折叠 @嵌入式方法 = "">
    参数 是否折叠 <类型 = 逻辑型>
    参数 执行条件 <类型 = IM执行条件 @默认值 = IM执行条件.无>
    {
        @ ImGui::SetNextWindowCollapsed(static_cast<bool>(@<是否折叠>), static_cast<ImGuiCond>(@<执行条件>))
    }

    方法 置下一窗口获得焦点 <公开 静态 注释 = "设置下一个窗口获得输入焦点,请在\"窗口/窗口开端\"之前调用." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::SetNextWindowFocus()
    }

    方法 置下一窗口滚动量 <公开 静态 注释 = "设置下一个窗口的滚动量,请在\"窗口/窗口开端\"之前调用." 折叠 @嵌入式方法 = "">
    参数 滚动量 <类型 = ImVec2 注释 = "值小于0.0f时将不影响对应轴">
    {
        @ ImGui::SetNextWindowScroll(@<滚动量>)
    }

    方法 置下一窗口背景透明度 <公开 静态 注释 = "设置下一个窗口的背景颜色透明度,请在\"窗口开端\"之前调用."
            注释 = "helper to easily override the Alpha component of ImGuiCol_WindowBg/ChildBg/PopupBg."
            注释 = "you may also use ImGuiWindowFlags_NoBackground." 折叠 @嵌入式方法 = "">
    参数 Alpha值 <类型 = 单精度小数 注释 = "0.0-1.0">
    {
        @ ImGui::SetNextWindowBgAlpha(@<Alpha值>)
    }

    方法 置下一窗口视口 <公开 静态 注释 = "设置下一个窗口的视口" 折叠 @嵌入式方法 = "">
    参数 视口ID <类型 = 整数>
    {
        @ ImGui::SetNextWindowViewport(static_cast<ImGuiID>(@<视口ID>))
    }

    方法 置窗口位置 <公开 静态 注释 = "设置指定窗口的位置" 折叠 @嵌入式方法 = "">
    参数 窗口名称 <注释 = "提供所欲设置位置的窗口名称;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 窗口位置 <类型 = ImVec2>
    参数 执行条件 <类型 = IM执行条件 @默认值 = IM执行条件.无>
    {
        @ ImGui::SetWindowPos(*PivAny2U{@<窗口名称>}, @<窗口位置>, static_cast<ImGuiCond>(@<执行条件>))
    }

    方法 置窗口尺寸 <公开 静态 注释 = "设置指定窗口的尺寸,请在\"窗口开端\"之前调用. set axis to 0.0f to force an auto-fit on this axis." 折叠
            @嵌入式方法 = "">
    参数 窗口名称 <注释 = "提供所欲设置尺寸的窗口名称;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 窗口尺寸 <类型 = ImVec2>
    参数 执行条件 <类型 = IM执行条件 @默认值 = IM执行条件.无>
    {
        @ ImGui::SetWindowSize(*PivAny2U{@<窗口名称>}, @<窗口尺寸>, static_cast<ImGuiCond>(@<执行条件>))
    }

    方法 置窗口折叠状态 <公开 静态 注释 = "设置指定窗口的折叠状态" 折叠 @嵌入式方法 = "">
    参数 窗口名称 <注释 = "提供所欲设置折叠状态的窗口名称;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 是否折叠 <类型 = 逻辑型>
    参数 执行条件 <类型 = IM执行条件 @默认值 = IM执行条件.无>
    {
        @ ImGui::SetWindowCollapsed(*PivAny2U{@<窗口名称>}, static_cast<bool>(@<是否折叠>), static_cast<ImGuiCond>(@<执行条件>))
    }

    方法 置窗口获得焦点 <公开 静态 注释 = "设置指定窗口获得输入焦点" 折叠 @嵌入式方法 = "">
    参数 窗口名称 <注释 = "提供所欲获得焦点的窗口名称;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    {
        @ ImGui::SetWindowFocus(*PivAny2U{@<窗口名称>})
    }

    # 内容区域 | Content region

    方法 取可用内容区域 <公开 静态 类型 = ImVec2 注释 = "等同于\"取最大内容区域() - 取光标位置()\"." 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetContentRegionAvail()}
    }

    方法 取最大内容区域 <公开 静态 类型 = ImVec2
            注释 = "current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates"
            折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetContentRegionMax()}
    }

    方法 取最小窗口内容区域 <公开 静态 类型 = ImVec2
            注释 = "content boundaries min for the full window (roughly (0,0)-Scroll), in window coordinates" 折叠
            @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetWindowContentRegionMin()}
    }

    方法 取最大窗口内容区域 <公开 静态 类型 = ImVec2
            注释 = "content boundaries max for the full window (roughly (0,0)+Size-Scroll) where Size can be overridden with SetNextWindowContentSize(), in window coordinates"
            折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetWindowContentRegionMax()}
    }

    # 滚动窗口 | Windows Scrolling

    方法 取水平滚动量 <公开 静态 类型 = 单精度小数 注释 = "get scrolling amount [0 .. GetScrollMaxX()]" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetScrollX()
    }

    方法 取垂直滚动量 <公开 静态 类型 = 单精度小数 注释 = "get scrolling amount [0 .. GetScrollMaxY()]" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetScrollY()
    }

    方法 置水平滚动量 <公开 静态 注释 = "set scrolling amount [0 .. GetScrollMaxX()]" 折叠 @嵌入式方法 = "">
    参数 滚动量 <类型 = 单精度小数>
    {
        @ ImGui::SetScrollX(@<滚动量>)
    }

    方法 置垂直滚动量 <公开 静态 注释 = "set scrolling amount [0 .. GetScrollMaxY()]" 折叠 @嵌入式方法 = "">
    参数 滚动量 <类型 = 单精度小数>
    {
        @ ImGui::SetScrollY(@<滚动量>)
    }

    方法 取最大水平滚动量 <公开 静态 类型 = 单精度小数
            注释 = "get maximum scrolling amount ~~ ContentSize.x - WindowSize.x - DecorationsSize.x" 折叠
            @嵌入式方法 = "">
    {
        @ ImGui::GetScrollMaxX()
    }

    方法 取最大垂直滚动量 <公开 静态 类型 = 单精度小数
            注释 = "get maximum scrolling amount ~~ ContentSize.y - WindowSize.y - DecorationsSize.y" 折叠
            @嵌入式方法 = "">
    {
        @ ImGui::GetScrollMaxY()
    }

    方法 水平滚动至此 <公开 静态
            注释 = "adjust scrolling amount to make current cursor position visible. center_x_ratio=0.0: left, 0.5: center, 1.0: right."
            注释 = "When using to make a \"default/current item\" visible, consider using SetItemDefaultFocus() instead."
            折叠 @嵌入式方法 = "">
    参数 水平中心比例 <类型 = 单精度小数 @默认值 = 0.5>
    {
        @ ImGui::SetScrollHereX(@<水平中心比例>)
    }

    方法 垂直滚动至此 <公开 静态
            注释 = "adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom."
            注释 = "When using to make a \"default/current item\" visible, consider using SetItemDefaultFocus() instead."
            折叠 @嵌入式方法 = "">
    参数 垂直中心比例 <类型 = 单精度小数 @默认值 = 0.5>
    {
        @ ImGui::SetScrollHereY(@<垂直中心比例>)
    }

    方法 置水平滚动位置 <公开 静态
            注释 = "adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position."
            折叠 @嵌入式方法 = "">
    参数 水平位置 <类型 = 单精度小数>
    参数 水平中心比例 <类型 = 单精度小数 @默认值 = 0.5>
    {
        @ ImGui::SetScrollFromPosX(@<水平位置>, @<水平中心比例>)
    }

    方法 置垂直滚动位置 <公开 静态
            注释 = "adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position."
            折叠 @嵌入式方法 = "">
    参数 垂直位置 <类型 = 单精度小数>
    参数 垂直中心比例 <类型 = 单精度小数 @默认值 = 0.5>
    {
        @ ImGui::SetScrollFromPosY(@<垂直位置>, @<垂直中心比例>)
    }

    # 参数堆栈(共用) | Parameters stacks (shared)

    方法 设置字体 <公开 静态 注释 = "将指定的字体压入到堆栈,然后在子语句体中更改字体的参数." 注释 = "本方法不需要手动弹出堆栈." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::PopFont();\"">
    参数 字体 <类型 = IM字体类>
    {
        @ ImGui::PushFont(@<字体>)
    }

    方法 压入样式颜色 <公开 静态 注释 = "在\"新建帧\"之后需要调用本方法修改一个\"整数\"类型的样式颜色,必须与\"弹出样式颜色\"成对使用." 折叠 @嵌入式方法 = "">
    参数 颜色ID <类型 = IM颜色标识符>
    参数 新颜色 <类型 = 整数>
    {
        @ ImGui::PushStyleColor(static_cast<ImGuiCol>(@<颜色ID>), @<新颜色>)
    }

    方法 压入样式颜色2 <公开 静态 注释 = "在\"新建帧\"之后需要调用本方法修改一个\"ImVec4\"类型的样式颜色,必须与\"弹出样式颜色\"成对使用." 折叠 @嵌入式方法 = "">
    参数 颜色ID <类型 = IM颜色标识符>
    参数 新颜色 <类型 = ImVec4>
    {
        @ ImGui::PushStyleColor(static_cast<ImGuiCol>(@<颜色ID>), @<新颜色>)
    }

    方法 弹出样式颜色 <公开 静态 注释 = "必须与\"压入样式颜色\"成对使用." 折叠 @嵌入式方法 = "">
    参数 弹出次数 <类型 = 整数 @默认值 = 1>
    {
        @ ImGui::PopStyleColor(@<弹出次数>)
    }

    方法 压入样式变量 <公开 静态 注释 = "在\"新建帧\"之后需要调用本方法修改一个\"小数\"变量的样式,必须与\"弹出样式变量\"成对使用." 折叠 @嵌入式方法 = "">
    参数 样式变量ID <类型 = IM样式标识符>
    参数 新值 <类型 = 单精度小数>
    {
        @ ImGui::PushStyleVar(static_cast<ImGuiStyleVar>(@<样式变量ID>), @<新值>)
    }

    方法 压入样式变量2 <公开 静态 注释 = "在\"新建帧\"之后需要调用本方法修改一个\"ImVec4\"变量的样式,必须与\"弹出样式变量\"成对使用." 折叠 @嵌入式方法 = "">
    参数 样式变量ID <类型 = IM样式标识符>
    参数 新值 <类型 = ImVec4>
    {
        @ ImGui::PushStyleVar(static_cast<ImGuiStyleVar>(@<样式变量ID>), @<新值>)
    }

    方法 弹出样式变量 <公开 静态 注释 = "必须与\"压入样式变量\"成对使用." 折叠 @嵌入式方法 = "">
    参数 弹出次数 <类型 = 整数 @默认值 = 1>
    {
        @ ImGui::PopStyleVar(@<弹出次数>)
    }

    方法 设置可停留焦点 <公开 静态 注释 = "可以选择是否让子语句体中创建的组件禁用可停留焦点(允许使用TAB/Shift+TAB循环切换焦点)." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::PopTabStop();\"">
    参数 是否可停留焦点 <类型 = 逻辑型 注释 = "默认情况下已启用可停留焦点">
    {
        @ ImGui::PushTabStop(static_cast<bool>(@<是否可停留焦点>));
    }

    方法 设置可重复按钮 <公开 静态 注释 = "可以选择是否让子语句体中创建的按钮启用\"重复\"模式." 注释 = "在\"重复\"模式下,按住\"按钮\"不放将会重复返回结果." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::PopButtonRepeat();\"">
    参数 是否可重复 <类型 = 逻辑型>
    {
        @ ImGui::PushButtonRepeat(static_cast<bool>(@<是否可重复>));
    }

    # 参数堆栈(当前窗口) | Parameters stacks (current window)

    方法 设置项目宽度 <公开 静态 注释 = "子语句体中创建的项目将统一为所指定的项目宽度."
            注释 = "push width of items for common large \"item+label\" widgets. >0.0f: width in pixels,"
            注释 = "<0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side)."
            折叠 隐藏值属性 = "0" @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::PopItemWidth();\"">
    参数 项目宽度 <类型 = 单精度小数>
    {
        @ ImGui::PushItemWidth(@<项目宽度>);
    }

    方法 置下一项目宽度 <公开 静态
            注释 = "set width of the _next_ common large \"item+label\" widget. >0.0f: width in pixels,"
            注释 = "<0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side)"
            折叠 @嵌入式方法 = "">
    参数 新项目宽度 <类型 = 单精度小数>
    {
        @ ImGui::SetNextItemWidth(@<新项目宽度>)
    }

    方法 计算项目宽度 <公开 静态 类型 = 单精度小数
            注释 = "width of item given pushed settings and current cursor position. NOT necessarily the width of last item unlike most \'Item\' functions."
            折叠 @嵌入式方法 = "">
    {
        @ ImGui::CalcItemWidth()
    }

    方法 设置文本换行位置 <公开 静态 注释 = "子语句体中创建的文本框将统一按指定的位置换行." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::PopTextWrapPos();\"">
    参数 换行位置 <类型 = 单精度小数 注释 = "小于0.0f: 不换行; 等于0.0f: 按窗口/列边缘换行; 大于0.0f: 按提供的位置换行.">
    {
        @ ImGui::PushTextWrapPos(@<换行位置>);
    }

    # 只读访问样式 | Style read access

    方法 取当前字体 <公开 静态 类型 = IM字体类 注释 = "返回当前字体" 折叠 @嵌入式方法 = "">
    {
        @ @dt<IM字体类>{ImGui::GetFont()}
    }

    方法 取字体大小 <公开 静态 类型 = 单精度小数 注释 = "获取基于当前字体的字体大小(等于像素高度),该大小应用了当前的缩放比例." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetFontSize()
    }

    方法 取字体白色纹理UV <公开 静态 类型 = ImVec2
            注释 = "get UV coordinate for a white pixel, useful to draw custom shapes via the ImDrawList API" 折叠
            @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetFontTexUvWhitePixel()}
    }

    方法 取32位颜色 <公开 静态 类型 = 整数
            注释 = "retrieve given style color with style alpha applied and optional extra alpha multiplier,"
            注释 = "packed as a 32-bit value suitable for ImDrawList" 折叠 @嵌入式方法 = "">
    参数 颜色ID <类型 = IM颜色标识符>
    参数 Alpha乘数 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ ImGui::GetColorU32(static_cast<ImGuiCol>(@<颜色ID>), @<Alpha乘数>)
    }

    方法 取32位颜色2 <公开 静态 类型 = 整数
            注释 = "retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList"
            折叠 @嵌入式方法 = "">
    参数 颜色 <类型 = ImVec4>
    {
        @ ImGui::GetColorU32(@<颜色>)
    }

    方法 取32位颜色3 <公开 静态 类型 = 整数
            注释 = "retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList"
            折叠 @嵌入式方法 = "">
    参数 颜色 <类型 = 整数>
    {
        @ ImGui::GetColorU32(@<颜色>)
    }

    方法 取样式颜色 <公开 静态 类型 = ImVec4
            注释 = "retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(),"
            注释 = "otherwise use GetColorU32() to get style color with style alpha baked in." 折叠 @嵌入式方法 = "">
    参数 颜色ID <类型 = IM颜色标识符>
    {
        @ @dt<ImVec4>{ImGui::GetStyleColorVec4(static_cast<ImGuiCol>(@<颜色ID>))}
    }

    # 光标位置 | Layout cursor positioning

    方法 取光标屏幕位置 <公开 静态 类型 = ImVec2 注释 = "返回绝对坐标的光标位置"
            注释 = "enerally top-left == GetMainViewport()->Pos == (0,0) in single viewport mode,"
            注释 = "and bottom-right == GetMainViewport()->Pos+Size == io.DisplaySize in single-viewport mode." 折叠
            @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetCursorScreenPos()}
    }

    方法 置光标屏幕位置 <公开 静态 注释 = "设置光标位置的绝对坐标" 折叠 @嵌入式方法 = "">
    参数 光标位置 <类型 = ImVec2>
    {
        @ ImGui::SetCursorScreenPos(@<光标位置>)
    }

    方法 取光标位置 <公开 静态 类型 = ImVec2 注释 = "返回相对于窗口坐标的光标位置" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetCursorPos()}
    }

    方法 取光标水平位置 <公开 静态 类型 = 单精度小数 注释 = "返回相对于窗口坐标的水平光标位置" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetCursorPosX()
    }

    方法 取光标垂直位置 <公开 静态 类型 = 单精度小数 注释 = "返回相对于窗口坐标的垂直光标位置" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetCursorPosY()
    }

    方法 置光标位置 <公开 静态 注释 = "设置相对于窗口坐标的光标位置" 折叠 @嵌入式方法 = "">
    参数 本地位置 <类型 = ImVec2>
    {
        @ ImGui::SetCursorPos(@<本地位置>)
    }

    方法 置光标水平位置 <公开 静态 折叠 @嵌入式方法 = "">
    参数 水平位置 <类型 = 单精度小数>
    {
        @ ImGui::SetCursorPosX(@<水平位置>)
    }

    方法 置光标垂直位置 <公开 静态 折叠 @嵌入式方法 = "">
    参数 垂直位置 <类型 = 单精度小数>
    {
        @ ImGui::SetCursorPosY(@<垂直位置>)
    }

    方法 取光标起始位置 <公开 静态 类型 = ImVec2 注释 = "返回相对于窗口坐标的初始光标位置" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetCursorStartPos()}
    }

    # 其他布局函数 | Other layout functions

    方法 分隔条 <公开 静态 注释 = "插入一个分隔条,通常是水平的,但在菜单栏或水平布局模式中会变成垂直分隔条." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::Separator()
    }

    方法 同一行 <公开 静态 注释 = "在小组件或分组框之间调用本方法,可以将它们水平布局." 折叠 @嵌入式方法 = "">
    参数 水平偏移位置 <类型 = 单精度小数 注释 = "等于0将位于上一项目的后面,不为0时对齐到指定的X轴坐标(窗口或分组框左边的相对坐标)" @默认值 = 0.0>
    参数 水平间距 <类型 = 单精度小数 注释 = "小于0时,若\"水平偏移位置\"等于0表示使用默认间距,若\"水平偏移位置\"不等于0则没有间距." 注释 = "本值大于等于0将强制执行指定的间距;"
            @默认值 = -1.0>
    {
        @ ImGui::SameLine(@<水平偏移位置>, @<水平间距>)
    }

    方法 换行 <公开 静态 注释 = "撤销\"同一行\",或者在水平布局上下文中强制换行." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::NewLine()
    }

    方法 添加间距 <公开 静态 注释 = "添加一个垂直间距" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::Spacing()
    }

    方法 伪项目 <公开 静态 注释 = "添加一个指定大小的伪项目,与\"隐身按钮\"不同,伪项目不能被鼠标点击或导航." 折叠 @嵌入式方法 = "">
    参数 尺寸 <类型 = ImVec2 注释 = "x为宽度,y为高度">
    {
        @ ImGui::Dummy(@<尺寸>)
    }

    方法 增加缩进 <公开 静态 注释 = "将内容的位置向右移动" 折叠 @嵌入式方法 = "">
    参数 缩进间距 <类型 = 单精度小数 注释 = "如果\"缩进间距\"小于等于0,则按\"style.IndentSpacing\"的大小移动,否则按提供的值移动." @默认值 = 0.0>
    {
        @ ImGui::Indent(@<缩进间距>)
    }

    方法 减少缩进 <公开 静态 注释 = "将内容的位置向左移动" 折叠 @嵌入式方法 = "">
    参数 缩进间距 <类型 = 单精度小数 注释 = "如果\"缩进间距\"小于等于0,则按\"style.IndentSpacing\"的大小移动,否则按提供的值移动." @默认值 = 0.0>
    {
        @ ImGui::Unindent(@<缩进间距>)
    }

    方法 分组框 <公开 静态 注释 = "创建一个分组框,在子语句体里创建的多个项目会最终被捕获为一个项目." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::EndGroup();\"">
    {
        @ ImGui::BeginGroup();
    }

    方法 文本对齐到框边距 <公开 静态 注释 = "将之后显示的文本基线与\"FramePadding.y\"垂直对齐,使其与常规带框的项目正确对齐." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::AlignTextToFramePadding()
    }

    方法 取文本行高 <公开 静态 类型 = 单精度小数 注释 = "返回文本的行高,约等于字体大小." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetTextLineHeight()
    }

    方法 取文本带间距行高 <公开 静态 类型 = 单精度小数 注释 = "返回两行连续文本之间的像素距离,约等于字体大小 + 项目垂直间距." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetTextLineHeightWithSpacing()
    }

    方法 取框体高度 <公开 静态 类型 = 单精度小数 注释 = "返回项目的框体高度,约等于字体大小 + 框体垂直边距 * 2." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetFrameHeight()
    }

    方法 取框体带间距高度 <公开 静态 类型 = 单精度小数 注释 = "返回两个连续行的带框窗口组件之间的像素距离,约等于字体大小 + 框垂直边距 *2 + 项目垂直间距." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetFrameHeightWithSpacing()
    }

    # ID堆栈/作用域 | ID stack/scopes

    方法 设置文本ID <公开 静态 注释 = "在子语句体内的项目中添加指定的文本ID,可用于快速区别不同项目的唯一ID." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::PopID();\"">
    参数 文本ID <注释 = "提供一个文本ID;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    {
        @ ImGui::PushID(*PivAny2U{@<文本ID>});
    }

    方法 设置整数ID <公开 静态 注释 = "在子语句体内的项目中添加指定的整数ID,可用于快速区别不同项目的唯一ID." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::PopID();\"">
    参数 整数ID <类型 = 整数>
    {
        @ ImGui::PushID(@<整数ID>);
    }

    方法 取文本ID <公开 静态 类型 = 整数 注释 = "使用所提供文本ID和整个ID堆栈的hash值,计算出唯一的ID." 折叠 @嵌入式方法 = "">
    参数 文本ID <注释 = "提供一个文本ID;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    {
        @ ImGui::GetID(@<文本ID>)
    }

    # 组件: 文本框 | Widgets: Text

    方法 无格式文本框 <公开 静态 注释 = "创建一个文本框,用于显示无格式的原生文本." 注释 = "本方法无内存复制和缓冲区大小限制,建议用于长文本." 折叠 @嵌入式方法 = "">
    参数 文本内容 <注释 = "提供显示在文本框中的文本内容;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    {
        @ ImGui::TextUnformatted(*PivAny2U{@<文本内容>})
    }

    方法 文本框 <公开 静态 注释 = "创建一个文本框,支持格式化文本." 折叠 隐藏值属性 = "0" @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 格式文本 <注释 = "提供显示在文本框中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::Text(*PivAny2U{@<格式文本>}, @<替换数据>)
    }

    方法 彩色文本框 <公开 静态 注释 = "创建一个文本框,用于显示带颜色的格式化文本." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 文本颜色 <类型 = ImVec4>
    参数 格式文本 <注释 = "提供显示在文本框中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::TextColored(@<文本颜色>, *PivAny2U{@<格式文本>}, @<替换数据>)
    }

    方法 被禁用文本框 <公开 静态 注释 = "创建一个显示为禁用状态的文本框,支持格式化文本." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 格式文本 <注释 = "提供显示在文本框中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::TextDisabled(*PivAny2U{@<格式文本>}, @<替换数据>)
    }

    方法 换行文本框 <公开 静态 注释 = "创建一段可以自动换行的文本框,支持格式化文本." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 格式文本 <注释 = "提供显示在文本框中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::TextWrapped(*PivAny2U{@<格式文本>}, @<替换数据>)
    }

    方法 标签文本框 <公开 静态 注释 = "创建一个带标签的文本框,支持格式化文本." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 标签文本 <注释 = "提供显示在组合框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 格式文本 <注释 = "提供显示在文本框中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::LabelText(*PivAny2U{@<标签文本>}, *PivAny2U{@<格式文本>}, @<替换数据>)
    }

    方法 项目符号文本框 <公开 静态 注释 = "创建一个带项目符号的文本框,支持格式化文本." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 格式文本 <注释 = "提供显示在文本框中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::BulletText(*PivAny2U{@<格式文本>}, @<替换数据>)
    }

    方法 分隔文本框 <公开 静态 注释 = "创建一个带水平分隔线的文本框,用于显示无格式的原生文本." 折叠 @嵌入式方法 = "">
    参数 文本内容 <注释 = "提供显示在文本框中的文本内容;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    {
        @ ImGui::SeparatorText(*PivAny2U{@<文本内容>})
    }

    # 组件: 主要 | Widgets: Main

    方法 按钮 <公开 静态 类型 = 逻辑型 注释 = "创建一个按钮组件,按钮被单击后返回真." 返回值注释 = "按钮被单击后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在按钮旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 按钮尺寸 <类型 = ImVec2 注释 = "提供按钮的宽高,留空为自动根据标签文本的长度调整宽度." @默认值 = 空对象>
    {
        @ ImGui::Button(*PivAny2U{@<标签文本>}, @<按钮尺寸>)
    }

    方法 小按钮 <公开 静态 类型 = 逻辑型 注释 = "创建一个框边距为0的小按钮组件,按钮被单击后返回真." 注释 = "小按钮适合嵌入到文本行中." 返回值注释 = "按钮被单击后返回真" 折叠
            @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在按钮旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    {
        @ ImGui::SmallButton(*PivAny2U{@<标签文本>})
    }

    方法 隐身按钮 <公开 静态 类型 = 逻辑型 注释 = "创建一个不可见的按钮组件,但它仍会占用窗口位置和响应按钮行为." 返回值注释 = "本返回值受\"按钮标志\"影响" 折叠 @嵌入式方法 = "">
    参数 文本ID <注释 = "提供组件的唯一文本ID,本ID不会显示在按钮中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 按钮尺寸 <类型 = ImVec2 注释 = "提供按钮的宽高">
    参数 按钮标志 <类型 = 整数 注释 = "按钮标志将影响返回值的结果" @默认值 = IM按钮标志.无>
    {
        @ ImGui::InvisibleButton(*PivAny2U{@<文本ID>}, @<按钮尺寸>, static_cast<ImGuiButtonFlags>(@<按钮标志>))
    }

    方法 箭头按钮 <公开 静态 类型 = 逻辑型 注释 = "创建一个箭头形状的按钮,可以选择箭头的方向." 返回值注释 = "按钮被单击后返回真" 折叠 @嵌入式方法 = "">
    参数 文本ID <注释 = "提供组件的唯一文本ID,本ID不会显示在按钮中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 箭头方向 <类型 = IM基本方向 注释 = "提供箭头的方向">
    {
        @ ImGui::ArrowButton(*PivAny2U{@<文本ID>}, static_cast<ImGuiDir>(@<箭头方向>))
    }

    方法 复选框 <公开 静态 类型 = 逻辑型 注释 = "创建一个复选框" 返回值注释 = "复选框被单击后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在复选框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 选中状态 <类型 = 逻辑型 注释 = "必须提供一个逻辑型变量,表示复选框的选中状态." @需求类型 = 可写入变量>
    {
        @ ImGui::Checkbox(*PivAny2U{@<标签文本>}, reinterpret_cast<bool*>(&@<选中状态>))
    }

    方法 标志复选框 <公开 静态 类型 = 逻辑型 注释 = "创建一个复选框,复选框被选中后,在\"当前标志\"中设置标志值,否则为取消设置标志值." 返回值注释 = "复选框被单击后返回真" 折叠
            @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在复选框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 当前标志 <类型 = 整数 注释 = "必须提供一个整数变量,复选框被单击后可能会更改变量的值." @需求类型 = 可写入变量>
    参数 标志值 <类型 = 整数 注释 = "提供一个标志值,复选框被选中时按位或赋值(当前标志 |= 标志值),取消选中时按位异或赋值(当前标志 ^= 标志值).">
    {
        @ ImGui::CheckboxFlags(*PivAny2U{@<标签文本>}, &@<当前标志>, @<标志值>)
    }

    方法 单选按钮 <公开 静态 类型 = 逻辑型 注释 = "创建一个单选按钮" 返回值注释 = "按钮被单击后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在按钮旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 是否选中 <类型 = 逻辑型>
    {
        @ ImGui::RadioButton(*PivAny2U{@<标签文本>}, static_cast<bool>(@<是否选中>))
    }

    方法 单选按钮Ex <公开 静态 类型 = 逻辑型 注释 = "创建一个单选按钮,提供提供的整数变量决定选中项." 返回值注释 = "按钮被单击后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在按钮旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 现行选中项目 <类型 = 整数 注释 = "必须提供一个整数变量,用来指定选中的单选按钮." @需求类型 = 可写入变量>
    参数 索引值 <类型 = 整数 注释 = "当前单选按钮的自定义索引值,当\"现行选中项目 == 索引值\",则选中当前按钮.">
    {
        @ ImGui::RadioButton(*PivAny2U{@<标签文本>}, &@<现行选中项目>, @<索引值>)
    }

    方法 进度条 <公开 静态 注释 = "创建一个进度条组件" 折叠 @嵌入式方法 = "">
    参数 进度 <类型 = 单精度小数 注释 = "提供当前的进度位置,范围[0.0-1.0].">
    参数 尺寸 <类型 = ImVec2 注释 = "提供进度条的像素尺寸,小于0.0将使用全部可用宽度/高度," 注释 = "等于0.0为默认的项目宽度/高度,大于0.0则使用提供的宽度/高度."
            @默认值 = 空对象>
    参数 覆盖文本 <类型 = 标准文本类U 注释 = "默认在进度条上显示如\"95%\"的当前进度文本,若提供了自定义的文本,将覆盖原来的进度文本." @默认值 = 空对象>
    {
        @ ImGui::ProgressBar(@<进度>, GET_ImVec2_MaybeNull(@<尺寸>, -FLT_MIN, 0), @<覆盖文本>.GetTextMaybeNull())
    }

    方法 项目符号 <公开 静态 注释 = "绘制一个小圆点并将光标保持在同一行." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::Bullet()
    }

    # 组件: 图片 | Widgets: Images

    方法 图片框 <公开 静态 注释 = "创建一个图片框组件" 折叠 @嵌入式方法 = "">
    参数 图片纹理ID <类型 = 长整数 注释 = "提供图片纹理ID,请使用\"IM_×××渲染器.加载图片××()\".">
    参数 图片尺寸 <类型 = ImVec2 注释 = "提供纹理图片的显示尺寸,单位为像素,本参数可以缩放图片.">
    参数 左上纹理坐标 <类型 = ImVec2 注释 = "提供纹理的左上坐标,默认的(0.0, 0.0)表示最左上角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 右下纹理坐标 <类型 = ImVec2 注释 = "提供纹理的右下坐标,默认的(1.0, 1.0)表示最右下角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 色调 <类型 = ImVec4 注释 = "默认为不添加色调" @默认值 = 空对象>
    参数 边框颜色 <类型 = ImVec4 注释 = "默认为黑色边框" @默认值 = 空对象>
    {
        @ ImGui::Image((ImTextureID)@<图片纹理ID>, @<图片尺寸>.data(), GET_ImVec2_MaybeNull(@<左上纹理坐标>, 0, 0), GET_ImVec2_MaybeNull(@<右下纹理坐标>, 1, 1),
        @              GET_ImVec4_MaybeNull(@<色调>, 1, 1, 1, 1), GET_ImVec4_MaybeNull(@<边框颜色>, 0, 0, 0, 0))
    }

    方法 图片按钮 <公开 静态 类型 = 逻辑型 注释 = "创建一个图片按钮组件" 返回值注释 = "按钮被单击后返回真" 折叠 @嵌入式方法 = "">
    参数 文本ID <注释 = "提供组件的唯一文本ID,本ID不会显示在按钮中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 图片纹理ID <类型 = 长整数 注释 = "提供图片纹理ID,请使用\"IM_×××渲染器.加载图片××()\".">
    参数 图片尺寸 <类型 = ImVec2 注释 = "提供纹理图片的显示尺寸,单位为像素,本参数可以缩放图片.">
    参数 左上纹理坐标 <类型 = ImVec2 注释 = "提供纹理的左上坐标,默认的(0.0, 0.0)表示最左上角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 右下纹理坐标 <类型 = ImVec2 注释 = "提供纹理的右下坐标,默认的(1.0, 1.0)表示最右下角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 背景颜色 <类型 = ImVec4 注释 = "默认为黑色背景" @默认值 = 空对象>
    参数 色调 <类型 = ImVec4 注释 = "默认为不添加色调" @默认值 = 空对象>
    {
        @ ImGui::ImageButton(*PivAny2U{@<文本ID>}, (ImTextureID)@<图片纹理ID>, @<图片尺寸>.data(), GET_ImVec2_MaybeNull(@<左上纹理坐标>, 0, 0), GET_ImVec2_MaybeNull(@<右下纹理坐标>, 1, 1),
        @                    GET_ImVec4_MaybeNull(@<背景颜色>, 0, 0, 0, 0), GET_ImVec4_MaybeNull(@<色调>, 1, 1, 1, 1))
    }

    # 组件: 组合框(下拉) | Widgets: Combo Box (Dropdown)

    方法 创建组合框 <公开 静态 注释 = "创建一个组合框(下拉列表框)组件,可以在子语句体中使用\"可选项\"自定义内容." 注释 = "创建失败将不执行子语句体中的代码." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndCombo();\\r\\n}\"">
    参数 标签文本 <注释 = "提供显示在组合框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 预览项目 <注释 = "提供组合框的默认项目文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 组合框标志 <类型 = 整数 注释 = "设置组合框的标志" @默认值 = IM组合框标志.无>
    {
        @ if (ImGui::BeginCombo(*PivAny2U{@<标签文本>}, *PivAny2U{@<预览项目>}, static_cast<ImGuiComboFlags>(@<组合框标志>)) == true)
    }

    方法 组合框 <公开 静态 类型 = 逻辑型 注释 = "创建一个组合框(下拉列表框)组件" 返回值注释 = "返回是否创建成功" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在组合框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 现行选中项 <类型 = 整数 注释 = "必须提供一个整数变量(必须确保其生命周期),用于返回当前选中的项目." 注释 = "如果值是\"项目数组\"的有效索引,则自动选中对应的项目."
            注释 = "变量值为-1或大于\"项目数组\"的成员数则不选中任何项目." @需求类型 = 可写入变量>
    参数 项目数组 <类型 = IM文本数组类 注释 = "提供所创建组合框的项目文本数组">
    参数 弹出框高度 <类型 = 整数 注释 = "提供组合框弹出列表框的高度,以项目数量为单位." 注释 = "比如8指的是8个项目的高度,实际项目数超过本值将显示滚动条." @默认值 = -1>
    {
        @ ImGui::Combo(*PivAny2U{@<标签文本>}, &@<现行选中项>, &@dt<IM文本数组类>::ItemGetter, IM_STRARRAY_PTR_AND_SIZE(@<项目数组>.pdata()), @<弹出框高度>)
    }

    # 组件: 拖动滑块 | Widgets: Drag Sliders

    方法 单浮点拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一个拖动框,可以拖动更改一个单精度小数变量的值." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 单精度小数 注释 = "必须提供单精度小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 单精度小数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0.0>
    参数 最大值 <类型 = 单精度小数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragFloat(*PivAny2U{@<标签文本>}, &@<值变量>, @<速度>, @<最小值>, @<最大值>,
        @                  u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 小数拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一个拖动框,可以拖动更改一个双精度小数变量的值." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 小数 注释 = "必须提供一个小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 小数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0.0>
    参数 最大值 <类型 = 小数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.6f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarT<double>(*PivAny2U{@<标签文本>}, ImGuiDataType_Double, &@<值变量>, @<速度>, @<最小值>,
        @                            @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 字节拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一个拖动框,可以拖动更改一个8位字节变量的值." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 字节 注释 = "必须提供一个字节变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 字节 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 字节 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarT<char>(*PivAny2U{@<标签文本>}, ImGuiDataType_S8, &@<值变量>, @<速度>, @<最小值>,
        @                          @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 短整数拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一个拖动框,可以拖动更改一个16位短整数变量的值." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 短整数 注释 = "必须提供一个短整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 短整数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 短整数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarT<short>(*PivAny2U{@<标签文本>}, ImGuiDataType_S16, &@<值变量>, @<速度>, @<最小值>,
        @                           @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 整数拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一个拖动框,可以拖动更改一个32位整数变量的值." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 整数 注释 = "必须提供一个整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 整数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 整数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragInt(*PivAny2U{@<标签文本>}, &@<值变量>, @<速度>, @<最小值>,
        @                @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 长整数拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一个拖动框,可以拖动更改一个64位长整数变量的值." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 长整数 注释 = "必须提供一个长整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 整数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 整数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%I64d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarT<INT64>(*PivAny2U{@<标签文本>}, ImGuiDataType_S64, &@<值变量>, @<速度>, @<最小值>,
        @                           @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 单浮点数组拖动框 <公开 静态 类型 = 逻辑型 注释 = "提供一个单精度小数数组,在一行内创建跟数组成员数相同数量的拖动框." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "数组变量的值被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "单精度小数 []" 注释 = "必须提供单精度小数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 单精度小数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0.0>
    参数 最大值 <类型 = 单精度小数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarTN<float>(*PivAny2U{@<标签文本>}, ImGuiDataType_Float, IM_ARRAY_AND_SIZE(@<数组变量>), @<速度>,
        @                            @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 小数数组拖动框 <公开 静态 类型 = 逻辑型 注释 = "提供一个双精度小数数组,在一行内创建跟数组成员数相同数量的拖动框." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "数组变量的值被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "小数 []" 注释 = "必须提供一个小数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 小数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0.0>
    参数 最大值 <类型 = 小数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.6f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarTN<double>(*PivAny2U{@<标签文本>}, ImGuiDataType_Double, IM_ARRAY_AND_SIZE(@<数组变量>), @<速度>,
        @                             @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 字节数组拖动框 <公开 静态 类型 = 逻辑型 注释 = "提供一个字节数组,在一行内创建跟数组成员数相同数量的拖动框." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "数组变量的值被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "字节 []" 注释 = "必须提供一个字节基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 字节 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 字节 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarTN<char>(*PivAny2U{@<标签文本>}, ImGuiDataType_S8, IM_ARRAY_AND_SIZE(@<数组变量>), @<速度>,
        @                           @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 短整数数组拖动框 <公开 静态 类型 = 逻辑型 注释 = "提供一个短整数数组,在一行内创建跟数组成员数相同数量的拖动框." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "数组变量的值被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "短整数 []" 注释 = "必须提供一个短整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 短整数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 短整数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarTN<short>(*PivAny2U{@<标签文本>}, ImGuiDataType_S16, IM_ARRAY_AND_SIZE(@<数组变量>), @<速度>,
        @                            @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 整数数组拖动框 <公开 静态 类型 = 逻辑型 注释 = "提供一个整数数组,在一行内创建跟数组成员数相同数量的拖动框." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "数组变量的值被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "整数 []" 注释 = "必须提供一个整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 整数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 整数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarTN<int>(*PivAny2U{@<标签文本>}, ImGuiDataType_S32, IM_ARRAY_AND_SIZE(@<数组变量>), @<速度>,
        @                          @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 长整数数组拖动框 <公开 静态 类型 = 逻辑型 注释 = "提供一个长整数数组,在一行内创建跟数组成员数相同数量的拖动框." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "数组变量的值被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "长整数 []" 注释 = "必须提供一个长整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 长整数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 长整数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%I64d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarTN<INT64>(*PivAny2U{@<标签文本>}, ImGuiDataType_S64, IM_ARRAY_AND_SIZE(@<数组变量>), @<速度>,
        @                            @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 ImVec2拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一行两个拖动框,可以拖动更改ImVec2中两个成员值." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "数组变量的值被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数据变量 <类型 = ImVec2 注释 = "必须提供一个ImVec2变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 单精度小数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0.0>
    参数 最大值 <类型 = 单精度小数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarTN<float>(*PivAny2U{@<标签文本>}, ImGuiDataType_Float, reinterpret_cast<float*>(@<数据变量>.pdata()), 2, @<速度>,
        @                            @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 ImVec4拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一行四个拖动框,可以拖动更改ImVec4中四个成员值." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "数组变量的值被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数据变量 <类型 = ImVec4 注释 = "必须提供一个ImVec4变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 单精度小数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0.0>
    参数 最大值 <类型 = 单精度小数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarTN<float>(*PivAny2U{@<标签文本>}, ImGuiDataType_Float, reinterpret_cast<float*>(@<数据变量>.pdata()), 4, @<速度>,
        @                            @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 单浮点范围拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一组两个拖动框,可以拖动更改两个单精度小数变量的值,其中第一个值始终不大于第二个值."
            注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值." 返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 当前较小值 <类型 = 单精度小数 注释 = "必须提供单精度小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 当前较大值 <类型 = 单精度小数 注释 = "必须提供单精度小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 单精度小数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0.0>
    参数 最大值 <类型 = 单精度小数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0.0>
    参数 较小值格式 <类型 = 文本型 注释 = "较小值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 较大值格式 <类型 = 文本型 注释 = "较大值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.始终限制范围>
    {
        @ ImGui::DragFloatRange2(*PivAny2U{@<标签文本>}, &@<当前较小值>, &@<当前较大值> @<速度>, @<最小值>, @<最大值>,
        @                        u8@sn<quot>@pvpt<较小值格式>@sn<quot>, u8@sn<quot>@pvpt<较大值格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 整数范围拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一组两个拖动框,可以拖动更改两个整数变量的值,其中第一个值始终不大于第二个值."
            注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值." 返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 当前较小值 <类型 = 整数 注释 = "必须提供一个整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 当前较大值 <类型 = 整数 注释 = "必须提供一个整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 整数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 整数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 较小值格式 <类型 = 文本型 注释 = "较小值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 较大值格式 <类型 = 文本型 注释 = "较大值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.始终限制范围>
    {
        @ ImGui::DragIntRange2(*PivAny2U{@<标签文本>}, &@<当前较小值>, &@<当前较大值>, @<速度>, @<最小值>, @<最大值>,
        @                      u8@sn<quot>@pvpt<较小值格式>@sn<quot>, u8@sn<quot>@pvpt<较大值格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    # 组件: 常规滑块条 | Widgets: Regular Sliders

    方法 单浮点滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个滑块条,可以在指定的的范围内拖动更改一个单精度小数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 单精度小数 注释 = "必须提供单精度小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 单精度小数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 单精度小数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderFloat(*PivAny2U{@<标签文本>}, &@<值变量>, @<最小值>, @<最大值>,
        @                    u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 小数滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个滑块条,可以在指定的的范围内拖动更改一个双精度小数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 小数 注释 = "必须提供一个小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 小数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 小数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.6f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarT<double>(*PivAny2U{@<标签文本>}, ImGuiDataType_Double, &@<值变量>, @<最小值>, @<最大值>,
        @                              u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 字节滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个滑块条,可以在指定的的范围内拖动更改一个8位字节变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 字节 注释 = "必须提供一个字节变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 字节 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 字节 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarT<char>(*PivAny2U{@<标签文本>}, ImGuiDataType_S8, &@<值变量>, @<最小值>, @<最大值>,
        @                            u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 短整数滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个滑块条,可以在指定的的范围内拖动更改一个16位短整数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 短整数 注释 = "必须提供一个短整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 短整数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 短整数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarT<short>(*PivAny2U{@<标签文本>}, ImGuiDataType_S16, &@<值变量>, @<最小值>, @<最大值>,
        @                             u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 整数滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个滑块条,可以在指定的的范围内拖动更改一个32位整数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 整数 注释 = "必须提供一个整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 整数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 整数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderInt(*PivAny2U{@<标签文本>}, &@<值变量>, @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 长整数滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个滑块条,可以在指定的的范围内拖动更改一个64位长整数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 长整数 注释 = "必须提供一个长整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 长整数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 长整数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%I64d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarT<INT64>(*PivAny2U{@<标签文本>}, ImGuiDataType_S64, &@<值变量>, @<最小值>, @<最大值>,
        @                             u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 角度滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个滑块条,可以在指定的的范围内拖动更改一个单精度小数角度的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 单精度小数 注释 = "必须提供单精度小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小角度 <类型 = 单精度小数 注释 = "滑块位于最左边时的数值" @默认值 = -360.0>
    参数 最大角度 <类型 = 单精度小数 注释 = "滑块位于最右边时的数值" @默认值 = +360.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.0f°">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderAngle(*PivAny2U{@<标签文本>}, &@<值变量>, @<最小角度>, @<最大角度>,
        @                    u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 单浮点数组滑块条 <公开 静态 类型 = 逻辑型 注释 = "提供一个单精度小数数组,在一行内创建跟数组成员数相同数量的滑块,可以在指定的的范围内拖动更改成员值."
            注释 = "注: Ctrl+点击滑块可以切换到手动输入数值." 返回值注释 = "数组变量的值被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "单精度小数 []" 注释 = "必须提供单精度小数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 单精度小数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 单精度小数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarTN<float>(*PivAny2U{@<标签文本>}, ImGuiDataType_Float, IM_ARRAY_AND_SIZE(@<数组变量>), @<最小值>, @<最大值>,
        @                              u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 小数数组滑块条 <公开 静态 类型 = 逻辑型 注释 = "提供一个双精度小数数组,在一行内创建跟数组成员数相同数量的滑块,可以在指定的的范围内拖动更改成员值."
            注释 = "注: Ctrl+点击滑块可以切换到手动输入数值." 返回值注释 = "数组变量的值被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "小数 []" 注释 = "必须提供一个小数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 小数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 小数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.6f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarTN<double>(*PivAny2U{@<标签文本>}, ImGuiDataType_Double, IM_ARRAY_AND_SIZE(@<数组变量>), @<最小值>, @<最大值>,
        @                               u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 字节数组滑块条 <公开 静态 类型 = 逻辑型 注释 = "提供一个字节数组,在一行内创建跟数组成员数相同数量的滑块,可以在指定的的范围内拖动更改成员值."
            注释 = "注: Ctrl+点击滑块可以切换到手动输入数值." 返回值注释 = "数组变量的值被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "字节 []" 注释 = "必须提供一个字节基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 字节 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 字节 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarTN<char>(*PivAny2U{@<标签文本>}, ImGuiDataType_S8, IM_ARRAY_AND_SIZE(@<数组变量>), @<最小值>, @<最大值>,
        @                             u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 短整数数组滑块条 <公开 静态 类型 = 逻辑型 注释 = "提供一个短整数数组,在一行内创建跟数组成员数相同数量的滑块,可以在指定的的范围内拖动更改成员值."
            注释 = "注: Ctrl+点击滑块可以切换到手动输入数值." 返回值注释 = "数组变量的值被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "短整数 []" 注释 = "必须提供一个短整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 短整数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 短整数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarTN<short>(*PivAny2U{@<标签文本>}, ImGuiDataType_S16, IM_ARRAY_AND_SIZE(@<数组变量>), @<最小值>, @<最大值>,
        @                              u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 整数数组滑块条 <公开 静态 类型 = 逻辑型 注释 = "提供一个整数数组,在一行内创建跟数组成员数相同数量的滑块,可以在指定的的范围内拖动更改成员值."
            注释 = "注: Ctrl+点击滑块可以切换到手动输入数值." 返回值注释 = "数组变量的值被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "整数 []" 注释 = "必须提供一个整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 整数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 整数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarTN<int>(*PivAny2U{@<标签文本>}, ImGuiDataType_S32, IM_ARRAY_AND_SIZE(@<数组变量>), @<最小值>, @<最大值>,
        @                            u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 长整数数组滑块条 <公开 静态 类型 = 逻辑型 注释 = "提供一个长整数数组,在一行内创建跟数组成员数相同数量的滑块,可以在指定的的范围内拖动更改成员值."
            注释 = "注: Ctrl+点击滑块可以切换到手动输入数值." 返回值注释 = "数组变量的值被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "长整数 []" 注释 = "必须提供一个长整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 长整数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 长整数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%I64d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarTN<INT64>(*PivAny2U{@<标签文本>}, ImGuiDataType_S64, IM_ARRAY_AND_SIZE(@<数组变量>), @<最小值>,
        @                              @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 ImVec2滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一行两个滑块,可以在指定的的范围内拖动更改ImVec2中两个成员值."
            注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值." 返回值注释 = "数组变量的值被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数据变量 <类型 = ImVec2 注释 = "必须提供一个ImVec2变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 单精度小数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 单精度小数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarTN<float>(*PivAny2U{@<标签文本>}, ImGuiDataType_Float, reinterpret_cast<float*>(@<数据变量>.pdata()), 2, @<最小值>, @<最大值>,
        @                              u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 ImVec4滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一行四个滑块,可以在指定的的范围内拖动更改ImVec4中四个成员值."
            注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值." 返回值注释 = "数组变量的值被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数据变量 <类型 = ImVec4 注释 = "必须提供一个ImVec4变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 单精度小数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 单精度小数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarTN<float>(*PivAny2U{@<标签文本>}, ImGuiDataType_Float, reinterpret_cast<float*>(@<数据变量>.pdata()), 4, @<最小值>,
        @                              @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 单浮点垂直滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个垂直滑块条,可以在指定的的范围内拖动更改一个32位整数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 尺寸 <类型 = ImVec2 注释 = "提供滑块的宽度和高度">
    参数 值变量 <类型 = 单精度小数 注释 = "必须提供单精度小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 单精度小数 注释 = "滑块位于最上边时的数值">
    参数 最大值 <类型 = 单精度小数 注释 = "滑块位于最下边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::VSliderFloat(*PivAny2U{@<标签文本>}, @<尺寸>, &@<值变量>, @<最小值>, @<最大值>,
        @                     u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 小数垂直滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个垂直滑块条,可以在指定的的范围内拖动更改一个32位整数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 尺寸 <类型 = ImVec2 注释 = "提供滑块的宽度和高度">
    参数 值变量 <类型 = 小数 注释 = "必须提供一个小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 小数 注释 = "滑块位于最上边时的数值">
    参数 最大值 <类型 = 小数 注释 = "滑块位于最下边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.6f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::VSliderScalarT<double>(*PivAny2U{@<标签文本>}, @<尺寸>, ImGuiDataType_Double, &@<值变量>, @<最小值>,
        @                               @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 字节垂直滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个垂直滑块条,可以在指定的的范围内拖动更改一个8位字节变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 尺寸 <类型 = ImVec2 注释 = "提供滑块的宽度和高度">
    参数 值变量 <类型 = 字节 注释 = "必须提供一个字节变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 字节 注释 = "滑块位于最上边时的数值">
    参数 最大值 <类型 = 字节 注释 = "滑块位于最下边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::VSliderScalarT<char>(*PivAny2U{@<标签文本>}, @<尺寸>, ImGuiDataType_S8, &@<值变量>, @<最小值>,
        @                             @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 短整数垂直滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个垂直滑块条,可以在指定的的范围内拖动更改一个16位短整数变量的值."
            注释 = "注: Ctrl+点击滑块可以切换到手动输入数值." 返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 尺寸 <类型 = ImVec2 注释 = "提供滑块的宽度和高度">
    参数 值变量 <类型 = 短整数 注释 = "必须提供一个短整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 短整数 注释 = "滑块位于最上边时的数值">
    参数 最大值 <类型 = 短整数 注释 = "滑块位于最下边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::VSliderScalarT<short>(*PivAny2U{@<标签文本>}, @<尺寸>, ImGuiDataType_S16, &@<值变量>, @<最小值>,
        @                              @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 整数垂直滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个垂直滑块条,可以在指定的的范围内拖动更改一个32位整数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 尺寸 <类型 = ImVec2 注释 = "提供滑块的宽度和高度">
    参数 值变量 <类型 = 整数 注释 = "必须提供一个整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 整数 注释 = "滑块位于最上边时的数值">
    参数 最大值 <类型 = 整数 注释 = "滑块位于最下边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::VSliderInt(*PivAny2U{@<标签文本>}, @<尺寸>, &@<值变量>, @<最小值>, @<最大值>,
        @                   u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    方法 长整数垂直滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个垂直滑块条,可以在指定的的范围内拖动更改一个32位整数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 尺寸 <类型 = ImVec2 注释 = "提供滑块的宽度和高度">
    参数 值变量 <类型 = 长整数 注释 = "必须提供一个长整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 长整数 注释 = "滑块位于最上边时的数值">
    参数 最大值 <类型 = 长整数 注释 = "滑块位于最下边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%I64d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::VSliderScalarT<INT64>(*PivAny2U{@<标签文本>}, @<尺寸>, ImGuiDataType_S64, &@<值变量>, @<最小值>,
        @                              @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiSliderFlags>(@<滑块标志>))
    }

    # 组件: 键盘输入  | Widgets: Input with Keyboard

    方法 文本输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个文本输入框,输入的UTF-8编码内容将保存在\"文本内容\"参数中."
            注释 = "注: \"标准文本类U\"封装了大量文本操作功能,若想转换到文本型,可以调用\"到文本型\"." 返回值注释 = "文本内容被更改时返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 文本内容 <类型 = 标准文本类U 注释 = "必须提供一个\"标准文本类U\"变量,并确保其生命周期,输入的内容将保存在此变量中." @需求类型 = 可写入变量>
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputText(*PivAny2U{@<标签文本>}, @<文本内容>.pdata(), static_cast<ImGuiInputTextFlags>(@<输入框标志>), nullptr, nullptr)
    }

    方法 多行文本输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个多行文本输入框,输入的UTF-8编码内容将保存在\"文本内容\"参数中."
            注释 = "注: \"标准文本类U\"封装了大量文本操作功能,若想转换到文本型,可以调用\"到文本型\"." 返回值注释 = "文本内容被更改时返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 文本内容 <类型 = 标准文本类U 注释 = "必须提供一个\"标准文本类U\"变量,并确保其生命周期,输入的内容将保存在此变量中." @需求类型 = 可写入变量>
    参数 尺寸 <类型 = ImVec2 注释 = "提供输入框的尺寸" @默认值 = 空对象>
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputTextMultiline(*PivAny2U{@<标签文本>}, @<文本内容>.pdata(), @<尺寸>, static_cast<ImGuiInputTextFlags>(@<输入框标志>), nullptr, nullptr)
    }

    方法 提示输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个文本输入框,未输入内容时将以灰色显示提示文本,输入的UTF-8编码内容将保存在\"文本内容\"参数中."
            注释 = "注: \"标准文本类U\"封装了大量文本操作功能,若想转换到文本型,可以调用\"到文本型\"." 返回值注释 = "文本内容被更改时返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 提示文本 <注释 = "如果输入框未输入任何内容,则显示本提示内容;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型." @匹配类型 = 通用型>
    参数 文本内容 <类型 = 标准文本类U 注释 = "必须提供一个\"标准文本类U\"变量,并确保其生命周期,输入的内容将保存在此变量中." @需求类型 = 可写入变量>
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputTextWithHint(*PivAny2U{@<标签文本>}, *PivAny2U{@<提示文本>}, @<文本内容>.pdata(), static_cast<ImGuiInputTextFlags>(@<输入框标志>), nullptr, nullptr)
    }

    方法 单浮点输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个输入框,用于输入单精度小数值,可选添加两个增加按钮." 返回值注释 = "值被改变时返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 单精度小数 注释 = "必须提供单精度小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 单精度小数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0.0>
    参数 快速增减量 <类型 = 单精度小数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputFloat(*PivAny2U{@<标签文本>}, &@<值变量>, @<增减量>, @<快速增减量>,
        @                   u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiInputTextFlags>(@<输入框标志>))
    }

    方法 小数输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个输入框,用于输入双精度小数值,可选添加两个增加按钮." 返回值注释 = "值被改变时返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 小数 注释 = "必须提供一个小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 小数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0.0>
    参数 快速增减量 <类型 = 小数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.6f">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputDouble(*PivAny2U{@<标签文本>}, &@<值变量>, @<增减量>, @<快速增减量>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiInputTextFlags>(@<输入框标志>))
    }

    方法 字节输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个输入框,用于输入8位字节值,可选添加两个增加按钮." 返回值注释 = "值被改变时返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 字节 注释 = "必须提供一个小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 字节 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0>
    参数 快速增减量 <类型 = 整数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarT<char>(*PivAny2U{@<标签文本>}, ImGuiDataType_S8, &@<值变量>, @<增减量>, @<快速增减量>,
        @                           u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiInputTextFlags>(@<输入框标志>))
    }

    方法 短整数输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个输入框,用于输入16位短整数值,可选添加两个增加按钮." 返回值注释 = "值被改变时返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 整数 注释 = "必须提供一个小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 整数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0>
    参数 快速增减量 <类型 = 整数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarT<short>(*PivAny2U{@<标签文本>}, ImGuiDataType_S16, &@<值变量>, @<增减量>, @<快速增减量>,
        @                            u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiInputTextFlags>(@<输入框标志>))
    }

    方法 整数输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个输入框,用于输入32位整数值,可选添加两个增加按钮." 返回值注释 = "值被改变时返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 整数 注释 = "必须提供一个小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 整数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0>
    参数 快速增减量 <类型 = 整数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." 注释 = "输入十六进制文本时请使用\"%08X\""
            @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputInt(*PivAny2U{@<标签文本>}, &@<值变量>, @<增减量>, @<快速增减量>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiInputTextFlags>(@<输入框标志>))
    }

    方法 长整数输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个输入框,用于输入62位长整数值,可选添加两个增加按钮." 返回值注释 = "值被改变时返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 长整数 注释 = "必须提供一个小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 长整数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0>
    参数 快速增减量 <类型 = 长整数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%I64d">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarT<INT64>(*PivAny2U{@<标签文本>}, ImGuiDataType_S64, &@<值变量>, @<增减量>, @<快速增减量>,
        @                            u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiInputTextFlags>(@<输入框标志>))
    }

    方法 单浮点数组输入框 <公开 静态 类型 = 逻辑型 注释 = "提供一个单精度小数数组,在一行内创建跟数组成员数相同数量的输入框." 返回值注释 = "成员值被改变时返回真" 折叠
            @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "单精度小数 []" 注释 = "必须提供单精度小数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 单精度小数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0.0>
    参数 快速增减量 <类型 = 单精度小数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarTN<float>(*PivAny2U{@<标签文本>}, ImGuiDataType_Float, IM_ARRAY_AND_SIZE(@<数组变量>), @<增减量>, @<快速增减量>,
        @                             u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiInputTextFlags>(@<输入框标志>))
    }

    方法 小数数组输入框 <公开 静态 类型 = 逻辑型 注释 = "提供一个双精度小数数组,在一行内创建跟数组成员数相同数量的输入框." 返回值注释 = "成员值被改变时返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "小数 []" 注释 = "必须提供一个小数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 小数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0.0>
    参数 快速增减量 <类型 = 小数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.6f">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarTN<double>(*PivAny2U{@<标签文本>}, ImGuiDataType_Double, IM_ARRAY_AND_SIZE(@<数组变量>), @<增减量>, @<快速增减量>,
        @                              u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiInputTextFlags>(@<输入框标志>))
    }

    方法 字节数组输入框 <公开 静态 类型 = 逻辑型 注释 = "提供一个字节数组,在一行内创建跟数组成员数相同数量的输入框." 返回值注释 = "成员值被改变时返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "字节 []" 注释 = "必须提供一个字节基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 字节 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0>
    参数 快速增减量 <类型 = 字节 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarTN<char>(*PivAny2U{@<标签文本>}, ImGuiDataType_S8, IM_ARRAY_AND_SIZE(@<数组变量>), @<增减量>, @<快速增减量>,
        @                            u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiInputTextFlags>(@<输入框标志>))
    }

    方法 短整数数组输入框 <公开 静态 类型 = 逻辑型 注释 = "提供一个短整数数组,在一行内创建跟数组成员数相同数量的输入框." 返回值注释 = "成员值被改变时返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "短整数 []" 注释 = "必须提供一个短整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 短整数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0>
    参数 快速增减量 <类型 = 短整数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarTN<short>(*PivAny2U{@<标签文本>}, ImGuiDataType_S16, IM_ARRAY_AND_SIZE(@<数组变量>), @<增减量>, @<快速增减量>,
        @                             u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiInputTextFlags>(@<输入框标志>))
    }

    方法 整数数组输入框 <公开 静态 类型 = 逻辑型 注释 = "提供一个整数数组,在一行内创建跟数组成员数相同数量的输入框." 返回值注释 = "成员值被改变时返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "整数 []" 注释 = "必须提供一个整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 整数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0>
    参数 快速增减量 <类型 = 整数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarTN<int>(*PivAny2U{@<标签文本>}, ImGuiDataType_S32, IM_ARRAY_AND_SIZE(@<数组变量>), @<增减量>, @<快速增减量>,
        @                           u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiInputTextFlags>(@<输入框标志>))
    }

    方法 长整数数组输入框 <公开 静态 类型 = 逻辑型 注释 = "提供一个长整数数组,在一行内创建跟数组成员数相同数量的输入框." 返回值注释 = "成员值被改变时返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "长整数 []" 注释 = "必须提供一个长整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 长整数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0>
    参数 快速增减量 <类型 = 长整数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%I64d">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarTN<INT64>(*PivAny2U{@<标签文本>}, ImGuiDataType_S64, IM_ARRAY_AND_SIZE(@<数组变量>), @<增减量>, @<快速增减量>,
        @                             u8@sn<quot>@pvpt<显示格式>@sn<quot>, static_cast<ImGuiInputTextFlags>(@<输入框标志>))
    }

    # 组件: 颜色编辑器/拾色器 | Widgets: Color Editor/Picker

    方法 颜色编辑器RGB <公开 静态 类型 = 逻辑型 注释 = "创建一个颜色编辑框,可以设置RGB颜色."
            注释 = "注: 本方法采用ImVec4来表示颜色,内含4个单精度小数,每个值的有效范围是(0.0-1.0),对应0-255的色值." 返回值注释 = "颜色被更改后返回真" 折叠
            @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在颜色编辑器旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 颜色 <类型 = ImVec4 注释 = "必须提供一个变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 颜色编辑标志 <类型 = 整数 注释 = "请使用\"IM颜色编辑标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM颜色编辑标志.无>
    {
        @ ImGui::ColorEdit3(*PivAny2U{@<标签文本>}, reinterpret_cast<float*>(@<颜色>.pdata()), static_cast<ImGuiColorEditFlags>(@<颜色编辑标志>))
    }

    方法 颜色编辑器RGBA <公开 静态 类型 = 逻辑型 注释 = "创建一个颜色编辑框,可以设置RGBA颜色."
            注释 = "注: 本方法采用ImVec4来表示颜色,内含4个单精度小数,每个值的有效范围是(0.0-1.0),对应0-255的色值." 返回值注释 = "颜色被更改后返回真" 折叠
            @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在颜色编辑器旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 颜色 <类型 = ImVec4 注释 = "必须提供一个变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 颜色编辑标志 <类型 = 整数 注释 = "请使用\"IM颜色编辑标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM颜色编辑标志.无>
    {
        @ ImGui::ColorEdit4(*PivAny2U{@<标签文本>}, reinterpret_cast<float*>(@<颜色>.pdata()), static_cast<ImGuiColorEditFlags>(@<颜色编辑标志>))
    }

    方法 颜色选取器RGB <公开 静态 类型 = 逻辑型 注释 = "创建一个颜色选取器,可以选取RGB颜色."
            注释 = "注: 本方法采用ImVec4来表示颜色,内含4个单精度小数,每个值的有效范围是(0.0-1.0),对应0-255的色值." 返回值注释 = "颜色被更改后返回真" 折叠
            @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在颜色选取器旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 选取颜色 <类型 = ImVec4 注释 = "必须提供一个变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 颜色编辑标志 <类型 = 整数 注释 = "请使用\"IM颜色编辑标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM颜色编辑标志.无>
    {
        @ ImGui::ColorPicker3(*PivAny2U{@<标签文本>}, reinterpret_cast<float*>(@<选取颜色>.pdata()), static_cast<ImGuiColorEditFlags>(@<颜色编辑标志>))
    }

    方法 颜色选取器RGBA <公开 静态 类型 = 逻辑型 注释 = "创建一个颜色选取器,可以选取RGBA颜色."
            注释 = "注: 本方法采用ImVec4来表示颜色,内含4个单精度小数,每个值的有效范围是(0.0-1.0),对应0-255的色值." 返回值注释 = "颜色被更改后返回真" 折叠
            @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在颜色选取器旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 选取颜色 <类型 = ImVec4 注释 = "选取的颜色保存在此参数中,必须提供一个变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 参考颜色 <类型 = ImVec4 注释 = "提供一个参考颜色,例如原来的颜色,可以留空." @默认值 = 空对象>
    参数 颜色编辑标志 <类型 = 整数 注释 = "请使用\"IM颜色编辑标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM颜色编辑标志.无>
    {
        @ ImGui::ColorPicker4(*PivAny2U{@<标签文本>}, reinterpret_cast<float*>(@<选取颜色>.pdata()), static_cast<ImGuiColorEditFlags>(@<颜色编辑标志>), reinterpret_cast<float*>(@<参考颜色>.GetPtr()))
    }

    方法 色板按钮 <公开 静态 类型 = 逻辑型 注释 = "创建一个色板按钮,鼠标在按钮上悬停时会显示颜色的详细信息."
            注释 = "注: 本方法采用ImVec4来表示颜色,内含4个单精度小数,每个值的有效范围是(0.0-1.0),对应0-255的色值." 返回值注释 = "按钮被单击后返回真" 折叠
            @嵌入式方法 = "">
    参数 描述文本 <注释 = "提供色板的描述文本,会显示在悬停提示框中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 颜色 <类型 = ImVec4 注释 = "选取的颜色保存在此参数中,必须提供一个变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 颜色编辑标志 <类型 = 整数 注释 = "请使用\"IM颜色编辑标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM颜色编辑标志.无>
    参数 尺寸 <类型 = ImVec2 注释 = "提供按钮的尺寸,留空使用默认尺寸." @默认值 = 空对象>
    {
        @ ImGui::ColorButton(*PivAny2U{@<描述文本>}, @<颜色>, static_cast<ImGuiColorEditFlags>(@<颜色编辑标志>), @<尺寸>)
    }

    方法 置颜色编辑选项 <公开 静态 注释 = "如果你想自定义默认格式和选取类型,请在新建帧之前初始化当前选项." 折叠 @嵌入式方法 = "">
    参数 颜色编辑标志 <类型 = 整数 注释 = "请使用\"IM颜色编辑标志\"中的常量,可以使用\"连续位或\"组合多个标志.">
    {
        @ ImGui::SetColorEditOptions(static_cast<ImGuiColorEditFlags>(@<颜色编辑标志>))
    }

    # 组件: 树结构 | Widgets: Trees

    方法 创建树节点 <公开 静态 注释 = "创建一个可以展开和折叠的树节点,可以在子语句体内添加组件." 注释 = "树节点被折叠时不执行子语句体中的代码." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::TreePop();\\r\\n}\"">
    参数 标签文本 <注释 = "提供显示在树节点上的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 树节点标志 <类型 = 整数 注释 = "请使用\"IM树节点标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM树节点标志.无>
    {
        @ if (ImGui::TreeNodeEx(*PivAny2U{@<标签文本>}, static_cast<ImGuiTreeNodeFlags>(@<树节点标志>)) == true)
    }

    方法 创建树节点Ex <公开 静态 注释 = "创建一个可以展开和折叠的树节点,可以在子语句体内添加组件." 注释 = "树节点被折叠时不执行子语句体中的代码." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::TreePop();\\r\\n}\"">
    参数 文本ID <注释 = "提供组件的唯一文本ID,本ID不会显示在组件标签中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 树节点标志 <类型 = 整数 注释 = "请使用\"IM树节点标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM树节点标志.无>
    参数 格式文本 <注释 = "提供显示在树节点标签中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ if (ImGui::TreeNodeEx(*PivAny2U{@<文本ID>}, static_cast<ImGuiTreeNodeFlags>(@<树节点标志>), *PivAny2U{@<格式文本>}, @<替换数据>) == true)
    }

    方法 取树节点和标签间距 <公开 静态 类型 = 单精度小数 注释 = "获取\"树节点/项目符号\"和标签之间的距离" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetTreeNodeToLabelSpacing()
    }

    方法 可折叠标题 <公开 静态 类型 = 逻辑型 注释 = "创建一个可折叠的标题,鼠标经过会有高亮显示." 返回值注释 = "当标题被展开时返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在折叠式标题上的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 打开状态 <类型 = 逻辑型类 注释 = "本参数非空将在标题右边显示一个关闭按钮,单击按钮会删掉本标题并将本参数的逻辑值设置为假." @默认值 = 空对象>
    参数 树节点标志 <类型 = 整数 注释 = "请使用\"IM树节点标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM树节点标志.无>
    {
        @ ImGui::CollapsingHeader(*PivAny2U{@<标签文本>}, piv::GetBaseDataPtr<bool*>(@<打开状态>), static_cast<ImGuiTreeNodeFlags>(@<树节点标志>))
    }

    方法 置下一项目展开 <公开 静态 注释 = "设置下一个\"树节点/可折叠标题\"的展开/折叠状态." 折叠 @嵌入式方法 = "">
    参数 是否展开 <类型 = 逻辑型 注释 = "真为展开,假为折叠">
    参数 执行条件 <类型 = IM执行条件 注释 = "设置本方法的执行条件" @默认值 = IM执行条件.无>
    {
        @ ImGui::SetNextItemOpen(static_cast<bool>(@<是否展开>), static_cast<ImGuiCond>(@<执行条件>))
    }

    # 组件: 可选项 | Widgets: Selectables

    方法 可选项 <公开 静态 类型 = 逻辑型 注释 = "创建一个可选择的项目(悬停时会高亮显示,选中后会变成另一种颜色)." 注释 = "本方法创建的选项,单击后不能切换选中状态,需要另外写代码实现."
            返回值注释 = "项目被单击时返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供可选项的文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 是否选中 <类型 = 逻辑型 注释 = "指定当前是否被选中" @默认值 = 假>
    参数 可选项标志 <类型 = 整数 注释 = "请使用\"IM可选项标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM可选项标志.无>
    参数 尺寸 <类型 = ImVec2 注释 = "x等于0.0：使用剩余宽度,x大于0.0：使用指定宽度;" 注释 = "y等于0.0: 使用标签文本高度,y大于0.0: 使用指定高度;"
            @默认值 = 空对象>
    {
        @ ImGui::Selectable(*PivAny2U{@<标签文本>}, static_cast<bool>(@<是否选中>), static_cast<ImGuiSelectableFlags>(@<可选项标志>), @<尺寸>)
    }

    方法 可选项Ex <公开 静态 类型 = 逻辑型 注释 = "创建一个可选择的项目(悬停时会高亮显示,选中后会变成另一种颜色)." 注释 = "本方法创建的选项,单击后可以自动切换选中状态."
            返回值注释 = "项目被单击时返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供可选项的文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 是否选中 <类型 = 逻辑型 注释 = "必须提供一个逻辑型变量,并确保它的生命周期." @需求类型 = 可写入变量>
    参数 可选项标志 <类型 = 整数 注释 = "请使用\"IM可选项标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM可选项标志.无>
    参数 尺寸 <类型 = ImVec2 注释 = "x等于0.0：使用剩余宽度,x大于0.0：使用指定宽度;" 注释 = "y等于0.0: 使用标签文本高度,y大于0.0: 使用指定高度;"
            @默认值 = 空对象>
    {
        @ ImGui::Selectable(*PivAny2U{@<标签文本>}, reinterpret_cast<bool*>(&@<是否选中>), static_cast<ImGuiSelectableFlags>(@<可选项标志>), @<尺寸>)
    }

    # 组件: 列表框 | Widgets: List Boxes

    方法 创建列表框 <公开 静态 注释 = "创建一个列表框,可以在子语句体中使用\"可选项\"自定义内容." 注释 = "创建失败将不执行子语句体中的代码." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndListBox();\\r\\n}\"">
    参数 标签文本 <注释 = "提供显示在列表框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 尺寸 <类型 = ImVec2 注释 = "提供列表框的尺寸" @默认值 = 空对象>
    {
        @ if (ImGui::BeginListBox(*PivAny2U{@<标签文本>}, @<尺寸>) == true)
    }

    方法 列表框 <公开 静态 类型 = 逻辑型 注释 = "创建一个列表框组件" 返回值注释 = "返回是否创建成功" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在组合框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 现行选中项 <类型 = 整数 注释 = "必须提供一个整数变量(必须确保其生命周期),用于返回当前选中的项目." 注释 = "如果值是\"项目数组\"的有效索引,则自动选中对应的项目."
            注释 = "变量值为-1或大于\"项目数组\"的成员数则不选中任何项目." @需求类型 = 可写入变量>
    参数 项目数组 <类型 = IM文本数组类 注释 = "提供所创建列表框的项目文本数组">
    参数 列表框高度 <类型 = 整数 注释 = "提供列表框的高度,以项目数量为单位." 注释 = "比如8指的是8个项目的高度,实际项目数超过本值将显示滚动条." @默认值 = -1>
    {
        @ ImGui::ListBox(*PivAny2U{@<标签文本>}, &@<现行选中项>, &@dt<IM文本数组类>::ItemGetter, IM_STRARRAY_PTR_AND_SIZE(@<项目数组>.pdata()), @<列表框高度>)
    }

    # 组件: 菜单 | Widgets: Menus

    方法 创建主菜单栏 <公开 静态 注释 = "在整个窗口框架上创建和添加菜单栏." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = \"MainMenuBar\"\r\nhas_body = true\r\nbody_tail = \"ImGui::EndMainMenuBar();\\r\\n}\"">
    {
        @ if (ImGui::BeginMainMenuBar() == true)
    }

    方法 创建菜单栏 <公开 静态 注释 = "在当前ImGui窗口上添加一个菜单栏,窗口必须设置了\"IM窗口标志.菜单栏\"才会显示菜单栏." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = \"MenuBar\"\r\nhas_body = true\r\nbody_tail = \"ImGui::EndMenuBar();\\r\\n}\"">
    {
        @ if (ImGui::BeginMenuBar() == true)
    }

    方法 创建菜单 <公开 静态 注释 = "但菜单栏中创建一个子菜单,可以在子语句体中添加\"菜单项\"." 注释 = "注: 子菜单被打开时才执行子语体中的代码." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndMenu();\\r\\n}\"\r\nparent = \"MainMenuBar, MenuBar\"">
    参数 标签文本 <注释 = "提供子菜单的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 是否启用 <类型 = 逻辑型 注释 = "设置当前的子菜单是否可用" @默认值 = 真>
    {
        @ if (ImGui::BeginMenu(*PivAny2U{@<标签文本>}, static_cast<bool>(@<是否启用>)) == true)
    }

    方法 菜单项 <公开 静态 类型 = 逻辑型 注释 = "在菜单中创建一个菜单项,参数中的快捷键仅用于显示,本方法不会实现对应的快捷键功能." 返回值注释 = "菜单项被单击时返回真" 折叠
            隐藏值属性 = "0" @嵌入式方法 = "parent = \"MainMenuBar, MenuBar\"">
    参数 标签文本 <注释 = "提供菜单项的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 快捷键 <注释 = "提供菜单项的快捷键(仅作显示),留空时不显示快捷键;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型 @默认值 = 0>
    参数 是否选中 <类型 = 逻辑型 注释 = "设置当前的菜单项是否为选中状态" @默认值 = 假>
    参数 是否启用 <类型 = 逻辑型 注释 = "设置当前的菜单项是否可用" @默认值 = 真>
    {
        @ ImGui::MenuItem(*PivAny2U{@<标签文本>}, PivAny2U{@<快捷键>}.GetPtr(), static_cast<bool>(@<是否选中>), static_cast<bool>(@<是否启用>))
    }

    方法 菜单项Ex <公开 静态 类型 = 逻辑型 注释 = "在菜单中创建一个菜单项,参数中的快捷键仅用于显示,本方法不会实现对应的快捷键功能." 返回值注释 = "菜单项被单击时返回真" 折叠
            隐藏值属性 = "0" @嵌入式方法 = "parent = \"MainMenuBar, MenuBar\"">
    参数 标签文本 <注释 = "提供菜单项的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 快捷键 <注释 = "提供菜单项的快捷键(仅作显示),留空时不显示快捷键;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型 @默认值 = 0>
    参数 是否选中 <类型 = 逻辑型 注释 = "必须提供一个变量,可以设置和返回当前的菜单项是否为选中状态." @需求类型 = 可写入变量>
    参数 是否启用 <类型 = 逻辑型 注释 = "设置当前的菜单项是否可用" @默认值 = 真>
    {
        @ ImGui::MenuItem(*PivAny2U{@<标签文本>}, PivAny2U{@<快捷键>}.GetPtr(), reinterpret_cast<bool*>(&@<是否选中>), static_cast<bool>(@<是否启用>))
    }

    # 工具提示 | Tooltips

    方法 创建工具提示 <公开 静态 注释 = "创建一个功能齐全的工具提示窗口,可以在子语句体中使用任意项目." 注释 = "工具提示窗口将跟随鼠标显示,它不会获得焦点." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndTooltip();\\r\\n}\"">
    参数 是否显示 <类型 = 逻辑型 注释 = "设置是否显示工具提示窗口,建议使用\"可有悬停项目\"来判断" @默认值 = 真>
    {
        @ if (@<是否显示> && ImGui::BeginTooltip())
    }

    方法 置工具提示 <公开 静态 注释 = "创建一个仅显示文本的工具提示窗口,通常配合\"可有悬停项目\"使用." 注释 = "工具提示窗口将跟随鼠标显示,它不会获得焦点." 折叠 @嵌入式方法 = "">
    参数 格式文本 <注释 = "提供显示在工具提示窗口中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::SetTooltip(*PivAny2U{@<格式文本>}, @<替换数据>)
    }

    方法 创建项目工具提示 <公开 静态 注释 = "创建一个功能齐全的工具提示窗口,可以在子语句体中使用任意项目." 注释 = "跟\"创建工具提示\"不同,只要有项目悬停它就会自动弹出." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndTooltip();\\r\\n}\"">
    {
        @ if (ImGui::BeginItemTooltip())
    }

    方法 置项目工具提示 <公开 静态 注释 = "创建一个仅显示文本的工具提示窗口,只要有项目悬停它就会自动弹出." 注释 = "工具提示窗口将跟随鼠标显示,它不会获得焦点." 折叠 @嵌入式方法 = "">
    参数 格式文本 <注释 = "提供显示在工具提示窗口中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::SetItemTooltip(*PivAny2U{@<格式文本>}, @<替换数据>)
    }

    方法 提示文本框 <公开 静态 注释 = "创建一个文本框,鼠标悬停时可以弹出工具提示窗口." 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 帮助文本 <注释 = "提供帮助的文本内容;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    {
        @ ImGui::TextTooltip(*PivAny2U{@<标签文本>}, *PivAny2U{@<帮助文本>})
    }

    # 弹出项目,模态 | Popups, Modals

    方法 创建弹出菜单 <公开 静态 注释 = "创建一个弹出菜单,被打开时才会执行子语句体中的代码,子语体中可以调用\"关闭当前弹出项\"." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = \"Popup\"\r\nhas_body = true\r\nbody_tail = \"ImGui::EndPopup();\\r\\n}\"">
    参数 文本ID <注释 = "设置弹出项的唯一文本ID,本ID不会显示在弹出项中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 窗口标志 <类型 = 整数 注释 = "本标志会转发给当前窗口;" 注释 = "请参考\"IM窗口标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM窗口标志.无>
    {
        @ if (ImGui::BeginPopup(*PivAny2U{@<文本ID>}, static_cast<ImGuiWindowFlags>(@<窗口标志>)) == true)
    }

    方法 创建弹出模态窗口 <公开 静态 注释 = "创建一个弹出模态窗口,被打开时才会执行子语句体中的代码,子语体中可以调用\"关闭当前弹出项\"." 注释 = "注: 点击其他位置不会自动关闭模态窗口"
            折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = \"PopupModal\"\r\nhas_body = true\r\nbody_tail = \"ImGui::EndPopup();\\r\\n}\"">
    参数 名称 <注释 = "设置弹出窗口的标题,同时也是它的唯一文本ID;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 打开状态 <类型 = 逻辑型类 注释 = "本参数非空将在模态窗口上显示一个关闭按钮,通过按钮关闭后会将本参数的逻辑值设置为假." @默认值 = 空对象>
    参数 窗口标志 <类型 = 整数 注释 = "本标志会转发给当前窗口;" 注释 = "请参考\"IM窗口标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM窗口标志.无>
    {
        @ if (ImGui::BeginPopupModal(*PivAny2U{@<名称>}, piv::GetBaseDataPtr<bool*>(@<打开状态>), static_cast<ImGuiWindowFlags>(@<窗口标志>)) == true)
    }

    方法 弹出 <公开 静态 注释 = "弹出指定文本ID的弹出项,请勿在每一帧调用本方法!" 折叠 @嵌入式方法 = "">
    参数 文本ID <注释 = "提供所欲打开弹出项的唯一文本ID;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 弹出标志 <类型 = 整数 注释 = "请参考\"IM弹出标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM弹出标志.无>
    {
        @ ImGui::OpenPopup(*PivAny2U{@<文本ID>}, static_cast<ImGuiPopupFlags>(@<弹出标志>))
    }

    方法 单击项目弹出 <公开 静态 注释 = "(右键)单击最后一个项目时,弹出指定文本ID的弹出项." 折叠 @嵌入式方法 = "">
    参数 文本ID <注释 = "提供所欲打开弹出项的唯一文本ID;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 弹出标志 <类型 = 整数 注释 = "请参考\"IM弹出标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM弹出标志.鼠标右键>
    {
        @ ImGui::OpenPopupOnItemClick(*PivAny2U{@<文本ID>}, static_cast<ImGuiPopupFlags>(@<弹出标志>))
    }

    方法 关闭当前弹出项 <公开 静态 注释 = "手动关闭当前的弹出项,必须在\"创建弹出菜单/创建弹出模态窗口/单击××弹出菜单\"的子语句体中调用." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "parent = \"Popup, PopupModal\"">
    {
        @ ImGui::CloseCurrentPopup()
    }

    方法 单击项目创建弹出菜单 <公开 静态 注释 = "(右键)单击最后一个项目时,弹出一个上下文菜单,可在子语句体中自定义菜单项." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndPopup();\\r\\n}\"">
    参数 文本ID <注释 = "设置弹出项的唯一文本ID,本ID不会显示在弹出项中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型 @默认值 = 0>
    参数 弹出标志 <类型 = 整数 注释 = "请参考\"IM弹出标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM弹出标志.鼠标右键>
    {
        @ if (ImGui::BeginPopupContextItem(PivAny2U{@<文本ID>}.GetPtr(), static_cast<ImGuiPopupFlags>(@<弹出标志>)) == true)
    }

    方法 单击窗口创建弹出菜单 <公开 静态 注释 = "(右键)单击当前窗口的任意位置时,弹出一个上下文菜单,可在子语句体中自定义菜单项." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndPopup();\\r\\n}\"">
    参数 文本ID <注释 = "设置弹出项的唯一文本ID,本ID不会显示在弹出项中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型 @默认值 = 0>
    参数 弹出标志 <类型 = 整数 注释 = "请参考\"IM弹出标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM弹出标志.鼠标右键>
    {
        @ if (ImGui::BeginPopupContextWindow(PivAny2U{@<文本ID>}.GetPtr(), static_cast<ImGuiPopupFlags>(@<弹出标志>)) == true)
    }

    方法 单击背景创建弹出菜单 <公开 静态 注释 = "(右键)单击背景(没有窗口的区域)的任意位置时,弹出一个上下文菜单,可在子语句体中自定义菜单项." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndPopup();\\r\\n}\"">
    参数 文本ID <注释 = "设置弹出项的唯一文本ID,本ID不会显示在弹出项中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型 @默认值 = 0>
    参数 弹出标志 <类型 = 整数 注释 = "请参考\"IM弹出标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM弹出标志.鼠标右键>
    {
        @ if (ImGui::BeginPopupContextVoid(PivAny2U{@<文本ID>}.GetPtr(), static_cast<ImGuiPopupFlags>(@<弹出标志>)) == true)
    }

    方法 是否已弹出 <公开 静态 类型 = 逻辑型 注释 = "返回指定的弹出项是否已经弹出显示,返回结果因标志而异." 折叠 @嵌入式方法 = "">
    参数 文本ID <注释 = "提供所欲检查的弹出项唯一文本ID;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 弹出标志 <类型 = 整数 注释 = "请参考\"IM弹出标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM弹出标志.鼠标右键>
    {
        @ ImGui::IsPopupOpen(*PivAny2U{@<文本ID>}, static_cast<ImGuiPopupFlags>(@<弹出标志>))
    }

    # 选项卡栏 | Tab Bars, Tabs

    方法 选项卡栏 <公开 静态 注释 = "创建一个选项卡栏,可以在子语句体中添加选项卡." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = \"TabBar\"\r\nhas_body = true\r\nbody_tail = \"ImGui::EndTabBar();\\r\\n}\"">
    参数 文本ID <注释 = "设置选项卡栏的唯一文本ID,本ID不会显示在界面中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型 @默认值 = 0>
    参数 标志 <类型 = 整数 注释 = "请参考\"IM选项卡栏标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM选项卡栏标志.无>
    {
        @ if (ImGui::BeginTabBar(*PivAny2U{@<文本ID>}, static_cast<ImGuiTabBarFlags>(@<标志>)) == true)
    }

    方法 选项卡 <公开 静态 注释 = "创建一个选项卡项目,可以在子语句体中添加组件." 注释 = "注: 只有选项卡被选中时才会执行子语句体中的代码." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndTabItem();\\r\\n}\"\r\nparent = \"TabBar\"">
    参数 标签文本 <注释 = "提供选项卡项目的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 打开状态 <类型 = 逻辑型类 注释 = "本参数非空将在选项卡项标题右边显示一个关闭按钮,单击按钮会关闭选项卡并将本参数的逻辑值设置为假." @默认值 = 空对象>
    参数 标志 <类型 = 整数 注释 = "请参考\"IM选项卡项标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM选项卡项标志.无>
    {
        @ if (ImGui::BeginTabItem(*PivAny2U{@<标签文本>}, piv::GetBaseDataPtr<bool*>(@<打开状态>), static_cast<ImGuiTabItemFlags>(@<标志>)) == true)
    }

    方法 选项卡按钮 <公开 静态 类型 = 逻辑型 注释 = "创建一个行为类似按钮的选项卡项目,本项目不能在选项卡栏中切换选择." 返回值注释 = "按钮被单击时返回真" 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "parent = \"TabBar\"">
    参数 标签文本 <注释 = "提供选项卡按钮的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 标志 <类型 = 整数 注释 = "请参考\"IM选项卡项标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM选项卡项标志.无>
    {
        @ ImGui::TabItemButton(PivAny2U{@<标签文本>}.GetPtr(), static_cast<ImGuiTabItemFlags>(@<标志>))
    }

    方法 置选项卡关闭 <公开 静态 注释 = "通知指定的选项卡已关闭" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "所欲关闭的选项卡标签;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    {
        @ ImGui::SetTabItemClosed(*PivAny2U{@<标签文本>})
    }

    # 停靠 | Docking

    方法 停靠空间 <公开 静态 类型 = 整数 注释 = "创建一个停靠空间"
            注释 = "create an explicit dock node _within_ an existing window. See Docking demo for details." 折叠
            @嵌入式方法 = "">
    参数 ID <类型 = 整数>
    参数 尺寸 <类型 = ImVec2 @默认值 = 空对象>
    参数 标志 <类型 = 整数 @默认值 = IM停靠节点标志.无>
    参数 窗口类 <类型 = IM窗口类 @默认值 = 空对象>
    {
        @ static_cast<INT>(ImGui::DockSpace(static_cast<ImGuiID>(@<ID>), @<尺寸>, static_cast<ImGuiDockNodeFlags>(@<标志>), @<窗口类>.GetPtr()))
    }

    方法 覆盖式停靠空间 <公开 静态 类型 = 整数 注释 = "创建一个覆盖屏幕或特定视口的显式停靠节点." 折叠 @嵌入式方法 = "">
    参数 视口 <类型 = IM视口类 @默认值 = 空对象>
    参数 标志 <类型 = 整数 @默认值 = IM停靠节点标志.无>
    参数 窗口类 <类型 = IM窗口类 @默认值 = 空对象>
    {
        @ static_cast<INT>(ImGui::DockSpaceOverViewport(@<视口>.GetPtr(), static_cast<ImGuiDockNodeFlags>(@<标志>), @<窗口类>.GetPtr()))
    }

    方法 置下一窗口停靠ID <公开 静态 折叠 @嵌入式方法 = "">
    参数 停靠ID <类型 = 整数 "">
    参数 执行条件 <类型 = IM执行条件 @默认值 = IM执行条件.无>
    {
        @ ImGui::SetNextWindowDockID(static_cast<ImGuiID>(@<停靠ID>), static_cast<ImGuiCond>(@<执行条件>))
    }

    方法 置下一窗口类 <公开 静态 注释 = "set next window class (control docking compatibility +"
            注释 = "provide hints to platform backend via custom viewport flags and platform parent/child relationship)"
            折叠 @嵌入式方法 = "">
    参数 窗口类 <类型 = IM窗口类 @默认值 = 空对象>
    {
        @ ImGui::SetNextWindowClass(@<窗口类>.GetPtr())
    }

    方法 取窗口停靠ID <公开 静态 类型 = 整数 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(ImGui::GetWindowDockID())
    }

    方法 窗口是否已停靠 <公开 静态 类型 = 逻辑型 注释 = "is current window docked into another window?" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsWindowDocked()
    }

    # 日志记录 | Logging/Capture

    方法 记录到控制台 <公开 静态 注释 = "开始记录日志,之后会记录界面中显示的文本数据,直到执行\"结束记录\"后一并输出到控制台(stdout)." 折叠 @嵌入式方法 = "">
    参数 自动展开深度 <类型 = 整数 @默认值 = -1>
    {
        @ ImGui::LogToTTY(@<自动展开深度>)
    }

    方法 记录到文件 <公开 静态 注释 = "开始记录日志,之后会记录界面中显示的文本数据,直到执行\"结束记录\"后一并输出到指定的文件." 折叠 @嵌入式方法 = "">
    参数 自动展开深度 <类型 = 整数 @默认值 = -1>
    参数 文件名 <类型 = 文本型>
    {
        @ ImGui::LogToFile(@<自动展开深度>, PivW2U{@<文件名>})
    }

    方法 记录到剪贴板 <公开 静态 注释 = "开始记录日志,之后会记录界面中显示的文本数据,直到执行\"结束记录\"后一并输出到剪贴板" 折叠 @嵌入式方法 = "">
    参数 自动展开深度 <类型 = 整数 @默认值 = -1>
    {
        @ ImGui::LogToClipboard(@<自动展开深度>)
    }

    方法 结束记录 <公开 静态 注释 = "结束日志记录并输出数据,前面要执行\"记录到×××\"." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::LogFinish()
    }

    方法 记录文本 <公开 静态 注释 = "将文本数据直接传递到日志(界面上不显示),需要在\"记录到×××\"和\"结束记录\"之间调用." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 格式文本 <注释 = "提供显示在文本框中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::LogText(*PivAny2U{@<格式文本>}, @<替换数据>)
    }

    # 拖放 | Drag and Drop

    方法 拖放来源 <公开 静态 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = \"DragDropSource\"\r\nhas_body = true\r\nbody_tail = \"ImGui::EndDragDropSource();\\r\\n}\"">
    参数 标志 <类型 = 整数 注释 = "请参考\"IM拖放标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM拖放标志.无>
    {
        @ if (ImGui::BeginDragDropSource(static_cast<ImGuiDragDropFlags>(@<标志>)) == true)
    }

    方法 设置拖放有效载荷 <公开 静态 类型 = 逻辑型 注释 = "提供的数据会被ImGui复制保存,接受有效载荷后返回真." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "parent = \"DragDropSource\"">
    参数 类型 <注释 = "类型是用户定义的文本,最多32个UTF-8字符,字符\'_\'开头的是ImGui的内部保留类型." 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            @匹配类型 = 通用型>
    参数 数据指针 <类型 = 变整数 注释 = "提供数据指针">
    参数 数据尺寸 <类型 = 变整数 注释 = "提供数据尺寸">
    参数 执行条件 <类型 = IM执行条件 注释 = "提供本方法的执行条件" @默认值 = IM执行条件.无>
    {
        @ ImGui::SetDragDropPayload(*PivAny2U{@<类型>}, reinterpret_cast<void*>(@<数据指针>), static_cast<size_t>(@<数据尺寸>), static_cast<ImGuiCond>(@<执行条件>))
    }

    方法 拖放目标 <公开 静态 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = \"DragDropTarget\"\r\nhas_body = true\r\nbody_tail = \"ImGui::EndDragDropTarget();\\r\\n}\"">
    {
        @ if (ImGui::BeginDragDropTarget() == true)
    }

    方法 接收拖放有效载荷 <公开 静态 类型 = IM有效载荷类 注释 = "接收指定类型的有效载荷" 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "parent = \"DragDropTarget\"">
    参数 类型 <注释 = "类型是用户定义的文本,最多32个UTF-8字符,字符\'_\'开头的是ImGui的内部保留类型." 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            @匹配类型 = 通用型>
    参数 标志 <类型 = 整数 注释 = "请参考\"IM拖放标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM拖放标志.无>
    {
        @ @dt<IM有效载荷类>{ImGui::AcceptDragDropPayload(*PivAny2U{@<类型>},  static_cast<ImGuiDragDropFlags>(@<标志>))}
    }

    方法 取拖放有效载荷 <公开 静态 类型 = IM有效载荷类 注释 = "从任何位置直接查看当前有效有效载荷." 折叠 @嵌入式方法 = "">
    {
        @ @dt<IM有效载荷类>{ImGui::GetDragDropPayload()}
    }

    # 剪切 | Clipping

    方法 剪切矩形 <公开 静态 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::PopClipRect();\"">
    参数 左上剪切矩形 <类型 = ImVec2>
    参数 右下剪切矩形 <类型 = ImVec2>
    参数 与当前剪切矩形交叉 <类型 = 逻辑型>
    {
        @ ImGui::PushClipRect(@<左上剪切矩形>, @<右下剪切矩形>, @<与当前剪切矩形交叉>);
    }

    # 焦点、激活 | Focus, Activation

    方法 置项目为默认焦点 <公开 静态 注释 = "将最后一个项目成为窗口的默认焦点项目." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::SetItemDefaultFocus()
    }

    方法 置键盘焦点 <公开 静态 注释 = "将键盘的输入焦点设置到下一个窗口组件上." 注释 = "使用正\"偏移量\"可以访问窗口组件中的子组件,使用-1可访问上一个窗口组件." 折叠
            @嵌入式方法 = "">
    参数 偏移量 <类型 = 整数 @默认值 = 0>
    {
        @ ImGui::SetKeyboardFocusHere(@<偏移量>)
    }

    # 项目/窗口组件的实用工具和查询功能 | Item/Widgets Utilities and Query Functions

    方法 项目可有悬停 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否有鼠标悬停" 折叠 @嵌入式方法 = "">
    参数 标志 <类型 = 整数 @默认值 = IM悬停标志.无>
    {
        @ ImGui::IsItemHovered(static_cast<ImGuiHoveredFlags>(@<标志>))
    }

    方法 项目是否活动 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否为活动状态.例如按住按钮、编辑文本等." 注释 = "在项目上按住鼠标按钮时会持续返回真,不交互的项目是在返回假." 折叠
            @嵌入式方法 = "">
    {
        @ ImGui::IsItemActive()
    }

    方法 项目可有焦点 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否有键盘或游戏手柄的输入焦点" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsItemFocused()
    }

    方法 项目被单击 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否已经被鼠标悬停和单击." 折叠 @嵌入式方法 = "">
    参数 鼠标按钮 <类型 = IM鼠标按钮 @默认值 = IM鼠标按钮.左键>
    {
        @ ImGui::IsItemClicked(static_cast<ImGuiMouseButton>(@<鼠标按钮>))
    }

    方法 项目是否可见 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否为可见状态,项目也可能会被剪切或滚动而离开可见范围." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsItemVisible()
    }

    方法 项目被编辑 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否在当前帧被编辑了值,或被按下." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsItemEdited()
    }

    方法 项目被激活 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否刚被激活(上一帧为停用状态)." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsItemActivated()
    }

    方法 项目被停用 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否刚被停用(上一帧为激活状态)." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsItemDeactivated()
    }

    方法 项目被编辑后停用 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否刚被停用,而且在激活时被修改过值." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsItemDeactivatedAfterEdit()
    }

    方法 项目被展开 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否切换到展开状态(树节点)." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsItemToggledOpen()
    }

    方法 可有悬停项目 <公开 静态 类型 = 逻辑型 注释 = "返回是否有任意一个项目有鼠标悬停" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsAnyItemHovered()
    }

    方法 可有活动项目 <公开 静态 类型 = 逻辑型 注释 = "返回是否有任意一个项目为活动状态" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsAnyItemActive()
    }

    方法 可有焦点项目 <公开 静态 类型 = 逻辑型 注释 = "返回是否有任意一个项目有输入焦点" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsAnyItemFocused()
    }

    方法 取项目ID <公开 静态 类型 = 整数 注释 = "获取最后一个项目的唯一ID" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(ImGui::GetItemID())
    }

    方法 取项目左上矩形 <公开 静态 类型 = ImVec2 注释 = "获取最后一个项目的左上角边界矩形(屏幕空间)" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetItemRectMin()}
    }

    方法 取项目右下矩形 <公开 静态 类型 = ImVec2 注释 = "获取最后一个项目的右下角边界矩形(屏幕空间)" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetItemRectMax()}
    }

    方法 取项目尺寸 <公开 静态 类型 = ImVec2 注释 = "获取最后一个项目的尺寸(宽度和高度)" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetItemRectSize()}
    }

    方法 允许项目重叠 <公开 静态 注释 = "将最后一个项目设置为允许和后面的项目重叠." 注释 = "有时与\"隐身按钮\"、\"可选项\"等配合使用,可以捕获未使用的区域." 折叠
            @嵌入式方法 = "">
    {
        @ ImGui::SetItemAllowOverlap()
    }

    # 视口 | Viewports

    方法 取主视口 <公开 静态 类型 = IM视口类 注释 = "返回主视口" 折叠 @嵌入式方法 = "">
    {
        @ @dt<IM视口类>{ImGui::GetMainViewport()}
    }

    # 背景/前景绘制列表 | Background/Foreground Draw Lists

    方法 取背景绘制列表 <公开 静态 类型 = IM绘制列表类 注释 = "此为第一个渲染的绘制列表,用于在ImGui内容后面快速绘制形状与文本." 折叠 @嵌入式方法 = "">
    {
        @ @dt<IM绘制列表类>{ImGui::GetBackgroundDrawList()}
    }

    方法 取前景绘制列表 <公开 静态 类型 = IM绘制列表类 注释 = "此为最后一个渲染的绘制列表,用于在ImGui内容上快速绘制形状与文本." 折叠 @嵌入式方法 = "">
    {
        @ @dt<IM绘制列表类>{ImGui::GetForegroundDrawList()}
    }

    # 杂项实用工具 | Miscellaneous Utilities

    方法 矩形是否可见 <公开 静态 类型 = 逻辑型 注释 = "检查指定矩形(从光标位置开始的给定大小)是否可见和未被剪切." 折叠 @嵌入式方法 = "">
    参数 尺寸 <类型 = ImVec2>
    {
        @ ImGui::IsRectVisible(@<尺寸>)
    }

    方法 矩形是否可见2 <公开 静态 类型 = 逻辑型 注释 = "检查指定两个矩形(屏幕空间)的范围是否可见和未被剪切." 折叠 @嵌入式方法 = "">
    参数 左上矩形 <类型 = ImVec2>
    参数 右下矩形 <类型 = ImVec2>
    {
        @ ImGui::IsRectVisible(@<左上矩形>, @<右下矩形>)
    }

    方法 取启动时间 <公开 静态 类型 = 小数 注释 = "获取ImGui自启动以来的计时(单位为秒)." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetTime()
    }

    方法 取总帧数 <公开 静态 类型 = 整数 注释 = "获取ImGui自启动以来渲染的总帧数" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetFrameCount()
    }

    方法 "// 取绘制列表共享数据" <公开 静态 类型 = 整数 注释 = "可以在创建自己的绘制列表实例时使用此选项" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::ImDrawListSharedData()
    }

    方法 取样式颜色名 <公开 静态 类型 = 文本视图类U 注释 = "获取与IM颜色标识符(ImGuiCol)枚举值对应的文本(用于显示、保存)." 折叠 @嵌入式方法 = "">
    参数 颜色标识符 <类型 = IM颜色标识符>
    {
        @ @dt<文本视图类U>{ImGui::GetStyleColorName(static_cast<ImGuiCol>(@<颜色标识符>))}
    }

    # 文本实用工具 | Text Utilities

    方法 计算文本尺寸 <公开 静态 类型 = ImVec2 注释 = "计算所提供文本渲染后的尺寸" 折叠 @嵌入式方法 = "">
    参数 文本内容 <注释 = "所欲计算尺寸的文本" @匹配类型 = 通用型>
    参数 隐藏两个井号后面 <类型 = 逻辑型 注释 = "隐藏两个井号后面的文本" @默认值 = 假>
    参数 换行宽度 <类型 = 小数 注释 = "小于0时表示不换行." @默认值 = -1.0>
    {
        @ @dt<ImVec2>{ImGui::CalcTextSize(*PivAny2U{@<文本内容>}, nullptr, static_cast<bool>(@<隐藏两个井号后面>), @<换行宽度>)}
    }

    # 颜色实用工具 | Color Utilities

    方法 颜色值到ImVec4 <公开 静态 类型 = ImVec4 注释 = "将32位RGB颜色值转换到ImVec4类型" 折叠 @嵌入式方法 = "">
    参数 颜色值 <类型 = 整数 注释 = "32位RGB颜色值">
    {
        @ @dt<ImVec4>{ImGui::ColorConvertU32ToFloat4(static_cast<ImU32>(@<颜色值>))}
    }

    方法 ImVec4到颜色值 <公开 静态 类型 = 整数 注释 = "将ImVec4类型的RGB颜色值转换到32位整数" 折叠 @嵌入式方法 = "">
    参数 颜色 <类型 = ImVec4>
    {
        @ static_cast<INT>(ImGui::ColorConvertFloat4ToU32(@<颜色>))
    }

    方法 RGB到HSV <公开 静态 注释 = "将RGB颜色值转换到HSV" 折叠 @嵌入式方法 = "">
    参数 R <类型 = 单精度小数 注释 = "所欲转换的红色分量">
    参数 G <类型 = 单精度小数 注释 = "所欲转换的绿色分量">
    参数 B <类型 = 单精度小数 注释 = "所欲转换的蓝色分量">
    参数 H <类型 = 单精度小数 注释 = "返回转换结果色相" @需求类型 = 可写入变量>
    参数 S <类型 = 单精度小数 注释 = "返回转换结果饱和度" @需求类型 = 可写入变量>
    参数 V <类型 = 单精度小数 注释 = "返回转换结果明度" @需求类型 = 可写入变量>
    {
        @ ImGui::ColorConvertRGBtoHSV(@<R>, @<G>, @<B>, &@<H>, &@<S>, &@<V>)
    }

    方法 HSV到RGB <公开 静态 注释 = "将HSV颜色值转换到RGB" 折叠 @嵌入式方法 = "">
    参数 H <类型 = 单精度小数 注释 = "所欲转换的色相">
    参数 S <类型 = 单精度小数 注释 = "所欲转换的饱和度">
    参数 V <类型 = 单精度小数 注释 = "所欲转换的明度">
    参数 R <类型 = 单精度小数 注释 = "返回转换结果红色分量" @需求类型 = 可写入变量>
    参数 G <类型 = 单精度小数 注释 = "返回转换结果绿色分量" @需求类型 = 可写入变量>
    参数 B <类型 = 单精度小数 注释 = "返回转换结果蓝色分量" @需求类型 = 可写入变量>
    {
        @ ImGui::ColorConvertHSVtoRGB(@<H>, @<S>, @<V>, &@<R>, &@<G>, &@<B>)
    }

    # 输入实用工具 | Inputs Utilities: Keyboard/Mouse/Gamepad

    方法 键被按住 <公开 静态 类型 = 逻辑型 注释 = "返回指定的按键是否被持续按住" 折叠 @嵌入式方法 = "">
    参数 按键码 <类型 = 整数 注释 = "请使用\"IM按键码\"中的常量">
    {
        @ ImGui::IsKeyDown(static_cast<ImGuiKey>(@<按键码>))
    }

    方法 键被按下 <公开 静态 类型 = 逻辑型 注释 = "返回指定的按键是否被按下" 折叠 @嵌入式方法 = "">
    参数 按键码 <类型 = 整数 注释 = "请使用\"IM按键码\"中的常量">
    参数 重复按键 <类型 = 逻辑型 注释 = "是否为重复按键" @默认值 = 真>
    {
        @ ImGui::IsKeyPressed(static_cast<ImGuiKey>(@<按键码>), static_cast<bool>(@<重复按键>))
    }

    方法 键被释放 <公开 静态 类型 = 逻辑型 注释 = "返回指定的按键是否被释放" 折叠 @嵌入式方法 = "">
    参数 按键码 <类型 = 整数 注释 = "请使用\"IM按键码\"中的常量">
    {
        @ ImGui::IsKeyReleased(static_cast<ImGuiKey>(@<按键码>))
    }

    方法 组合键被按下 <公开 静态 类型 = 逻辑型 注释 = "返回指定的组合键是否被按下" 折叠 @嵌入式方法 = "">
    参数 组合键 <类型 = 整数 注释 = "为\"IM按键码\"中修饰键和按键的组合值,例:" 注释 = "位或 (IM按键码.Shift键, IM按键码.S键)">
    {
        @ ImGui::IsKeyChordPressed(static_cast<ImGuiKeyChord>(@<组合键>))
    }

    方法 取键按下计数 <公开 静态 类型 = 整数 注释 = "使用提供的重复按键速率和延迟计算出按键的重复计数" 折叠 @嵌入式方法 = "">
    参数 按键码 <类型 = 整数 注释 = "请使用\"IM按键码\"中的常量">
    参数 重复延迟 <类型 = 单精度小数>
    参数 重复率 <类型 = 单精度小数>
    {
        @ ImGui::GetKeyPressedAmount(static_cast<ImGuiKey>(@<按键码>), @<重复延迟>, @<重复率>)
    }

    方法 取键名称 <公开 静态 类型 = 文本视图类U 注释 = "返回指定按键码的英文名称" 折叠 @嵌入式方法 = "">
    参数 按键码 <类型 = 整数 注释 = "请使用\"IM按键码\"中的常量">
    {
        @ @dt<文本视图类U>{ImGui::GetKeyPressedAmount(static_cast<ImGuiKey>(@<按键码>))}
    }

    方法 置下一帧捕获键盘 <公开 静态 注释 = "强制下一帧捕获键盘" 折叠 @嵌入式方法 = "">
    参数 捕获键盘 <类型 = 逻辑型>
    {
        @ ImGui::SetNextFrameWantCaptureKeyboard(static_cast<bool>(@<捕获键盘>))
    }

    # 输入实用工具: 鼠标 | Inputs Utilities: Mouse specific

    方法 鼠标键被按住 <公开 静态 类型 = 逻辑型 注释 = "返回指定的鼠标键是否被持续按住" 折叠 @嵌入式方法 = "">
    参数 按键 <类型 = IM鼠标按钮>
    {
        @ ImGui::IsKeyDown(static_cast<ImGuiMouseButton>(@<按键>))
    }

    方法 鼠标键被单击 <公开 静态 类型 = 逻辑型 注释 = "返回指定的鼠标键是否被按下" 折叠 @嵌入式方法 = "">
    参数 按键 <类型 = IM鼠标按钮>
    参数 重复按键 <类型 = 逻辑型 注释 = "是否为重复按键" @默认值 = 真>
    {
        @ ImGui::IsMouseClicked(static_cast<ImGuiMouseButton>(@<按键>), static_cast<bool>(@<重复按键>))
    }

    方法 鼠标键被释放 <公开 静态 类型 = 逻辑型 注释 = "返回指定的鼠标键是否被释放" 折叠 @嵌入式方法 = "">
    参数 按键 <类型 = IM鼠标按钮>
    {
        @ ImGui::IsMouseReleased(static_cast<ImGuiMouseButton>(@<按键>))
    }

    方法 鼠标键被双击 <公开 静态 类型 = 逻辑型 注释 = "返回指定的鼠标键是否被双击" 折叠 @嵌入式方法 = "">
    参数 按键 <类型 = IM鼠标按钮>
    {
        @ ImGui::IsMouseDoubleClicked(static_cast<ImGuiMouseButton>(@<按键>))
    }

    方法 取鼠标键单击计数 <公开 静态 类型 = 整数 注释 = "返回发生鼠标键单击后的连续单击次数" 折叠 @嵌入式方法 = "">
    参数 按键 <类型 = IM鼠标按钮>
    {
        @ ImGui::GetMouseClickedCount(static_cast<ImGuiMouseButton>(@<按键>))
    }

    方法 矩形可有鼠标悬停 <公开 静态 类型 = 逻辑型 注释 = "返回鼠标是否悬停在给定的边界矩形上" 折叠 @嵌入式方法 = "">
    参数 左上矩形 <类型 = ImVec2>
    参数 右下矩形 <类型 = ImVec2>
    参数 是否剪切 <类型 = 逻辑型>
    {
        @ ImGui::IsMouseHoveringRect(@<左上矩形>, @<右下矩形>, static_cast<bool>(@<是否剪切>))
    }

    方法 鼠标位置是否有效 <公开 静态 类型 = 逻辑型 注释 = "返回指定的鼠标位置是否有效" 折叠 @嵌入式方法 = "">
    参数 鼠标位置 <类型 = ImVec2 注释 = "留空时为当前的鼠标位置" @默认值 = 空对象>
    {
        @ ImGui::IsMousePosValid(@<鼠标位置>.GetPtr())
    }

    方法 取鼠标位置 <公开 静态 类型 = ImVec2 注释 = "返回当前的鼠标位置" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetMousePos()}
    }

    方法 取鼠标弹出项位置 <公开 静态 类型 = ImVec2 注释 = "返回鼠标在弹出项中的位置(需要在弹出项的子语体内使用)" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetMousePosOnOpeningCurrentPopup()}
    }

    方法 鼠标被拖动 <公开 静态 类型 = 逻辑型 注释 = "返回指定的鼠标键是否正在被拖动" 折叠 @嵌入式方法 = "">
    参数 按键 <类型 = IM鼠标按钮>
    参数 锁定阈值 <类型 = 单精度小数 注释 = "如果鼠标移动超过提供的距离,则判断为正在拖动." 注释 = "小于-1.0f时使用默认的鼠标拖动阈值." @默认值 = -1.0>
    {
        @ ImGui::IsMouseDragging(static_cast<ImGuiMouseButton>(@<按键>), @<锁定阈值>)
    }

    方法 取鼠标拖动增量 <公开 静态 类型 = ImVec2 注释 = "返回从初始单击位置到当前位置的拖动距离增量" 折叠 @嵌入式方法 = "">
    参数 按键 <类型 = IM鼠标按钮>
    参数 锁定阈值 <类型 = 单精度小数 注释 = "如果鼠标移动超过提供的距离,则判断为正在拖动." 注释 = "小于-1.0f时使用默认的鼠标拖动阈值." @默认值 = -1.0>
    {
        @ @dt<ImVec2>{ImGui::GetMouseDragDelta(static_cast<ImGuiMouseButton>(@<按键>), @<锁定阈值>)}
    }

    方法 重置鼠标拖动增量 <公开 静态 注释 = "重置指定鼠标键的拖动增量" 折叠 @嵌入式方法 = "">
    参数 按键 <类型 = IM鼠标按钮>
    {
        @ ImGui::ResetMouseDragDelta(static_cast<ImGuiMouseButton>(@<按键>))
    }

    方法 取鼠标光标 <公开 静态 类型 = IM鼠标光标 注释 = "获取当前所用的光标形状" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetMouseCursor()
    }

    方法 置鼠标光标 <公开 静态 注释 = "设置当前所用的光标形状" 折叠 @嵌入式方法 = "">
    参数 鼠标光标 <类型 = IM鼠标光标>
    {
        @ ImGui::SetMouseCursor(static_cast<ImGuiMouseCursor>(@<鼠标光标>))
    }

    方法 置下一帧捕获鼠标 <公开 静态 注释 = "强制下一帧捕获鼠标" 折叠 @嵌入式方法 = "">
    参数 捕获键盘 <类型 = 逻辑型>
    {
        @ ImGui::SetNextFrameWantCaptureMouse(static_cast<bool>(@<捕获键盘>))
    }

    # (Optional) Platform/OS interface for multi-viewport support

    方法 取平台IO <公开 静态 类型 = IM平台IO类 注释 = "platform/renderer functions, for backend to setup + viewports list."
            折叠 @嵌入式方法 = "">
    {
        @ @dt<IM平台IO类>{&ImGui::GetPlatformIO()}
    }

    方法 更新平台窗口 <公开 静态 注释 = "call in main loop. will call CreateWindow/ResizeWindow/etc."
            注释 = "platform functions for each secondary viewport, and DestroyWindow for each inactive viewport."
            折叠 @嵌入式方法 = "">
    {
        @ ImGui::UpdatePlatformWindows()
    }

    方法 渲染平台默认窗口 <公开 静态 注释 = "call in main loop."
            注释 = "will call RenderWindow/SwapBuffers platform functions for each"
            注释 = "secondary viewport which doesn\'t have the ImGuiViewportFlags_Minimized flag set."
            注释 = "May be reimplemented by user for custom rendering needs." 折叠 @嵌入式方法 = "">
    参数 平台渲染参数 <类型 = 变整数 @默认值 = 0>
    参数 渲染器参数 <类型 = 变整数 @默认值 = 0>
    {
        @ ImGui::RenderPlatformWindowsDefault(reinterpret_cast<void*>(@<平台渲染参数>), reinterpret_cast<void*>(@<渲染器参数>))
    }

    方法 销毁平台窗口 <公开 静态 注释 = "call DestroyWindow platform functions for all viewports."
            注释 = "call from backend Shutdown() if you need to close platform windows before imgui shutdown."
            注释 = "otherwise will be called by DestroyContext()." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::DestroyPlatformWindows()
    }

    方法 寻找视口_ID <公开 静态 类型 = IM视口类 注释 = "this is a helper for backends." 折叠 @嵌入式方法 = "">
    参数 视口ID <类型 = 整数>
    {
        @ @dt<IM视口类>{&ImGui::FindViewportByID(static_cast<ImGuiID>(@<视口ID>))}
    }

    方法 寻找视口_平台句柄 <公开 静态 类型 = IM视口类
            注释 = "this is a helper for backends. the type platform_handle is decided by the backend"
            注释 = "(e.g. HWND, MyWindow*, GLFWwindow* etc.)" 折叠 @嵌入式方法 = "">
    参数 平台句柄 <类型 = 变整数>
    {
        @ @dt<IM视口类>{&ImGui::FindViewportByPlatformHandle(reinterpret_cast<void*>(@<平台句柄>))}
    }
}

类 ImGui表格 <公开 注释 = "ImGui的表格组件" 折叠>
{

    # 表格 | Tables

    方法 创建表格 <公开 静态 注释 = "创建一个表格,然后在子语句体中填写数据." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = \"Table\"\r\nhas_body = true\r\nbody_tail = \"ImGui::EndTable();\\r\\n}\"">
    参数 文本ID <注释 = "设置表格的唯一文本ID,本ID不会显示在表格中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 列数 <类型 = 整数 注释 = "提供表格的列数">
    参数 表格标志 <类型 = 整数 注释 = "请参考\"IM表格标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM表格标志.无>
    参数 外边框尺寸 <类型 = ImVec2 @默认值 = 空对象>
    参数 内宽度 <类型 = 单精度小数 @默认值 = 0.0>
    {
        @ if (ImGui::BeginTable(*PivAny2U{@<文本ID>}, @<列数>, static_cast<ImGuiTableFlags>(@<表格标志>), @<外边框尺寸>, @<内宽度>) == true)
    }

    方法 到下一行 <公开 静态 注释 = "加入到新一行的第一个单元格." 折叠 隐藏值属性 = "0" @嵌入式方法 = "parent = \"Table\"">
    参数 表格行标志 <类型 = 整数 注释 = "请参考\"IM表格行标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM表格行标志.无>
    参数 最小行高度 <类型 = 单精度小数 @默认值 = 0.0>
    {
        @ ImGui::TableNextRow(static_cast<ImGuiTableRowFlags>(@<表格行标志>), @<最小行高度>)
    }

    方法 到下一列 <公开 静态 类型 = 逻辑型 注释 = "加入到下一列,如果当前为最后一列则加入到下一行的第一列,列为可见状态时返回真." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "parent = \"Table\"">
    {
        @ ImGui::TableNextColumn()
    }

    方法 到指定列 <公开 静态 类型 = 逻辑型 注释 = "加入到指定列,列为可见状态时返回真." 折叠 隐藏值属性 = "0" @嵌入式方法 = "parent = \"Table\"">
    参数 列索引 <类型 = 整数>
    {
        @ ImGui::TableSetColumnIndex(@<列索引>)
    }

    方法 置列属性 <公开 静态 注释 = "设置列的首行标题、调整大小策略、默认宽度和权重、唯一元素ID和其他标志."
            注释 = "注: 只能在\"创建表格\"和\"到下一行\"之间调用,并需要根据表格的列数调用多次." 折叠 隐藏值属性 = "0" @嵌入式方法 = "parent = \"Table\"">
    参数 标签文本 <注释 = "提供显示在表格第一行的列标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 表格行标志 <类型 = 整数 注释 = "请参考\"IM表格行标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM表格行标志.无>
    参数 初始宽度 <类型 = 单精度小数 注释 = "提供列的初始宽度,单位为像素或权重(依标志而定)" @默认值 = 0.0>
    参数 用户ID <类型 = 整数 注释 = "提供用户自定义的ID值" @默认值 = 0>
    {
        @ ImGui::TableSetupColumn(*PivAny2U{@<标签文本>}, static_cast<ImGuiTableRowFlags>(@<表格行标志>), @<初始宽度>, static_cast<ImGuiID>(@<用户ID>))
    }

    方法 冻结窗格 <公开 静态 注释 = "锁定指定数量的列和行,使它们在表格滚动时始终可见." 注释 = "注: 只能在\"置列属性\"和\"到下一行\"之间调用." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "parent = \"Table\"">
    参数 列数 <类型 = 整数>
    参数 行数 <类型 = 整数>
    {
        @ ImGui::TableSetupScrollFreeze(@<列数>, @<行数>)
    }

    方法 提交标题行 <公开 静态 注释 = "根据\"置列属性\"的数据提交所有表头行的单元格,以及提交上下文菜单." 折叠 隐藏值属性 = "0" @嵌入式方法 = "parent = \"Table\"">
    {
        @ ImGui::TableHeadersRow()
    }

    方法 提交倾斜标题行 <公开 静态
            注释 = "submit a row with angled headers for every column with the ImGuiTableColumnFlags_AngledHeader flag. MUST BE FIRST ROW."
            注释 = "注意: 必须为首行." 折叠 隐藏值属性 = "0" @嵌入式方法 = "parent = \"Table\"">
    {
        @ ImGui::TableAngledHeadersRow()
    }

    方法 "// 取排序规范" <公开 静态 类型 = ImGuiTableSortSpecs 注释 = "获取表格最后的排序规范(可能为空,表示无排序)."
            注释 = "生命周期: 返回值只能在当前帧使用,如果当前帧后面又调用了\"创建表格\",则请勿再调用本返回值." 折叠 隐藏值属性 = "0" @嵌入式方法 = "parent = \"Table\"">
    {
        @ ImGui::TableGetSortSpecs()
    }

    方法 取列数 <公开 静态 类型 = 整数 注释 = "返回当前表格的列数(\"创建表格\"时提供的值)." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::TableGetColumnCount()
    }

    方法 取列索引 <公开 静态 类型 = 整数 注释 = "返回当前列的索引" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::TableGetColumnIndex()
    }

    方法 取行索引 <公开 静态 类型 = 整数 注释 = "返回当前行的索引" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::TableGetRowIndex()
    }

    方法 取列标题 <公开 静态 类型 = 标准文本类U 注释 = "获取指定列的标题名称,如果未设置\"置列属性\"则返回空文本." 折叠 @嵌入式方法 = "">
    参数 列索引 <类型 = 整数 注释 = "-1表示当前列" @默认值 = -1>
    {
        @ @dt<标准文本类U>{ImGui::TableGetColumnName(@<列索引>)}
    }

    方法 取列标志 <公开 静态 类型 = 整数 注释 = "获取指定列的标志,通过标志可以检测列的可用、可见、排序、悬停等状态." 折叠 @嵌入式方法 = "">
    参数 列索引 <类型 = 整数 注释 = "-1表示当前列" @默认值 = -1>
    {
        @ static_cast<INT>(ImGui::TableGetColumnFlags(@<列索引>))
    }

    方法 置列启用 <公开 静态 类型 = 标准文本类U 注释 = "设置指定列是否可以被用户访问,设置为假可隐藏列." 注释 = "用户也可以使用上下文菜单自行更改(在列标题中右键单击)." 折叠
            @嵌入式方法 = "">
    参数 列索引 <类型 = 整数 注释 = "-1表示当前列" @默认值 = -1>
    参数 是否启用 <类型 = 逻辑型 注释 = "是否启用指定的列,假时将隐藏列">
    {
        @ ImGui::TableSetColumnEnabled(@<列索引>, static_cast<bool>(@<是否启用>))
    }

    方法 置背景颜色 <公开 静态 类型 = 标准文本类U 注释 = "设置指定单元格、行或列的背景颜色" 折叠 @嵌入式方法 = "">
    参数 设置目标 <类型 = IM表格背景目标 注释 = "-1表示当前列">
    参数 颜色值 <类型 = 整数 注释 = "32位颜色值">
    参数 列索引 <类型 = 整数 注释 = "-1表示当前列" @默认值 = -1>
    {
        @ ImGui::TableSetBgColor(static_cast<ImGuiTableBgTarget>(@<设置目标>), static_cast<ImU32>(@<颜色值>), @<列索引>)
    }
}

类 IM绘制列表类 <公开 基础类 = 结构指针基础类 注释 = "ImDrawList" 折叠>
{

    # @ @m<PIV_DECLARE_STRUCT_PTR> (ImDrawList)

    方法 标志 <公开 属性读 类型 = 整数 注释 = "返回绘制列表标志,为\"IM绘制列表标志\"的组合值." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().Flags
    }

    方法 标志 <公开 属性写 注释 = "设置绘制列表标志,请使用\"IM绘制列表标志\"的位或组合值." 折叠>
    参数 新标志 <类型 = 整数>
    {
        @ data().Flags = (ImDrawListFlags)@<新标志>;
    }

    # 基本图形 | Primitives

    方法 添加直线 <公开 折叠 @嵌入式方法 = "">
    参数 端点1 <类型 = ImVec2>
    参数 端点2 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ @sn<this>.data().AddLine(@<端点1>, @<端点2>, static_cast<ImU32>(@<颜色>), @<粗细>)
    }

    方法 添加矩形 <公开 折叠 @嵌入式方法 = "">
    参数 左上矩形 <类型 = ImVec2>
    参数 右下矩形 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 圆角半径 <类型 = 单精度小数 @默认值 = 0.0>
    参数 标志 <类型 = 整数 @默认值 = IM绘制标志.无>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ @sn<this>.data().AddRect(@<左上矩形>, @<右下矩形>, static_cast<ImU32>(@<颜色>),
        @                          @<圆角半径>, static_cast<ImDrawFlags>(@<标志>), @<粗细>)
    }

    方法 添加矩形填充 <公开 折叠 @嵌入式方法 = "">
    参数 左上矩形 <类型 = ImVec2>
    参数 右下矩形 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 圆角半径 <类型 = 单精度小数 @默认值 = 0.0>
    参数 标志 <类型 = 整数 @默认值 = IM绘制标志.无>
    {
        @ @sn<this>.data().AddRectFilled(@<左上矩形>, @<右下矩形>, static_cast<ImU32>(@<颜色>),
        @                                @<圆角半径>, static_cast<ImDrawFlags>(@<标志>))
    }

    方法 添加多色矩形填充 <公开 折叠 @嵌入式方法 = "">
    参数 左上矩形 <类型 = ImVec2>
    参数 右下矩形 <类型 = ImVec2>
    参数 左上颜色 <类型 = 整数>
    参数 右上颜色 <类型 = 整数>
    参数 右下颜色 <类型 = 整数>
    参数 左下颜色 <类型 = 整数>
    {
        @ @sn<this>.data().AddRectFilled(@<左上矩形>, @<右下矩形>, static_cast<ImU32>(@<左上颜色>),
        @                                static_cast<ImU32>(@<右上颜色>), static_cast<ImU32>(@<右下颜色>), static_cast<ImU32>(@<左下颜色>))
    }

    方法 添加四边形 <公开 折叠 @嵌入式方法 = "">
    参数 端点1 <类型 = ImVec2>
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 端点4 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ @sn<this>.data().AddQuad(@<端点1>, @<端点2>, @<端点3>, @<端点4>, static_cast<ImU32>(@<颜色>), @<粗细>)
    }

    方法 添加四边形填充 <公开 折叠 @嵌入式方法 = "">
    参数 端点1 <类型 = ImVec2>
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 端点4 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    {
        @ @sn<this>.data().AddQuadFilled(@<端点1>, @<端点2>, @<端点3>, @<端点4>, static_cast<ImU32>(@<颜色>))
    }

    方法 添加三角形 <公开 折叠 @嵌入式方法 = "">
    参数 端点1 <类型 = ImVec2>
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ @sn<this>.data().AddTriangle(@<端点1>, @<端点2>, @<端点3>, static_cast<ImU32>(@<颜色>), @<粗细>)
    }

    方法 添加三角形填充 <公开 折叠 @嵌入式方法 = "">
    参数 端点1 <类型 = ImVec2>
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    {
        @ @sn<this>.data().AddTriangleFilled(@<端点1>, @<端点2>, @<端点3>, static_cast<ImU32>(@<颜色>))
    }

    方法 添加圆形 <公开 折叠 @嵌入式方法 = "">
    参数 圆心 <类型 = ImVec2>
    参数 半径 <类型 = 单精度小数>
    参数 颜色 <类型 = 整数>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ @sn<this>.data().AddCircle(@<圆心>, @<半径>, static_cast<ImU32>(@<颜色>), @<分段数>, @<粗细>)
    }

    方法 添加圆形填充 <公开 折叠 @嵌入式方法 = "">
    参数 圆心 <类型 = ImVec2>
    参数 半径 <类型 = 单精度小数>
    参数 颜色 <类型 = 整数>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    {
        @ @sn<this>.data().AddCircleFilled(@<圆心>, @<半径>, static_cast<ImU32>(@<颜色>), @<分段数>)
    }

    方法 添加多边形 <公开 折叠 @嵌入式方法 = "">
    参数 中心点 <类型 = ImVec2>
    参数 半径 <类型 = 单精度小数>
    参数 颜色 <类型 = 整数>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ @sn<this>.data().AddCircle(@<中心点>, @<半径>, static_cast<ImU32>(@<颜色>), @<分段数>, @<粗细>)
    }

    方法 添加多边形填充 <公开 折叠 @嵌入式方法 = "">
    参数 中心点 <类型 = ImVec2>
    参数 半径 <类型 = 单精度小数>
    参数 颜色 <类型 = 整数>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    {
        @ @sn<this>.data().AddNgonFilled(@<中心点>, @<半径>, static_cast<ImU32>(@<颜色>), @<分段数>)
    }

    方法 添加椭圆 <公开 折叠 @嵌入式方法 = "">
    参数 圆心 <类型 = ImVec2>
    参数 水平半径 <类型 = 单精度小数>
    参数 垂直半径 <类型 = 单精度小数>
    参数 颜色 <类型 = 整数>
    参数 rot <类型 = 单精度小数 @默认值 = 0.0>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ @sn<this>.data().AddEllipse(@<圆心>, @<水平半径>, @<垂直半径> static_cast<ImU32>(@<颜色>), @<rot>, @<分段数>, @<粗细>)
    }

    方法 添加椭圆填充 <公开 折叠 @嵌入式方法 = "">
    参数 圆心 <类型 = ImVec2>
    参数 水平半径 <类型 = 单精度小数>
    参数 垂直半径 <类型 = 单精度小数>
    参数 颜色 <类型 = 整数>
    参数 rot <类型 = 单精度小数 @默认值 = 0.0>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    {
        @ @sn<this>.data().AddEllipseFilled(@<圆心>, @<水平半径>, @<垂直半径>, static_cast<ImU32>(@<颜色>), @<rot>, @<分段数>)
    }

    方法 添加文本 <公开 折叠 @嵌入式方法 = "">
    参数 位置 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 文本内容 <注释 = "所欲添加的文本内容;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    {
        @ @sn<this>.data().AddText(@<位置>, static_cast<ImU32>(@<颜色>), *PivAny2U{@<文本内容>}, nullptr)
    }

    方法 添加文本Ex <公开 折叠 @嵌入式方法 = "">
    参数 字体 <类型 = IM字体类>
    参数 字体大小 <类型 = 单精度小数>
    参数 位置 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 文本内容 <注释 = "所欲添加的文本内容;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 换行宽度 <类型 = 单精度小数 @默认值 = 0.0>
    参数 精细剪切矩形 <类型 = ImVec4 注释 = "CPU精细剪切矩形" @默认值 = 空对象>
    {
        @ @sn<this>.data().AddText(@<字体>, @<字体大小>, @<位置>, static_cast<ImU32>(@<颜色>), *PivAny2U{@<文本内容>}, nullptr, @<换行宽度>, @<精细剪切矩形>.GetPtr())
    }

    方法 添加折线 <公开 折叠>
    参数 端点数组 <类型 = ImVec2数组类>
    参数 颜色 <类型 = 整数>
    参数 标志 <类型 = 整数 @默认值 = IM绘制标志.无>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ data().AddPolyline(@<端点数组>.data().data(), @<端点数组>.data().size(), static_cast<ImU32>(@<颜色>), static_cast<ImDrawFlags>(@<标志>), @<粗细>);
    }

    方法 添加凸多边形填充 <公开 折叠>
    参数 端点数组 <类型 = ImVec2数组类>
    参数 颜色 <类型 = 整数>
    {
        @ data().AddConvexPolyFilled(@<端点数组>.data().data(), @<端点数组>.data().size(), static_cast<ImU32>(@<颜色>));
    }

    方法 添加三次贝塞尔曲线 <公开 折叠 @嵌入式方法 = "">
    参数 端点1 <类型 = ImVec2>
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 端点4 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    {
        @ @sn<this>.data().AddBezierCubic(@<端点1>, @<端点2>, @<端点3>, <端点4>, static_cast<ImU32>(@<颜色>), @<粗细>, @<分段数>)
    }

    方法 添加二次贝塞尔曲线 <公开 折叠 @嵌入式方法 = "">
    参数 端点1 <类型 = ImVec2>
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    {
        @ @sn<this>.data().AddBezierQuadratic(@<端点1>, @<端点2>, @<端点3>, static_cast<ImU32>(@<颜色>), @<粗细>, @<分段数>)
    }

    # 图像基元 | Image primitives

    方法 添加图像 <公开 @嵌入式方法 = "">
    参数 用户纹理ID <类型 = 长整数>
    参数 左上矩形 <类型 = ImVec2>
    参数 右下矩形 <类型 = ImVec2>
    参数 左上纹理坐标 <类型 = ImVec2 注释 = "提供纹理的左上坐标,默认的(0.0, 0.0)表示最左上角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 右下纹理坐标 <类型 = ImVec2 注释 = "提供纹理的右下坐标,默认的(1.0, 1.0)表示最右下角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 颜色 <类型 = 整数 注释 = "默认为白色" @默认值 = 0xFFFFFFFF>
    {
        @ @sn<this>.data().AddImage((ImTextureID)@<用户纹理ID>, @<左上矩形>, @<右下矩形>, GET_ImVec2_MaybeNull(@<左上纹理坐标>, 0, 0),
        @                           GET_ImVec2_MaybeNull(@<右下纹理坐标>, 1, 1), static_cast<ImU32>(@<颜色>))
    }

    方法 添加四边形图像 <公开 @嵌入式方法 = "">
    参数 用户纹理ID <类型 = 长整数>
    参数 端点1 <类型 = ImVec2>
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 端点4 <类型 = ImVec2>
    参数 纹理坐标1 <类型 = ImVec2 注释 = "提供纹理的左上坐标,默认的(0.0, 0.0)表示最左上角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 纹理坐标2 <类型 = ImVec2 注释 = "提供纹理的右下坐标,默认的(1.0, 1.0)表示最右下角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 纹理坐标3 <类型 = ImVec2 @默认值 = 空对象>
    参数 纹理坐标4 <类型 = ImVec2 @默认值 = 空对象>
    参数 颜色 <类型 = 整数 注释 = "默认为白色" @默认值 = 0xFFFFFFFF>
    {
        @ @sn<this>.data().AddImageQuad((ImTextureID)@<用户纹理ID>, @<端点1>, @<端点2>, @<端点3>, @<端点4>, GET_ImVec2_MaybeNull(@<纹理坐标1>, 0, 0),
        @                               GET_ImVec2_MaybeNull(@<纹理坐标2>, 1, 0), GET_ImVec2_MaybeNull(@<纹理坐标3>, 1, 1), GET_ImVec2_MaybeNull(@<纹理坐标4>, 0, 1),
        @                               static_cast<ImU32>(@<颜色>))
    }

    方法 添加圆角矩形图像 <公开 @嵌入式方法 = "">
    参数 用户纹理ID <类型 = 长整数>
    参数 左上矩形 <类型 = ImVec2>
    参数 右下矩形 <类型 = ImVec2>
    参数 左上纹理坐标 <类型 = ImVec2 注释 = "提供纹理的左上坐标,默认的(0.0, 0.0)表示最左上角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 右下纹理坐标 <类型 = ImVec2 注释 = "提供纹理的右下坐标,默认的(1.0, 1.0)表示最右下角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 颜色 <类型 = 整数 注释 = "默认为白色" @默认值 = 0xFFFFFFFF>
    参数 圆角半径 <类型 = 单精度小数>
    参数 标志 <类型 = 整数 @默认值 = IM绘制标志.无>
    {
        @ @sn<this>.data().AddImage((ImTextureID)@<用户纹理ID>, @<左上矩形>, @<右下矩形>, GET_ImVec2_MaybeNull(@<左上纹理坐标>, 0, 0),
        @                           GET_ImVec2_MaybeNull(@<右下纹理坐标>, 1, 1), static_cast<ImU32>(@<颜色>), @<圆角半径>, static_cast<ImDrawFlags>(@<标志>))
    }

    # Stateful path API, add points then finish with PathFillConvex() or PathStroke()

    方法 清除路径 <公开 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().PathClear()
    }

    方法 连接折线路径 <公开 折叠 @嵌入式方法 = "">
    参数 位置 <类型 = ImVec2>
    {
        @ @sn<this>.data().PathLineTo(@<位置>)
    }

    方法 连接折线路径_去重 <公开 折叠 @嵌入式方法 = "">
    参数 位置 <类型 = ImVec2>
    {
        @ @sn<this>.data().PathLineToMergeDuplicate(@<位置>)
    }

    方法 填充凸多边形路径 <公开 折叠 @嵌入式方法 = "">
    参数 颜色 <类型 = 整数>
    {
        @ @sn<this>.data().PathFillConvex(static_cast<ImU32>(@<颜色>))
    }

    方法 描边路径 <公开 折叠 @嵌入式方法 = "">
    参数 颜色 <类型 = 整数>
    参数 标志 <类型 = 整数 @默认值 = IM绘制标志.无>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ @sn<this>.data().PathStroke(static_cast<ImU32>(@<颜色>), static_cast<ImDrawFlags>(@<标志>), @<粗细>)
    }

    方法 连接弧形路径 <公开 折叠 @嵌入式方法 = "">
    参数 圆心 <类型 = ImVec2>
    参数 半径 <类型 = 单精度小数>
    参数 a_min <类型 = 单精度小数>
    参数 a_max <类型 = 单精度小数>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    {
        @ @sn<this>.data().PathArcTo(@<圆心>, @<半径>, @<a_min>, @<a_max>, @<分段数>)
    }

    方法 连接弧形路径_快速 <公开 折叠 @嵌入式方法 = "">
    参数 圆心 <类型 = ImVec2>
    参数 半径 <类型 = 单精度小数>
    参数 a_min_of_12 <类型 = 单精度小数>
    参数 a_max_of_12 <类型 = 单精度小数>
    {
        @ @sn<this>.data().PathArcToFast(@<圆心>, @<半径>, @<a_min_of_12>, @<a_max_of_12>)
    }

    方法 连接椭圆弧形路径 <公开 折叠 @嵌入式方法 = "">
    参数 圆心 <类型 = ImVec2>
    参数 水平半径 <类型 = 单精度小数>
    参数 垂直半径 <类型 = 单精度小数>
    参数 rot <类型 = 单精度小数>
    参数 a_min <类型 = 单精度小数>
    参数 a_max <类型 = 单精度小数>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    {
        @ @sn<this>.data().PathEllipticalArcTo(@<圆心>, @<水平半径>, @<垂直半径>, @<rot>, @<a_min>, @<a_max>, @<分段数>)
    }

    方法 连接三次贝塞尔曲线路径 <公开 折叠 @嵌入式方法 = "">
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 端点4 <类型 = ImVec2>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    {
        @ @sn<this>.data().PathBezierCubicCurveTo(@<端点2>, @<端点3>, @<端点4>, @<分段数>)
    }

    方法 连接二次贝塞尔曲线路径 <公开 折叠 @嵌入式方法 = "">
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    {
        @ @sn<this>.data().PathBezierQuadraticCurveTo(@<端点2>, @<端点3>, @<分段数>)
    }

    方法 矩形路径 <公开 折叠 @嵌入式方法 = "">
    参数 左上矩形 <类型 = ImVec2>
    参数 右下矩形 <类型 = ImVec2>
    参数 圆角半径 <类型 = 单精度小数 @默认值 = 0.0>
    参数 标志 <类型 = 整数 @默认值 = IM绘制标志.无>
    {
        @ @sn<this>.data().PathRect(@<左上矩形>, @<右下矩形>, @<圆角半径>, static_cast<ImDrawFlags>(@<标志>))
    }
}

# 辅助类

类 IM颜色类 <公开 注释 = "提供了ImGui中的各种颜色的快捷创建与转换" 折叠 @文档 = "category = \"辅助类\"" @禁止创建对象 = 真>
{
    方法 取颜色值 <公开 静态 类型 = 整数 注释 = "将指定的RGBA颜色分量组合为32位整数颜色值并返回" 折叠 @嵌入式方法 = "">
    参数 红色分量值 <类型 = 整数 注释 = "数值范围从 0 到 255,表示颜色中的红色分量值.">
    参数 绿色分量值 <类型 = 整数 注释 = "数值范围从 0 到 255,表示颜色中的绿色分量值.">
    参数 蓝色分量值 <类型 = 整数 注释 = "数值范围从 0 到 255,表示颜色中的蓝色分量值.">
    参数 透明分量值 <类型 = 整数 注释 = "数值范围从 0 到 255,表示颜色中的透明分量值;" 注释 = "0为完全透明,255为完全不透明." @默认值 = 255>
    {
        @ (CLIP(@<红色分量值>, 0, 255) << 0 ) | (CLIP(@<绿色分量值>, 0, 255) << 8 ) |
        @ (CLIP(@<蓝色分量值>, 0, 255) << 16) | (CLIP(@<透明分量值>, 0, 255) << 24)
    }

    方法 取ImVec4颜色 <公开 静态 类型 = ImVec4 注释 = "使用指定的RGBA颜色分量创建一个ImVec4实例并返回" 折叠 @嵌入式方法 = "">
    参数 红色值 <类型 = 单精度小数 注释 = "数值范围从 0.0 到 1.0,表示颜色中的红色分量值." @默认值 = 0>
    参数 绿色值 <类型 = 单精度小数 注释 = "数值范围从 0.0 到 1.0,表示颜色中的绿色分量值." @默认值 = 0>
    参数 蓝色值 <类型 = 单精度小数 注释 = "数值范围从 0.0 到 1.0,表示颜色中的蓝色分量值." @默认值 = 0>
    参数 透明值 <类型 = 单精度小数 注释 = "数值范围从 0.0 到 1.0,表示颜色中的透明分量值." @默认值 = 0>
    {
        @ @dt<ImVec4>{ImVec4(@<红色值>, @<绿色值>, @<蓝色值>, @<透明值>)}
    }

    方法 RGB到RGBA <公开 静态 类型 = 整数 注释 = "将指定的RGB颜色转换为RGBA颜色值并返回." 注释 = "注: 可用于转换\"颜色类\"中的常量." 折叠 @嵌入式方法 = "">
    参数 RGB颜色值 <类型 = 整数 注释 = "可以提供\"颜色类\"中的常量,或\"取颜色值\"的返回值.">
    参数 透明分量值 <类型 = 整数 注释 = "数值范围从 0 到 255,表示颜色中的透明分量值;" 注释 = "0为完全透明,255为完全不透明." @默认值 = 255>
    {
        @ @<RGB颜色值> | (CLIP(@<透明分量值>, 0, 255) << 24)
    }

    方法 RGBA到RGB <公开 静态 类型 = 整数 注释 = "将指定的RGBA颜色转换为RGB颜色值并返回."
            注释 = "注: 返回的是COLORREF值,不能用于ImGui,但可以给Win32窗口使用." 折叠 @禁止流程检查 = 真>
    参数 RGBA颜色值 <类型 = 整数 注释 = "可以提供\"颜色类\"中的常量,或\"取颜色值\"的返回值.">
    参数 是否应用透明 <类型 = 逻辑型 注释 = "是否将透明度应用到返回的RGB值中,为真时按比例降低RGB各颜色分量;" 注释 = "为假则仅将透明分量值置0后返回." @默认值 = 真>
    {
        @ if (@<是否应用透明>) {
        @     int alpha = (@<RGBA颜色值> >> 24) & 0xFF;
        @     if (alpha != 255) {
        @         float a = alpha / 255.0f;
        @         return ((int)(((@<RGBA颜色值> >> 0) & 0xFF) * a + 0.5f) << 0) | ((int)(((@<RGBA颜色值> >> 8) & 0xFF) * a + 0.5f) << 8) |
        @                 ((int)(((@<RGBA颜色值> >> 16) & 0xFF) * a + 0.5f) << 16);
        @     }
        @ }
        @ return (@<RGBA颜色值> & 0x00FFFFFF);
    }

    方法 颜色值到ImVec4 <公开 静态 类型 = ImVec4 注释 = "将32位整数的RGBA颜色值转换到4个单精度小数" 折叠 @嵌入式方法 = "">
    参数 颜色值 <类型 = 整数 注释 = "32位RGBA颜色值">
    {
        @ @dt<ImVec4>{ImGui::ColorConvertU32ToFloat4(static_cast<ImU32>(@<颜色值>))}
    }

    方法 ImVec4到颜色值 <公开 静态 类型 = 整数 注释 = "将4个单精度小数的RGBA颜色值转换到32位整数" 折叠 @嵌入式方法 = "">
    参数 浮点数颜色 <类型 = ImVec4>
    {
        @ static_cast<INT>(ImGui::ColorConvertFloat4ToU32(@<浮点数颜色>))
    }
}

类 IM文本数组类 <公开 基础类 = 扩展对象类 注释 = "  成员类型为\"标准文本类U\"的数组类,内部文本编码是UTF-8," 注释 = "加入成员时支持多种文本类型,如有必要会自动转换编码."
        注释 = "  主要供\"组合框\"、\"列表框\"等ImGUI窗口组件使用." 折叠 @文档 = "category = \"辅助类\"" @视窗.外部头文件 = "<vector>">
{
    方法 枚举循环 <公开 注释 = "  启动一个循环来枚举数组的每一个成员,在循环中可以调用" 注释 = "\"取枚举值\"方法来获取当前所枚举到的成员值,调用\"取枚举索引\""
            注释 = "方法来获取当前所枚举到成员的索引位置." 折叠 @嵌入式方法 = "name = counter\r\nhas_loop_body = true">
    {
        @ IM_VECTOR_FOR_FORWARD (@sn<this>)
    }

    方法 逆向枚举循环 <公开 注释 = "  启动一个逆向循环来枚举数组的每一个成员,在循环中可以调" 注释 = "用\"取枚举值\"方法来获取当前所枚举到的成员值,调用\"取枚举索引\""
            注释 = "方法来获取当前所枚举到成员的索引位置." 折叠 @嵌入式方法 = "name = rcounter\r\nhas_loop_body = true">
    {
        @ IM_VECTOR_FOR_REVERSE (@sn<this>)
    }

    方法 取枚举索引 <公开 类型 = 变整数 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前枚举到成员的索引位置."
            注释 = "跟官方库的不一样,即使有多层本类或本类继承类的\"枚举循环\"嵌套,本方法仍能正确返回" 注释 = "枚举到成员的索引位置." 折叠
            @嵌入式方法 = "parent = \"counter, rcounter\"">
    {
        @ static_cast<INT_P>(@sn<this>.m_index)
    }

    方法 取枚举成员 <公开 类型 = 标准文本类U 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前枚举到的成员值."
            注释 = "跟官方库的不一样,即使有多层本类或本类继承类的\"枚举循环\"嵌套,本方法仍能正确" 注释 = "返回枚举成员值." 折叠
            @嵌入式方法 = "parent = \"counter, rcounter\"" @视窗.返回参考 = 真>
    {
        @ IM_VECTOR_FOR_GET_VALUES (@sn<this>)
    }

    方法 取枚举成员文本 <公开 类型 = 文本型 注释 = "跟\"取枚举成员\"不同,本方法返回的是火山的\"文本型\",会产生编码转换." 折叠
            @嵌入式方法 = "parent = \"counter, rcounter\"">
    {
        @ IM_VECTOR_FOR_GET_VALUES (@sn<this>).ToVolString()
    }

    方法 索引是否有效 <公开 类型 = 逻辑型 注释 = "返回所指定的索引值是否大于等于0且小于本数组的成员数." 折叠 @禁止流程检查 = 真>
    参数 所欲检查的索引值 <类型 = 变整数>
    {
        @ return static_cast<size_t>(@<所欲检查的索引值>) >= 0 && static_cast<size_t>(@<所欲检查的索引值>) < data().size();
    }

    方法 重置数组 <公开 注释 = "重置数组中的成员数为所指定的数目,数组原有的数据将被覆盖." 折叠 @嵌入式方法 = "">
    参数 欲重置的成员数目 <类型 = 整数 注释 = "重置后的数组成员数">
    {
        @ @sn<this>.data().assign(@<欲重置的成员数目>, PivStringU{})
    }

    方法 是否为空 <公开 类型 = 逻辑型 注释 = "返回本数组是否为空" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<BOOL>(@sn<this>.data().empty())
    }

    方法 删除所有成员 <公开 注释 = "删除数组中的当前所有成员" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().clear()
    }

    方法 删除成员 <公开 注释 = "删除数组中所指定索引范围的单个或多个成员" 折叠>
    参数 删除索引位置 <类型 = 变整数 注释 = "提供所欲删除的索引位置,必须大于等于0且小于等于数组成员数目.">
    参数 结束索引位置 <类型 = 变整数 注释 = "默认为-1, 即只删除单个成员." 注释 = "提供所欲删除的尾成员的索引位置,必须大于\"所欲删除首位置\"且小于等于数组成员数目."
            @默认值 = -1>
    {
        @ auto it = data().begin();
        @ if (@<结束索引位置> != -1){
        @     data().erase(it + static_cast<size_t>(@<删除索引位置>), it + static_cast<size_t>(@<结束索引位置>) + 1);
        @ } else {
        @     data().erase(it + static_cast<size_t>(@<删除索引位置>), it + static_cast<size_t>(@<删除索引位置>) + 1);
        @ }
    }

    方法 取成员数 <公开 类型 = 变整数 注释 = "返回数组中的当前已有成员数目" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT_P>(@sn<this>.data().size())
    }

    方法 取成员 <公开 类型 = 标准文本类U 注释 = "返回所指定索引位置处的\"标准文本类U\"成员值." 注释 = "高效率,不检查边界,不抛出异常,索引无效直接崩溃." 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ @sn<this>.data()[static_cast<size_t>(@<索引位置>)]
    }

    方法 取成员文本 <公开 类型 = 文本型 注释 = "返回所指定索引位置处的\"文本型\"成员值,会产生编码转换." 注释 = "高效率,不检查边界,不抛出异常,索引无效直接崩溃." 折叠
            @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ @sn<this>.data()[static_cast<size_t>(@<索引位置>)].ToVolString()
    }

    方法 置成员值 <公开 注释 = "设置数组中所指定索引位置处的成员文本值,本方法不执行索引检查,索引无效直接崩溃." 折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    参数 所欲设置的文本 <注释 = "提供所欲设置的成员值,先前的值将被覆盖." 注释 = "支持类型(*表示会进行编码转换):" 注释 = "  标准文本类U、文本视图类U"
            注释 = "  *文本型、*标准文本类、*文本视图类" @匹配类型 = 通用型>
    {
        @ @sn<this>.data()[static_cast<size_t>(@<索引位置>)] = @dt<标准文本类U>{@<所欲设置的文本>}
    }

    方法 加入成员 <公开 注释 = "将一个或多个文本值加入到数组尾部" 折叠 @嵌入式方法 = "">
    参数 所欲加入文本 <注释 = "所欲添加的文本值,支持类型(*表示会进行编码转换):" 注释 = "  标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = "  *文本型、*标准文本类、*文本视图类" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @sn<this>.push_backs(@<所欲加入文本>)
    }

    方法 加入成员2 <公开 注释 = "将一个文本值加入到数组尾部,本方法不会进行编码转换." 折叠 @嵌入式方法 = "">
    参数 所欲加入文本 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量或文本常量" @需求类型 = 立即数或常量>
    {
        @ @sn<this>.data().push_back(@dt<标准文本类U>{u8@sn<quot>@pvpt<所欲加入文本>@sn<quot>})
    }

    方法 插入成员 <公开 注释 = "将所指定的文本值插入到所指定的索引位置" 折叠 @嵌入式方法 = "">
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于数组成员数目.">
    参数 所欲插入的文本 <注释 = "所欲添加的文本值,支持类型(*表示会进行编码转换):" 注释 = "  标准文本类U、文本视图类U" 注释 = "  *文本型、*标准文本类、*文本视图类"
            @匹配类型 = 通用型>
    {
        @ data().emplace (data().begin() + static_cast<size_t>(@<插入索引位置>), @dt<标准文本类U>{@<所欲插入的文本>});
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<IM_项目数组类> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举成员 ()))

        }
    }

    # @begin
    # <> <include>
    # #define IM_VECTOR_FOR_FORWARD(cThis) for (cThis.m_index = 0; cThis.m_index < cThis.data().size(); cThis.m_index++)
    # #define IM_VECTOR_FOR_REVERSE(cThis) for (cThis.m_index = cThis.data().size() - 1; cThis.m_index >= 0; cThis.m_index--)
    # #define IM_VECTOR_FOR_GET_VALUES(cThis) cThis.data()[cThis.m_index]
    # size_t m_index;
    # std::vector<PivStringU> m_vecData;
    # inline void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom) { m_vecData = objCopyFrom.m_vecData; }
    # inline @sn<current_class>& operator= (@sn<current_class>&& rhs) { m_vecData = std::move(rhs.m_vecData); return *this; }
    # inline BOOL @an<_IsSelfEqualExtra> (const @sn<current_class>& objCompare) const { return (m_vecData == objCompare.m_vecData); }
    # inline std::vector<PivStringU> &data () { return m_vecData; }
    # inline std::vector<PivStringU> *pdata () { return &m_vecData; }
    # inline void push_backs(const std::string &s) { m_vecData.push_back(PivStringU{s}); }
    # inline void push_backs(const std::wstring &s) { m_vecData.push_back(PivStringU{s}); }
    # inline void push_backs(const piv::string_view &s) { m_vecData.push_back(PivStringU{s}); }
    # inline void push_backs(const piv::wstring_view &s) { m_vecData.push_back(PivStringU{s}); }
    # template <typename T>
    # inline void push_backs(const T &s) { m_vecData.push_back(PivStringU{s}); }
    # template <typename T, typename... Args>
    # inline void push_backs(const T &s, const Args... args) {
    #     push_backs(s); push_backs(args...);
    # }
    # static const char* ItemGetter(void* data, int idx) {
    #     std::vector<PivStringU>* arr = reinterpret_cast<std::vector<PivStringU>*>(data);
    #     return arr->at(idx).data().c_str();
    # }
    # <> </include>
    # @end
}

类 IM字体类 <公开 基础类 = 数据类型基础类 注释 = "ImFont" 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImFont)
}

类 IM字体图集类 <公开 基础类 = 数据类型基础类 注释 = "ImFontAtlas" 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImFontAtlas)

    方法 添加默认字体 <公开 类型 = IM字体类 注释 = "添加ImGui的默认字体(ProggyClean.ttf)" 返回值注释 = "返回字体指针" 折叠 @嵌入式方法 = "">
    {
        @ @dt<IM字体类>{@sn<this>.pdata()->AddFontDefault(nullptr)}
    }

    方法 添加字体文件 <公开 类型 = IM字体类 注释 = "从文件中添加字体" 返回值注释 = "返回字体" 折叠 @嵌入式方法 = "">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲添加的字体文件路径">
    参数 像素大小 <类型 = 单精度小数 注释 = "栅格化字体时的像素大小,每种字体的大小都不一样,请自行测试找到合适的大小.">
    参数 字形范围 <类型 = IM字形范围 注释 = "选择字体的字形范围,范围内的字符将栅格化为图集,如果范围过大将消耗更多的内存." 注释 = "但如果有不在范围内字符,将无法正常显示."
            @默认值 = IM字形范围.中文>
    {
        @ @dt<IM字体类>{@sn<this>.pdata()->AddFontFromFileTTF(*PivAny2U{@<文件名>}, @<像素大小>, nullptr, ImFontAtlas().@pvpt<字形范围>())}
    }

    方法 添加内存字体 <公开 类型 = IM字体类 注释 = "从内存数据添加字体,添加后请勿自行释放字体的内存数据." 返回值注释 = "返回字体指针" 折叠 @嵌入式方法 = "">
    参数 字体数据地址 <类型 = 变整数 注释 = "提供所欲添加的字体数据地址,字体数据的所有权将自动转移到ImGui内部,由ImGui释放相关内存,所以请勿自行释放.">
    参数 字体数据大小 <类型 = 整数 注释 = "提供所欲添加的字体数据大小">
    参数 像素大小 <类型 = 单精度小数 注释 = "栅格化字体时的像素大小,每种字体的大小都不一样,请自行测试找到合适的大小.">
    参数 字形范围 <类型 = IM字形范围 注释 = "选择字体的字形范围,范围内的字符将栅格化为图集,如果范围过大将消耗更多的内存." 注释 = "但如果有不在范围内字符,将无法正常显示."
            @默认值 = IM字形范围.中文>
    {
        @ @dt<IM字体类>{@sn<this>.pdata()->AddFontFromMemoryTTF(reinterpret_cast<void*>(@<字体数据地址>), @<字体数据大小>,
        @                                                       @<像素大小>, nullptr, ImFontAtlas().@pvpt<字形范围>())}
    }

    方法 添加字体文件Ex <公开 类型 = IM字体类 注释 = "从文件中添加字体" 返回值注释 = "返回字体" 折叠 @嵌入式方法 = "">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲添加的字体文件路径">
    参数 像素大小 <类型 = 单精度小数 注释 = "栅格化字体时的像素大小,每种字体的大小都不一样,请自行测试找到合适的大小.">
    参数 字形范围 <类型 = IM字形范围构建类 注释 = "选择字体的字形范围,范围内的字符将栅格化为图集,如果范围过大将消耗更多的内存." 注释 = "但如果有不在范围内字符,将无法正常显示.">
    {
        @ @dt<IM字体类>{@sn<this>.pdata()->AddFontFromFileTTF(*PivAny2U{@<文件名>}, @<像素大小>, nullptr, @<字形范围>.ranges())}
    }

    方法 添加内存字体Ex <公开 类型 = IM字体类 注释 = "从内存数据添加字体,添加后请勿自行释放字体的内存数据." 返回值注释 = "返回字体指针" 折叠 @嵌入式方法 = "">
    参数 字体数据地址 <类型 = 变整数 注释 = "提供所欲添加的字体数据地址,字体数据的所有权将自动转移到ImGui内部,由ImGui释放相关内存,所以请勿自行释放.">
    参数 字体数据大小 <类型 = 整数 注释 = "提供所欲添加的字体数据大小">
    参数 像素大小 <类型 = 单精度小数 注释 = "栅格化字体时的像素大小,每种字体的大小都不一样,请自行测试找到合适的大小.">
    参数 字形范围 <类型 = IM字形范围构建类 注释 = "选择字体的字形范围,范围内的字符将栅格化为图集,如果范围过大将消耗更多的内存." 注释 = "但如果有不在范围内字符,将无法正常显示.">
    {
        @ @dt<IM字体类>{@sn<this>.pdata()->AddFontFromMemoryTTF(reinterpret_cast<void*>(@<字体数据地址>), @<字体数据大小>, @<像素大小>, nullptr, @<字形范围>.ranges())}
    }

    方法 清除输入数据 <公开 注释 = "清除字体的输入数据(所有ImFontConfig结构,包括大小、字体内存数据、字形范围等),即用于生成纹理和字体的所有数据." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->ClearInputData()
    }

    方法 清除纹理数据 <公开 注释 = "清除输出的字体纹理数据(CPU侧),每当字体纹理复制到显卡内存后保存到内存中." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->ClearTexData()
    }

    方法 清除字体 <公开 注释 = "清除输出的字体数据(字形存储、UV坐标等)" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->ClearFonts()
    }

    方法 清除 <公开 注释 = "清除字体图集的所有输入和输出数据" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->Clear()
    }

    方法 生成 <公开 注释 = "生成8位单通道Alpha颜色的字体图集像素,本方法亦会在执行\"取纹理数据_xxx\"时自动调用." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->Build()
    }

    方法 取纹理数据_Alpha8 <公开 类型 = 变整数 注释 = "生成8位单通道Alpha颜色的字体图集像素(1字节/像素),然后返回纹理的指针和宽高."
            返回值注释 = "返回字体纹理的指针,可以转换到字节集: 字节集.指针添加字节集 (纹理指针, 纹理宽度 * 纹理高度 * 1)" 折叠 @禁止流程检查 = 真>
    参数 纹理宽度 <类型 = 整数类 注释 = "返回字体图集纹理的宽度." @默认值 = 空对象>
    参数 纹理高度 <类型 = 整数类 注释 = "返回字体图集纹理的高度." @默认值 = 空对象>
    {
        @ unsigned char* tex_pixels = nullptr;
        @ pdata()->GetTexDataAsAlpha8(&tex_pixels, &@<纹理宽度.值>, &@<纹理高度.值>, nullptr);
        @ return reinterpret_cast<INT_P>(tex_pixels);
    }

    方法 取纹理数据_RGBA32 <公开 类型 = 变整数 注释 = "生成32位RGBA颜色的字体图集像素(4字节/像素),然后返回纹理的指针和宽高."
            注释 = "注意: 提供RGBA32格式主要为了方便和兼容性,除非手动操作或将颜色数据复制到纹理中," 注释 = "否则生成的RGB像素将始终是白色(约浪费75%的内存占用)."
            注释 = "无论如何,内部都会先生成8位Alpha颜色,再转换到RGBA32."
            返回值注释 = "返回字体纹理的指针,可以转换到字节集: 字节集.指针添加字节集 (纹理指针, 纹理宽度 * 纹理高度 * 4)" 折叠 @禁止流程检查 = 真>
    参数 纹理宽度 <类型 = 整数类 注释 = "返回字体图集纹理的宽度." @默认值 = 空对象>
    参数 纹理高度 <类型 = 整数类 注释 = "返回字体图集纹理的高度." @默认值 = 空对象>
    {
        @ unsigned char* tex_pixels = nullptr;
        @ pdata()->GetTexDataAsRGBA32(&tex_pixels, &@<纹理宽度.值>, &@<纹理高度.值>, nullptr);
        @ return reinterpret_cast<INT_P>(tex_pixels);
    }

    方法 是否已生成 <公开 类型 = 逻辑型 注释 = "返回是否已经生成了纹理数据" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->IsBuilt()
    }
}

类 IM字形范围构建类 <公开 基础类 = 数据类型基础类 注释 = "ImFontGlyphRangesBuilder,用于自定义字体的字形范围,"
        注释 = "可实现只渲染字体中需要的文字,可以有效缩减字体纹理数据的内存占用." 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImFontGlyphRangesBuilder)

    方法 清空 <公开 注释 = "清空当前的字形范围" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().Clear()
    }

    方法 加入字符 <公开 注释 = "添加一个宽字库到字形范围中" 折叠 @嵌入式方法 = "">
    参数 所加入字符 <类型 = 字符 注释 = "所欲添加的字符,可以用单引号输入汉字,比如: \'火\'">
    {
        @ @sn<this>.data().AddChar(@<所加入字符>)
    }

    方法 加入文本 <公开 注释 = "以火山的文本型添加一组文字到自定义的字形范围中." 注释 = "本方法不会产生编码转换,推荐使用." 折叠>
    参数 所加入文本 <类型 = 文本型>
    {
        @ for (INT_P i = 0; i < @<所加入文本>.GetLength(); i++) {
        @     this->data().AddChar(@<所加入文本>.GetCharAt (i));
        @ }
    }

    方法 加入文本U <公开 注释 = "添加UTF-8编码的文本数据到自定义的字形范围中."
            注释 = "注意: 由于内部会将UTF-8字符转换到Unicode字符,因此会产生一到两次的编码转换,不太建议使用." 折叠 @嵌入式方法 = "">
    参数 所加入文本 <注释 = "支持类型(*表示会进行编码转换):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8编码)" 注释 = " *文本型、*标准文本类、*文本视图类"
            @匹配类型 = 通用型>
    {
        @ @sn<this>.data().AddText(*PivAny2U{@<所加入文本>})
    }

    方法 加入范围 <公开 注释 = "添加\"IM字形范围\"常量中的字形范围,可以方便添加英文数字等常用文字类型." 折叠 @嵌入式方法 = "">
    参数 字形范围 <类型 = IM字形范围 注释 = "选择字体的字形范围,范围内的字符将栅格化为图集,如果范围过大将消耗更多的内存." 注释 = "但如果有不在范围内字符,将无法正常显示."
            @默认值 = IM字形范围.中文>
    {
        @ @sn<this>.data().AddRanges(ImFontAtlas().@pvpt<字形范围>())
    }

    # @begin
    # <> <include>
    # ImVector<ImWchar>* m_ranges = nullptr;
    # // 下面的方法找不到释放内存的时机,但只内存泄漏一次,问题不大...
    # inline ImWchar* ranges() {
    #     if (!m_ranges) { m_ranges = new ImVector<ImWchar>; }
    #     this->data().BuildRanges(m_ranges);
    #     return m_ranges->Data;
    # }
    # <> </include>
    # @end
}

类 ImVec2 <公开 基础类 = 数据类型基础类 注释 = "ImVec2" 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImVec2)

    方法 创建 <公开 静态 类型 = ImVec2 注释 = "带参构造一个ImVec2实例,请以类名使用本方法." 折叠 @嵌入式方法 = "">
    参数 x值 <类型 = 单精度小数 @默认值 = 0>
    参数 y值 <类型 = 单精度小数 @默认值 = 0>
    {
        @ @dt<ImVec2>{ImVec2(@<x值>, @<y值>)}
    }

    方法 x <公开 属性读 类型 = 单精度小数 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->x
    }

    方法 x <公开 属性写 折叠>
    参数 所欲设置值 <类型 = 单精度小数>
    {
        @ pdata()->x = @<所欲设置值>;
    }

    方法 y <公开 属性读 类型 = 单精度小数 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->y
    }

    方法 y <公开 属性写 折叠>
    参数 所欲设置值 <类型 = 单精度小数>
    {
        @ pdata()->y = @<所欲设置值>;
    }

    方法 置值 <公开 注释 = "一个命令设置ImVec2的所有值" 折叠>
    参数 x值 <类型 = 单精度小数>
    参数 y值 <类型 = 单精度小数>
    {
        @ pdata()->x = @<x值>;
        @ pdata()->y = @<y值>;
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        加入格式文本 (展示内容, "<ImVec2> {x: %.2f, y: %.2f}", x, y)
    }
}

类 ImVec2数组类 <公开 基础类 = 数据容器模板类 折叠 @文档 = "category = \"辅助类\"" @模板实现类 = "ImVec2">
{

    # @ @m<PIV_DECLARE_VECTOR_CLASS> (ImVec2)
}

类 ImVec4 <公开 基础类 = 数据类型基础类 注释 = "ImVec4" 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImVec4)

    方法 创建 <公开 静态 类型 = ImVec4 注释 = "带参构造一个ImVec4实例,请以类名使用本方法." 折叠 @嵌入式方法 = "">
    参数 x值 <类型 = 单精度小数 @默认值 = 0>
    参数 y值 <类型 = 单精度小数 @默认值 = 0>
    参数 z值 <类型 = 单精度小数 @默认值 = 0>
    参数 w值 <类型 = 单精度小数 @默认值 = 0>
    {
        @ @dt<ImVec4>{ImVec4(@<x值>, @<y值>, @<z值>, @<w值>)}
    }

    方法 x <公开 属性读 类型 = 单精度小数 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->x
    }

    方法 x <公开 属性写 折叠>
    参数 所欲设置值 <类型 = 单精度小数>
    {
        @ pdata()->x = @<所欲设置值>;
    }

    方法 y <公开 属性读 类型 = 单精度小数 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->y
    }

    方法 y <公开 属性写 折叠>
    参数 所欲设置值 <类型 = 单精度小数>
    {
        @ pdata()->y = @<所欲设置值>;
    }

    方法 z <公开 属性读 类型 = 单精度小数 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->z
    }

    方法 z <公开 属性写 折叠>
    参数 所欲设置值 <类型 = 单精度小数>
    {
        @ pdata()->z = @<所欲设置值>;
    }

    方法 w <公开 属性读 类型 = 单精度小数 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->w
    }

    方法 w <公开 属性写 折叠>
    参数 所欲设置值 <类型 = 单精度小数>
    {
        @ pdata()->w = @<所欲设置值>;
    }

    方法 置值 <公开 注释 = "一个命令设置ImVec4的所有值" 折叠>
    参数 x值 <类型 = 单精度小数>
    参数 y值 <类型 = 单精度小数>
    参数 z值 <类型 = 单精度小数>
    参数 w值 <类型 = 单精度小数>
    {
        @ pdata()->x = @<x值>;
        @ pdata()->y = @<y值>;
        @ pdata()->z = @<z值>;
        @ pdata()->w = @<w值>;
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        加入格式文本 (展示内容, "<ImVec4> {x: %.2f, y: %.2f, z: %.2f, w: %.2f}", x, y, z, w)
    }
}

类 IM图片信息类 <公开 基础类 = 扩展对象类 折叠 @文档 = "category = \"辅助类\"">
{
    变量 纹理ID <公开 类型 = 长整数>
    变量 宽度 <公开 类型 = 整数>
    变量 高度 <公开 类型 = 整数>
    变量 _内部数据 <公开 类型 = 变整数>
}

类 ImGuiIO类 <公开 基础类 = 数据类型基础类 注释 = "必须接收\"ImGui.取IO()\"的返回结果后,才能使用本类." 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImGuiIO)

    方法 帧速率 <公开 属性读 类型 = 单精度小数 注释 = "返回应用程序的平均帧速率" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().Framerate
    }

    方法 标志 <公开 属性读 类型 = 整数 注释 = "IM配置标志,请参考\"IM配置标志\"的常量" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(@sn<this>.data().ConfigFlags)
    }

    方法 标志 <公开 属性写 注释 = "IM配置标志" 折叠>
    参数 新标志 <类型 = 整数 注释 = "\"IM配置标志\"常量的位或值">
    {
        @ data().ConfigFlags = static_cast<ImGuiConfigFlags>(@<新标志>);
    }

    方法 INI保存间隔 <公开 属性读 类型 = 单精度小数 注释 = "返回INI保存设置的时间间隔,默认为5.0(单位为秒)." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().IniSavingRate
    }

    方法 INI保存间隔 <公开 属性写 注释 = "设置INI保存设置的时间间隔,单位为秒." 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().IniSavingRate = @<所欲设置的值>;
    }

    方法 INI文件名 <公开 属性读 类型 = 文本型 注释 = "返回.ini文件的路径(默认为当前工作目录下的\"imgui.ini\")." 折叠 @嵌入式方法 = "">
    {
        @ *PivU2Ws{@sn<this>.data().IniFilename}
    }

    方法 INI文件名 <公开 属性写 注释 = "设置.ini文件的路径,设置为空文本可以禁止自动加载和保存窗口设置到ini文件." 折叠>
    参数 新文件名 <类型 = 文本型 注释 = "空文本可以关掉自动读写.ini文件功能">
    {
        @ static PivW2U u8str;
        @ u8str.Convert(@<新文件名>);
        @ data().IniFilename = u8str.GetText();
    }

    方法 用户数据 <公开 属性读 类型 = 变整数 注释 = "返回用户自定义的数据" 折叠 @嵌入式方法 = "">
    {
        @ reinterpret_cast<INT_P>(@sn<this>.data().UserData)
    }

    方法 用户数据 <公开 属性写 注释 = "设置用户自定义的数据(可以为任意的指针)" 折叠>
    参数 所欲设置的值 <类型 = 变整数>
    {
        @ data().UserData = reinterpret_cast<void*>(@<所欲设置的值>);
    }

    方法 字体全局缩放 <公开 属性写 折叠>
    参数 新值 <类型 = 单精度小数>
    {
        @ data().FontGlobalScale = @<新值>;
    }

    方法 允许用户缩放字体 <公开 属性读 类型 = 逻辑型 注释 = "返回是否允许用户通过CTRL+Wheel缩放窗口中的字体" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().FontAllowUserScaling
    }

    方法 允许用户缩放字体 <公开 属性写 注释 = "设置是否允许用户通过CTRL+Wheel缩放窗口中的字体" 折叠>
    参数 所欲设置的值 <类型 = 逻辑型>
    {
        @ data().FontAllowUserScaling = static_cast<bool>(@<所欲设置的值>);
    }

    #
}

类 IM样式类 <公开 基础类 = 数据类型基础类 注释 = "ImGuiStyle" 注释 = "这些样式可以在\"新建帧\"之前更改,当然在当前帧更改也可以,但在下一帧生效."
        注释 = "如果需要更改当前帧的样式,请用\"ImGui.压入样式变量\"" 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImGuiStyle)

    方法 不透明度 <公开 属性读 类型 = 单精度小数 注释 = "Global alpha applies to everything in Dear ImGui." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().Alpha
    }

    方法 不透明度 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().Alpha = @<所欲设置的值>;
    }

    方法 禁用项不透明度 <公开 属性读 类型 = 单精度小数
            注释 = "Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().DisabledAlpha
    }

    方法 禁用项不透明度 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().DisabledAlpha = @<所欲设置的值>;
    }

    方法 窗口内边距 <公开 属性读 类型 = ImVec2 注释 = "Padding within a window." 折叠 @禁止流程检查 = 真>
    {
        @ return @dt<ImVec2>{data().WindowPadding}
    }

    方法 窗口内边距 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = ImVec2>
    {
        @ data().WindowPadding = @<所欲设置的值>;
    }

    方法 窗口圆角 <公开 属性读 类型 = 单精度小数
            注释 = "Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().WindowRounding
    }

    方法 窗口圆角 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().WindowRounding = @<所欲设置的值>;
    }

    方法 窗口边框粗细 <公开 属性读 类型 = 单精度小数
            注释 = "Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly)."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().WindowBorderSize
    }

    方法 窗口边框粗细 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().WindowBorderSize = @<所欲设置的值>;
    }

    方法 窗口最小尺寸 <公开 属性读 类型 = ImVec2
            注释 = "Minimum window size. This is a global setting. If you want to constrain individual windows, use SetNextWindowSizeConstraints()."
            折叠 @禁止流程检查 = 真>
    {
        @ return @dt<ImVec2>{data().WindowMinSize}
    }

    方法 窗口最小尺寸 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = ImVec2>
    {
        @ data().WindowMinSize = @<所欲设置的值>;
    }

    方法 窗口标题对齐 <公开 属性读 类型 = ImVec2
            注释 = "Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered." 折叠
            @禁止流程检查 = 真>
    {
        @ return @dt<ImVec2>{data().WindowTitleAlign}
    }

    方法 窗口标题对齐 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = ImVec2>
    {
        @ data().WindowTitleAlign = @<所欲设置的值>;
    }

    方法 窗口菜单按钮位置 <公开 属性读 类型 = IM基本方向
            注释 = "Side of the collapsing/docking button in the title bar (None/Left/Right). Defaults to ImGuiDir_Left."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().WindowMenuButtonPosition
    }

    方法 窗口菜单按钮位置 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = IM基本方向>
    {
        @ data().WindowMenuButtonPosition = static_cast<ImGuiDir>(@<所欲设置的值>);
    }

    方法 子窗口圆角 <公开 属性读 类型 = 单精度小数
            注释 = "Radius of child window corners rounding. Set to 0.0f to have rectangular windows." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.data().ChildRounding
    }

    方法 子窗口圆角 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().ChildRounding = @<所欲设置的值>;
    }

    方法 子窗口边框粗细 <公开 属性读 类型 = 单精度小数
            注释 = "Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly)."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().ChildBorderSize
    }

    方法 子窗口边框粗细 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().ChildBorderSize = @<所欲设置的值>;
    }

    方法 弹出项圆角 <公开 属性读 类型 = 单精度小数
            注释 = "Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)" 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.data().PopupRounding
    }

    方法 弹出项圆角 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().PopupRounding = @<所欲设置的值>;
    }

    方法 弹出项边框粗细 <公开 属性读 类型 = 单精度小数
            注释 = "Thickness of border around popup/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly)."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().PopupBorderSize
    }

    方法 弹出项边框粗细 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().PopupBorderSize = @<所欲设置的值>;
    }

    方法 框体内边距 <公开 属性读 类型 = ImVec2 注释 = "Padding within a framed rectangle (used by most widgets)." 折叠
            @禁止流程检查 = 真>
    {
        @ return @dt<ImVec2>{data().FramePadding}
    }

    方法 框体内边距 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = ImVec2>
    {
        @ data().FramePadding = @<所欲设置的值>;
    }

    方法 框体圆角 <公开 属性读 类型 = 单精度小数
            注释 = "Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets)."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().FrameRounding
    }

    方法 框体圆角 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().FrameRounding = @<所欲设置的值>;
    }

    方法 框体边框粗细 <公开 属性读 类型 = 单精度小数
            注释 = "Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly)."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().FrameBorderSize
    }

    方法 框体边框框粗细 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().FrameBorderSize = @<所欲设置的值>;
    }

    方法 项目行间距 <公开 属性读 类型 = ImVec2 注释 = "Horizontal and vertical spacing between widgets/lines." 折叠
            @禁止流程检查 = 真>
    {
        @ return @dt<ImVec2>{data().ItemSpacing}
    }

    方法 项目行间距 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = ImVec2>
    {
        @ data().ItemSpacing = @<所欲设置的值>;
    }

    方法 项目内间距 <公开 属性读 类型 = ImVec2
            注释 = "Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)."
            折叠 @禁止流程检查 = 真>
    {
        @ return @dt<ImVec2>{data().ItemInnerSpacing}
    }

    方法 项目内间距 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = ImVec2>
    {
        @ data().ItemInnerSpacing = @<所欲设置的值>;
    }

    方法 单元格内边距 <公开 属性读 类型 = ImVec2
            注释 = "Padding within a table cell. CellPadding.y may be altered between different rows." 折叠
            @禁止流程检查 = 真>
    {
        @ return @dt<ImVec2>{data().CellPadding}
    }

    方法 单元格内边距 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = ImVec2>
    {
        @ data().CellPadding = @<所欲设置的值>;
    }

    方法 触摸扩展内边距 <公开 属性读 类型 = ImVec2
            注释 = "Expand reactive bounding box for touch-based system where touch position is not accurate enough."
            注释 = "Unfortunately we don\'t sort widgets so priority on overlap will always be given to the first widget. So don\'t grow this too much!"
            折叠 @禁止流程检查 = 真>
    {
        @ return @dt<ImVec2>{data().TouchExtraPadding}
    }

    方法 触摸扩展内边距 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = ImVec2>
    {
        @ data().TouchExtraPadding = @<所欲设置的值>;
    }

    方法 缩进间距 <公开 属性读 类型 = 单精度小数
            注释 = "Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2)."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().IndentSpacing
    }

    方法 缩进间距 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().IndentSpacing = @<所欲设置的值>;
    }

    方法 最小列间距 <公开 属性读 类型 = 单精度小数
            注释 = "Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1)." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.data().ColumnsMinSpacing
    }

    方法 最小列间距 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().ColumnsMinSpacing = @<所欲设置的值>;
    }

    方法 滚动条大小 <公开 属性读 类型 = 单精度小数 注释 = "Width of the vertical scrollbar, Height of the horizontal scrollbar."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().ScrollbarSize
    }

    方法 滚动条大小 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().ScrollbarSize = @<所欲设置的值>;
    }

    方法 滚动条圆角 <公开 属性读 类型 = 单精度小数 注释 = "Radius of grab corners for scrollbar." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().ScrollbarRounding
    }

    方法 滚动条圆角 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().ScrollbarRounding = @<所欲设置的值>;
    }

    方法 抓取框最小尺寸 <公开 属性读 类型 = 单精度小数 注释 = "Minimum width/height of a grab box for slider/scrollbar." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.data().GrabMinSize
    }

    方法 抓取框最小尺寸 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().GrabMinSize = @<所欲设置的值>;
    }

    方法 抓取框圆角 <公开 属性读 类型 = 单精度小数
            注释 = "Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().GrabRounding
    }

    方法 抓取框圆角 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().GrabRounding = @<所欲设置的值>;
    }

    方法 对数滑块条死区 <公开 属性读 类型 = 单精度小数
            注释 = "The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.data().LogSliderDeadzone
    }

    方法 对数滑块条死区 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().LogSliderDeadzone = @<所欲设置的值>;
    }

    方法 选项卡圆角 <公开 属性读 类型 = 单精度小数
            注释 = "Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().TabRounding
    }

    方法 选项卡圆角 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().TabRounding = @<所欲设置的值>;
    }

    方法 选项卡边框粗细 <公开 属性读 类型 = 单精度小数 注释 = "Thickness of border around tabs." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().TabBorderSize
    }

    方法 选项卡边框粗细 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().TabBorderSize = @<所欲设置的值>;
    }

    方法 选项卡关闭按钮的最小宽度 <公开 属性读 类型 = 单精度小数
            注释 = "Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().TabMinWidthForCloseButton
    }

    方法 选项卡关闭按钮的最小宽度 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().TabMinWidthForCloseButton = @<所欲设置的值>;
    }

    方法 选项卡栏边框粗细 <公开 属性读 类型 = 单精度小数
            注释 = "Thickness of tab-bar separator, which takes on the tab active color to denote focus." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.data().TabBarBorderSize
    }

    方法 选项卡栏边框粗细 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().TabBarBorderSize = @<所欲设置的值>;
    }

    方法 表格标题倾斜角度 <公开 属性读 类型 = 单精度小数
            注释 = "Angle of angled headers (supported values range from -50.0f degrees to +50.0f degrees)." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.data().TableAngledHeadersAngle
    }

    方法 表格标题倾斜角度 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().TableAngledHeadersAngle = @<所欲设置的值>;
    }

    方法 颜色按钮位置 <公开 属性读 类型 = IM基本方向
            注释 = "Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.data().ColorButtonPosition
    }

    方法 颜色按钮位置 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = IM基本方向>
    {
        @ data().ColorButtonPosition = static_cast<ImGuiDir>(@<所欲设置的值>);
    }

    方法 按钮文本对齐 <公开 属性读 类型 = ImVec2
            注释 = "Alignment of button text when button is larger than text. Defaults to (0.5f, 0.5f) (centered)."
            折叠 @禁止流程检查 = 真>
    {
        @ return @dt<ImVec2>{data().ButtonTextAlign}
    }

    方法 按钮文本对齐 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = ImVec2>
    {
        @ data().ButtonTextAlign = @<所欲设置的值>;
    }

    方法 可选项文本对齐 <公开 属性读 类型 = ImVec2
            注释 = "Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned)."
            注释 = "It\'s generally important to keep this left-aligned if you want to lay multiple items on a same line."
            折叠 @禁止流程检查 = 真>
    {
        @ return @dt<ImVec2>{data().SelectableTextAlign}
    }

    方法 可选项文本对齐 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = ImVec2>
    {
        @ data().SelectableTextAlign = @<所欲设置的值>;
    }

    方法 分隔条文本框粗细 <公开 属性读 类型 = 单精度小数 注释 = "Thickkness of border in SeparatorText()" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().SeparatorTextBorderSize
    }

    方法 分隔条文本框粗细 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().SeparatorTextBorderSize = @<所欲设置的值>;
    }

    方法 分隔条文本对齐 <公开 属性读 类型 = ImVec2
            注释 = "Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center)." 折叠
            @禁止流程检查 = 真>
    {
        @ return @dt<ImVec2>{data().SeparatorTextAlign}
    }

    方法 分隔条文本对齐 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = ImVec2>
    {
        @ data().SeparatorTextAlign = @<所欲设置的值>;
    }

    方法 分隔条文本内边距 <公开 属性读 类型 = ImVec2
            注释 = "Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y."
            折叠 @禁止流程检查 = 真>
    {
        @ return @dt<ImVec2>{data().SeparatorTextPadding}
    }

    方法 分隔条文本内边距 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = ImVec2>
    {
        @ data().SeparatorTextPadding = @<所欲设置的值>;
    }

    方法 显示窗口内边距 <公开 属性读 类型 = ImVec2
            注释 = "Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows."
            折叠 @禁止流程检查 = 真>
    {
        @ return @dt<ImVec2>{data().DisplayWindowPadding}
    }

    方法 显示窗口内边距 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = ImVec2>
    {
        @ data().DisplayWindowPadding = @<所欲设置的值>;
    }

    方法 显示安全区内边距 <公开 属性读 类型 = ImVec2
            注释 = "If you cannot see the edges of your screen (e.g. on a TV) increase the safe area padding. Apply to popups/tooltips as well regular windows. NB: Prefer configuring your TV sets correctly!"
            折叠 @禁止流程检查 = 真>
    {
        @ return @dt<ImVec2>{data().DisplaySafeAreaPadding}
    }

    方法 显示安全区内边距 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = ImVec2>
    {
        @ data().DisplaySafeAreaPadding = @<所欲设置的值>;
    }

    方法 停靠分隔条大小 <公开 属性读 类型 = 单精度小数 注释 = "Thickness of resizing border between docked windows" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().DockingSeparatorSize
    }

    方法 停靠分隔条大小 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().DockingSeparatorSize = @<所欲设置的值>;
    }

    方法 鼠标光标缩放 <公开 属性读 类型 = 单精度小数
            注释 = "Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). We apply per-monitor DPI scaling over this scale. May be removed later."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().MouseCursorScale
    }

    方法 鼠标光标缩放 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().MouseCursorScale = @<所欲设置的值>;
    }

    方法 抗锯齿线条 <公开 属性读 类型 = 逻辑型
            注释 = "Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU. Latched at the beginning of the frame (copied to ImDrawList)."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().AntiAliasedLines
    }

    方法 抗锯齿线条 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 逻辑型>
    {
        @ data().AntiAliasedLines = static_cast<bool>(@<所欲设置的值>);
    }

    方法 抗锯齿纹理线条 <公开 属性读 类型 = 逻辑型 注释 = "Enable anti-aliased lines/borders using textures where possible."
            注释 = "Require backend to render with bilinear filtering (NOT point/nearest filtering)."
            注释 = "Latched at the beginning of the frame (copied to ImDrawList)." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().AntiAliasedLinesUseTex
    }

    方法 抗锯齿纹理线条 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 逻辑型>
    {
        @ data().AntiAliasedLinesUseTex = static_cast<bool>(@<所欲设置的值>);
    }

    方法 抗锯齿填充 <公开 属性读 类型 = 逻辑型
            注释 = "Enable anti-aliased edges around filled shapes (rounded rectangles, circles, etc.)."
            注释 = "Disable if you are really tight on CPU/GPU."
            注释 = "Latched at the beginning of the frame (copied to ImDrawList)." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().AntiAliasedFill
    }

    方法 抗锯齿填充 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 逻辑型>
    {
        @ data().AntiAliasedFill = static_cast<bool>(@<所欲设置的值>);
    }

    方法 曲线细分公差 <公开 属性读 类型 = 单精度小数
            注释 = "Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments."
            注释 = "Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().CurveTessellationTol
    }

    方法 曲线细分公差 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().CurveTessellationTol = @<所欲设置的值>;
    }

    方法 曲线细分最大误差 <公开 属性读 类型 = 单精度小数
            注释 = "Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().CircleTessellationMaxError
    }

    方法 曲线细分最大误差 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().CircleTessellationMaxError = @<所欲设置的值>;
    }

    方法 颜色 <公开 类型 = ImVec4 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 颜色索引 <类型 = IM颜色标识符>
    {
        @ @dt<ImVec4>{&@sn<this>.data().Colors[(int)@<颜色索引>]}
    }

    # 以下选项可以在当前帧修改 ---

    方法 固定悬停延迟 <公开 属性读 类型 = 单精度小数
            注释 = "Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().HoverStationaryDelay
    }

    方法 固定悬停延迟 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().HoverStationaryDelay = @<所欲设置的值>;
    }

    方法 短悬停延迟 <公开 属性读 类型 = 单精度小数
            注释 = "Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().HoverDelayShort
    }

    方法 短悬停延迟 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().HoverDelayShort = @<所欲设置的值>;
    }

    方法 正常悬停延迟 <公开 属性读 类型 = 单精度小数 注释 = "Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal)." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.data().HoverDelayNormal
    }

    方法 正常悬停延迟 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().HoverDelayNormal = @<所欲设置的值>;
    }

    方法 工具提示鼠标悬停标志 <公开 属性读 类型 = 整数
            注释 = "Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse."
            注释 = "请参考常量\"IM悬停标志\"" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().HoverFlagsForTooltipMouse
    }

    方法 工具提示鼠标悬停标志 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 整数 注释 = "请参考常量\"IM悬停标志\"">
    {
        @ data().HoverFlagsForTooltipMouse = static_cast<ImGuiHoveredFlags>(@<所欲设置的值>);
    }

    方法 工具提示键盘悬停标志 <公开 属性读 类型 = 整数
            注释 = "Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using keyboard/gamepad."
            注释 = "请参考常量\"IM悬停标志\"" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().HoverFlagsForTooltipNav
    }

    方法 工具提示键盘悬停标志 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 整数 注释 = "请参考常量\"IM悬停标志\"">
    {
        @ data().HoverFlagsForTooltipNav = static_cast<ImGuiHoveredFlags>(@<所欲设置的值>);
    }
}

类 IM有效载荷类 <公开 基础类 = 数据类型基础类 注释 = "ImGuiPayload 拖放的有效载荷" 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImGuiPayload)

    方法 数据指针 <公开 属性读 类型 = 变整数 折叠 @嵌入式方法 = "">
    {
        @ reinterpret_cast<INT_P>(@sn<this>.data().Data)
    }

    方法 数据长度 <公开 属性读 类型 = 整数 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().DataSize
    }

    方法 是否预览 <公开 属性读 类型 = 逻辑型 注释 = "当调用了\"接收拖放有效载荷\"且鼠标悬停在目标项目时返回真." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().IsPreview()
    }

    方法 是否传递 <公开 属性读 类型 = 逻辑型 注释 = "当调用了\"接收拖放有效载荷\"且鼠标按钮在目标按钮上释放时返回真." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().IsDelivery()
    }

    方法 是否为指定类型 <公开 类型 = 逻辑型 注释 = "检查当前的数据类型是否为指定的类型" 折叠 @嵌入式方法 = "">
    参数 类型 <注释 = "类型是用户定义的文本,最多32个UTF-8字符,字符\'_\'开头的是ImGui的内部保留类型." 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            @匹配类型 = 通用型>
    {
        @ @sn<this>.data().IsDataType(*PivAny2U{@<类型>})
    }
}

类 IM视口类 <公开 基础类 = 数据类型基础类 注释 = "ImGuiViewport 用于接收\"ImGui.取主视口()\"的返回结果" 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImGuiViewport)

    方法 ID <公开 属性读 类型 = 整数 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(@sn<this>.data().ID)
    }

    方法 标志 <公开 属性读 类型 = 整数 注释 = "请参考\"IM视口标志\"" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(@sn<this>.data().Flags)
    }

    方法 标志 <公开 属性写 注释 = "请参考\"IM视口标志\"" 折叠>
    参数 所欲设置的值 <类型 = 整数>
    {
        @ data().Flags = static_cast<ImGuiViewportFlags>(@<所欲设置的值>);
    }

    方法 平台句柄 <公开 属性读 类型 = 变整数 注释 = "Windows平台下返回Win32的窗口句柄" 折叠 @嵌入式方法 = "">
    {
        @ reinterpret_cast<INT_P>(@sn<this>.data().PlatformHandleRaw)
    }

    方法 DPI缩放 <公开 属性读 类型 = 单精度小数 注释 = "1.0f = 96 DPI,即没有额外缩放." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().DpiScale
    }

    方法 DPI缩放 <公开 属性写 注释 = "1.0f = 96 DPI,即没有额外缩放." 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().DpiScale = @<所欲设置的值>;
    }

    方法 父视口ID <公开 属性读 类型 = 整数
            注释 = "(Advanced) 0: no parent. Instruct the platform backend to setup a parent/child relationship between platform windows."
            折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(@sn<this>.data().ParentViewportId)
    }

    方法 父视口ID <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 整数>
    {
        @ data().ParentViewportId = static_cast<ImGuiID>(@<所欲设置的值>);
    }

    方法 取位置 <公开 类型 = ImVec2 注释 = "返回主区域的视口位置,坐标与操作系统桌面/本地坐标相同." 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{@sn<this>.data().Pos}
    }

    方法 取尺寸 <公开 类型 = ImVec2 注释 = "返回主区域的视口尺寸" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{@sn<this>.data().Size}
    }

    方法 取工作区位置 <公开 类型 = ImVec2 注释 = "返回工作区的位置,即视口位置减去任务栏、菜单栏、状态栏" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{@sn<this>.data().WorkPos}
    }

    方法 取工作区尺寸 <公开 类型 = ImVec2 注释 = "返回工作区的尺寸,即视口尺寸减去任务栏、菜单栏、状态栏" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{@sn<this>.data().WorkSize}
    }

    方法 取中心 <公开 类型 = ImVec2 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{@sn<this>.data().GetCenter()}
    }

    方法 取工作区中心 <公开 类型 = ImVec2 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{@sn<this>.data().GetWorkCenter()}
    }
}

类 IM窗口类 <公开 基础类 = 数据类型基础类 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImGuiWindowClass)
}

类 IM平台IO类 <公开 基础类 = 数据类型基础类 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImGuiPlatformIO)
}

# 标志常量

类 IM窗口标志 <公开 注释 = "ImGui.窗口开端()" 注释 = "ImGuiWindowFlags" @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiWindowFlags_None 注释 = "无标志">
    常量 禁止标题栏 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoTitleBar 注释 = "禁止显示标题栏">
    常量 禁止调整大小 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoResize 注释 = "禁止使用右下大小调节手柄来重新调整窗口大小">
    常量 禁止移动 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoMove 注释 = "禁止用户移动窗口位置">
    常量 禁止滚动条 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoScrollbar 注释 = "禁止显示滚动条,但仍可以通过鼠标和编程方式进行滚动窗口.">
    常量 禁止鼠标滚动 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoScrollWithMouse
            注释 = "禁止用户使用鼠标滚轮垂直滚动窗口.除非同时设置了\"禁止滚动条\",否则子窗口的鼠标滚轮将转发到父窗口中.">
    常量 禁止折叠 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoCollapse 注释 = "禁止用户通过双击来折叠窗口,通用适用于窗口菜单按钮.">
    常量 始终自动调整大小 <公开 类型 = 整数 值 = @ImGuiWindowFlags_AlwaysAutoResize 注释 = "根据每一帧的内容调整每个窗口的大小">
    常量 禁止背景 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoBackground
            注释 = "禁止绘制背景颜色(窗口背景等)和外边框.类似于调用\"置下一窗口背景透明度(0.0)\".">
    常量 禁止保存配置 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoSavedSettings 注释 = "从不在 .ini 文件中加载和保存窗口配置">
    常量 禁止鼠标输入 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoMouseInputs 注释 = "禁止捕捉鼠标,悬停会穿透该窗口.">
    常量 菜单栏 <公开 类型 = 整数 值 = @ImGuiWindowFlags_MenuBar 注释 = "窗口拥有菜单栏">
    常量 水平滚动条 <公开 类型 = 整数 值 = @ImGuiWindowFlags_HorizontalScrollbar 注释 = "允许出现水平滚动条(默认不允许).">
    常量 显示时不获得焦点 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoFocusOnAppearing 注释 = "从隐藏状态切换到可视状态时禁止获得焦点.">
    常量 获得焦点时不置于顶层 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoBringToFrontOnFocus
            注释 = "当窗口获得焦点时,禁止将窗口置于顶层(例如单击窗口或以编程方式让窗口获得焦点).">
    常量 始终显示垂直滚动条 <公开 类型 = 整数 值 = @ImGuiWindowFlags_AlwaysVerticalScrollbar 注释 = "始终显示垂直滚动条,即使内容高度小于窗口高度.">
    常量 始终显示水平滚动条 <公开 类型 = 整数 值 = @ImGuiWindowFlags_AlwaysHorizontalScrollbar 注释 = "始终显示水平滚动条,即使内容宽度小于窗口宽度.">
    常量 始终使用窗口边距 <公开 类型 = 整数 值 = @ImGuiWindowFlags_AlwaysUseWindowPadding
            注释 = "Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)">
    常量 禁止导航输入 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoNavInputs 注释 = "禁止使用游戏手柄和鼠标导航窗口(控制窗口的前进、后退、刷新等)">
    常量 禁止导航焦点 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoNavFocus 注释 = "使用游戏手柄和鼠标导航窗口将无法焦点到此窗口,除了CTRL+TAB">
    常量 未保存文档 <公开 类型 = 整数 值 = @ImGuiWindowFlags_UnsavedDocument 注释 = "在窗口标题后面显示一个小圆点"
            注释 = "When used in a tab/docking context, tab is selected when clicking the X + closure is not assumed (will wait for user to stop submitting the tab)."
            注释 = "Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.">
    常量 禁止停靠 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoDocking 注释 = "禁止窗口使用停靠">
    常量 禁止导航 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoNav 注释 = "连续位或(禁止导航输入, 禁止导航焦点)">
    常量 禁止窗口装饰 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoDecoration 注释 = "连续位或(禁止标题栏, 禁止调整大小, 禁止滚动条, 禁止折叠)">
    常量 禁止输入 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoInputs 注释 = "连续位或(禁止鼠标输入, 禁止导航输入, 禁止导航焦点)">
}

类 IM子窗口标志 <公开 注释 = "ImGui.子窗口开端()" 注释 = "ImGuiChildFlags" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiChildFlags_None 注释 = "无标志">
    常量 显示外边框 <公开 类型 = 整数 值 = @ImGuiChildFlags_Border
            注释 = "Show an outer border and enable WindowPadding. (Important: this is always == 1 == true for legacy reason)">
    常量 始终启用窗口内边距 <公开 类型 = 整数 值 = @ImGuiChildFlags_AlwaysUseWindowPadding
            注释 = "Pad with style.WindowPadding even if no border are drawn (no padding by default for non-bordered child windows because it makes more sense)">
    常量 允许调整水平大小 <公开 类型 = 整数 值 = @ImGuiChildFlags_ResizeX
            注释 = "Allow resize from right border (layout direction). Enable .ini saving (unless ImGuiWindowFlags_NoSavedSettings passed to window flags)">
    常量 允许调整垂直大小 <公开 类型 = 整数 值 = @ImGuiChildFlags_ResizeY
            注释 = "Allow resize from bottom border (layout direction).">
    常量 自动调整水平大小 <公开 类型 = 整数 值 = @ImGuiChildFlags_AutoResizeX
            注释 = "Enable auto-resizing width. Read \"IMPORTANT: Size measurement\" details above.">
    常量 自动调整垂直大小 <公开 类型 = 整数 值 = @ImGuiChildFlags_AutoResizeY
            注释 = "Enable auto-resizing height. Read \"IMPORTANT: Size measurement\" details above.">
    常量 始终自动调整大小 <公开 类型 = 整数 值 = @ImGuiChildFlags_AlwaysAutoResize
            注释 = "Combined with AutoResizeX/AutoResizeY. Always measure size even when child is hidden, always return true, always disable clipping optimization! NOT RECOMMENDED.">
    常量 使用框体样式 <公开 类型 = 整数 值 = @ImGuiChildFlags_FrameStyle
            注释 = "Style the child window like a framed item: use FrameBg, FrameRounding, FrameBorderSize, FramePadding instead of ChildBg, ChildRounding, ChildBorderSize, WindowPadding.">
}

类 IM输入框标志 <公开 注释 = "ImGuiInputTextFlags" 注释 = "Flags for ImGui::InputText()"
        注释 = "(Those are per-item flags."
        注释 = "There are shared flags in ImGuiIO: io.ConfigInputTextCursorBlink"
        注释 = "and io.ConfigInputTextEnterKeepActive)" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_None>
    常量 十进制数字 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CharsDecimal 注释 = "允许输入 0123456789.+-*/">
    常量 十六进制数字 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CharsHexadecimal 注释 = "允许输入 0123456789ABCDEFabcdef">
    常量 转换到大写 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CharsUppercase 注释 = "将小写字母a..z转换到大写A..Z">
    常量 禁止空白 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CharsNoBlank 注释 = "过滤掉空格和制表符">
    常量 自动全选 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_AutoSelectAll 注释 = "第一次获得鼠标焦点时选择整个文本">
    常量 按回车返回真 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_EnterReturnsTrue
            注释 = "按回车键时返回\"true\",与每次修改值时相反.请查看IsItemDeactivatedAfterEdit()函数.">
    常量 完成回调 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CallbackCompletion 注释 = "在输入TAB键时触发回调,用于处理结束文本编辑">
    常量 历史记录回调 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CallbackHistory 注释 = "在输入向上/向下键时触发回调,用于处理历史记录">
    常量 始终回调 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CallbackAlways 注释 = "每次迭代的回调.用户代码可以查询光标位置,修改文本缓冲区.">
    常量 字符过滤回调 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CallbackCharFilter
            注释 = "在回调中替换或丢弃对输入的字符.修改\"EventChar\"以替换或丢弃，或在回调中返回1以丢弃。">
    常量 允许制表符 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_AllowTabInput 注释 = "按TAB键时输入一个\'\\t\'字符到文本区">
    常量 按Ctrl_回车换行 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CtrlEnterForNewLine
            注释 = "在多行模式下,按回车失去焦点,按Ctrl+回车添加新行(与默认行为正好相反)">
    常量 禁止水平滚动 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_NoHorizontalScroll 注释 = "禁止水平跟随光标">
    常量 改写模式 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_AlwaysOverwrite 注释 = "改写模式">
    常量 只读模式 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_ReadOnly 注释 = "只读模式">
    常量 密码模式 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_Password 注释 = "密码模式,将所有字符显示为\'*\'">
    常量 禁止撤销重做 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_NoUndoRedo
            注释 = "禁用撤消/重做.请注意输入框在活动时拥有文本数据,如果你想提供自己的撤销/重做堆栈,你需要调用ClearActiveID().">
    常量 科学计数法 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CharsScientific 注释 = "允许输入小数 0123456789.+-*/eE (科学计数法输入)">
    常量 重设大小回调 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CallbackResize
            注释 = "缓冲区容量超过\"buf_size\"参数值时,请求更改的回调,以允许字符串增长." 注释 = "当字符串需要调整大小时通知(对于保存其大小的缓存的字符串类型)."
            注释 = "回调中会提供一个新的缓存大小,你需要遵守它.">
    常量 编辑回调 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CallbackEdit
            注释 = "在进行任何编辑时触发回调.请注意\"输入框\"在编辑时已经返回true,这个回调主要用于在获得焦点时操作底层缓冲区.">
    常量 按ESC键清除 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_EscapeClearsAll
            注释 = "如果内容不为空,按ESC键将清除内容,否则为停用(与ESC的默认行为正好相反)">
}

类 IM树节点标志 <公开 注释 = "ImGuiTreeNodeFlags"
        注释 = "Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_None>
    常量 已选中状态 <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_Selected 注释 = "Draw as selected">
    常量 绘制框体 <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_Framed
            注释 = "Draw frame with background (e.g. for CollapsingHeader)">
    常量 允许项目重叠 <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_AllowItemOverlap
            注释 = "Hit testing to allow subsequent widgets to overlap this one">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_NoTreePushOnOpen
            注释 = "Don\'t do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_NoAutoOpenOnLog
            注释 = "Don\'t automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)">
    常量 默认打开节点 <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_DefaultOpen 注释 = "Default node to be open">
    常量 以双击打开 <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_OpenOnDoubleClick 注释 = "Need double-click to open node">
    常量 以剪头打开 <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_OpenOnArrow
            注释 = "Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.">
    常量 书页 <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_Leaf
            注释 = "No collapsing, no arrow (use as a convenience for leaf nodes).">
    常量 项目符号 <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_Bullet 注释 = "Display a bullet instead of arrow">
    常量 框体内边距 <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_FramePadding
            注释 = "Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().">
    常量 横跨可用宽度 <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_SpanAvailWidth
            注释 = "Extend hit box to the right-most edge, even if not framed."
            注释 = "This is not the default in order to allow adding other items on the same line."
            注释 = "In the future we may refactor the hit system to be front-to-back, allowing natural overlaps and then this can become the default.">
    常量 横跨全部宽度 <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_SpanFullWidth
            注释 = "Extend hit box to the left-most and right-most edges (bypass the indented area).">
    常量 横跨所有列 <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_SpanAllColumns
            注释 = "Frame will span all columns of its container table (text will still fit in current column)">
    常量 "" <类型 = 整数 值 = @ImGuiTreeNodeFlags_NavLeftJumpsBackHere
            注释 = "(WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)">
    常量 折叠标题 <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_CollapsingHeader
            注释 = "ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog">
}

类 IM弹出标志 <公开
        注释 = "ImGuiPopupFlags Flags for OpenPopup*(), BeginPopupContext*(), IsPopupOpen() functions." 折叠
        @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiPopupFlags_None>
    常量 鼠标左键 <公开 类型 = 整数 值 = @ImGuiPopupFlags_MouseButtonLeft
            注释 = "For BeginPopupContext*(): open on Left Mouse release. Guaranteed to always be == 0 (same as ImGuiMouseButton_Left)">
    常量 鼠标右键 <公开 类型 = 整数 值 = @ImGuiPopupFlags_MouseButtonRight
            注释 = "For BeginPopupContext*(): open on Right Mouse release. Guaranteed to always be == 1 (same as ImGuiMouseButton_Right)">
    常量 鼠标中键 <公开 类型 = 整数 值 = @ImGuiPopupFlags_MouseButtonMiddle
            注释 = "For BeginPopupContext*(): open on Middle Mouse release. Guaranteed to always be == 2 (same as ImGuiMouseButton_Middle)">
    常量 "" <类型 = 整数 值 = @ImGuiPopupFlags_MouseButtonMask_>
    常量 "" <类型 = 整数 值 = @ImGuiPopupFlags_MouseButtonDefault_>
    常量 "" <公开 类型 = 整数 值 = @ImGuiPopupFlags_NoOpenOverExistingPopup
            注释 = "For OpenPopup*(), BeginPopupContext*(): don\'t open if there\'s already a popup at the same level of the popup stack">
    常量 "" <公开 类型 = 整数 值 = @ImGuiPopupFlags_NoOpenOverItems
            注释 = "For BeginPopupContextWindow(): don\'t return true when hovering items, only when hovering empty space">
    常量 "" <公开 类型 = 整数 值 = @ImGuiPopupFlags_AnyPopupId
            注释 = "For IsPopupOpen(): ignore the ImGuiID parameter and test for any popup.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiPopupFlags_AnyPopupLevel
            注释 = "For IsPopupOpen(): search/test at any level of the popup stack (default test in the current level)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiPopupFlags_AnyPopup
            注释 = "ImGuiPopupFlags_AnyPopupId | ImGuiPopupFlags_AnyPopupLevel">
}

类 IM可选项标志 <公开 注释 = "ImGuiSelectableFlags Flags for ImGui::Selectable()" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiSelectableFlags_None>
    常量 不关闭弹出项 <公开 类型 = 整数 值 = @ImGuiSelectableFlags_DontClosePopups
            注释 = "Clicking this doesn\'t close parent popup window">
    常量 横跨所有列 <公开 类型 = 整数 值 = @ImGuiSelectableFlags_SpanAllColumns
            注释 = "Frame will span all columns of its container table (text will still fit in current column)">
    常量 允许双击 <公开 类型 = 整数 值 = @ImGuiSelectableFlags_AllowDoubleClick
            注释 = "Generate press events on double clicks too">
    常量 禁用 <公开 类型 = 整数 值 = @ImGuiSelectableFlags_Disabled 注释 = "Cannot be selected, display grayed out text">
    常量 允许项目重叠 <公开 类型 = 整数 值 = @ImGuiSelectableFlags_AllowItemOverlap
            注释 = "(WIP) Hit testing to allow subsequent widgets to overlap this one">
}

类 IM组合框标志 <公开 注释 = "ImGuiComboFlags Flags for ImGui::BeginCombo()" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiComboFlags_None>
    常量 左对齐弹出项 <公开 类型 = 整数 值 = @ImGuiComboFlags_PopupAlignLeft
            注释 = "Align the popup toward the left by default">
    常量 小型高度 <公开 类型 = 整数 值 = @ImGuiComboFlags_HeightSmall
            注释 = "Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()">
    常量 常规高度 <公开 类型 = 整数 值 = @ImGuiComboFlags_HeightRegular 注释 = "Max ~8 items visible (default)">
    常量 大型高度 <公开 类型 = 整数 值 = @ImGuiComboFlags_HeightLarge 注释 = "Max ~20 items visible">
    常量 最大高度 <公开 类型 = 整数 值 = @ImGuiComboFlags_HeightLargest 注释 = "As many fitting items as possible">
    常量 无箭头按钮 <公开 类型 = 整数 值 = @ImGuiComboFlags_NoArrowButton
            注释 = "Display on the preview box without the square arrow button">
    常量 无预览项 <公开 类型 = 整数 值 = @ImGuiComboFlags_NoPreview 注释 = "Display only a square arrow button">
    常量 预览项适合宽度 <公开 类型 = 整数 值 = @ImGuiComboFlags_WidthFitPreview
            注释 = "Width dynamically calculated from preview contents">
    常量 高度掩码 <类型 = 整数 值 = @ImGuiComboFlags_HeightMask_
            注释 = "ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest">
}

类 IM选项卡栏标志 <公开 注释 = "ImGuiTabBarFlags Flags for ImGui::BeginTabBar()" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiTabBarFlags_None>
    常量 可重新排列 <公开 类型 = 整数 值 = @ImGuiTabBarFlags_Reorderable
            注释 = "Allow manually dragging tabs to re-order them + New tabs are appended at the end of list">
    常量 自动选中新选项卡 <公开 类型 = 整数 值 = @ImGuiTabBarFlags_AutoSelectNewTabs
            注释 = "Automatically select new tabs when they appear">
    常量 选项卡列表下拉按钮 <公开 类型 = 整数 值 = @ImGuiTabBarFlags_TabListPopupButton
            注释 = "Disable buttons to open the tab list popup">
    常量 禁止鼠标中键关闭 <公开 类型 = 整数 值 = @ImGuiTabBarFlags_NoCloseWithMiddleMouseButton
            注释 = "Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button."
            注释 = "You may handle this behavior manually on user\'s side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.">
    常量 禁止选项卡列表滚动按钮 <公开 类型 = 整数 值 = @ImGuiTabBarFlags_NoTabListScrollingButtons
            注释 = "Disable scrolling buttons (apply when fitting policy is ImGuiTabBarFlags_FittingPolicyScroll)">
    常量 禁止工具提示 <公开 类型 = 整数 值 = @ImGuiTabBarFlags_NoTooltip 注释 = "Disable tooltips when hovering a tab">
    常量 已满时缩窄选项卡 <公开 类型 = 整数 值 = @ImGuiTabBarFlags_FittingPolicyResizeDown
            注释 = "Resize tabs when they don\'t fit">
    常量 已满时添加滚动按钮 <公开 类型 = 整数 值 = @ImGuiTabBarFlags_FittingPolicyScroll
            注释 = "Add scroll buttons when tabs don\'t fit">
    常量 "" <类型 = 整数 值 = @ImGuiTabBarFlags_FittingPolicyMask_
            注释 = "ImGuiTabBarFlags_FittingPolicyResizeDown | ImGuiTabBarFlags_FittingPolicyScroll">
    常量 "" <类型 = 整数 值 = @ImGuiTabBarFlags_FittingPolicyDefault_
            注释 = "ImGuiTabBarFlags_FittingPolicyResizeDown">
}

类 IM选项卡项标志 <公开 注释 = "ImGuiTabItemFlags Flags for ImGui::BeginTabItem()" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiTabItemFlags_None>
    常量 未保存文档 <公开 类型 = 整数 值 = @ImGuiTabItemFlags_UnsavedDocument
            注释 = "Display a dot next to the title + set ImGuiTabItemFlags_NoAssumedClosure.">
    常量 置为选中 <公开 类型 = 整数 值 = @ImGuiTabItemFlags_SetSelected
            注释 = "Trigger flag to programmatically make the tab selected when calling BeginTabItem()">
    常量 禁用鼠标中键关闭 <公开 类型 = 整数 值 = @ImGuiTabItemFlags_NoCloseWithMiddleMouseButton
            注释 = "Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button."
            注释 = "You can still repro this behavior on user\'s side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.">
    常量 禁止压入ID <公开 类型 = 整数 值 = @ImGuiTabItemFlags_NoPushId
            注释 = "Don\'t call PushID(tab->ID)/PopID() on BeginTabItem()/EndTabItem()">
    常量 禁止工具提示 <公开 类型 = 整数 值 = @ImGuiTabItemFlags_NoTooltip 注释 = "Disable tooltip for the given tab">
    常量 禁止重新排列 <公开 类型 = 整数 值 = @ImGuiTabItemFlags_NoReorder
            注释 = "Disable reordering this tab or having another tab cross over this tab">
    常量 在左侧新建 <公开 类型 = 整数 值 = @ImGuiTabItemFlags_Leading
            注释 = "Enforce the tab position to the left of the tab bar (after the tab list popup button)">
    常量 在右侧新建 <公开 类型 = 整数 值 = @ImGuiTabItemFlags_Trailing
            注释 = "Enforce the tab position to the right of the tab bar (before the scrolling buttons)">
}

类 IM表格标志 <公开 注释 = "ImGuiTableFlags Flags for ImGui::BeginTable()" 折叠 @文档 = "category = \"标志类\"">
{

    # 功能 / Features

    常量 无 <公开 类型 = 整数 值 = @ImGuiTableFlags_None>
    常量 可调节列 <公开 类型 = 整数 值 = @ImGuiTableFlags_Resizable 注释 = "Enable resizing columns.">
    常量 可重新排列 <公开 类型 = 整数 值 = @ImGuiTableFlags_Reorderable
            注释 = "Enable reordering columns in header row (need calling TableSetupColumn() + TableHeadersRow() to display headers)">
    常量 可隐藏 <公开 类型 = 整数 值 = @ImGuiTableFlags_Hideable
            注释 = "Enable hiding/disabling columns in context menu.">
    常量 可排序 <公开 类型 = 整数 值 = @ImGuiTableFlags_Sortable
            注释 = "Enable sorting. Call TableGetSortSpecs() to obtain sort specs. Also see ImGuiTableFlags_SortMulti and ImGuiTableFlags_SortTristate.">
    常量 不保存设置 <公开 类型 = 整数 值 = @ImGuiTableFlags_NoSavedSettings
            注释 = "Disable persisting columns order, width and sort settings in the .ini file.">
    常量 正文内上下文菜单 <公开 类型 = 整数 值 = @ImGuiTableFlags_ContextMenuInBody
            注释 = "Right-click on columns body/contents will display table context menu. By default it is available in TableHeadersRow().">

    # Decorations

    常量 行背景 <公开 类型 = 整数 值 = @ImGuiTableFlags_RowBg
            注释 = "Set each RowBg color with ImGuiCol_TableRowBg or ImGuiCol_TableRowBgAlt (equivalent of calling TableSetBgColor with ImGuiTableBgFlags_RowBg0 on each row manually)">
    常量 横向内边框 <公开 类型 = 整数 值 = @ImGuiTableFlags_BordersInnerH 注释 = "Draw horizontal borders between rows.">
    常量 横向外边框 <公开 类型 = 整数 值 = @ImGuiTableFlags_BordersOuterH
            注释 = "Draw horizontal borders at the top and bottom.">
    常量 纵向内边框 <公开 类型 = 整数 值 = @ImGuiTableFlags_BordersInnerV 注释 = "Draw vertical borders between columns.">
    常量 纵向外边框 <公开 类型 = 整数 值 = @ImGuiTableFlags_BordersOuterV
            注释 = "Draw vertical borders on the left and right sides.">
    常量 水平边框 <公开 类型 = 整数 值 = @ImGuiTableFlags_BordersH 注释 = "Draw horizontal borders.">
    常量 纵向边框 <公开 类型 = 整数 值 = @ImGuiTableFlags_BordersV 注释 = "Draw vertical borders.">
    常量 内边框 <公开 类型 = 整数 值 = @ImGuiTableFlags_BordersInner 注释 = "Draw inner borders.">
    常量 外边框 <公开 类型 = 整数 值 = @ImGuiTableFlags_BordersOuter 注释 = "Draw outer borders.">
    常量 全部边框 <公开 类型 = 整数 值 = @ImGuiTableFlags_Borders 注释 = "Draw all borders.">
    常量 "" <类型 = 整数 值 = @ImGuiTableFlags_NoBordersInBody
            注释 = "[ALPHA] Disable vertical borders in columns Body (borders will always appear in Headers). -> May move to style">
    常量 "" <类型 = 整数 值 = @ImGuiTableFlags_NoBordersInBodyUntilResize
            注释 = "[ALPHA] Disable vertical borders in columns Body until hovered for resize (borders will always appear in Headers). -> May move to style">

    # Sizing Policy (read above for defaults)

    常量 按内容调整列宽 <公开 类型 = 整数 值 = @ImGuiTableFlags_SizingFixedFit
            注释 = "Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching contents width.">
    常量 均一化调整列宽 <公开 类型 = 整数 值 = @ImGuiTableFlags_SizingFixedSame
            注释 = "Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching the maximum contents width of all columns. Implicitly enable ImGuiTableFlags_NoKeepColumnsVisible.">
    常量 按比例拉伸列宽 <公开 类型 = 整数 值 = @ImGuiTableFlags_SizingStretchProp
            注释 = "Columns default to _WidthStretch with default weights proportional to each columns contents widths.">
    常量 均一化拉伸列宽 <公开 类型 = 整数 值 = @ImGuiTableFlags_SizingStretchSame
            注释 = "Columns default to _WidthStretch with default weights all equal, unless overridden by TableSetupColumn().">

    # Sizing Extra Options

    常量 禁止宿主扩展宽度 <公开 类型 = 整数 值 = @ImGuiTableFlags_NoHostExtendX
            注释 = "Make outer width auto-fit to columns, overriding outer_size.x value. Only available when ScrollX/ScrollY are disabled and Stretch columns are not used.">
    常量 禁止宿主扩展高度 <公开 类型 = 整数 值 = @ImGuiTableFlags_NoHostExtendY
            注释 = "Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit)."
            注释 = "Only available when ScrollX/ScrollY are disabled. Data below the limit will be clipped and not visible.">
    常量 不保持列可见 <公开 类型 = 整数 值 = @ImGuiTableFlags_NoKeepColumnsVisible
            注释 = "Disable keeping column always minimally visible when ScrollX is off and table gets too small. Not recommended if columns are resizable.">
    常量 精确宽度 <公开 类型 = 整数 值 = @ImGuiTableFlags_PreciseWidths
            注释 = "Disable distributing remainder width to stretched columns (width allocation on a 100-wide table with 3 columns: Without this flag: 33,33,34. With this flag: 33,33,33)."
            注释 = "With larger number of columns, resizing will appear to be less smooth.">

    # Clipping

    常量 禁止裁剪 <公开 类型 = 整数 值 = @ImGuiTableFlags_NoClip
            注释 = "Disable clipping rectangle for every individual columns (reduce draw command count, items will be able to overflow into other columns)."
            注释 = "Generally incompatible with TableSetupScrollFreeze().">

    # Padding

    常量 水平外边距 <公开 类型 = 整数 值 = @ImGuiTableFlags_PadOuterX
            注释 = "Default if BordersOuterV is on. Enable outermost padding. Generally desirable if you have headers.">
    常量 禁止水平外边距 <公开 类型 = 整数 值 = @ImGuiTableFlags_NoPadOuterX
            注释 = "Default if BordersOuterV is off. Disable outermost padding.">
    常量 禁止水平内边距 <公开 类型 = 整数 值 = @ImGuiTableFlags_NoPadInnerX
            注释 = "Disable inner padding between columns (double inner padding if BordersOuterV is on, single inner padding if BordersOuterV is off).">

    # Scrolling

    常量 水平滚动条 <公开 类型 = 整数 值 = @ImGuiTableFlags_ScrollX
            注释 = "Enable horizontal scrolling. Require \'outer_size\' parameter of BeginTable() to specify the container size. Changes default sizing policy."
            注释 = "Because this creates a child window, ScrollY is currently generally recommended when using ScrollX.">
    常量 垂直滚动条 <公开 类型 = 整数 值 = @ImGuiTableFlags_ScrollY
            注释 = "Enable vertical scrolling. Require \'outer_size\' parameter of BeginTable() to specify the container size.">

    # Sorting

    常量 多列排序 <公开 类型 = 整数 值 = @ImGuiTableFlags_SortMulti
            注释 = "Hold shift when clicking headers to sort on multiple column. TableGetSortSpecs() may return specs where (SpecsCount > 1).">
    常量 三态排序 <公开 类型 = 整数 值 = @ImGuiTableFlags_SortTristate
            注释 = "Allow no sorting, disable default sorting. TableGetSortSpecs() may return specs where (SpecsCount == 0).">
    常量 ""
    常量 悬停时高亮列标题 <公开 类型 = 整数 值 = @ImGuiTableFlags_HighlightHoveredColumn
            注释 = "Highlight column headers when hovered (may evolve into a fuller highlight)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_SizingMask_
            注释 = "ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_SizingFixedSame | ImGuiTableFlags_SizingStretchProp | ImGuiTableFlags_SizingStretchSame">
}

类 IM表格列标志 <公开 注释 = "ImGuiTableColumnFlags Flags for ImGui::TableSetupColumn()"
        @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_None>
    常量 已禁用 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_Disabled
            注释 = "Overriding/master disable flag: hide column, won\'t show in context menu (unlike calling TableSetColumnEnabled() which manipulates the user accessible state)">
    常量 默认隐藏 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_DefaultHide 注释 = "Default as a hidden/disabled column.">
    常量 默认排序 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_DefaultSort 注释 = "Default as a sorting column.">
    常量 拉伸宽度 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_WidthStretch
            注释 = "Column will stretch. Preferable with horizontal scrolling disabled (default if table sizing policy is _SizingStretchSame or _SizingStretchProp).">
    常量 固定宽度 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_WidthFixed
            注释 = "Column will not stretch. Preferable with horizontal scrolling enabled (default if table sizing policy is _SizingFixedFit and table is resizable).">
    常量 禁止调整宽度 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoResize 注释 = "禁止手动调整列宽度">
    常量 禁止重新排序 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoReorder
            注释 = "Disable manual reordering this column, this will also prevent other columns from crossing over this column.">
    常量 禁止隐藏 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoHide
            注释 = "Disable ability to hide/disable this column.">
    常量 禁止裁剪 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoClip
            注释 = "Disable clipping for this column (all NoClip columns will render in a same draw command).">
    常量 禁止排序 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoSort
            注释 = "Disable ability to sort on this field (even if ImGuiTableFlags_Sortable is set on the table).">
    常量 禁止升序 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoSortAscending
            注释 = "Disable ability to sort in the ascending direction.">
    常量 禁止降序 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoSortDescending
            注释 = "Disable ability to sort in the descending direction.">
    常量 无标题标签 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoHeaderLabel
            注释 = "TableHeadersRow() will not submit label for this column. Convenient for some small columns. Name will still appear in context menu.">
    常量 无标题宽度 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoHeaderWidth
            注释 = "Disable header text width contribution to automatic column width.">
    常量 优先升序 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_PreferSortAscending
            注释 = "Make the initial sort direction Ascending when first sorting on this column (default).">
    常量 优先降序 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_PreferSortDescending
            注释 = "Make the initial sort direction Descending when first sorting on this column.">
    常量 启用缩进 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_IndentEnable
            注释 = "Use current Indent value when entering cell (default for column 0).">
    常量 禁用缩进 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_IndentDisable
            注释 = "Ignore current Indent value when entering cell (default for columns > 0). Indentation changes _within_ the cell will still be honored.">
    常量 倾斜标题 <类型 = 整数 值 = @ImGuiTableColumnFlags_AngledHeader
            注释 = "TableHeadersRow() will submit an angled header row for this column. Note this will add an extra row.">
    常量 已启用 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_IsEnabled
            注释 = "Status: is enabled == not hidden by user/api (referred to as \"Hide\" in _DefaultHide and _NoHide) flags.">
    常量 已可见 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_IsVisible
            注释 = "Status: is visible == is enabled AND not clipped by scrolling.">
    常量 已排序 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_IsSorted
            注释 = "Status: is currently part of the sort specs">
    常量 已悬停 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_IsHovered 注释 = "Status: is hovered by mouse">
    常量 ""
    常量 宽度掩码_ <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_WidthMask_
            注释 = "ImGuiTableColumnFlags_WidthStretch | ImGuiTableColumnFlags_WidthFixed">
    常量 缩进掩码_ <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_IndentMask_
            注释 = "ImGuiTableColumnFlags_IndentEnable | ImGuiTableColumnFlags_IndentDisable">
    常量 状态掩码_ <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_StatusMask_
            注释 = "ImGuiTableColumnFlags_IsEnabled | ImGuiTableColumnFlags_IsVisible | ImGuiTableColumnFlags_IsSorted | ImGuiTableColumnFlags_IsHovered,">
    常量 "" <类型 = 整数 值 = @ImGuiTableColumnFlags_NoDirectResize_
            注释 = "[Internal] Disable user resizing this column directly (it may however we resized indirectly from its left edge)">
}

类 IM表格行标志 <公开 注释 = "ImGuiTableRowFlags Flags for ImGui::TableNextRow()" @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiTableRowFlags_None>
    常量 标题 <公开 类型 = 整数 值 = @ImGuiTableRowFlags_Headers 注释 = "标识表头标题行(设置默认背景颜色+其内容的宽度,以不同方式考虑自动列宽)"
            注释 = "Identify header row (set default background color + width of its contents accounted differently for auto column width)">
}

类 IM焦点标志 <公开 注释 = "ImGuiFocusedFlags ImGui.窗口可有焦点()" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiFocusedFlags_None>
    常量 子窗口 <公开 类型 = 整数 值 = @ImGuiFocusedFlags_ChildWindows 注释 = "如果任意子窗口有焦点也返回真">
    常量 根窗口 <公开 类型 = 整数 值 = @ImGuiFocusedFlags_RootWindow 注释 = "从根窗口测试(当前层级结构的最顶端父级)">
    常量 任意窗口 <公开 类型 = 整数 值 = @ImGuiFocusedFlags_AnyWindow 注释 = "任意窗口获得焦点都会返回真">
    常量 无弹出层级 <公开 类型 = 整数 值 = @ImGuiFocusedFlags_NoPopupHierarchy
            注释 = "不考虑弹出层级结构(不将触发弹出的窗口视为弹出项的父级,与\"子窗口\"或\"根窗口\"一起使用）">
    常量 停靠层级 <公开 类型 = 整数 值 = @ImGuiFocusedFlags_DockHierarchy
            注释 = "考虑停靠的层次结构,将停靠空间的宿主视为停靠窗口的父级(与\"子窗口\"和\"根窗口\"组合使用)">
    常量 根和子窗口 <公开 类型 = 整数 值 = @ImGuiFocusedFlags_RootAndChildWindows
            注释 = "ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows">
}

类 IM悬停标志 <公开 注释 = "ImGuiHoveredFlags ImGui.窗口可有悬停()、ImGui.项目可有悬停()" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_None 注释 = "当鼠标直接悬停于项目/窗口,未被另一个窗口遮挡,且未被活动弹出项或模态输入框遮挡,则返回真.">
    常量 子窗口 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_ChildWindows 注释 = "仅限\"窗口可有悬停\": 在此窗口的任意子窗口上悬停时返回真.">
    常量 根窗口 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_RootWindow 注释 = "仅限\"窗口可有悬停\": 从根窗口测试(当前层级结构的最顶端父级)">
    常量 任意窗口 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_AnyWindow 注释 = "仅限\"窗口可有悬停\": 在任意窗口上悬停时返回真">
    常量 无弹出层级 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_NoPopupHierarchy
            注释 = "仅限\"窗口可有悬停\": 不考虑弹出层级结构(不将触发弹出的窗口视为弹出项的父级,与\"子窗口\"或\"根窗口\"一起使用）">
    常量 停靠层级 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_DockHierarchy
            注释 = "仅限\"窗口可有悬停\": 考虑停靠的层次结构,将停靠空间的宿主视为停靠窗口的父级(与\"子窗口\"和\"根窗口\"组合使用)">
    常量 允许被弹出项遮挡 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_AllowWhenBlockedByPopup
            注释 = "Return true even if a popup window is normally blocking access to this item/window">
    常量 允许被活动项遮挡 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_AllowWhenBlockedByActiveItem
            注释 = "Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.">
    常量 允许被重叠 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_AllowWhenOverlapped
            注释 = "仅限\"项目可有悬停\": Return true even if the position is obstructed or overlapped by another window">
    常量 允许为禁用项 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_AllowWhenDisabled
            注释 = "仅限\"项目可有悬停\": Return true even if the item is disabled">
    常量 禁止被导航覆盖 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_NoNavOverride
            注释 = "仅限\"项目可有悬停\": Disable using gamepad/keyboard navigation state when active, always query mouse">
    常量 仅限矩形框 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_RectOnly
            注释 = "ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped">
    常量 根和子窗口 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_RootAndChildWindows 注释 = "连续位或 (根窗口, 子窗口)">
    常量 工具提示专用 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_ForTooltip
            注释 = "Shortcut for standard flags when using IsItemHovered() + SetTooltip() sequence.">
    常量 固定延迟 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_Stationary
            注释 = "Require mouse to be stationary for style.HoverStationaryDelay (~0.15 sec) _at least one time_."
            注释 = "After this, can move on same item/window. Using the stationary test tends to reduces the need for a long delay.">
    常量 无延迟 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_DelayNone 注释 = "仅限\"工具提示\": 立即返回真(默认),因为它是默认的,你可以忽略它.">
    常量 正常延迟 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_DelayNormal
            注释 = "仅限\"工具提示\": 经过 io.HoverDelayNormal (约0.30秒)的时间后返回真">
    常量 短延迟 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_DelayShort
            注释 = "仅限\"工具提示\": 经过 io.HoverDelayShort  (约0.10秒)的时间后返回真">
    常量 禁止共用延迟 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_NoSharedDelay
            注释 = "仅限\"工具提示\": 禁止共用延迟系统(即从一个项目移动到另一个项目,会继续使用之前的计时,以缩短延迟时间.这是长延迟工具提示的标准设置.)">
}

类 IM停靠节点标志 <公开 注释 = "ImGuiDockNodeFlags" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiDockNodeFlags_None>
    常量 仅保持活动状态 <公开 类型 = 整数 值 = @ImGuiDockNodeFlags_KeepAliveOnly
            注释 = "不显示停靠空间节点,但使其保持活动状态.拖放到此停靠空间节点的窗口不会被取消停靠.">
    常量 禁止停靠到中心节点 <公开 类型 = 整数 值 = @ImGuiDockNodeFlags_NoDockingOverCentralNode 注释 = "禁止将窗口停靠到中心节点,让它始终保持空白.">
    常量 透传中心节点 <公开 类型 = 整数 值 = @ImGuiDockNodeFlags_PassthruCentralNode 注释 = "启用透传(直通)停靠空间:"
            注释 = "1. 除非中心节点为空,停靠空间将渲染一个背景色覆盖一切内容;" 注释 = "   等同于在创建窗口之前,先将背景透明度设置为0."
            注释 = "2. 当中心节点为空: 让所有输入透传,并且不显示空节点的背景色.">
    常量 禁止分拆停靠节点 <公开 类型 = 整数 值 = @ImGuiDockNodeFlags_NoDockingSplit 注释 = "禁止将停靠节点分拆为更小的节点."
            注释 = "Useful e.g. when embedding dockspaces into a main root one (the root one may have splitting disabled to reduce confusion)."
            注释 = "Note: when turned off, existing splits will be preserved.">
    常量 禁止调整大小 <公开 类型 = 整数 值 = @ImGuiDockNodeFlags_NoResize 注释 = "禁止使用分离器和分隔条来调整节点的尺寸.适用于以编程方式设置停靠空间.">
    常量 自动隐藏选项卡 <公开 类型 = 整数 值 = @ImGuiDockNodeFlags_AutoHideTabBar 注释 = "当停靠节点只有一个窗口时自动隐藏选项卡">
    常量 禁止取消停靠 <公开 类型 = 整数 值 = @ImGuiDockNodeFlags_NoUndocking 注释 = "禁止从该节点取消停靠">
}

类 IM拖放标志 <公开
        注释 = "ImGuiDragDropFlags Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload()" 折叠
        @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiDragDropFlags_None>
    常量 不预览来源的工具提示 <公开 类型 = 整数 值 = @ImGuiDragDropFlags_SourceNoPreviewTooltip
            注释 = "Disable preview tooltip. By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents."
            注释 = "This flag disables this behavior.">
    常量 不禁止来源的悬停 <公开 类型 = 整数 值 = @ImGuiDragDropFlags_SourceNoDisableHover
            注释 = "By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips."
            注释 = "This flag disables this behavior so you can still call IsItemHovered() on the source item.">
    常量 不打开经过的项目 <公开 类型 = 整数 值 = @ImGuiDragDropFlags_SourceNoHoldToOpenOthers
            注释 = "Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.">
    常量 允许空ID来源 <公开 类型 = 整数 值 = @ImGuiDragDropFlags_SourceAllowNullID
            注释 = "Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position."
            注释 = "This is extremely unusual within the dear imgui ecosystem and so we made it explicit.">
    常量 外部来源 <公开 类型 = 整数 值 = @ImGuiDragDropFlags_SourceExtern
            注释 = "External source (from outside of dear imgui), won\'t attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.">
    常量 有效载荷自动过期 <公开 类型 = 整数 值 = @ImGuiDragDropFlags_SourceAutoExpirePayload
            注释 = "Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)">
    常量 在传递之前接收 <公开 类型 = 整数 值 = @ImGuiDragDropFlags_AcceptBeforeDelivery
            注释 = "AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.">
    常量 不绘制目标矩形框 <公开 类型 = 整数 值 = @ImGuiDragDropFlags_AcceptNoDrawDefaultRect
            注释 = "Do not draw the default highlight rectangle when hovering over target.">
    常量 接收不预览工具提示 <公开 类型 = 整数 值 = @ImGuiDragDropFlags_AcceptNoPreviewTooltip
            注释 = "Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.">
    常量 仅查看接收内容 <公开 类型 = 整数 值 = @ImGuiDragDropFlags_AcceptPeekOnly
            注释 = "For peeking ahead and inspecting the payload before delivery.">
}

类 IM配置标志 <公开
        注释 = "ImGuiConfigFlags Configuration flags stored in io.ConfigFlags. Set by user/application."
        注释 = "" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiConfigFlags_None>
    常量 键盘导航 <公开 类型 = 整数 值 = @ImGuiConfigFlags_NavEnableKeyboard
            注释 = "Master keyboard navigation enable flag. Enable full Tabbing + directional arrows + space/enter to activate.">
    常量 游戏手柄导航 <公开 类型 = 整数 值 = @ImGuiConfigFlags_NavEnableGamepad
            注释 = "Master gamepad navigation enable flag. Backend also needs to set ImGuiBackendFlags_HasGamepad.">
    常量 导航移动鼠标位置 <公开 类型 = 整数 值 = @ImGuiConfigFlags_NavEnableSetMousePos
            注释 = "Instruct navigation to move the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is awkward."
            注释 = "Will update io.MousePos and set io.WantSetMousePos=true."
            注释 = "If enabled you MUST honor io.WantSetMousePos requests in your backend, otherwise ImGui will react as if the mouse is jumping around back and forth.">
    常量 不捕获键盘 <公开 类型 = 整数 值 = @ImGuiConfigFlags_NavNoCaptureKeyboard
            注释 = "Instruct navigation to not set the io.WantCaptureKeyboard flag when io.NavActive is set.">
    常量 无鼠标 <公开 类型 = 整数 值 = @ImGuiConfigFlags_NoMouse
            注释 = "Instruct imgui to clear mouse position/buttons in NewFrame(). This allows ignoring the mouse information set by the backend.">
    常量 不改变鼠标光标 <公开 类型 = 整数 值 = @ImGuiConfigFlags_NoMouseCursorChange
            注释 = "Instruct backend to not alter mouse cursor shape and visibility. Use if the backend cursor changes are interfering with yours and you don\'t want to use SetMouseCursor() to change mouse cursor."
            注释 = "You may want to honor requests from imgui by reading GetMouseCursor() yourself instead.">
    常量 启用停靠 <公开 类型 = 整数 值 = @ImGuiConfigFlags_DockingEnable 注释 = "Docking enable flags.">
    常量 启用视口 <公开 类型 = 整数 值 = @ImGuiConfigFlags_ViewportsEnable
            注释 = "Viewport enable flags (require both ImGuiBackendFlags_PlatformHasViewports + ImGuiBackendFlags_RendererHasViewports set by the respective backends)">
    常量 SRGB颜色 <公开 类型 = 整数 值 = @ImGuiConfigFlags_IsSRGB 注释 = "Application is SRGB-aware.">
    常量 触控屏 <公开 类型 = 整数 值 = @ImGuiConfigFlags_IsTouchScreen
            注释 = "Application is using a touch screen instead of a mouse.">
}

类 IM后端标志 <公开
        注释 = "ImGuiBackendFlags Backend capabilities flags stored in io.BackendFlags. Set by imgui_impl_xxx or custom backend."
        注释 = "" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiBackendFlags_None>
    常量 支持游戏手柄 <公开 类型 = 整数 值 = @ImGuiBackendFlags_HasGamepad
            注释 = "Backend Platform supports gamepad and currently has one connected.">
    常量 支持鼠标光标 <公开 类型 = 整数 值 = @ImGuiBackendFlags_HasMouseCursors
            注释 = "Backend Platform supports honoring GetMouseCursor() value to change the OS cursor shape.">
    常量 支持设置鼠标位置 <公开 类型 = 整数 值 = @ImGuiBackendFlags_HasSetMousePos
            注释 = "Backend Platform supports io.WantSetMousePos requests to reposition the OS mouse position (only used if ImGuiConfigFlags_NavEnableSetMousePos is set).">
    常量 渲染器支持VTX偏移 <公开 类型 = 整数 值 = @ImGuiBackendFlags_RendererHasVtxOffset
            注释 = "Backend Renderer supports ImDrawCmd::VtxOffset. This enables output of large meshes (64K+ vertices) while still using 16-bit indices.">
    常量 平台支持视口 <公开 类型 = 整数 值 = @ImGuiBackendFlags_PlatformHasViewports
            注释 = "Backend Platform supports multiple viewports.">
    常量 视口接受鼠标悬停 <公开 类型 = 整数 值 = @ImGuiBackendFlags_HasMouseHoveredViewport
            注释 = "Backend Platform supports calling io.AddMouseViewportEvent() with the viewport under the mouse. IF POSSIBLE, ignore viewports with the ImGuiViewportFlags_NoInputs flag (Win32 backend, GLFW 3.30+ backend can do this, SDL backend cannot). If this cannot be done, Dear ImGui needs to use a flawed heuristic to find the viewport under.">
    常量 渲染器支持视口 <公开 类型 = 整数 值 = @ImGuiBackendFlags_RendererHasViewports
            注释 = "Backend Renderer supports multiple viewports.">
}

类 IM按钮标志 <公开 注释 = "ImGuiButtonFlags Flags for InvisibleButton() [extended in imgui_internal.h]" 折叠
        @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiButtonFlags_None>
    常量 鼠标左键 <公开 类型 = 整数 值 = @ImGuiButtonFlags_MouseButtonLeft 注释 = "响应鼠标左键(默认值)">
    常量 鼠标右键 <公开 类型 = 整数 值 = @ImGuiButtonFlags_MouseButtonRight 注释 = "响应鼠标右键">
    常量 鼠标中键 <公开 类型 = 整数 值 = @ImGuiButtonFlags_MouseButtonMiddle 注释 = "响应鼠标中键">
    常量 鼠标按键掩码_ <公开 类型 = 整数 值 = @ImGuiButtonFlags_MouseButtonMask_ 注释 = "连续位或 (鼠标左键, 鼠标右键, 鼠标中键)">
    常量 默认鼠标按键_ <公开 类型 = 整数 值 = @ImGuiButtonFlags_MouseButtonDefault_ 注释 = "等于\"鼠标左键\"">
}

类 IM颜色编辑标志 <公开
        注释 = "ImGuiColorEditFlags Flags for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()"
        折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_None>
    常量 无透明分量 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoAlpha
            注释 = "ColorEdit, ColorPicker, ColorButton: ignore Alpha component (will only read 3 components from the input pointer).">
    常量 无选取器 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoPicker
            注释 = "ColorEdit: disable picker when clicking on color square.">
    常量 无选项菜单 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoOptions
            注释 = "ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.">
    常量 无小预览 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoSmallPreview
            注释 = "ColorEdit, ColorPicker: disable color square preview next to the inputs. (e.g. to show only the inputs)">
    常量 无输入组件 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoInputs
            注释 = "ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview color square).">
    常量 无工具提示 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoTooltip
            注释 = "ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.">
    常量 无文本标签 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoLabel
            注释 = "ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).">
    常量 无滑块预览 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoSidePreview
            注释 = "ColorPicker: disable bigger color preview on right side of the picker, use small color square preview instead.">
    常量 禁止拖放 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoDragDrop
            注释 = "ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.">
    常量 无边框 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoBorder
            注释 = "ColorButton: disable border (which is enforced by default)">
    常量 ""
    常量 显示透明条 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_AlphaBar
            注释 = "ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.">
    常量 透明预览 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_AlphaPreview
            注释 = "ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.">
    常量 半透明预览 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_AlphaPreviewHalf
            注释 = "ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.">
    常量 HDR <公开 类型 = 整数 值 = @ImGuiColorEditFlags_HDR
            注释 = "(WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).">
    常量 显示RGB <公开 类型 = 整数 值 = @ImGuiColorEditFlags_DisplayRGB
            注释 = "ColorEdit: override _display_ type among RGB/HSV/Hex. ColorPicker: select any combination using one or more of RGB/HSV/Hex.">
    常量 显示HSV <公开 类型 = 整数 值 = @ImGuiColorEditFlags_DisplayHSV>
    常量 显示HEX <公开 类型 = 整数 值 = @ImGuiColorEditFlags_DisplayHex>
    常量 整数值 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_Uint8
            注释 = "ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.">
    常量 浮点数值 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_Float
            注释 = "ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.">
    常量 色相条 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_PickerHueBar
            注释 = "ColorPicker: bar for Hue, rectangle for Sat/Value.">
    常量 色相环 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_PickerHueWheel
            注释 = "ColorPicker: wheel for Hue, triangle for Sat/Value.">
    常量 RGB输入 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_InputRGB
            注释 = "ColorEdit, ColorPicker: input and output data in RGB format.">
    常量 HSV输入 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_InputHSV
            注释 = "ColorEdit, ColorPicker: input and output data in HSV format.">
    常量 ""
    常量 默认选项_ <公开 类型 = 整数 值 = @ImGuiColorEditFlags_DefaultOptions_
            注释 = "ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_PickerHueBar"
            注释 = "Defaults Options. You can set application defaults using SetColorEditOptions(). The intent is that you probably don\'t want to"
            注释 = "override them in most of your calls. Let the user choose via the option menu and/or call SetColorEditOptions() once during startup.">
    常量 显示掩码_ <公开 类型 = 整数 值 = @ImGuiColorEditFlags_DisplayMask_
            注释 = "ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_DisplayHex">
    常量 数据类型掩码_ <公开 类型 = 整数 值 = @ImGuiColorEditFlags_DataTypeMask_
            注释 = "ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_Float">
    常量 选取器掩码_ <类型 = 整数 值 = @ImGuiColorEditFlags_PickerMask_
            注释 = "ImGuiColorEditFlags_PickerHueWheel | ImGuiColorEditFlags_PickerHueBar">
    常量 输入掩码_ <类型 = 整数 值 = @ImGuiColorEditFlags_InputMask_
            注释 = "ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_InputHSV">
}

类 IM滑块标志 <公开 注释 = "\"××拖动框\"和\"××滑块\"组件的标志[ImGuiSliderFlags]." 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiSliderFlags_None>
    常量 始终限制范围 <公开 类型 = 整数 值 = @ImGuiSliderFlags_AlwaysClamp
            注释 = "使用Ctrl+单击手动输入时,始终将值限制在\"最小值~最大值\"的范围内.默认情况下,手动输入值允许越界.">
    常量 对数 <公开 类型 = 整数 值 = @ImGuiSliderFlags_Logarithmic
            注释 = "Make the widget logarithmic (linear otherwise). Consider using ImGuiSliderFlags_NoRoundToFormat with this if using a format-string with small amount of digits.">
    常量 不舍弃精度 <公开 类型 = 整数 值 = @ImGuiSliderFlags_NoRoundToFormat
            注释 = "禁用舍入基础值以匹配显示格式文本的精度(例如\"%.3f\"会将值四舍五入到小数点后3位)">
    常量 禁止输入 <公开 类型 = 整数 值 = @ImGuiSliderFlags_NoInput 注释 = "禁止使用Ctrl+单击、双击、回车键来直接输入数值到组件中">
}

类 IM视口标志 <公开 注释 = "ImGuiViewportFlags" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiViewportFlags_None>
    常量 平台窗口 <公开 类型 = 整数 值 = @ImGuiViewportFlags_IsPlatformWindow 注释 = "显示一个平台窗口">
    常量 平台显示器 <公开 类型 = 整数 值 = @ImGuiViewportFlags_IsPlatformMonitor 注释 = "显示一个平台显示器,目前未使用">
    常量 属于应用程序 <公开 类型 = 整数 值 = @ImGuiViewportFlags_OwnedByApp 注释 = "平台窗口：由应用程序创建和管理,而不是一个ImGui后端."
            注释 = "Platform Window: Was created/managed by the user application? (rather than our backend)">
    常量 无窗口边框 <公开 类型 = 整数 值 = @ImGuiViewportFlags_NoDecoration
            注释 = "Platform Window: Disable platform decorations: title bar, borders, etc. (generally set all windows, but if ImGuiConfigFlags_ViewportsDecoration is set we only set this on popups/tooltips)">
    常量 无任务栏图标 <公开 类型 = 整数 值 = @ImGuiViewportFlags_NoTaskBarIcon
            注释 = "Platform Window: Disable platform task bar icon (generally set on popups/tooltips, or all windows if ImGuiConfigFlags_ViewportsNoTaskBarIcon is set)">
    常量 创建时不获取焦点 <公开 类型 = 整数 值 = @ImGuiViewportFlags_NoFocusOnAppearing
            注释 = "Platform Window: Don\'t take focus when created.">
    常量 单击时不获取焦点 <公开 类型 = 整数 值 = @ImGuiViewportFlags_NoFocusOnClick
            注释 = "Platform Window: Don\'t take focus when clicked on.">
    常量 禁止输入 <公开 类型 = 整数 值 = @ImGuiViewportFlags_NoInputs
            注释 = "Platform Window: Make mouse pass through so we can drag this window while peaking behind it.">
    常量 禁止渲染器清除 <公开 类型 = 整数 值 = @ImGuiViewportFlags_NoRendererClear
            注释 = "Platform Window: Renderer doesn\'t need to clear the framebuffer ahead (because we will fill it entirely).">
    常量 禁止自动合并 <公开 类型 = 整数 值 = @ImGuiViewportFlags_NoAutoMerge
            注释 = "Platform Window: Avoid merging this window into another host window."
            注释 = "This can only be set via ImGuiWindowClass viewport flags override (because we need to now ahead if we are going to create a viewport in the first place!).">
    常量 置于顶层 <公开 类型 = 整数 值 = @ImGuiViewportFlags_TopMost
            注释 = "Platform Window: Display on top (for tooltips only).">
    常量 作为其他窗口的宿主 <公开 类型 = 整数 值 = @ImGuiViewportFlags_CanHostOtherWindows
            注释 = "Viewport can host multiple imgui windows (secondary viewports are associated to a single window)."
            注释 = "// FIXME: In practice there\'s still probably code making the assumption that this is always and only on the MainViewport. Will fix once we add support for \"no main viewport\".">
    常量 窗口最小化 <公开 类型 = 整数 值 = @ImGuiViewportFlags_IsMinimized
            注释 = "Platform Window: Window is minimized, can skip render."
            注释 = "When minimized we tend to avoid using the viewport pos/size for clipping window or testing if they are contained in the viewport.">
    常量 获取焦点 <公开 类型 = 整数 值 = @ImGuiViewportFlags_IsFocused
            注释 = "Platform Window: Window is focused (last call to Platform_GetWindowFocus() returned true)">
}

类 IM绘制标志 <公开 注释 = "ImDrawFlags" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImDrawFlags_None>
    常量 闭合形状 <公开 类型 = 整数 值 = @ImDrawFlags_Closed
            注释 = "PathStroke(), AddPolyline(): specify that shape should be closed (Important: this is always == 1 for legacy reason)">
    常量 左上圆角 <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersTopLeft
            注释 = "AddRect(), AddRectFilled(), PathRect(): enable rounding top-left corner only (when rounding > 0.0f, we default to all corners). Was 0x01.">
    常量 右上圆角 <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersTopRight
            注释 = "AddRect(), AddRectFilled(), PathRect(): enable rounding top-right corner only (when rounding > 0.0f, we default to all corners). Was 0x02.">
    常量 左下圆角 <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersBottomLeft
            注释 = "AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-left corner only (when rounding > 0.0f, we default to all corners). Was 0x04.">
    常量 右下圆角 <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersBottomRight
            注释 = "AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-right corner only (when rounding > 0.0f, we default to all corners). Wax 0x08.">
    常量 无圆角 <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersNone
            注释 = "AddRect(), AddRectFilled(), PathRect(): disable rounding on all corners (when rounding > 0.0f). This is NOT zero, NOT an implicit flag!">
    常量 上侧圆角 <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersTop
            注释 = "ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight">
    常量 下侧圆角 <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersBottom
            注释 = "ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight">
    常量 左侧圆角 <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersLeft
            注释 = "ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersTopLeft">
    常量 右侧圆角 <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersRight
            注释 = "ImDrawFlags_RoundCornersBottomRight | ImDrawFlags_RoundCornersTopRight">
    常量 全体圆角 <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersAll
            注释 = "ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight | ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight">
}

类 IM绘制列表标志 <公开 注释 = "ImDrawListFlags" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImDrawListFlags_None>
    常量 抗锯齿线条 <公开 类型 = 整数 值 = @ImDrawListFlags_AntiAliasedLines 注释 = "启用线条和边线的抗锯齿">
    常量 纹理抗锯齿线条 <公开 类型 = 整数 值 = @ImDrawListFlags_AntiAliasedLinesUseTex
            注释 = "尽可能使用纹理启用线条和边线的抗锯齿,要求后端使用双线性过滤进行渲染.">
    常量 抗锯齿填充 <公开 类型 = 整数 值 = @ImDrawListFlags_AntiAliasedFill 注释 = "启用填充形状(圆角矩形、圆形)周围边缘的抗锯齿.">
    常量 允许VTX偏移 <公开 类型 = 整数 值 = @ImDrawListFlags_AllowVtxOffset
            注释 = "Can emit \'VtxOffset > 0\' to allow large meshes. Set when \'ImGuiBackendFlags_RendererHasVtxOffset\' is enabled.">
}

# 枚举常量

类 IM字形范围 <公开 注释 = "用于获取常用的Unicode范围列表(每个范围2个值,包含值的以零结尾列表)" 折叠 @文档 = "category = \"常量类\"" @常量类 = 文本型>
{
    常量 默认 <公开 值 = "GetGlyphRangesDefault" 注释 = "基本拉丁文 + 扩展拉丁文">
    常量 希腊文 <公开 值 = "GetGlyphRangesGreek" 注释 = "默认 + 希腊文 + 科普特文">
    常量 韓文 <公开 值 = "GetGlyphRangesKorean" 注释 = "默认 + 韓文">
    常量 日文 <公开 值 = "GetGlyphRangesJapanese" 注释 = "默认 + 平假名、平假名、半角字符、2999字的常用汉字表">
    常量 中文 <公开 值 = "GetGlyphRangesChineseFull" 注释 = "默认 + 半角字符 + 日文平假名/平假名 + 约21000字的完整中日韩统一表意文字">
    常量 简体中文 <公开 值 = "GetGlyphRangesChineseSimplifiedCommon"
            注释 = "默认 + 半角字符 + 日文平假名/平假名 + 2500字的中日韩统一表意文字(简体中文)">
    常量 西里尔文 <公开 值 = "GetGlyphRangesCyrillic" 注释 = "默认 + 大约400字的西里尔文字符">
    常量 泰文 <公开 值 = "GetGlyphRangesThai" 注释 = "默认 + 泰文字符">
    常量 越南文 <公开 值 = "GetGlyphRangesVietnamese" 注释 = "默认 + 越南文字符">
}

类 IM表格背景目标 <公开 注释 = "ImGuiTableBgTarget Enum for ImGui::TableSetBgColor()" 折叠
        @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 无 <公开 值 = @ImGuiTableBgTarget_None>
    常量 行背景颜色0 <公开 值 = @ImGuiTableBgTarget_RowBg0
            注释 = "设置行背景颜色0(通常用于行背景,使用\"ImGuiTableFlags_RowBg\"时自动设置本标志)">
    常量 行背景颜色1 <公开 值 = @ImGuiTableBgTarget_RowBg1 注释 = "设置行背景颜色1(通常用于被选中项)">
    常量 单元格背景颜色 <公开 值 = @ImGuiTableBgTarget_CellBg 注释 = "设置单元格的背景颜色(最顶层的颜色)">
}

类 IM排序方向 <公开 注释 = "ImGuiSortDirection" 折叠 @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 无 <公开 值 = @ImGuiSortDirection_None>
    常量 升序 <公开 值 = @ImGuiSortDirection_Ascending 注释 = "升序 = 0->9, A->Z etc.">
    常量 降序 <公开 值 = @ImGuiSortDirection_Descending 注释 = "降序 = 9->0, Z->A etc.">
}

类 IM按键码 <公开 注释 = "ImGuiKey" 折叠 @文档 = "category = \"常量类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiKey_None>
    常量 Tab键 <公开 类型 = 整数 值 = @ImGuiKey_Tab>
    常量 左光标键 <公开 类型 = 整数 值 = @ImGuiKey_LeftArrow 注释 = "左箭头">
    常量 右光标键 <公开 类型 = 整数 值 = @ImGuiKey_RightArrow 注释 = "右箭头">
    常量 上光标键 <公开 类型 = 整数 值 = @ImGuiKey_UpArrow 注释 = "上箭头">
    常量 下光标键 <公开 类型 = 整数 值 = @ImGuiKey_DownArrow 注释 = "下箭头">
    常量 PageUp键 <公开 类型 = 整数 值 = @ImGuiKey_PageUp 注释 = "上翻页">
    常量 PageDown键 <公开 类型 = 整数 值 = @ImGuiKey_PageDown 注释 = "下翻页">
    常量 Home键 <公开 类型 = 整数 值 = @ImGuiKey_Home>
    常量 End键 <公开 类型 = 整数 值 = @ImGuiKey_End>
    常量 插入键 <公开 类型 = 整数 值 = @ImGuiKey_Insert 注释 = "Insert">
    常量 删除键 <公开 类型 = 整数 值 = @ImGuiKey_Delete 注释 = "Delete">
    常量 退格键 <公开 类型 = 整数 值 = @ImGuiKey_Backspace 注释 = "Backspace">
    常量 空格键 <公开 类型 = 整数 值 = @ImGuiKey_Space 注释 = "Space">
    常量 回车键 <公开 类型 = 整数 值 = @ImGuiKey_Enter 注释 = "Enter">
    常量 Esc键 <公开 类型 = 整数 值 = @ImGuiKey_Escape 注释 = "Escape">
    常量 左Ctrl键 <公开 类型 = 整数 值 = @ImGuiKey_LeftCtrl>
    常量 左Shift键 <公开 类型 = 整数 值 = @ImGuiKey_LeftShift>
    常量 左Alt键 <公开 类型 = 整数 值 = @ImGuiKey_LeftAlt>
    常量 左徽标键 <公开 类型 = 整数 值 = @ImGuiKey_LeftSuper 注释 = "Win键">
    常量 右Ctrl键 <公开 类型 = 整数 值 = @ImGuiKey_RightCtrl>
    常量 右Shift键 <公开 类型 = 整数 值 = @ImGuiKey_RightShift>
    常量 右Alt键 <公开 类型 = 整数 值 = @ImGuiKey_RightAlt>
    常量 右徽标键 <公开 类型 = 整数 值 = @ImGuiKey_RightSuper>
    常量 菜单键 <公开 类型 = 整数 值 = @ImGuiKey_Menu>
    常量 数字0键 <公开 类型 = 整数 值 = @ImGuiKey_0>
    常量 数字1键 <公开 类型 = 整数 值 = @ImGuiKey_1>
    常量 数字2键 <公开 类型 = 整数 值 = @ImGuiKey_2>
    常量 数字3键 <公开 类型 = 整数 值 = @ImGuiKey_3>
    常量 数字4键 <公开 类型 = 整数 值 = @ImGuiKey_4>
    常量 数字5键 <公开 类型 = 整数 值 = @ImGuiKey_5>
    常量 数字6键 <公开 类型 = 整数 值 = @ImGuiKey_6>
    常量 数字7键 <公开 类型 = 整数 值 = @ImGuiKey_7>
    常量 数字8键 <公开 类型 = 整数 值 = @ImGuiKey_8>
    常量 数字9键 <公开 类型 = 整数 值 = @ImGuiKey_9>
    常量 A键 <公开 类型 = 整数 值 = @ImGuiKey_A>
    常量 B键 <公开 类型 = 整数 值 = @ImGuiKey_B>
    常量 C键 <公开 类型 = 整数 值 = @ImGuiKey_C>
    常量 D键 <公开 类型 = 整数 值 = @ImGuiKey_D>
    常量 E键 <公开 类型 = 整数 值 = @ImGuiKey_E>
    常量 F键 <公开 类型 = 整数 值 = @ImGuiKey_F>
    常量 G键 <公开 类型 = 整数 值 = @ImGuiKey_G>
    常量 H键 <公开 类型 = 整数 值 = @ImGuiKey_H>
    常量 I键 <公开 类型 = 整数 值 = @ImGuiKey_I>
    常量 J键 <公开 类型 = 整数 值 = @ImGuiKey_J>
    常量 K键 <公开 类型 = 整数 值 = @ImGuiKey_K>
    常量 L键 <公开 类型 = 整数 值 = @ImGuiKey_L>
    常量 M键 <公开 类型 = 整数 值 = @ImGuiKey_M>
    常量 N键 <公开 类型 = 整数 值 = @ImGuiKey_N>
    常量 O键 <公开 类型 = 整数 值 = @ImGuiKey_O>
    常量 P键 <公开 类型 = 整数 值 = @ImGuiKey_P>
    常量 Q键 <公开 类型 = 整数 值 = @ImGuiKey_Q>
    常量 R键 <公开 类型 = 整数 值 = @ImGuiKey_R>
    常量 S键 <公开 类型 = 整数 值 = @ImGuiKey_S>
    常量 T键 <公开 类型 = 整数 值 = @ImGuiKey_T>
    常量 U键 <公开 类型 = 整数 值 = @ImGuiKey_U>
    常量 V键 <公开 类型 = 整数 值 = @ImGuiKey_V>
    常量 W键 <公开 类型 = 整数 值 = @ImGuiKey_W>
    常量 X键 <公开 类型 = 整数 值 = @ImGuiKey_X>
    常量 Y键 <公开 类型 = 整数 值 = @ImGuiKey_Y>
    常量 Z键 <公开 类型 = 整数 值 = @ImGuiKey_Z>
    常量 F1键 <公开 类型 = 整数 值 = @ImGuiKey_F1>
    常量 F2键 <公开 类型 = 整数 值 = @ImGuiKey_F2>
    常量 F3键 <公开 类型 = 整数 值 = @ImGuiKey_F3>
    常量 F4键 <公开 类型 = 整数 值 = @ImGuiKey_F4>
    常量 F5键 <公开 类型 = 整数 值 = @ImGuiKey_F5>
    常量 F6键 <公开 类型 = 整数 值 = @ImGuiKey_F6>
    常量 F7键 <公开 类型 = 整数 值 = @ImGuiKey_F7>
    常量 F8键 <公开 类型 = 整数 值 = @ImGuiKey_F8>
    常量 F9键 <公开 类型 = 整数 值 = @ImGuiKey_F9>
    常量 F10键 <公开 类型 = 整数 值 = @ImGuiKey_F10>
    常量 F11键 <公开 类型 = 整数 值 = @ImGuiKey_F11>
    常量 F12键 <公开 类型 = 整数 值 = @ImGuiKey_F12>
    常量 F13键 <公开 类型 = 整数 值 = @ImGuiKey_F13>
    常量 F14键 <公开 类型 = 整数 值 = @ImGuiKey_F14>
    常量 F15键 <公开 类型 = 整数 值 = @ImGuiKey_F15>
    常量 F16键 <公开 类型 = 整数 值 = @ImGuiKey_F16>
    常量 F17键 <公开 类型 = 整数 值 = @ImGuiKey_F17>
    常量 F18键 <公开 类型 = 整数 值 = @ImGuiKey_F18>
    常量 F19键 <公开 类型 = 整数 值 = @ImGuiKey_F19>
    常量 F20键 <公开 类型 = 整数 值 = @ImGuiKey_F20>
    常量 F21键 <公开 类型 = 整数 值 = @ImGuiKey_F21>
    常量 F22键 <公开 类型 = 整数 值 = @ImGuiKey_F22>
    常量 F23键 <公开 类型 = 整数 值 = @ImGuiKey_F23>
    常量 F24键 <公开 类型 = 整数 值 = @ImGuiKey_F24>
    常量 撇号键 <公开 类型 = 整数 值 = @ImGuiKey_Apostrophe 注释 = "单引号 \'">
    常量 逗号键 <公开 类型 = 整数 值 = @ImGuiKey_Comma 注释 = ",">
    常量 减号键 <公开 类型 = 整数 值 = @ImGuiKey_Minus 注释 = "-">
    常量 句号键 <公开 类型 = 整数 值 = @ImGuiKey_Period 注释 = ".">
    常量 斜杠键 <公开 类型 = 整数 值 = @ImGuiKey_Slash 注释 = "/">
    常量 分号键 <公开 类型 = 整数 值 = @ImGuiKey_Semicolon 注释 = ";">
    常量 等号键 <公开 类型 = 整数 值 = @ImGuiKey_Equal 注释 = "=">
    常量 左中括号键 <公开 类型 = 整数 值 = @ImGuiKey_LeftBracket 注释 = "[">
    常量 反斜杠键 <公开 类型 = 整数 值 = @ImGuiKey_Backslash
            注释 = "\\ (this text inhibit multiline comment caused by backslash)">
    常量 右中括号键 <公开 类型 = 整数 值 = @ImGuiKey_RightBracket 注释 = "]">
    常量 反撇号键 <公开 类型 = 整数 值 = @ImGuiKey_GraveAccent 注释 = "`">
    常量 大写锁定键 <公开 类型 = 整数 值 = @ImGuiKey_CapsLock 注释 = "CapsLock">
    常量 滚动锁定键 <公开 类型 = 整数 值 = @ImGuiKey_ScrollLock 注释 = "ScrollLock">
    常量 数字锁定键 <公开 类型 = 整数 值 = @ImGuiKey_NumLock 注释 = "NumLock">
    常量 截屏键 <公开 类型 = 整数 值 = @ImGuiKey_PrintScreen 注释 = "PrintScreen">
    常量 暂停键 <公开 类型 = 整数 值 = @ImGuiKey_Pause 注释 = "Pause">
    常量 小键盘0键 <公开 类型 = 整数 值 = @ImGuiKey_Keypad0>
    常量 小键盘1键 <公开 类型 = 整数 值 = @ImGuiKey_Keypad1>
    常量 小键盘2键 <公开 类型 = 整数 值 = @ImGuiKey_Keypad2>
    常量 小键盘3键 <公开 类型 = 整数 值 = @ImGuiKey_Keypad3>
    常量 小键盘4键 <公开 类型 = 整数 值 = @ImGuiKey_Keypad4>
    常量 小键盘5键 <公开 类型 = 整数 值 = @ImGuiKey_Keypad5>
    常量 小键盘6键 <公开 类型 = 整数 值 = @ImGuiKey_Keypad6>
    常量 小键盘7键 <公开 类型 = 整数 值 = @ImGuiKey_Keypad7>
    常量 小键盘8键 <公开 类型 = 整数 值 = @ImGuiKey_Keypad8>
    常量 小键盘9键 <公开 类型 = 整数 值 = @ImGuiKey_Keypad9>
    常量 小键盘小数点键 <公开 类型 = 整数 值 = @ImGuiKey_KeypadDecimal>
    常量 小键盘除号键 <公开 类型 = 整数 值 = @ImGuiKey_KeypadDivide>
    常量 小键盘乘号键 <公开 类型 = 整数 值 = @ImGuiKey_KeypadMultiply>
    常量 小键盘减号键 <公开 类型 = 整数 值 = @ImGuiKey_KeypadSubtract>
    常量 小键盘加号键 <公开 类型 = 整数 值 = @ImGuiKey_KeypadAdd>
    常量 小键盘回车键 <公开 类型 = 整数 值 = @ImGuiKey_KeypadEnter>
    常量 小键盘等号键 <公开 类型 = 整数 值 = @ImGuiKey_KeypadEqual>
    常量 前进键 <公开 类型 = 整数 值 = @ImGuiKey_AppBack 注释 = "在部分键盘鼠标中可用,通常指向浏览器前进">
    常量 后退键 <公开 类型 = 整数 值 = @ImGuiKey_AppForward 注释 = "在部分键盘鼠标中可用,通常指向浏览器后退">
    常量 ""
    常量 手柄开始键 <公开 类型 = 整数 值 = @ImGuiKey_GamepadStart 注释 = "Menu (Xbox)      + (Switch)   Start/Options (PS)">
    常量 手柄返回键 <公开 类型 = 整数 值 = @ImGuiKey_GamepadBack 注释 = "View (Xbox)      - (Switch)   Share (PS)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_GamepadFaceLeft 注释 = "X (Xbox)         Y (Switch)   Square (PS)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_GamepadFaceRight 注释 = "B (Xbox)         A (Switch)   Circle (PS)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_GamepadFaceUp 注释 = "Y (Xbox)         X (Switch)   Triangle (PS)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_GamepadFaceDown 注释 = "A (Xbox)         B (Switch)   Cross (PS)">
    常量 手柄向左键 <公开 类型 = 整数 值 = @ImGuiKey_GamepadDpadLeft 注释 = "D-pad Left">
    常量 手柄向右键 <公开 类型 = 整数 值 = @ImGuiKey_GamepadDpadRight 注释 = "D-pad Right">
    常量 手柄向上键 <公开 类型 = 整数 值 = @ImGuiKey_GamepadDpadUp 注释 = "D-pad Up">
    常量 手柄向下键 <公开 类型 = 整数 值 = @ImGuiKey_GamepadDpadDown 注释 = "D-pad Down">
    常量 手柄L1键 <公开 类型 = 整数 值 = @ImGuiKey_GamepadL1 注释 = "L Bumper (Xbox)  L (Switch)   L1 (PS)">
    常量 手柄R1键 <公开 类型 = 整数 值 = @ImGuiKey_GamepadR1 注释 = "R Bumper (Xbox)  R (Switch)   R1 (PS)">
    常量 手柄L2键 <公开 类型 = 整数 值 = @ImGuiKey_GamepadL2 注释 = "L Trig. (Xbox)   ZL (Switch)  L2 (PS) [模拟]">
    常量 手柄R2键 <公开 类型 = 整数 值 = @ImGuiKey_GamepadR2 注释 = "R Trig. (Xbox)   ZR (Switch)  R2 (PS) [模拟]">
    常量 手柄L3键 <公开 类型 = 整数 值 = @ImGuiKey_GamepadL3 注释 = "L Stick (Xbox)   L3 (Switch)  L3 (PS)">
    常量 手柄R3键 <公开 类型 = 整数 值 = @ImGuiKey_GamepadR3 注释 = "R Stick (Xbox)   R3 (Switch)  R3 (PS)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_GamepadLStickLeft 注释 = "[模拟]">
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_GamepadLStickRight 注释 = "[模拟]">
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_GamepadLStickUp 注释 = "[模拟]">
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_GamepadLStickDown 注释 = "[模拟]">
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_GamepadRStickLeft 注释 = "[模拟]">
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_GamepadRStickRight 注释 = "[模拟]">
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_GamepadRStickUp 注释 = "[模拟]">
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_GamepadRStickDown 注释 = "[模拟]">
    常量 ""
    常量 鼠标左键 <公开 类型 = 整数 值 = @ImGuiKey_MouseLeft>
    常量 鼠标右键 <公开 类型 = 整数 值 = @ImGuiKey_MouseRight>
    常量 鼠标中键 <公开 类型 = 整数 值 = @ImGuiKey_MouseMiddle>
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_MouseX1>
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_MouseX2>
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_MouseWheelX>
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_MouseWheelY>
    常量 ""
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_ReservedForModCtrl>
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_ReservedForModShift>
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_ReservedForModAlt>
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_ReservedForModSuper>
    常量 "" <公开 类型 = 整数 值 = @ImGuiKey_COUNT>
    常量 ""
    常量 Ctrl键 <公开 类型 = 整数 值 = @ImGuiMod_Ctrl 注释 = "Ctrl">
    常量 Shift键 <公开 类型 = 整数 值 = @ImGuiMod_Shift 注释 = "Shift">
    常量 Alt键 <公开 类型 = 整数 值 = @ImGuiMod_Alt 注释 = "Option/Menu">
    常量 徽标键 <公开 类型 = 整数 值 = @ImGuiMod_Super 注释 = "Cmd/Super/Windows">
    常量 "" <公开 类型 = 整数 值 = @ImGuiMod_Shortcut 注释 = "Alias for Ctrl (non-macOS) _or_ Super (macOS).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiMod_Mask_ 注释 = "5-bits">
}

类 IM颜色标识符 <公开 注释 = "样式的颜色标识符 ImGuiCol" 折叠 @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 文本 <公开 值 = @ImGuiCol_Text>
    常量 文本_已禁用 <公开 值 = @ImGuiCol_TextDisabled>
    常量 窗口背景 <公开 值 = @ImGuiCol_WindowBg 注释 = "常规窗口的背景颜色">
    常量 子窗口背景 <公开 值 = @ImGuiCol_ChildBg 注释 = "子窗口的背景颜色">
    常量 弹出项背景 <公开 值 = @ImGuiCol_PopupBg 注释 = "弹出项、菜单、工具提示窗口的背景颜色">
    常量 边框线 <公开 值 = @ImGuiCol_Border>
    常量 边框线阴影 <公开 值 = @ImGuiCol_BorderShadow>
    常量 框体背景 <公开 值 = @ImGuiCol_FrameBg 注释 = "复选框、单选按钮、绘图区、滑块、文本输入的背景颜色">
    常量 框体背景_悬停 <公开 值 = @ImGuiCol_FrameBgHovered>
    常量 框体背景_活动 <公开 值 = @ImGuiCol_FrameBgActive>
    常量 标题背景 <公开 值 = @ImGuiCol_TitleBg 注释 = "标题栏">
    常量 标题背景_活动 <公开 值 = @ImGuiCol_TitleBgActive 注释 = "当前焦点的标题栏">
    常量 标题背景_已折叠 <公开 值 = @ImGuiCol_TitleBgCollapsed 注释 = "已折叠的标题栏">
    常量 菜单栏背景 <公开 值 = @ImGuiCol_MenuBarBg>
    常量 滚动条背景 <公开 值 = @ImGuiCol_ScrollbarBg>
    常量 滚动条手柄 <公开 值 = @ImGuiCol_ScrollbarGrab>
    常量 滚动条手柄_悬停 <公开 值 = @ImGuiCol_ScrollbarGrabHovered>
    常量 滚动条手柄_活动 <公开 值 = @ImGuiCol_ScrollbarGrabActive>
    常量 选中标记 <公开 值 = @ImGuiCol_CheckMark>
    常量 滑块手柄 <公开 值 = @ImGuiCol_SliderGrab>
    常量 滑块手柄_活动 <公开 值 = @ImGuiCol_SliderGrabActive>
    常量 按钮 <公开 值 = @ImGuiCol_Button>
    常量 按钮_悬停 <公开 值 = @ImGuiCol_ButtonHovered>
    常量 按钮_活动 <公开 值 = @ImGuiCol_ButtonActive>
    常量 标题 <公开 值 = @ImGuiCol_Header 注释 = "标题颜色用于折叠标题、数节点、可选项、菜单项">
    常量 标题_悬停 <公开 值 = @ImGuiCol_HeaderHovered>
    常量 标题_活动 <公开 值 = @ImGuiCol_HeaderActive>
    常量 分隔条 <公开 值 = @ImGuiCol_Separator>
    常量 分隔条_悬停 <公开 值 = @ImGuiCol_SeparatorHovered>
    常量 分隔条_活动 <公开 值 = @ImGuiCol_SeparatorActive>
    常量 调整大小手柄 <公开 值 = @ImGuiCol_ResizeGrip 注释 = "窗口右下角和左下角的调整大小手柄">
    常量 调整大小手柄_悬停 <公开 值 = @ImGuiCol_ResizeGripHovered>
    常量 调整大小手柄_活动 <公开 值 = @ImGuiCol_ResizeGripActive>
    常量 选项卡 <公开 值 = @ImGuiCol_Tab 注释 = "选项卡栏的选项卡">
    常量 选项卡_悬停 <公开 值 = @ImGuiCol_TabHovered>
    常量 选项卡_活动 <公开 值 = @ImGuiCol_TabActive>
    常量 选项卡_失去焦点 <公开 值 = @ImGuiCol_TabUnfocused>
    常量 选项卡_失去焦点_活动 <公开 值 = @ImGuiCol_TabUnfocusedActive>
    常量 停靠_预览色 <公开 值 = @ImGuiCol_DockingPreview 注释 = "将要停靠某些内容时预览覆盖颜色">
    常量 停靠_空节点背景 <公开 值 = @ImGuiCol_DockingEmptyBg 注释 = "空节点的背景颜色(例如没有停靠窗口的节点)">
    常量 线形图 <公开 值 = @ImGuiCol_PlotLines>
    常量 线形图_悬停 <公开 值 = @ImGuiCol_PlotLinesHovered>
    常量 直方图 <公开 值 = @ImGuiCol_PlotHistogram>
    常量 直方图_悬停 <公开 值 = @ImGuiCol_PlotHistogramHovered>
    常量 表格标题背景 <公开 值 = @ImGuiCol_TableHeaderBg 注释 = "表格标题的背景颜色">
    常量 表格边框_粗 <公开 值 = @ImGuiCol_TableBorderStrong 注释 = "表格外边框和标题边框(最好使用 1.0 透明度)">
    常量 表格边框_细 <公开 值 = @ImGuiCol_TableBorderLight 注释 = "表格内边框(最好使用 1.0 透明度)">
    常量 表格偶数行背景 <公开 值 = @ImGuiCol_TableRowBg 注释 = "表格偶数行背景颜色">
    常量 表格奇数行背景 <公开 值 = @ImGuiCol_TableRowBgAlt 注释 = "表格奇数行背景颜色">
    常量 被选中文本背景 <公开 值 = @ImGuiCol_TextSelectedBg>
    常量 拖放目标 <公开 值 = @ImGuiCol_DragDropTarget 注释 = "用矩形框高亮拖放目标">
    常量 导航高亮颜色 <公开 值 = @ImGuiCol_NavHighlight 注释 = "游戏手柄/键盘: 当前突出显示的项目">
    常量 导航窗口高亮颜色 <公开 值 = @ImGuiCol_NavWindowingHighlight 注释 = "使用CTRL+TAB时突出显示窗口">
    常量 导航窗口暗背景 <公开 值 = @ImGuiCol_NavWindowingDimBg 注释 = "活动时,使CTRL+TAB窗口列表背后的整个屏幕变暗或着色">
    常量 模态窗口暗背景 <公开 值 = @ImGuiCol_ModalWindowDimBg 注释 = "当模态窗口处于活动状态时,使模态窗口后面的整个屏幕变暗或着色">
    常量 "// 标识符数量" <公开 值 = @ImGuiCol_COUNT>
}

类 IM样式标识符 <公开
        注释 = "ImGuiStyleVar Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure."
        折叠 @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 不透明度 <公开 值 = @ImGuiStyleVar_Alpha 注释 = "float">
    常量 禁用项不透明度 <公开 值 = @ImGuiStyleVar_DisabledAlpha 注释 = "float">
    常量 窗口内边距 <公开 值 = @ImGuiStyleVar_WindowPadding 注释 = "ImVec2">
    常量 窗口圆角 <公开 值 = @ImGuiStyleVar_WindowRounding 注释 = "float">
    常量 窗口边框粗细 <公开 值 = @ImGuiStyleVar_WindowBorderSize 注释 = "float">
    常量 窗口最小尺寸 <公开 值 = @ImGuiStyleVar_WindowMinSize 注释 = "ImVec2">
    常量 窗口标题对齐 <公开 值 = @ImGuiStyleVar_WindowTitleAlign 注释 = "ImVec2">
    常量 子窗口圆角 <公开 值 = @ImGuiStyleVar_ChildRounding 注释 = "float">
    常量 子窗口边框粗细 <公开 值 = @ImGuiStyleVar_ChildBorderSize 注释 = "float">
    常量 弹出项圆角 <公开 值 = @ImGuiStyleVar_PopupRounding 注释 = "float">
    常量 弹出项边框粗细 <公开 值 = @ImGuiStyleVar_PopupBorderSize 注释 = "float">
    常量 框体内边距 <公开 值 = @ImGuiStyleVar_FramePadding 注释 = "ImVec2">
    常量 框体圆角 <公开 值 = @ImGuiStyleVar_FrameRounding 注释 = "float">
    常量 框体边框粗细 <公开 值 = @ImGuiStyleVar_FrameBorderSize 注释 = "float">
    常量 项目行间距 <公开 值 = @ImGuiStyleVar_ItemSpacing 注释 = "ImVec2">
    常量 项目内间距 <公开 值 = @ImGuiStyleVar_ItemInnerSpacing 注释 = "ImVec2">
    常量 缩进间距 <公开 值 = @ImGuiStyleVar_IndentSpacing 注释 = "float">
    常量 单元格内边距 <公开 值 = @ImGuiStyleVar_CellPadding 注释 = "ImVec2">
    常量 滚动条大小 <公开 值 = @ImGuiStyleVar_ScrollbarSize 注释 = "float">
    常量 滚动条圆角 <公开 值 = @ImGuiStyleVar_ScrollbarRounding 注释 = "float">
    常量 抓取框最小尺寸 <公开 值 = @ImGuiStyleVar_GrabMinSize 注释 = "float">
    常量 抓取框圆角 <公开 值 = @ImGuiStyleVar_GrabRounding 注释 = "float">
    常量 选项卡圆角 <公开 值 = @ImGuiStyleVar_TabRounding 注释 = "float">
    常量 选项卡边框粗细 <公开 值 = @ImGuiStyleVar_TabBarBorderSize 注释 = "float">
    常量 按钮文本对齐 <公开 值 = @ImGuiStyleVar_ButtonTextAlign 注释 = "ImVec2">
    常量 可选项文本对齐 <公开 值 = @ImGuiStyleVar_SelectableTextAlign 注释 = "ImVec2">
    常量 分隔条文本框粗细 <公开 值 = @ImGuiStyleVar_SeparatorTextBorderSize 注释 = "float">
    常量 分隔条文本对齐 <公开 值 = @ImGuiStyleVar_SeparatorTextAlign 注释 = "ImVec2">
    常量 分隔条文本内边距 <公开 值 = @ImGuiStyleVar_SeparatorTextPadding 注释 = "ImVec2">
    常量 停靠分隔条大小 <公开 值 = @ImGuiStyleVar_DockingSeparatorSize 注释 = "float">
}

类 IM鼠标按钮 <公开 注释 = "鼠标按钮的标识符[ImGuiMouseButton]" 折叠 @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 左键 <公开 值 = @ImGuiMouseButton_Left>
    常量 右键 <公开 值 = @ImGuiMouseButton_Right>
    常量 中键 <公开 值 = @ImGuiMouseButton_Middle>
    常量 "" <公开 值 = @ImGuiMouseButton_COUNT>
}

类 IM鼠标光标 <公开 注释 = "ImGuiMouseCursor Enumeration for GetMouseCursor()" 折叠 @文档 = "category = \"常量类\""
        @常量类 = 整数>
{
    常量 无 <公开 值 = @ImGuiMouseCursor_None>
    常量 正常选择 <公开 值 = @ImGuiMouseCursor_Arrow>
    常量 文本选择 <公开 值 = @ImGuiMouseCursor_TextInput 注释 = "When hovering over InputText, etc.">
    常量 调整大小 <公开 值 = @ImGuiMouseCursor_ResizeAll 注释 = "(Unused by Dear ImGui functions)">
    常量 垂直调整大小 <公开 值 = @ImGuiMouseCursor_ResizeNS 注释 = "When hovering over a horizontal border">
    常量 水平调整大小 <公开 值 = @ImGuiMouseCursor_ResizeEW 注释 = "When hovering over a vertical border or a column">
    常量 沿对角线调整大小1 <公开 值 = @ImGuiMouseCursor_ResizeNESW
            注释 = "When hovering over the bottom-left corner of a window">
    常量 沿对角线调整大小2 <公开 值 = @ImGuiMouseCursor_ResizeNWSE
            注释 = "When hovering over the bottom-right corner of a window">
    常量 链接选择 <公开 值 = @ImGuiMouseCursor_Hand 注释 = "(Unused by Dear ImGui functions. Use for e.g. hyperlinks)">
    常量 不可用 <公开 值 = @ImGuiMouseCursor_NotAllowed
            注释 = "When hovering something with disallowed interaction. Usually a crossed circle.">
    常量 "" <公开 值 = @ImGuiMouseCursor_COUNT>
}

类 IM鼠标来源 <公开
        注释 = "ImGuiMouseSource Enumeration for AddMouseSourceEvent() actual source of Mouse Input data." 折叠
        @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 鼠标 <公开 值 = @ImGuiMouseSource_Mouse 注释 = "Input is coming from an actual mouse.">
    常量 触摸屏 <公开 值 = @ImGuiMouseSource_TouchScreen
            注释 = "Input is coming from a touch screen (no hovering prior to initial press, less precise initial press aiming, dual-axis wheeling possible).">
    常量 笔 <公开 值 = @ImGuiMouseSource_Pen
            注释 = "Input is coming from a pressure/magnetic pen (often used in conjunction with high-sampling rates).">
    常量 "" <公开 值 = @ImGuiMouseSource_COUNT>
}

类 IM执行条件 <公开
        注释 = "ImGuiCond Enumeration for ImGui::SetWindow***(), SetNextWindow***(), SetNextItem***() functions"
        折叠 @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 无 <公开 值 = @ImGuiCond_None 注释 = "无条件执行(始终设置变量),等同于\"始终执行\"">
    常量 始终执行 <公开 值 = @ImGuiCond_Always 注释 = "无条件执行(始终设置变量),等同于\"无\"">
    常量 执行一次 <公开 值 = @ImGuiCond_Once 注释 = "只在第一次调用本方法时执行">
    常量 首次使用 <公开 值 = @ImGuiCond_FirstUseEver 注释 = "仅在对象/窗口未持久化保存数据前执行,(即.ini文件中无此内容)">
    常量 首次显示 <公开 值 = @ImGuiCond_Appearing 注释 = "在对象/窗口第一次显示时执行,包括从隐藏或禁用状态重新显示">
}

类 IM数据类型 <公开 注释 = "主要数据类型 ImGuiDataType" 折叠 @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 字节型 <公开 值 = @ImGuiDataType_S8>
    常量 无符号字节 <公开 值 = @ImGuiDataType_U8>
    常量 短整数型 <公开 值 = @ImGuiDataType_S16>
    常量 无符号短整数 <公开 值 = @ImGuiDataType_U16>
    常量 整数型 <公开 值 = @ImGuiDataType_S32>
    常量 无符号整数 <公开 值 = @ImGuiDataType_U32>
    常量 长整数型 <公开 值 = @ImGuiDataType_S64>
    常量 无符号长整数 <公开 值 = @ImGuiDataType_U64>
    常量 单精度浮点数 <公开 值 = @ImGuiDataType_Float>
    常量 双精度浮点数 <公开 值 = @ImGuiDataType_Double>
}

类 IM基本方向 <公开 注释 = "ImGuiDir" 折叠 @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 无 <公开 值 = @ImGuiDir_None>
    常量 向左 <公开 值 = @ImGuiDir_Left>
    常量 向右 <公开 值 = @ImGuiDir_Right>
    常量 向上 <公开 值 = @ImGuiDir_Up>
    常量 向下 <公开 值 = @ImGuiDir_Down>
}

# @begin
# <> <global>
# <> <include>
# #define GET_ImVec2_MaybeNull(_vec, _x, _y) (_vec).IsNullObject() ? ImVec2(_x, _y) : (_vec).data()
# #define GET_ImVec4_MaybeNull(_vec, _x, _y, _z, _w) (_vec).IsNullObject() ? ImVec4(_x, _y, _z, _w) : (_vec).data()
# <> </include>
# <> </global>
# @end
