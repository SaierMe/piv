<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "源码: https://github.com/marzer/tomlplusplus"
        注释 = "TOML v1.0.0 https://toml.io/cn/v1.0.0"
        注释 = "全称：Tom的(语义)明显、(配置)最小化的语言(Tom\'s Obvious, Minimal Language)."
        注释 = "TOML 旨在成为一个语义明显且易于阅读的最小化配置文件格式." 注释 = "TOML 被设计成可以无歧义地映射为哈希表."
        注释 = "TOML 应该能很容易地被解析成各种语言中的数据结构.">

类 TOML节点模板 <公开 基础类 = PIV本地类模板 折叠 @文档 = "category = \"配置文件.TOML\"" @模板基础类 = 真
        @视窗.外部头文件 = "src\\piv_toml.hpp" @视窗.附加编译参数 = "cpp: /std:c++17" @视窗.需求VS版本 = "15-">
{

    # 元数据 Metadata

    方法 取源文档位置 <公开 静态 类型 = 文本型 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ std::stringstream ss;
        @ ss << @<欲操作本对象>.source();
        @ return @an<CVolString>{ss.str().c_str()};
    }

    # 序列化

    方法 到可读文本 <公开 静态 类型 = 文本型 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ std::stringstream ss;
        @ ss << toml::toml_formatter{@<欲操作本对象>};
        @ return @an<CVolString>{ss.str().c_str()};
    }

    方法 到JSON文本 <公开 静态 类型 = 文本型 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ std::stringstream ss;
        @ ss << toml::json_formatter{@<欲操作本对象>};
        @ return @an<CVolString>{ss.str().c_str()};
    }

    方法 到YAML文本 <公开 静态 类型 = 文本型 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ std::stringstream ss;
        @ ss << toml::yaml_formatter{@<欲操作本对象>};
        @ return @an<CVolString>{ss.str().c_str()};
    }

    方法 到可读数据 <公开 静态 类型 = 字节集类 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ std::stringstream ss;
        @ ss << toml::toml_formatter{@<欲操作本对象>};
        @ return @an<CVolMem>{ss.str().c_str(), static_cast<INT_P>(ss.str().size())};
    }

    方法 到JSON数据 <公开 静态 类型 = 字节集类 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ std::stringstream ss;
        @ ss << toml::json_formatter{@<欲操作本对象>};
        @ return @an<CVolMem>{ss.str().c_str(), static_cast<INT_P>(ss.str().size())};
    }

    方法 到YAML数据 <公开 静态 类型 = 字节集类 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ std::stringstream ss;
        @ ss << toml::yaml_formatter{@<欲操作本对象>};
        @ return @an<CVolMem>{ss.str().c_str(), static_cast<INT_P>(ss.str().size())};
    }

    # 取路径值 Node views

    方法 取路径文本值 <公开 静态 类型 = 文本型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ *PivU2Ws{@<欲操作本对象>.at_path(*PivS2V{@<路径>}).value_or<std::string_view>(std::string_view{""})}
    }

    方法 取路径文本值U <公开 静态 类型 = 标准文本类U 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @<欲操作本对象>.at_path(*PivS2V{@<路径>}).value_or<std::string_view>(std::string_view{""})
    }

    方法 取路径整数值 <公开 静态 类型 = 整数 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ static_cast<INT>(@<欲操作本对象>.at_path(*PivS2V{@<路径>}).value_or<int64_t>(0))
    }

    方法 取路径长整数值 <公开 静态 类型 = 长整数 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @<欲操作本对象>.at_path(*PivS2V{@<路径>}).value_or<int64_t>(0)
    }

    方法 取路径小数值 <公开 静态 类型 = 小数 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @<欲操作本对象>.at_path(*PivS2V{@<路径>}).value_or<double>(0.0)
    }

    方法 取路径逻辑值 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @<欲操作本对象>.at_path(*PivS2V{@<路径>}).value_or<bool>(false)
    }

    方法 取路径日期值 <公开 静态 类型 = TOML日期类 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @<欲操作本对象>.at_path(*PivS2V{@<路径>}).value_or<toml::date>(toml::date{})
    }

    方法 取路径时间值 <公开 静态 类型 = TOML时间类 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @<欲操作本对象>.at_path(*PivS2V{@<路径>}).value_or<toml::time>(toml::time{})
    }

    方法 取路径日期时间值 <公开 静态 类型 = TOML日期时间类 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @<欲操作本对象>.at_path(*PivS2V{@<路径>}).value_or<toml::date_time>(toml::date_time{})
    }

    # 类型转换

    方法 到键值表 <公开 静态 类型 = TOML键值表 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ *@<欲操作本对象>.as<toml::table>()
    }

    方法 到数组 <公开 静态 类型 = TOML数组类 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ *@<欲操作本对象>.as<toml::array>()()
    }

    方法 到文本 <公开 静态 类型 = 文本型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ *PivU2W{*@<欲操作本对象>.as<std::string>()}
    }

    方法 到标准文本 <公开 静态 类型 = 标准文本类U 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ **@<欲操作本对象>.as<std::string>()
    }

    方法 到整数 <公开 静态 类型 = 长整数 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ static_cast<INT>(*@<欲操作本对象>.as<int64_t>())
    }

    方法 到长整数 <公开 静态 类型 = 长整数 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ *@<欲操作本对象>.as<int64_t>()
    }

    方法 到小数 <公开 静态 类型 = 小数 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ *@<欲操作本对象>.as<double>()
    }

    方法 到逻辑 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ *@<欲操作本对象>.as<bool>()
    }

    方法 到日期 <公开 静态 类型 = TOML日期类 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ *@<欲操作本对象>.as<toml::date>()
    }

    方法 到时间 <公开 静态 类型 = TOML时间类 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ *@<欲操作本对象>.as<toml::time>()
    }

    方法 到日期时间 <公开 静态 类型 = TOML日期时间类 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ *@<欲操作本对象>.as<toml::date_time>()
    }

    # 类型检查

    方法 是否为同类元素 <公开 静态 类型 = 逻辑型 注释 = "检查节点是否仅包含一种类型的值或元素." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    参数 节点类型 <类型 = TOML节点类型>
    参数 不匹配的首元素 <类型 = TOML节点指针>
    {
        @ @<欲操作本对象>.is_homogeneous(static_cast<toml::node_type>(@<节点类型>), @<不匹配的首元素>)
    }

    方法 类型 <公开 静态 类型 = TOML节点类型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ @<欲操作本对象>.type()
    }

    方法 是否为键值表 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ @<欲操作本对象>.is_table()
    }

    方法 是否为数组 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ @<欲操作本对象>.is_array()
    }

    方法 是否为文本 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ @<欲操作本对象>.is_string()
    }

    方法 是否为整数 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ @<欲操作本对象>.is_integer()
    }

    方法 是否为小数 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ @<欲操作本对象>.is_floating_point()
    }

    方法 是否为数值 <公开 静态 类型 = 逻辑型 注释 = "是否为数值(整数型或小数型)" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ @<欲操作本对象>.is_number()
    }

    方法 是否为逻辑型 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ @<欲操作本对象>.is_boolean()
    }

    方法 是否为日期 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ @<欲操作本对象>.is_date()
    }

    方法 是否为时间 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ @<欲操作本对象>.is_time()
    }

    方法 是否为日期时间 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML节点模板>
    {
        @ @<欲操作本对象>.is_date_time()
    }
}

类 TOML节点类 <公开 基础类 = TOML节点模板 折叠 @文档 = "category = \"配置文件.TOML\"" @别名 = "toml::node" @别名类型 = 本地类
        @模板实现类 = "TOML节点类">

类 TOML键值表 <公开 基础类 = TOML节点模板 折叠 @文档 = "category = \"配置文件.TOML\"" @别名 = "toml::table" @别名类型 = 本地类
        @模板实现类 = "TOML键值表">
{
    方法 创建空对象 <公开 静态 类型 = TOML键值表 折叠 @嵌入式方法 = "">
    {
        @ toml::table{}
    }

    # 解析

    方法 解析文件 <公开 静态 类型 = 逻辑型 注释 = "解析toml文件" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 文件路径 <@匹配类型 = 通用型>
    {
        @ piv::toml::ParseFile(@<欲操作本对象>, @<文件路径>)
    }

    方法 解析文本 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 配置内容 <@匹配类型 = 通用型>
    参数 来源路径 <类型 = 文本型 @默认值 = "">
    {
        @ piv::toml::Parse(@<欲操作本对象>, @<配置内容>, @<来源路径>)
    }

    方法 解析字节集 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 配置内容 <类型 = 字节集类>
    参数 来源路径 <类型 = 文本型 @默认值 = "">
    {
        @ piv::toml::Parse(@<欲操作本对象>, @<配置内容>, @<来源路径>)
    }

    # 序列化

    方法 保存文件 <公开 静态 类型 = 逻辑型 折叠>
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 保存路径 <类型 = 文本型>
    {
        返回 (欲操作本对象.到可读数据 ().写字节集到文件 (保存路径))
    }

    # 成员数

    方法 是否为空 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    {
        @ @<欲操作本对象>.empty()
    }

    方法 取成员数 <公开 静态 类型 = 整数 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    {
        @ static_cast<INT>(@<欲操作本对象>.size())
    }

    方法 是否存在 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ @<欲操作本对象>.contains(*PivS2V{@<键名>})
    }

    # 删除

    方法 清空 <公开 静态 类型 = 整数 注释 = "Removes all key-value pairs from the table." 返回值注释 = "返回删除的键值对数量,0或1." 折叠
            @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    {
        @ @<欲操作本对象>.clear()
    }

    方法 删除 <公开 静态 类型 = 整数 返回值注释 = "返回删除的键值对数量,0或1." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ static_cast<int32_t>(@<欲操作本对象>.erase(*PivS2V{@<键名>}))
    }

    方法 删除空成员 <公开 静态 注释 = "Removes empty child arrays and tables." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 递归删除 <类型 = 逻辑型 注释 = "是否删除子数组和子键值表的自身">
    {
        @ @<欲操作本对象>.prune(@<递归删除>)
    }

    # 类型

    方法 是否为内联表 <公开 静态 类型 = 逻辑型 注释 = "Returns true if this table is an inline table."
            注释 = "Runtime-constructed tables (i.e. those not created"
            注释 = " during parsing) are not inline by default." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    {
        @ @<欲操作本对象>.is_inline()
    }

    # 插入

    方法 插入键值表 <公开 静态 类型 = 逻辑型 注释 = "插入一个指定键名的TOML键值表对象,如果所指定的键名已经存在,将覆盖先前值."
            注释 = "返回真表示插入了一个新值,返回假则表示覆盖了原有的键值对." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 键值表 <类型 = TOML键值表>
    {
        @ @<欲操作本对象>.insert_or_assign(*PivS2V{@<键名>}, @<键值表>).second
    }

    方法 插入数组值 <公开 静态 类型 = 逻辑型 注释 = "插入一个指定键名的TOML表数组对象,如果所指定的键名已经存在,将覆盖先前值."
            注释 = "返回真表示插入了一个新值,返回假则表示覆盖了原有的键值对." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 数组值 <类型 = TOML数组类>
    {
        @ @<欲操作本对象>.insert_or_assign(*PivS2V{@<键名>}, @<数组值>).second
    }

    方法 插入文本值 <公开 静态 类型 = 逻辑型 注释 = "插入一个指定键名的文本型值,如果所指定的键名已经存在,将覆盖先前值." 注释 = "返回真表示插入了一个新值,返回假则表示覆盖了原有的键值对."
            折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 文本值 <@匹配类型 = 通用型>
    {
        @ @<欲操作本对象>.insert_or_assign(*PivS2V{@<键名>}, *PivS2V{@<文本值>}).second
    }

    方法 插入整数值 <公开 静态 类型 = 逻辑型 注释 = "插入一个指定键名的整数型值,如果所指定的键名已经存在,将覆盖先前值." 注释 = "返回真表示插入了一个新值,返回假则表示覆盖了原有的键值对."
            折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 整数值 <类型 = 长整数>
    {
        @ @<欲操作本对象>.insert_or_assign(*PivS2V{@<键名>}, @<整数值>).second
    }

    方法 插入小数值 <公开 静态 类型 = 逻辑型 注释 = "插入一个指定键名的小数型值,如果所指定的键名已经存在,将覆盖先前值." 注释 = "返回真表示插入了一个新值,返回假则表示覆盖了原有的键值对."
            折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 小数值 <类型 = 小数>
    {
        @ @<欲操作本对象>.insert_or_assign(*PivS2V{@<键名>}, @<小数值>).second
    }

    方法 插入逻辑值 <公开 静态 类型 = 逻辑型 注释 = "插入一个指定键名的逻辑型值,如果所指定的键名已经存在,将覆盖先前值." 注释 = "返回真表示插入了一个新值,返回假则表示覆盖了原有的键值对."
            折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 逻辑值 <类型 = 逻辑型>
    {
        @ @<欲操作本对象>.insert_or_assign(*PivS2V{@<键名>}, static_cast<bool>(@<逻辑值>)).second
    }

    方法 插入日期值 <公开 静态 类型 = 逻辑型 注释 = "插入一个指定键名的TOML日期值,如果所指定的键名已经存在,将覆盖先前值."
            注释 = "返回真表示插入了一个新值,返回假则表示覆盖了原有的键值对." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 日期值 <类型 = TOML日期类>
    {
        @ @<欲操作本对象>.insert_or_assign(*PivS2V{@<键名>}, @<日期值>).second
    }

    方法 插入时间值 <公开 静态 类型 = 逻辑型 注释 = "插入一个指定键名的TOML时间值,如果所指定的键名已经存在,将覆盖先前值."
            注释 = "返回真表示插入了一个新值,返回假则表示覆盖了原有的键值对." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 时间值 <类型 = TOML时间类>
    {
        @ @<欲操作本对象>.insert_or_assign(*PivS2V{@<键名>}, @<时间值>).second
    }

    方法 插入日期时间值 <公开 静态 类型 = 逻辑型 注释 = "插入一个指定键名的TOML日期时间值,如果所指定的键名已经存在,将覆盖先前值."
            注释 = "返回真表示插入了一个新值,返回假则表示覆盖了原有的键值对." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 日期时间值 <类型 = TOML日期时间类>
    {
        @ @<欲操作本对象>.insert_or_assign(*PivS2V{@<键名>}, @<日期时间值>).second
    }

    # 置入

    方法 置入键值表 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 键值表 <类型 = TOML键值表>
    {
        @ @<欲操作本对象>.emplace<toml::table>(*PivS2V{@<键名>}, @<键值表>).second
    }

    方法 置入数组值 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 数组值 <类型 = TOML数组类>
    {
        @ @<欲操作本对象>.emplace<toml::array>(*PivS2V{@<键名>}, @<数组值>).second
    }

    方法 置入文本值 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 文本值 <@匹配类型 = 通用型>
    {
        @ @<欲操作本对象>.emplace<std::string>(*PivS2V{@<键名>}, *PivS2V{@<文本值>}).second
    }

    方法 置入整数值 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 整数值 <类型 = 长整数>
    {
        @ @<欲操作本对象>.emplace<int64_t>(*PivS2V{@<键名>}, @<整数值>).second
    }

    方法 置入小数值 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 小数值 <类型 = 小数>
    {
        @ @<欲操作本对象>.emplace<double>(*PivS2V{@<键名>}, @<小数值>).second
    }

    方法 置入逻辑值 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 逻辑值 <类型 = 逻辑型>
    {
        @ @<欲操作本对象>.emplace<bool>(*PivS2V{@<键名>}, @<逻辑值>).second
    }

    方法 置入日期值 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 日期值 <类型 = TOML日期类>
    {
        @ @<欲操作本对象>.emplace<toml::date>(*PivS2V{@<键名>}, @<日期值>).second
    }

    方法 置入时间值 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 时间值 <类型 = TOML时间类>
    {
        @ @<欲操作本对象>.emplace<toml::time>(*PivS2V{@<键名>}, @<时间值>).second
    }

    方法 置入日期时间值 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    参数 日期时间值 <类型 = TOML日期时间类>
    {
        @ @<欲操作本对象>.emplace<toml::date_time>(*PivS2V{@<键名>}, @<日期时间值>).second
    }

    # 取值

    方法 取节点 <公开 静态 类型 = TOML节点指针 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ @<欲操作本对象>.get(*PivS2V{@<键名>})
    }

    方法 取数组 <公开 静态 类型 = TOML数组类 @嵌入式方法 = "" "//@视窗.返回参考" = 真>
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ piv::toml::GetArr(@<欲操作本对象>, @<键名>, ::toml::array{})
    }

    方法 取键值表 <公开 静态 类型 = TOML键值表 @嵌入式方法 = "" "//@视窗.返回参考" = 真>
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ piv::toml::GetTable(@<欲操作本对象>, @<键名>, ::toml::table{})
    }

    方法 取文本值 <公开 静态 类型 = 文本型 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ *PivU2Ws{piv::toml::GetAs<std::string>(@<欲操作本对象>, @<键名>)}
    }

    方法 取文本值U <公开 静态 类型 = 标准文本类U @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ piv::toml::GetAs<std::string>(@<欲操作本对象>, @<键名>)
    }

    方法 取整数值 <公开 静态 类型 = 整数 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ static_cast<INT>(piv::toml::GetAs<int64_t>(@<欲操作本对象>, @<键名>))
    }

    方法 取长整数值 <公开 静态 类型 = 长整数 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ piv::toml::GetAs<int64_t>(@<欲操作本对象>, @<键名>)
    }

    方法 取小数值 <公开 静态 类型 = 小数 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ piv::toml::GetAs<double>(@<欲操作本对象>, @<键名>)
    }

    方法 取逻辑值 <公开 静态 类型 = 逻辑型 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ piv::toml::GetAs<bool>(@<欲操作本对象>, @<键名>)
    }

    方法 取日期值 <公开 静态 类型 = TOML日期类 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ piv::toml::GetAs<toml::date>(@<欲操作本对象>, @<键名>)
    }

    方法 取时间值 <公开 静态 类型 = TOML时间类 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ piv::toml::GetAs<toml::time>(@<欲操作本对象>, @<键名>)
    }

    方法 取日期时间值 <公开 静态 类型 = TOML日期时间类 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ piv::toml::GetAs<toml::date_time>(@<欲操作本对象>, @<键名>)
    }
}

类 TOML数组类 <公开 基础类 = TOML节点模板 @文档 = "category = \"配置文件.TOML\"" @别名 = "toml::array" @别名类型 = 本地类
        @模板实现类 = "TOML数组类">
{
    方法 创建空数组 <公开 静态 类型 = TOML数组类 折叠 @嵌入式方法 = "">
    {
        @ toml::array{}
    }

    方法 创建数组 <公开 静态 类型 = TOML数组类 折叠 @嵌入式方法 = "">
    参数 成员值 <@可扩展 = "" @匹配类型 = 通用型>
    {
        @ toml::array{@<成员值>}
    }

    # ---
    #
    #
}

类 TOML节点指针 <公开 基础类 = PIV参考指针模板 @文档 = "category = \"配置文件.TOML\"" @模板实现类 = "TOML节点类">

类 TOML日期类 <公开 基础类 = PIV本地类模板 注释 = "日期时间中的日期部分,表示一整天,不涉及时区偏移" @文档 = "category = \"配置文件.TOML.辅助类\""
        @别名 = "toml::date" @别名类型 = 本地类 @模板实现类 = "TOML日期类" @强制依赖 = "TOML键值表">
{

    # 全局方法

    方法 创建 <公开 静态 类型 = TOML日期类 折叠 @嵌入式方法 = "">
    参数 年 <@匹配类型 = 通用整数型>
    参数 月 <@匹配类型 = 通用整数型>
    参数 日 <@匹配类型 = 通用整数型>
    {
        @ toml::date(@<年>, @<月>, @<日>)
    }

    # 成员方法

    方法 置日期 <公开 静态 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML日期类>
    参数 年 <@匹配类型 = 通用整数型>
    参数 月 <@匹配类型 = 通用整数型>
    参数 日 <@匹配类型 = 通用整数型>
    {
        @ @<欲操作本对象> = std::move(toml::date(@<年>, @<月>, @<日>))
    }

    方法 年 <公开 静态 属性读 类型 = 短整数 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象>.year
    }

    方法 月 <公开 静态 属性读 类型 = 字节 注释 = "1 - 12" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象>.month
    }

    方法 日 <公开 静态 属性读 类型 = 字节 注释 = "1 - 31" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象>.day
    }

    方法 置火山时间 <公开 静态 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML日期类>
    参数 日期时间值 <类型 = 小数>
    {
        @ SYSTEMTIME SystemTime{0};
        @ if (::VariantTimeToSystemTime(@<日期时间值>, &SystemTime))
        @     @<欲操作本对象> = std::move(toml::date(SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay));
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 置时间戳 <公开 静态 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML日期类>
    参数 秒时间戳 <类型 = 长整数>
    {
        @ struct tm timeinfo;
        @ if (localtime_s(&timeinfo, &@<秒时间戳>) == 0)
        @ {
        @     @<欲操作本对象> =  std::move(toml::date(timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday));
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 到火山时间 <公开 静态 类型 = 小数 折叠>
    参数 欲操作本对象 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    {
        返回 (欲操作本对象.到时间戳 () / 86400.0 + 25569.0)
    }

    方法 到时间戳 <公开 静态 类型 = 长整数 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    {
        @ struct tm timeinfo{0, 0, 0, @<欲操作本对象>.day, @<欲操作本对象>.month - 1, @<欲操作本对象>.year - 1900, 0, 0, 0};
        @ return static_cast<int64_t>(::mktime(&timeinfo));
    }

    方法 到文本 <公开 静态 类型 = 文本型 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    {
        @ std::stringstream ss;
        @ ss << @<欲操作本对象>;
        @ return @an<CVolString>(ss.str().c_str());
    }

    方法 到标准文本 <公开 静态 类型 = 标准文本类U 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    {
        @ std::stringstream ss;
        @ ss << @<欲操作本对象>;
        @ return std::string{ss.str()};
    }

    # 比较

    方法 是否相等 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    参数 所欲比较对象 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象> == @<所欲比较对象>
    }

    方法 是否大于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    参数 所欲比较对象 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象> > @<所欲比较对象>
    }

    方法 是否大于等于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    参数 所欲比较对象 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象> >= @<所欲比较对象>
    }

    方法 是否小于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    参数 所欲比较对象 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象> < @<所欲比较对象>
    }

    方法 是否小于等于 <公开 静态 类型 = 逻辑型 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    参数 所欲比较对象 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象> <= @<所欲比较对象>
    }
}

类 TOML时间类 <公开 基础类 = PIV本地类模板 注释 = "只能表示某一天之中的时间点,与任何特定的日期无关、亦不涉及时区偏移." 折叠
        @文档 = "category = \"配置文件.TOML.辅助类\"" @别名 = "toml::time" @别名类型 = 本地类 @模板实现类 = "TOML时间类"
        @强制依赖 = "TOML键值表">
{

    # 全局方法

    方法 创建 <公开 静态 类型 = TOML时间类 折叠 @嵌入式方法 = "">
    参数 时 <@匹配类型 = 通用整数型>
    参数 分 <@匹配类型 = 通用整数型>
    参数 秒 <@匹配类型 = 通用整数型>
    参数 纳秒 <@匹配类型 = 通用整数型 @默认值 = 0>
    {
        @ toml::time(@<时>, @<分>, @<秒>, @<纳秒>)
    }

    # 成员方法

    方法 置时间 <公开 静态 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML时间类>
    参数 时 <@匹配类型 = 通用整数型>
    参数 分 <@匹配类型 = 通用整数型>
    参数 秒 <@匹配类型 = 通用整数型>
    参数 纳秒 <@匹配类型 = 通用整数型 @默认值 = 0>
    {
        @ @<欲操作本对象> = std::move(toml::time(@<时>, @<分>, @<秒>, @<纳秒>))
    }

    方法 时 <公开 静态 属性读 类型 = 字节 注释 = "0-23" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML时间类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象>.hour
    }

    方法 分 <公开 静态 属性读 类型 = 字节 注释 = "0-59" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML时间类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象>.minute
    }

    方法 秒 <公开 静态 属性读 类型 = 字节 注释 = "0-59" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML时间类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象>.second
    }

    方法 纳秒 <公开 静态 属性读 类型 = 整数 返回值注释 = "0-1000000000" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML时间类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象>.nanosecond
    }

    方法 置火山时间 <公开 静态 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML时间类>
    参数 日期时间值 <类型 = 小数>
    {
        @ SYSTEMTIME SystemTime{};
        @ if (::VariantTimeToSystemTime(vtime, &SystemTime))
        @ {
        @     @<欲操作本对象> = std::move(toml::time(SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, SystemTime.wMilliseconds * 1000000));
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 置时间戳 <公开 静态 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML时间类>
    参数 秒时间戳 <类型 = 长整数>
    {
        @ struct tm timeinfo;
        @ if (localtime_s(&timeinfo, &@<秒时间戳>) == 0)
        @ {
        @     @<欲操作本对象> = std::move(toml::time(timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec, 0));
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 置毫秒时间戳 <公开 静态 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML时间类>
    参数 毫秒时间戳 <类型 = 长整数>
    {
        @ struct tm timeinfo;
        @ time_t timestamp = @<毫秒时间戳> / 1000;
        @ if (localtime_s(&timeinfo, &timestamp) == 0)
        @ {
        @     @<欲操作本对象> = std::move(toml::time(timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec, (@<毫秒时间戳> % 1000) * 1000000));
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 到文本 <公开 静态 类型 = 文本型 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML时间类 @视窗.前缀文本 = "const ">
    {
        @ std::stringstream ss;
        @ ss << @<欲操作本对象>;
        @ return @an<CVolString>(ss.str().c_str());
    }

    方法 到标准文本 <公开 静态 类型 = 标准文本类U 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML时间类 @视窗.前缀文本 = "const ">
    {
        @ std::stringstream ss;
        @ ss << @<欲操作本对象>;
        @ return std::string{ss.str()}
    }

    # 比较

    方法 是否相等 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML时间类 @视窗.前缀文本 = "const ">
    参数 所欲比较对象 <类型 = TOML时间类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象> == @<所欲比较对象>
    }

    方法 是否大于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML时间类 @视窗.前缀文本 = "const ">
    参数 所欲比较对象 <类型 = TOML时间类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象> > @<所欲比较对象>
    }

    方法 是否大于等于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML时间类 @视窗.前缀文本 = "const ">
    参数 所欲比较对象 <类型 = TOML时间类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象> >= @<所欲比较对象>
    }

    方法 是否小于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML时间类 @视窗.前缀文本 = "const ">
    参数 所欲比较对象 <类型 = TOML时间类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象> < @<所欲比较对象>
    }

    方法 是否小于等于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML时间类 @视窗.前缀文本 = "const ">
    参数 所欲比较对象 <类型 = TOML时间类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象> <= @<所欲比较对象>
    }
}

类 TOML日期时间类 <公开 基础类 = PIV本地类模板 注释 = "完整的日期时间,可以指定或省略时区偏移量" 折叠 @文档 = "category = \"配置文件.TOML.辅助类\""
        @别名 = "toml::date_time" @别名类型 = 本地类 @模板实现类 = "TOML日期时间类" @强制依赖 = "TOML键值表">
{

    # 全局方法

    方法 创建 <公开 静态 类型 = TOML日期时间类 折叠 @禁止流程检查 = 真>
    参数 日期 <类型 = TOML日期类 @视窗.前缀文本 = "const ">
    参数 时间 <类型 = TOML时间类 @视窗.前缀文本 = "const ">
    参数 时区偏移 <类型 = 整数 注释 = "单位为分钟" @默认值 = 0>
    {
        @ if (@<时区偏移> == 0)
        @     return toml::date_time(@<日期>, @<时间>);
        @ else
        @     return toml::date_time(@<日期>, @<时间>, toml::time_offset(@<时区偏移> / 60, @<时区偏移> % 60));
    }

    # 成员方法

    方法 置日期时间 <公开 静态 折叠>
    参数 欲操作本对象 <类型 = TOML日期时间类>
    参数 日期 <类型 = TOML日期类>
    参数 时间 <类型 = TOML时间类>
    参数 时区偏移 <类型 = 整数 注释 = "单位为分钟" @默认值 = 0>
    {
        @ if (@<时区偏移> == 0)
        @     @<欲操作本对象> = std::move(toml::date_time(@<日期>, @<时间>));
        @ else
        @     @<欲操作本对象> = std::move(toml::date_time(@<日期>, @<时间>, toml::time_offset(@<时区偏移> / 60, @<时区偏移> % 60)));
    }

    方法 取日期部分 <公开 静态 类型 = TOML日期类 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 欲操作本对象 <类型 = TOML日期时间类>
    {
        @ @<欲操作本对象>.date
    }

    方法 取时间部分 <公开 静态 类型 = TOML时间类 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 欲操作本对象 <类型 = TOML日期时间类>
    {
        @ @<欲操作本对象>.time
    }

    方法 是否为本地 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML日期时间类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象>.is_local()
    }

    方法 置火山时间 <公开 静态 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML日期时间类>
    参数 日期时间值 <类型 = 小数>
    {
        @ SYSTEMTIME SystemTime{};
        @ if (::VariantTimeToSystemTime(@<日期时间值>, &SystemTime))
        @ {
        @     TIME_ZONE_INFORMATION tz{0};
        @     ::GetTimeZoneInformation(&tz);
        @     @<欲操作本对象> = std::move(toml::date_time(
        @         toml::date(SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay),
        @         toml::time(SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, SystemTime.wMilliseconds * 1000000),
        @         toml::time_offset(-tz.Bias / 60, -tz.Bias % 60)));
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 置时间戳 <公开 静态 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML日期时间类>
    参数 秒时间戳 <类型 = 长整数>
    {
        @ struct tm timeinfo;
        @ if (localtime_s(&timeinfo, &@<秒时间戳>) == 0)
        @ {
        @     TIME_ZONE_INFORMATION tz{0};
        @     ::GetTimeZoneInformation(&tz);
        @     @<欲操作本对象> = std::move(toml::date_time(
        @         toml::date(timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday),
        @         toml::time(timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec, 0),
        @         toml::time_offset(-tz.Bias / 60, -tz.Bias % 60)));
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 置毫秒时间戳 <公开 静态 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML日期时间类>
    参数 毫秒时间戳 <类型 = 长整数>
    {
        @ struct tm timeinfo;
        @ time_t timestamp = @<毫秒时间戳> / 1000;
        @ if (localtime_s(&timeinfo, &timestamp) == 0)
        @ {
        @     TIME_ZONE_INFORMATION tz{0};
        @     ::GetTimeZoneInformation(&tz);
        @     @<欲操作本对象> = std::move(toml::date_time(
        @         toml::date(timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday),
        @         toml::time(timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec, (@<毫秒时间戳> % 1000) * 1000000),
        @         toml::time_offset(-tz.Bias / 60, -tz.Bias % 60)));
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 到火山时间 <公开 静态 类型 = 小数 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML日期时间类 @视窗.前缀文本 = "const ">
    {
        变量 毫秒时间戳 <类型 = 长整数>
        毫秒时间戳 = 欲操作本对象.到毫秒时间戳 ()
        @ TIME_ZONE_INFORMATION tz{0};
        @ ::GetTimeZoneInformation(&tz);
        @ return (@<毫秒时间戳> - tz.Bias * 1000 * 60) / (1000.0 * 60.0 * 60.0 * 24.0) + 25569;
    }

    方法 到时间戳 <公开 静态 类型 = 长整数 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML日期时间类 @视窗.前缀文本 = "const ">
    {
        @ struct tm timeinfo {
        @     @<欲操作本对象>.time.second, @<欲操作本对象>.time.minute, @<欲操作本对象>.time.hour, @<欲操作本对象>.date.day,
        @     @<欲操作本对象>.date.month - 1, @<欲操作本对象>.date.year - 1900, 0, 0, 0
        @ };
        @ return static_cast<int64_t>(::mktime(&timeinfo));
    }

    方法 到毫秒时间戳 <公开 静态 类型 = 长整数 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML日期时间类 @视窗.前缀文本 = "const ">
    {
        @ struct tm timeinfo {
        @     @<欲操作本对象>.time.second, @<欲操作本对象>.time.minute, @<欲操作本对象>.time.hour, @<欲操作本对象>.date.day,
        @     @<欲操作本对象>.date.month - 1, @<欲操作本对象>.date.year - 1900, 0, 0, 0
        @ };
        @ return static_cast<int64_t>(::mktime(&timeinfo)) * 1000 + @<欲操作本对象>.time.nanosecond / 1000000;
    }

    方法 到文本 <公开 静态 类型 = 文本型 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML日期时间类 @视窗.前缀文本 = "const ">
    {
        @ std::stringstream ss;
        @ ss << @<欲操作本对象>;
        @ return @an<CVolString>(ss.str().c_str());
    }

    方法 到标准文本 <公开 静态 类型 = 标准文本类U 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = TOML日期时间类 @视窗.前缀文本 = "const ">
    {
        @ std::stringstream ss;
        @ ss << @<欲操作本对象>;
        @ return std::string{ss.str()}
    }

    # 比较

    方法 是否相等 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML日期时间类 @视窗.前缀文本 = "const ">
    参数 所欲比较对象 <类型 = TOML日期时间类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象> == @<所欲比较对象>
    }

    方法 是否大于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML日期时间类 @视窗.前缀文本 = "const ">
    参数 所欲比较对象 <类型 = TOML日期时间类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象> > @<所欲比较对象>
    }

    方法 是否大于等于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML日期时间类 @视窗.前缀文本 = "const ">
    参数 所欲比较对象 <类型 = TOML日期时间类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象> >= @<所欲比较对象>
    }

    方法 是否小于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML日期时间类 @视窗.前缀文本 = "const ">
    参数 所欲比较对象 <类型 = TOML日期时间类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象> < @<所欲比较对象>
    }

    方法 是否小于等于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = TOML日期时间类 @视窗.前缀文本 = "const ">
    参数 所欲比较对象 <类型 = TOML日期时间类 @视窗.前缀文本 = "const ">
    {
        @ @<欲操作本对象> <= @<所欲比较对象>
    }
}

类 TOML节点类型 <公开 折叠 @文档 = "category = \"配置文件.TOML.辅助类\"" @常量类 = 字节>
{
    常量 未知 <公开 值 = @"@(S_BYTE)toml::node_type::none" 注释 = "不是一个TOML节点">
    常量 键值表 <公开 值 = @"@(S_BYTE)toml::node_type::table" 注释 = "键值表(也被称为哈希表或字典)是键值对的集合">
    常量 数组 <公开 值 = @"@(S_BYTE)toml::node_type::array" 注释 = "toml::array">
    常量 字符串 <公开 值 = @"@(S_BYTE)toml::node_type::string" 注释 = "共有四种方式来表示字符串：基本字符串、多行基本字符串、字面量和多行字面量."
            注释 = "所有字符串都只能包含有效的UTF-8字符.">
    常量 整型 <公开 值 = @"@(S_BYTE)toml::node_type::integer" 注释 = "有符号整型数,最大8字节,负数的前缀是减号.">
    常量 浮点数 <公开 值 = @"@(S_BYTE)toml::node_type::floating_point" 注释 = "双精度浮点数(8字节)">
    常量 布尔值 <公开 值 = @"@(S_BYTE)toml::node_type::boolean" 注释 = "逻辑布尔值(1字节),必须是小写的true或false">
    常量 日期 <公开 值 = @"@(S_BYTE)toml::node_type::date" 注释 = "日期时间中的日期部分,表示一整天,不涉及时区偏移">
    常量 时间 <公开 值 = @"@(S_BYTE)toml::node_type::time" 注释 = "日期时间中的时间部分,只表示一天之中的那个时间,与任何特定的日期无关、亦不涉及时区偏移.">
    常量 日期时间 <公开 值 = @"@(S_BYTE)toml::node_type::date_time" 注释 = "完整的日期时间,可以指定或省略时区偏移量">
}

#
