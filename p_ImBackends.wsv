<火山程序 类型 = "通常" 版本 = 1 />

包 火山.ImGui <注释 = "例程下载: https://saier.lanzoul.com/b016cwvle"
        注释 = "GLFW     3.4.0      https://www.glfw.org" 注释 = "SDL2     2.32.8     https://www.libsdl.org"
        注释 = "SDL3     3.2.16     https://www.libsdl.org"
        注释 = "Vulkan   1.3.246.1  https://vulkan.lunarg.com/sdk/home"
        注释 = "glad     2023-04-04 https://github.com/Dav1dde/glad" @视窗.头文件搜寻目录 = "FrameWork"
        @视窗.外部头文件 = "stb/piv_image.h" @视窗.外部源文件 = "stb\\piv_image.cpp">

# 平台后端

类 IM_Win32平台 <公开 注释 = "基于Windows API的平台后端" 折叠 折叠2 @文档 = "category = \"平台后端\""
        @视窗.外部头文件 = "<backends/imgui_impl_win32.h>" @视窗.外部源文件 = "imgui\\backends\\imgui_impl_win32.cpp">
{
    方法 初始化 <公开 静态 类型 = 逻辑型 注释 = "初始化链接到DirectX渲染器" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <注释 = "提供Win32 API的窗口句柄(HWND)" @匹配类型 = 通用整数型>
    {
        @ ImGui_ImplWin32_Init(reinterpret_cast<void*>(@<窗口句柄>))
    }

    方法 初始化_OpenGL <公开 静态 类型 = 逻辑型 注释 = "初始化链接到OpenGL渲染器" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 注释 = "提供Win32 API的窗口句柄(HWND)">
    {
        @ ImGui_ImplWin32_InitForOpenGL(reinterpret_cast<void*>(@<窗口句柄>))
    }

    方法 关闭 <公开 静态 注释 = "关闭Win32框架" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplWin32_Shutdown()
    }

    方法 新建帧 <公开 静态 注释 = "新建Win32帧" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplWin32_NewFrame()
    }

    方法 消息处理 <公开 静态 类型 = 逻辑型 注释 = "让ImGui处理Windows窗口中的部分消息" 返回值注释 = "返回真表示允许消息继续向后传递并处理,返回假表示取消掉该消息的后续处理."
            折叠 @嵌入式方法 = "">
    参数 窗口句柄 <注释 = "提供消息所对应的窗口句柄(HWND)" @匹配类型 = 通用整数型>
    参数 消息值 <注释 = "提供消息的具体值" @匹配类型 = 通用整数型>
    参数 消息参数1 <注释 = "提供消息所附带的参数1的值" @匹配类型 = 通用整数型>
    参数 消息参数2 <注释 = "提供消息所附带的参数2的值" @匹配类型 = 通用整数型>
    {
        @ ImGui_ImplWin32_WndProcHandler(reinterpret_cast<HWND>(@<窗口句柄>), static_cast<UINT>(@<消息值>), static_cast<WPARAM>(@<消息参数1>), static_cast<LPARAM>(@<消息参数2>)) > 0
    }

    方法 关注DPI <公开 静态 注释 = "设置本程序是否关注系统默认显示器的DPI(缩放比例)" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplWin32_EnableDpiAwareness()
    }

    方法 取窗口DPI <公开 静态 类型 = 单精度小数 注释 = "返回指定窗口的DPI比例值(相对基准96 DPI)" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <注释 = "提供Win32 API的窗口句柄(HWND)" @匹配类型 = 通用整数型>
    {
        @ ImGui_ImplWin32_GetDpiScaleForHwnd(reinterpret_cast<HWND>(@<窗口句柄>))
    }

    方法 取显示器DPI <公开 静态 类型 = 单精度小数 注释 = "返回指定显示器的DPI比例值(相对基准96 DPI)" 折叠 @嵌入式方法 = "">
    参数 显示器句柄 <注释 = "提供Win32 API的显示器句柄(HMONITOR)" @匹配类型 = 通用整数型>
    {
        @ ImGui_ImplWin32_GetDpiScaleForHwnd(reinterpret_cast<HMONITOR>(@<显示器句柄>))
    }

    方法 启用透明度合成 <公开 静态 注释 = "启用桌面的alpha合成透明度,必须在窗口被创建和被显示之前使用才有效." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <注释 = "提供Win32 API的窗口句柄(HWND)" @匹配类型 = 通用整数型>
    {
        @ ImGui_ImplWin32_EnableAlphaCompositing(reinterpret_cast<HWND>(@<窗口句柄>))
    }

    # @begin
    # <> <global>
    # <> <include>
    # extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
    # <> </include>
    # <> </global>
    # @end
}

类 IM_GLFW平台 <公开 注释 = "基于GLFW的平台后端,GLFW是一个OpenGL应用框架." 折叠 折叠2 @文档 = "category = \"平台后端\""
        @视窗.头文件搜寻目录 = "FrameWork\\glfw\\include" @视窗.外部头文件 = "FrameWork/glfw/piv_glfw.h"
        @视窗.外部源文件 = "imgui\\backends\\imgui_impl_glfw.cpp"
        "@视窗.外部库.mt-non_dynamic" = "FrameWork\\glfw\\$(p)\\$(vs)\\glfw3_mt.lib"
        "@视窗.外部库.md-non_dynamic" = "FrameWork\\glfw\\$(p)\\$(vs)\\glfw3.lib"
        @视窗.外部库.dynamic = "FrameWork\\glfw\\$(p)\\$(vs)\\glfw3dll.lib"
        @视窗.附属文件.dynamic = "FrameWork\\glfw\\$(p)\\$(vs)\\glfw3.dll" @视窗.需求VS版本 = "15-">
{
    方法 初始化_OpenGL <公开 静态 类型 = 逻辑型 注释 = "初始化链接到OpenGL渲染器" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 窗口句柄 <注释 = "提供GLFW的窗口句柄,注意不支持Win32 API的窗口句柄." @匹配类型 = 通用整数型>
    参数 安装回调 <类型 = 逻辑型 注释 = "是否将GLFW的部分输入输出回调安装到ImGui中">
    {
        @ ImGui_ImplGlfw_InitForOpenGL(reinterpret_cast<GLFWwindow*>(@<窗口句柄>), @<安装回调>)
    }

    方法 初始化_Vulkan <公开 静态 类型 = 逻辑型 注释 = "初始化链接到Vulkan渲染器" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 窗口句柄 <注释 = "提供GLFW的窗口句柄,注意不支持Win32 API的窗口句柄." @匹配类型 = 通用整数型>
    参数 安装回调 <类型 = 逻辑型 注释 = "是否将GLFW的部分输入输出回调安装到ImGui中">
    {
        @ ImGui_ImplGlfw_InitForVulkan(reinterpret_cast<GLFWwindow*>(@<窗口句柄>), @<安装回调>)
    }

    方法 初始化_其他 <公开 静态 类型 = 逻辑型 注释 = "初始化链接到未知渲染器(本方法不可用)" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 窗口句柄 <注释 = "提供GLFW的窗口句柄,注意不支持Win32 API的窗口句柄." @匹配类型 = 通用整数型>
    参数 安装回调 <类型 = 逻辑型 注释 = "是否将GLFW的部分输入输出回调安装到ImGui中">
    {
        @ ImGui_ImplGlfw_InitForOther(reinterpret_cast<GLFWwindow*>(@<窗口句柄>), @<安装回调>)
    }

    方法 关闭 <公开 静态 注释 = "关闭GLFW框架" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplGlfw_Shutdown()
    }

    方法 新建帧 <公开 静态 注释 = "新建GLFW帧" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplGlfw_NewFrame()
    }

    方法 安装回调 <公开 静态 注释 = "将指定GLFW窗口的部分输入输出回调安装到ImGui中." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <注释 = "提供GLFW的窗口句柄,注意不支持Win32 API的窗口句柄." @匹配类型 = 通用整数型>
    {
        @ ImGui_ImplGlfw_InstallCallbacks(reinterpret_cast<GLFWwindow*>(@<窗口句柄>))
    }

    方法 还原回调 <公开 静态 注释 = "将指定GLFW窗口的部分输入输出回调函数,还原为ImGui接管前的设置." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <注释 = "提供GLFW的窗口句柄,注意不支持Win32 API的窗口句柄." @匹配类型 = 通用整数型>
    {
        @ ImGui_ImplGlfw_InstallCallbacks(reinterpret_cast<GLFWwindow*>(@<窗口句柄>))
    }

    方法 置链接所有窗口 <公开 静态 注释 = "在所有窗口(包括后台和用户创建的辅助视口)启用链接回调." 折叠 @嵌入式方法 = "">
    参数 链接所有窗口 <类型 = 逻辑型 注释 = "是否将回调链接到所有窗口">
    {
        @ ImGui_ImplGlfw_SetCallbacksChainForAllWindows(static_cast<bool>(@<链接所有窗口>))
    }
}

类 IM_SDL2平台 <公开 注释 = "基于SDL2(Simple DirectMedia Layer)的平台后端" 折叠 折叠2 @文档 = "category = \"平台后端\""
        @视窗.头文件搜寻目录 = "FrameWork\\SDL2\\include"
        @视窗.外部头文件 = "<SDL.h>\r\n<SDL_syswm.h>\r\n<backends/imgui_impl_sdl2.h>"
        @视窗.外部源文件 = "imgui\\backends\\imgui_impl_sdl2.cpp"
        @视窗.外部库 = "FrameWork\\SDL2\\$(p)\\SDL2.lib\r\nFrameWork\\SDL2\\$(p)\\SDL2main.lib"
        @视窗.附属文件 = "FrameWork\\SDL2\\$(p)\\SDL2.dll">
{
    方法 初始化_OpenGL <公开 静态 类型 = 逻辑型 注释 = "初始化链接到OpenGL渲染器" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <@匹配类型 = 通用整数型>
    参数 SDL环境 <@匹配类型 = 通用整数型>
    {
        @ ImGui_ImplSDL2_InitForOpenGL(reinterpret_cast<SDL_Window*>(@<窗口句柄>), reinterpret_cast<void*>(@<SDL环境>))
    }

    方法 初始化_D3D <公开 静态 类型 = 逻辑型 注释 = "初始化链接到DirectX渲染器" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <@匹配类型 = 通用整数型>
    {
        @ ImGui_ImplSDL2_InitForD3D(reinterpret_cast<SDL_Window*>(@<窗口句柄>))
    }

    方法 初始化_Vulkan <公开 静态 类型 = 逻辑型 注释 = "初始化链接到Vulkan渲染器" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <@匹配类型 = 通用整数型>
    {
        @ ImGui_ImplSDL2_InitForVulkan(reinterpret_cast<SDL_Window*>(@<窗口句柄>))
    }

    方法 关闭 <公开 静态 注释 = "关闭SDL2框架" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplSDL2_Shutdown()
    }

    方法 新建帧 <公开 静态 注释 = "新建SDL2帧" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplSDL2_NewFrame()
    }

    方法 处理事件 <公开 静态 类型 = 逻辑型 注释 = "让ImGui处理SDL2的部分输入输出事件" 折叠 @嵌入式方法 = "">
    参数 事件指针 <@匹配类型 = 通用整数型>
    {
        @ ImGui_ImplSDL2_ProcessEvent(reinterpret_cast<const SDL_Event*>(@<事件指针>))
    }
}

类 IM_SDL3平台 <公开 注释 = "基于SDL3(Simple DirectMedia Layer)的平台后端" 折叠 折叠2 @文档 = "category = \"平台后端\""
        @视窗.头文件搜寻目录 = "FrameWork\\SDL3\\include" @视窗.外部头文件 = "<SDL3/SDL.h>\r\n<backends/imgui_impl_sdl3.h>"
        @视窗.外部源文件 = "imgui\\backends\\imgui_impl_sdl3.cpp" @视窗.外部库 = "FrameWork\\SDL3\\$(p)\\SDL3.lib"
        @视窗.附属文件 = "FrameWork\\SDL3\\$(p)\\SDL3.dll">
{
    方法 初始化_OpenGL <公开 静态 类型 = 逻辑型 注释 = "初始化链接到OpenGL渲染器" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <@匹配类型 = 通用整数型>
    参数 SDL环境 <@匹配类型 = 通用整数型>
    {
        @ ImGui_ImplSDL3_InitForOpenGL(reinterpret_cast<SDL_Window*>(@<窗口句柄>), reinterpret_cast<void*>(@<SDL环境>))
    }

    方法 初始化_D3D <公开 静态 类型 = 逻辑型 注释 = "初始化链接到DirectX渲染器" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <@匹配类型 = 通用整数型>
    {
        @ ImGui_ImplSDL3_InitForD3D(reinterpret_cast<SDL_Window*>(@<窗口句柄>))
    }

    方法 初始化_Vulkan <公开 静态 类型 = 逻辑型 注释 = "初始化链接到Vulkan渲染器" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <@匹配类型 = 通用整数型>
    {
        @ ImGui_ImplSDL3_InitForVulkan(reinterpret_cast<SDL_Window*>(@<窗口句柄>))
    }

    方法 初始化_SDLGPU <公开 静态 类型 = 逻辑型 注释 = "初始化链接到SDL GPU渲染器" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <@匹配类型 = 通用整数型>
    {
        @ ImGui_ImplSDL3_InitForSDLGPU(reinterpret_cast<SDL_Window*>(@<窗口句柄>))
    }

    方法 关闭 <公开 静态 注释 = "关闭SDL2框架" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplSDL3_Shutdown()
    }

    方法 新建帧 <公开 静态 注释 = "新建SDL2帧" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplSDL3_NewFrame()
    }

    方法 处理事件 <公开 静态 类型 = 逻辑型 注释 = "让ImGui处理SDL3的部分输入输出事件" 折叠 @嵌入式方法 = "">
    参数 事件指针 <@匹配类型 = 通用整数型>
    {
        @ ImGui_ImplSDL3_ProcessEvent(reinterpret_cast<const SDL_Event*>(@<事件指针>))
    }
}

# 渲染器

类 IM_DX9渲染器 <公开 注释 = "基于DirectX9的渲染器后端,兼容Windows XP以上系统." 折叠 折叠2 @文档 = "category = \"渲染器\""
        @视窗.外部头文件 = "<d3d9.h>\r\n<backends/imgui_impl_dx9.h>"
        @视窗.外部源文件 = "imgui\\backends\\imgui_impl_dx9.cpp" @视窗.外部库 = "d3d9.lib">
{
    变量 垂直同步 <公开 类型 = 逻辑型 值 = 真 注释 = "必须在\"创建设备\"之前设置,后续更改无效." @输出名 = "m_vsync">
    变量 窗口宽度 <公开 类型 = 整数 值 = 0 @输出名 = "m_Width">
    变量 窗口高度 <公开 类型 = 整数 值 = 0 @输出名 = "m_Height">
    变量 _已创建 <类型 = 逻辑型 值 = 假>

    方法 渲染器类型 <公开 属性读 类型 = 整数 注释 = "返回渲染器类型(固定返回9)" 折叠>
    {
        返回 (9)
    }

    方法 渲染器名称 <公开 属性读 类型 = 文本型 折叠>
    {
        返回 ("DirectX 9")
    }

    方法 允许修改帧率 <公开 属性读 类型 = 逻辑型 折叠>
    {
        返回 (取反 (_已创建))
    }

    方法 初始化 <公开 类型 = 逻辑型 注释 = "在\"创建设备\"和\"ImGui.创建环境()\"后才能调用." 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX9_Init(@sn<this>.m_pd3dDevice)
    }

    方法 关闭 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX9_Shutdown()
    }

    方法 新建帧 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX9_NewFrame()
    }

    方法 渲染数据 <公开 折叠 @嵌入式方法 = "">
    参数 绘制数据 <类型 = IM绘制数据指针 注释 = "由\"ImGui.取渲染数据()\"返回">
    {
        @ ImGui_ImplDX9_RenderDrawData(@<绘制数据>)
    }

    方法 创建设备对象 <公开 注释 = "用于在不丢失ImGui状态的情况下重置渲染设备" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX9_CreateDeviceObjects()
    }

    方法 销毁设备对象 <公开 注释 = "用于在不丢失ImGui状态的情况下重置渲染设备" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX9_InvalidateDeviceObjects()
    }

    # 纹理图片 ---

    方法 加载图片文件 <公开 类型 = 逻辑型 注释 = "从指定的图片文件加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 折叠2 @禁止流程检查 = 真
            @视窗.外部头文件 = "FrameWork\\d3dx9\\include\\d3dx9tex.h"
            @视窗.外部库.debug = "FrameWork\\d3dx9\\Lib\\$(p)\\d3dx9d.lib"
            @视窗.外部库.release = "FrameWork\\d3dx9\\Lib\\$(p)\\d3dx9.lib"
            "//@视窗.需求系统头文件" = "D3dx9tex.h|需要安装 DirectX SDK 9 https://www.microsoft.com/zh-CN/download/details.aspx?id=6812 并在安装后添加头文件搜寻目录和库文件搜寻目录">
    参数 文件名 <类型 = 文本型 注释 = "支持格式: .bmp、.dds、.dib、.hdr、.jpg、.pfm、.png、.ppm 和 .tga">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ PDIRECT3DTEXTURE9 texture;
        @ HRESULT hr = D3DXCreateTextureFromFileW(m_pd3dDevice, @<文件名>.GetText(), &texture);
        @ if (hr != S_OK) return FALSE;
        @ D3DSURFACE_DESC my_image_desc;
        @ texture->GetLevelDesc(0, &my_image_desc);
        @ @<图片信息.纹理ID> = reinterpret_cast<UINT64>(texture);
        @ @<图片信息.宽度> = static_cast<int>(my_image_desc.Width);
        @ @<图片信息.高度> = static_cast<int>(my_image_desc.Height);
        @ return TRUE;
    }

    方法 加载图片资源 <公开 类型 = 逻辑型 注释 = "将程序文件中的图片资源加载到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 折叠2
            @禁止流程检查 = 真 @视窗.外部头文件 = "FrameWork\\d3dx9\\include\\d3dx9tex.h"
            @视窗.外部库.debug = "FrameWork\\d3dx9\\Lib\\$(p)\\d3dx9d.lib"
            @视窗.外部库.release = "FrameWork\\d3dx9\\Lib\\$(p)\\d3dx9.lib">
    参数 图片资源 <类型 = 视窗文件资源 注释 = "支持格式: 支持格式: .bmp、.dds、.dib、.hdr、.jpg、.pfm、.png、.ppm 和 .tga">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ PDIRECT3DTEXTURE9 texture;
        @ HRESULT hr = D3DXCreateTextureFromResourceW(m_pd3dDevice, g_objVolApp.GetInstanceHandle(), MAKEINTRESOURCE(@<图片资源>), &texture);
        @ if (hr != S_OK) return FALSE;
        @ D3DSURFACE_DESC my_image_desc;
        @ texture->GetLevelDesc(0, &my_image_desc);
        @ @<图片信息.纹理ID> = reinterpret_cast<UINT64>(texture);
        @ @<图片信息.宽度> = static_cast<int>(my_image_desc.Width);
        @ @<图片信息.高度> = static_cast<int>(my_image_desc.Height);
        @ return TRUE;
    }

    方法 加载图片字节集 <公开 类型 = 逻辑型 注释 = "从指定的图片字节集加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 折叠2
            @禁止流程检查 = 真 @视窗.外部头文件 = "FrameWork\\d3dx9\\include\\d3dx9tex.h"
            @视窗.外部库.debug = "FrameWork\\d3dx9\\Lib\\$(p)\\d3dx9d.lib"
            @视窗.外部库.release = "FrameWork\\d3dx9\\Lib\\$(p)\\d3dx9.lib">
    参数 图片数据 <类型 = 字节集类 注释 = "支持格式: 支持格式: .bmp、.dds、.dib、.hdr、.jpg、.pfm、.png、.ppm 和 .tga">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ PDIRECT3DTEXTURE9 texture;
        @ HRESULT hr = D3DXCreateTextureFromFileInMemory(m_pd3dDevice, @<图片数据>.GetPtr(), static_cast<UINT>(@<图片数据>.GetSize()), &texture);
        @ if (hr != S_OK) return FALSE;
        @ D3DSURFACE_DESC my_image_desc;
        @ texture->GetLevelDesc(0, &my_image_desc);
        @ @<图片信息.纹理ID> = reinterpret_cast<UINT64>(texture);
        @ @<图片信息.宽度> = static_cast<int>(my_image_desc.Width);
        @ @<图片信息.高度> = static_cast<int>(my_image_desc.Height);
        @ return TRUE;
    }

    方法 释放纹理 <公开 注释 = "释放图片纹理和对应的内存,之后不能再使用这个纹理ID." 折叠 折叠2
            @视窗.外部头文件 = "FrameWork\\d3dx9\\include\\d3dx9tex.h"
            @视窗.外部库.debug = "FrameWork\\d3dx9\\Lib\\$(p)\\d3dx9d.lib"
            @视窗.外部库.release = "FrameWork\\d3dx9\\Lib\\$(p)\\d3dx9.lib">
    参数 图片信息 <类型 = IM图片信息类 注释 = "提供由\"本对象.加载图片××\"返回的图片信息,释放后会清空信息.">
    {
        如果 (图片信息.纹理ID != 0)
        {
            @ reinterpret_cast<PDIRECT3DTEXTURE9>(@<图片信息.纹理ID>)->Release();
        }
        图片信息.重置为空对象 ()
    }

    # Win32 ---

    方法 创建设备 <公开 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数>
    {
        @ m_hwnd = reinterpret_cast<HWND>(@<窗口句柄>);
        @ if ((m_pD3D = Direct3DCreate9(D3D_SDK_VERSION)) == nullptr)
        @     return FALSE;

        // Create the D3DDevice
        @ ZeroMemory(&m_d3dpp, sizeof(m_d3dpp));
        @ m_d3dpp.Windowed = TRUE;
        @ m_d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
        // Need to use an explicit format with alpha if needing per-pixel alpha composition.
        @ m_d3dpp.BackBufferFormat = D3DFMT_A8R8G8B8; // D3DFMT_UNKNOWN
        @ m_d3dpp.EnableAutoDepthStencil = TRUE;
        @ m_d3dpp.AutoDepthStencilFormat = D3DFMT_D16;
        @ m_d3dpp.PresentationInterval = m_vsync ? D3DPRESENT_INTERVAL_ONE : D3DPRESENT_INTERVAL_IMMEDIATE;
        @ if (m_pD3D->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, m_hwnd, D3DCREATE_HARDWARE_VERTEXPROCESSING, &m_d3dpp, &m_pd3dDevice) < 0)
        @     return FALSE;
        _已创建 = 真
        @ return TRUE;
    }

    方法 释放设备 <公开 折叠>
    {
        @ if (m_pd3dDevice) { m_pd3dDevice->Release();  m_pd3dDevice = nullptr; }
        @ if (m_pD3D) { m_pD3D->Release(); m_pD3D = nullptr; }
    }

    方法 重置尺寸 <公开 折叠>
    {

    }

    方法 渲染 <公开 折叠>
    参数 背景颜色 <类型 = ImVec4 @输出名 = "clear_color">
    {
        @ ImGui::EndFrame();
        @ m_pd3dDevice->SetRenderState(D3DRS_ZENABLE, FALSE);
        @ m_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
        @ m_pd3dDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
        @ D3DCOLOR clear_col_dx = D3DCOLOR_RGBA((int)(clear_color.x*clear_color.w*255.0f), (int)(clear_color.y*clear_color.w*255.0f), (int)(clear_color.z*clear_color.w*255.0f), (int)(clear_color.w*255.0f));
        @ m_pd3dDevice->Clear(0, nullptr, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, clear_col_dx, 1.0f, 0);
        @ if (m_pd3dDevice->BeginScene() >= 0)
        @ {
        @     ImGui::Render();
        @     ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());
        @     m_pd3dDevice->EndScene();
        @ }

        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     ImGui::UpdatePlatformWindows();
        @     ImGui::RenderPlatformWindowsDefault();
        @ }

        @ HRESULT result = m_pd3dDevice->Present(nullptr, nullptr, nullptr, nullptr);
        @ if (result == D3DERR_DEVICELOST)
        @     m_DeviceLost = true;
    }

    方法 准备 <公开>

    方法 是否不可视 <公开 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    {
        // Handle lost D3D9 device
        @ if (m_DeviceLost)
        @ {
        @     HRESULT hr = m_pd3dDevice->TestCooperativeLevel();
        @     if (hr == D3DERR_DEVICELOST)
        @     {
        @         ::Sleep(10);
        @         return true;
        @     }
        @     if (hr == D3DERR_DEVICENOTRESET)
        @         @<_ResetDevice>();
        @     m_DeviceLost = false;
        @ }
        @ return false;
    }

    方法 帧前处理 <公开 折叠>
    {
        // Handle window resize (we don't resize directly in the WM_SIZE handler)
        @ if (m_Width != 0 && m_Height != 0)
        @ {
        @     m_d3dpp.BackBufferWidth = m_Width;
        @     m_d3dpp.BackBufferHeight = m_Height;
        @     m_Width = m_Height = 0;
        @     @<_ResetDevice>();
        @ }
    }

    # SDL ---

    方法 创建设备_SDL2 <公开 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ @sn<this>.@<创建设备>(@<窗口句柄>)
    }

    方法 创建设备_SDL3 <类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ @sn<this>.@<创建设备>(@<窗口句柄>)
    }

    方法 渲染_SDL <公开 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 背景颜色 <类型 = ImVec4>
    {
        @ @sn<this>.@<渲染>(@<背景颜色>)
    }

    # ---

    方法 _ResetDevice <公开 折叠>
    {
        @ ImGui_ImplDX9_InvalidateDeviceObjects();
        @ HRESULT hr = m_pd3dDevice->Reset(&m_d3dpp);
        @ if (hr == D3DERR_INVALIDCALL)
        @     IM_ASSERT(0);
        @ ImGui_ImplDX9_CreateDeviceObjects();
    }

    # @begin
    # <> <include>
    # LPDIRECT3D9            m_pD3D = nullptr;
    # LPDIRECT3DDEVICE9      m_pd3dDevice = nullptr;
    # bool                   m_DeviceLost = false;
    # D3DPRESENT_PARAMETERS  m_d3dpp = {};
    # HWND                   m_hwnd = nullptr;
    # <> </include>
    # @end
}

类 IM_DX10渲染器 <公开 注释 = "基于DirectX10的渲染器后端,兼容Windows Vista以上系统." 折叠 折叠2 @文档 = "category = \"渲染器\""
        @视窗.外部头文件 = "<backends/imgui_impl_dx10.h>\r\n<d3d10_1.h>\r\n<d3d10.h>"
        @视窗.外部源文件 = "imgui\\backends\\imgui_impl_dx10.cpp"
        @视窗.外部库 = "d3d10.lib\r\nd3dcompiler.lib\r\ndxgi.lib">
{
    变量 垂直同步 <公开 类型 = 逻辑型 值 = 真 注释 = "可以在每次渲染时变更" @输出名 = "m_vsync">
    变量 窗口宽度 <公开 类型 = 整数 值 = 0 @输出名 = "m_Width">
    变量 窗口高度 <公开 类型 = 整数 值 = 0 @输出名 = "m_Height">

    方法 渲染器类型 <公开 属性读 类型 = 整数 注释 = "返回渲染器类型(固定返回10)" 折叠>
    {
        返回 (10)
    }

    方法 渲染器名称 <公开 属性读 类型 = 文本型 折叠>
    {
        返回 ("DirectX 10")
    }

    方法 允许修改帧率 <公开 属性读 类型 = 逻辑型 折叠>
    {
        返回 (真)
    }

    方法 初始化 <公开 类型 = 逻辑型 注释 = "在\"创建设备\"和\"ImGui.创建环境()\"后才能调用." 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX10_Init(@sn<this>.m_pd3dDevice)
    }

    方法 关闭 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX10_Shutdown()
    }

    方法 新建帧 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX10_NewFrame()
    }

    方法 渲染数据 <公开 折叠 @嵌入式方法 = "">
    参数 绘制数据 <类型 = IM绘制数据指针 注释 = "由\"ImGui.取渲染数据()\"返回">
    {
        @ ImGui_ImplDX10_RenderDrawData(@<绘制数据>)
    }

    方法 创建设备对象 <公开 注释 = "用于在不丢失ImGui状态的情况下重置渲染设备" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX10_CreateDeviceObjects()
    }

    方法 销毁设备对象 <公开 注释 = "用于在不丢失ImGui状态的情况下重置渲染设备" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX10_InvalidateDeviceObjects()
    }

    # 图片纹理 ---

    方法 加载图片文件 <公开 类型 = 逻辑型 注释 = "从指定的图片文件加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ if (!m_pd3dDevice) return FALSE;
        @ PivImage image;
        @ unsigned char* image_data = image.load(@<文件名>.GetText(), 4);
        @ if (!image_data) return FALSE;
        @ @<图片信息.宽度> = image.x;
        @ @<图片信息.高度> = image.y;
        @ @<图片信息.纹理ID> = @<_加载纹理>(image_data, image.x, image.y);
        @ return TRUE;
    }

    方法 加载图片资源 <公开 类型 = 逻辑型 注释 = "将程序文件中的图片资源加载到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片资源 <类型 = 视窗文件资源 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ HMODULE hModule = g_objVolApp.GetInstanceHandle();
        @ HRSRC hSrc = ::FindResourceW(hModule, MAKEINTRESOURCE((WORD)@<图片资源>), RT_RCDATA);
        @ if (!hSrc) return FALSE;
        @ HGLOBAL resdata = ::LoadResource(hModule, hSrc);
        @ if (!resdata) return FALSE;
        @ PivImage image;
        @ unsigned char* image_data = image.load((unsigned char*)::LockResource(resdata), static_cast<int>(::SizeofResource(hModule, hSrc)), 4);
        @ if (!image_data) return FALSE;
        @ @<图片信息.宽度> = image.x;
        @ @<图片信息.高度> = image.y;
        @ @<图片信息.纹理ID> = @<_加载纹理>(image_data, image.x, image.y);
        @ return TRUE;
    }

    方法 加载图片字节集 <公开 类型 = 逻辑型 注释 = "从指定的图片字节集加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片数据 <类型 = 字节集类 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ PivImage image;
        @ unsigned char* image_data = image.load(@<图片数据>.GetPtr(), static_cast<int>(@<图片数据>.GetSize()), 4);
        @ if (!image_data) return FALSE;
        @ @<图片信息.宽度> = image.x;
        @ @<图片信息.高度> = image.y;
        @ @<图片信息.纹理ID> = @<_加载纹理>(image_data, image.x, image.y);
        @ return TRUE;
    }

    方法 _加载纹理 <类型 = 无符号长整数 折叠 @禁止流程检查 = 真>
    参数 image_data <类型 = PIV.类型.字节集指针 @输出名 = "image_data">
    参数 image_width <类型 = 整数 @输出名 = "image_width">
    参数 image_height <类型 = 整数 @输出名 = "image_height">
    {
        // Create texture
        @ D3D10_TEXTURE2D_DESC desc;
        @ ZeroMemory(&desc, sizeof(desc));
        @ desc.Width = image_width;
        @ desc.Height = image_height;
        @ desc.MipLevels = 1;
        @ desc.ArraySize = 1;
        @ desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ desc.SampleDesc.Count = 1;
        @ desc.Usage = D3D10_USAGE_DEFAULT;
        @ desc.BindFlags = D3D10_BIND_SHADER_RESOURCE;
        @ desc.CPUAccessFlags = 0;

        @ ID3D10Texture2D *pTexture = NULL;
        @ D3D10_SUBRESOURCE_DATA subResource;
        @ subResource.pSysMem = image_data;
        @ subResource.SysMemPitch = desc.Width * 4;
        @ subResource.SysMemSlicePitch = 0;
        @ m_pd3dDevice->CreateTexture2D(&desc, &subResource, &pTexture);

        // Create texture view
        @ D3D10_SHADER_RESOURCE_VIEW_DESC srvDesc;
        @ ZeroMemory(&srvDesc, sizeof(srvDesc));
        @ srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ srvDesc.ViewDimension = D3D10_SRV_DIMENSION_TEXTURE2D;
        @ srvDesc.Texture2D.MipLevels = desc.MipLevels;
        @ srvDesc.Texture2D.MostDetailedMip = 0;
        @ ID3D10ShaderResourceView* out_srv;
        @ m_pd3dDevice->CreateShaderResourceView(pTexture, &srvDesc, &out_srv);
        @ pTexture->Release();
        @ return (UINT64)out_srv;
    }

    方法 释放纹理 <公开 注释 = "释放图片纹理和对应的内存,之后不能再使用这个纹理ID." 折叠>
    参数 图片信息 <类型 = IM图片信息类 注释 = "提供由\"本对象.加载图片××\"返回的图片信息,释放后会清空信息.">
    {
        如果 (图片信息.纹理ID != 0)
        {
            @ reinterpret_cast<ID3D10ShaderResourceView*>(@<图片信息.纹理ID>)->Release();
        }
        图片信息.重置为空对象 ()
    }

    # Win32 ---

    方法 创建设备 <公开 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数>
    {
        @ m_hwnd = reinterpret_cast<HWND>(@<窗口句柄>);

        @ DXGI_SWAP_CHAIN_DESC sd = {};
        @ sd.BufferCount = 2;
        @ sd.BufferDesc.Width = 0;
        @ sd.BufferDesc.Height = 0;
        @ sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ sd.BufferDesc.RefreshRate.Numerator = 60;
        @ sd.BufferDesc.RefreshRate.Denominator = 1;
        @ sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
        @ sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
        @ sd.OutputWindow = m_hwnd;
        @ sd.SampleDesc.Count = 1;
        @ sd.SampleDesc.Quality = 0;
        @ sd.Windowed = TRUE;
        @ sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

        @ UINT createDeviceFlags = 0;
        @ //createDeviceFlags |= D3D10_CREATE_DEVICE_DEBUG;
        @ HRESULT res = D3D10CreateDeviceAndSwapChain(nullptr, D3D10_DRIVER_TYPE_HARDWARE, nullptr, createDeviceFlags, D3D10_SDK_VERSION, &sd, &m_pSwapChain, &m_pd3dDevice);
        @ if (res == DXGI_ERROR_UNSUPPORTED) // Try high-performance WARP software driver if hardware is not available.
        @     res = D3D10CreateDeviceAndSwapChain(nullptr, D3D10_DRIVER_TYPE_WARP, nullptr, createDeviceFlags, D3D10_SDK_VERSION, &sd, &m_pSwapChain, &m_pd3dDevice);
        @ if (res != S_OK)
        @     return FALSE;

        @ this->@<_CreateRenderTarget>();
        @ return TRUE;
    }

    方法 释放设备 <公开 折叠>
    {
        @ @<_CleanupRenderTarget>();
        @ if (m_pSwapChain) { m_pSwapChain->Release(); m_pSwapChain = nullptr; }
        @ if (m_pd3dDevice) { m_pd3dDevice->Release(); m_pd3dDevice = nullptr; }
    }

    方法 渲染 <公开 折叠>
    参数 背景颜色 <类型 = ImVec4 @输出名 = "clear_color">
    {
        @ ImGui::Render();
        @ const float clear_color_with_alpha[4] = { clear_color.x * clear_color.w, clear_color.y * clear_color.w, clear_color.z * clear_color.w, clear_color.w };
        @ m_pd3dDevice->OMSetRenderTargets(1, &m_mainRenderTargetView, nullptr);
        @ m_pd3dDevice->ClearRenderTargetView(m_mainRenderTargetView, clear_color_with_alpha);
        @ ImGui_ImplDX10_RenderDrawData(ImGui::GetDrawData());

        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     ImGui::UpdatePlatformWindows();
        @     ImGui::RenderPlatformWindowsDefault();
        @ }

        @ HRESULT hr = m_pSwapChain->Present(m_vsync, 0);
        @ m_SwapChainOccluded = (hr == DXGI_STATUS_OCCLUDED);
    }

    方法 重置尺寸 <公开 折叠>
    {

    }

    方法 准备 <公开 折叠>
    {

    }

    方法 是否不可视 <公开 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    {
        // Handle window being minimized or screen locked
        @ bool ret = false;
        @ if ((m_SwapChainOccluded && m_pSwapChain->Present(0, DXGI_PRESENT_TEST) == DXGI_STATUS_OCCLUDED))
        @ {
        @     ::Sleep(10);
        @     ret = true;
        @ }
        @ m_SwapChainOccluded = false;
        @ return ret;
    }

    方法 帧前处理 <公开 折叠>
    {
        // Handle window resize (we don't resize directly in the WM_SIZE handler)
        @ if (m_Width != 0 && m_Height != 0)
        @ {
        @     @<_CleanupRenderTarget>();
        @     m_pSwapChain->ResizeBuffers(0, m_Width, m_Height, DXGI_FORMAT_UNKNOWN, 0);
        @     m_Width = m_Height = 0;
        @     @<_CreateRenderTarget>();
        @ }
    }

    # SDL ---

    方法 创建设备_SDL2 <公开 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ @sn<this>.@<创建设备>(@<窗口句柄>)
    }

    方法 创建设备_SDL3 <公开 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ @sn<this>.@<创建设备>(@<窗口句柄>)
    }

    方法 渲染_SDL <公开 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 背景颜色 <类型 = ImVec4>
    {
        @ @sn<this>.@<渲染>(@<背景颜色>)
    }

    # ---

    方法 _CreateRenderTarget <公开 折叠>
    {
        @ ID3D10Texture2D* pBackBuffer;
        @ m_pSwapChain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer));
        @ m_pd3dDevice->CreateRenderTargetView(pBackBuffer, nullptr, &m_mainRenderTargetView);
        @ pBackBuffer->Release();
    }

    方法 _CleanupRenderTarget <公开 折叠>
    {
        @ if (m_mainRenderTargetView) { m_mainRenderTargetView->Release(); m_mainRenderTargetView = nullptr; }
    }

    # @begin
    # <> <include>
    # ID3D10Device*            m_pd3dDevice = nullptr;
    # IDXGISwapChain*          m_pSwapChain = nullptr;
    # bool                     m_SwapChainOccluded = false;
    # ID3D10RenderTargetView*  m_mainRenderTargetView = nullptr;
    # HWND                     m_hwnd = nullptr;
    # <> </include>
    # @end
}

类 IM_DX11渲染器 <公开 注释 = "基于DirectX11的渲染器后端,兼容Windows 7及以上系统." 折叠 折叠2 @文档 = "category = \"渲染器\""
        @视窗.外部头文件 = "<backends/imgui_impl_dx11.h>\r\n<d3d11.h>"
        @视窗.外部源文件 = "imgui\\backends\\imgui_impl_dx11.cpp"
        @视窗.外部库 = "d3d11.lib\r\nd3dcompiler.lib\r\ndxgi.lib">
{
    变量 垂直同步 <公开 类型 = 逻辑型 值 = 真 注释 = "可以在每次渲染时变更" @输出名 = "m_vsync">
    变量 窗口宽度 <公开 类型 = 整数 值 = 0 @输出名 = "m_Width">
    变量 窗口高度 <公开 类型 = 整数 值 = 0 @输出名 = "m_Height">

    方法 渲染器类型 <公开 属性读 类型 = 整数 注释 = "返回渲染器类型(固定返回11)" 折叠>
    {
        返回 (11)
    }

    方法 渲染器名称 <公开 属性读 类型 = 文本型 折叠>
    {
        返回 ("DirectX 11")
    }

    方法 允许修改帧率 <公开 属性读 类型 = 逻辑型 折叠>
    {
        返回 (真)
    }

    方法 初始化 <公开 类型 = 逻辑型 注释 = "在\"创建设备\"和\"ImGui.创建环境()\"后才能调用." 折叠 @禁止流程检查 = 真>
    {
        @ return ImGui_ImplDX11_Init(m_pd3dDevice, m_pd3dDeviceContext);
    }

    方法 关闭 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX11_Shutdown()
    }

    方法 新建帧 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX11_NewFrame()
    }

    方法 渲染数据 <公开 折叠 @嵌入式方法 = "">
    参数 绘制数据 <类型 = IM绘制数据指针 注释 = "由\"ImGui.取渲染数据()\"返回">
    {
        @ ImGui_ImplDX11_RenderDrawData(@<绘制数据>)
    }

    方法 创建设备对象 <公开 注释 = "用于在不丢失ImGui状态的情况下重置渲染设备" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX11_CreateDeviceObjects()
    }

    方法 销毁设备对象 <公开 注释 = "用于在不丢失ImGui状态的情况下重置渲染设备" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX11_InvalidateDeviceObjects()
    }

    # 纹理图片 ---

    方法 加载图片文件 <公开 类型 = 逻辑型 注释 = "从指定的图片文件加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ if (!m_pd3dDevice) return FALSE;
        @ PivImage image;
        @ unsigned char* image_data = image.load(@<文件名>.GetText(), 4);
        @ if (!image_data) return FALSE;
        @ @<图片信息.宽度> = image.x;
        @ @<图片信息.高度> = image.y;
        @ @<图片信息.纹理ID> = @<_加载纹理>(image_data, image.x, image.y);
        @ return TRUE;
    }

    方法 加载图片资源 <公开 类型 = 逻辑型 注释 = "将程序文件中的图片资源加载到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片资源 <类型 = 视窗文件资源 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ HMODULE hModule = g_objVolApp.GetInstanceHandle();
        @ HRSRC hSrc = ::FindResourceW(hModule, MAKEINTRESOURCE((WORD)@<图片资源>), RT_RCDATA);
        @ if (!hSrc) return FALSE;
        @ HGLOBAL resdata = ::LoadResource(hModule, hSrc);
        @ if (!resdata) return FALSE;
        @ PivImage image;
        @ unsigned char* image_data = image.load(reinterpret_cast<unsigned char*>(::LockResource(resdata)), static_cast<int>(::SizeofResource(hModule, hSrc)), 4);
        @ if (!image_data) return FALSE;
        @ @<图片信息.宽度> = image.x;
        @ @<图片信息.高度> = image.y;
        @ @<图片信息.纹理ID> = @<_加载纹理>(image_data, image.x, image.y);
        @ return TRUE;
    }

    方法 加载图片字节集 <公开 类型 = 逻辑型 注释 = "从指定的图片字节集加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片数据 <类型 = 字节集类 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ PivImage image;
        @ unsigned char* image_data = image.load(@<图片数据>.GetPtr(), static_cast<int>(@<图片数据>.GetSize()), 4);
        @ if (!image_data) return FALSE;
        @ @<图片信息.宽度> = image.x;
        @ @<图片信息.高度> = image.y;
        @ @<图片信息.纹理ID> = @<_加载纹理>(image_data, image.x, image.y);
        @ return TRUE;
    }

    方法 _加载纹理 <类型 = 无符号长整数 折叠 @禁止流程检查 = 真>
    参数 image_data <类型 = PIV.类型.字节集指针 @输出名 = "image_data">
    参数 image_width <类型 = 整数 @输出名 = "image_width">
    参数 image_height <类型 = 整数 @输出名 = "image_height">
    {
        // Create texture
        @ D3D11_TEXTURE2D_DESC desc;
        @ ZeroMemory(&desc, sizeof(desc));
        @ desc.Width = image_width;
        @ desc.Height = image_height;
        @ desc.MipLevels = 1;
        @ desc.ArraySize = 1;
        @ desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ desc.SampleDesc.Count = 1;
        @ desc.Usage = D3D11_USAGE_DEFAULT;
        @ desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
        @ desc.CPUAccessFlags = 0;

        @ ID3D11Texture2D *pTexture = NULL;
        @ D3D11_SUBRESOURCE_DATA subResource;
        @ subResource.pSysMem = image_data;
        @ subResource.SysMemPitch = desc.Width * 4;
        @ subResource.SysMemSlicePitch = 0;
        @ m_pd3dDevice->CreateTexture2D(&desc, &subResource, &pTexture);

        // Create texture view
        @ D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
        @ ZeroMemory(&srvDesc, sizeof(srvDesc));
        @ srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
        @ srvDesc.Texture2D.MipLevels = desc.MipLevels;
        @ srvDesc.Texture2D.MostDetailedMip = 0;
        @ ID3D11ShaderResourceView* out_srv;
        @ m_pd3dDevice->CreateShaderResourceView(pTexture, &srvDesc, &out_srv);
        @ pTexture->Release();
        @ return (UINT64)out_srv;
    }

    方法 释放纹理 <公开 注释 = "释放图片纹理和对应的内存,之后不能再使用这个纹理ID." 折叠>
    参数 图片信息 <类型 = IM图片信息类 注释 = "提供由\"本对象.加载图片××\"返回的图片信息,释放后会清空信息.">
    {
        如果 (图片信息.纹理ID != 0)
        {
            @ reinterpret_cast<ID3D11ShaderResourceView*>(@<图片信息.纹理ID>)->Release();
        }
        图片信息.重置为空对象 ()
    }

    # Win32 ---

    方法 创建设备 <公开 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数>
    {
        // Setup swap chain
        @ DXGI_SWAP_CHAIN_DESC sd;
        @ ZeroMemory(&sd, sizeof(sd));
        @ sd.BufferCount = 2;
        @ sd.BufferDesc.Width = 0;
        @ sd.BufferDesc.Height = 0;
        @ sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ sd.BufferDesc.RefreshRate.Numerator = 60;
        @ sd.BufferDesc.RefreshRate.Denominator = 1;
        @ sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
        @ sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
        @ sd.OutputWindow = reinterpret_cast<HWND>(@<窗口句柄>);
        @ sd.SampleDesc.Count = 1;
        @ sd.SampleDesc.Quality = 0;
        @ sd.Windowed = TRUE;
        @ sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

        @ UINT createDeviceFlags = 0;
        @ // createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
        @ D3D_FEATURE_LEVEL featureLevel;
        @ const D3D_FEATURE_LEVEL featureLevelArray[2] = { D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0, };
        @ HRESULT res = D3D11CreateDeviceAndSwapChain(nullptr, D3D_DRIVER_TYPE_HARDWARE, nullptr, createDeviceFlags, featureLevelArray, 2, D3D11_SDK_VERSION, &sd, &m_pSwapChain, &m_pd3dDevice, &featureLevel, &m_pd3dDeviceContext);
        @ if (res == DXGI_ERROR_UNSUPPORTED) // Try high-performance WARP software driver if hardware is not available.
        @     res = D3D11CreateDeviceAndSwapChain(nullptr, D3D_DRIVER_TYPE_WARP, nullptr, createDeviceFlags, featureLevelArray, 2, D3D11_SDK_VERSION, &sd, &m_pSwapChain, &m_pd3dDevice, &featureLevel, &m_pd3dDeviceContext);
        @ if (res != S_OK)
        @     return FALSE;

        @ this->@<_CreateRenderTarget>();
        @ return TRUE;
    }

    方法 释放设备 <公开 折叠>
    {
        @ this->@<_CleanupRenderTarget>();
        @ if (m_pSwapChain) { m_pSwapChain->Release(); m_pSwapChain = nullptr; }
        @ if (m_pd3dDeviceContext) { m_pd3dDeviceContext->Release(); m_pd3dDeviceContext = nullptr; }
        @ if (m_pd3dDevice) { m_pd3dDevice->Release(); m_pd3dDevice = nullptr; }
    }

    方法 重置尺寸 <公开 折叠>
    {

    }

    方法 渲染 <公开 折叠>
    参数 背景颜色 <类型 = ImVec4 @输出名 = "clear_color">
    {
        @ ImGui::Render();
        @ const float clear_color_with_alpha[4] = { clear_color.x * clear_color.w, clear_color.y * clear_color.w, clear_color.z * clear_color.w, clear_color.w };
        @ m_pd3dDeviceContext->OMSetRenderTargets(1, &m_mainRenderTargetView, nullptr);
        @ m_pd3dDeviceContext->ClearRenderTargetView(m_mainRenderTargetView, clear_color_with_alpha);
        @ ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

        // Update and Render additional Platform Windows
        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     ImGui::UpdatePlatformWindows();
        @     ImGui::RenderPlatformWindowsDefault();
        @ }

        // Present
        @ HRESULT hr = m_pSwapChain->Present(m_vsync, 0);
        @ m_SwapChainOccluded = (hr == DXGI_STATUS_OCCLUDED);
    }

    方法 准备 <公开>

    方法 是否不可视 <公开 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    {
        // Handle window being minimized or screen locked
        @ bool ret = false;
        @ if ((m_SwapChainOccluded && m_pSwapChain->Present(0, DXGI_PRESENT_TEST) == DXGI_STATUS_OCCLUDED))
        @ {
        @     ::Sleep(10);
        @     ret = true;
        @ }
        @ m_SwapChainOccluded = false;
        @ return ret;
    }

    方法 帧前处理 <公开 折叠>
    {
        // Handle window resize (we don't resize directly in the WM_SIZE handler)
        @ if (m_Width != 0 && m_Height != 0)
        @ {
        @     @<_CleanupRenderTarget>();
        @     m_pSwapChain->ResizeBuffers(0, m_Width, m_Height, DXGI_FORMAT_UNKNOWN, 0);
        @     m_Width = m_Height = 0;
        @     @<_CreateRenderTarget>();
        @ }
    }

    # SDL ---

    方法 创建设备_SDL2 <公开 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ @sn<this>.@<创建设备>(@<窗口句柄>)
    }

    方法 创建设备_SDL3 <公开 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ @sn<this>.@<创建设备>(@<窗口句柄>)
    }

    方法 渲染_SDL <公开 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 背景颜色 <类型 = ImVec4>
    {
        @ @sn<this>.@<渲染>(@<背景颜色>)
    }

    # ---

    方法 _CreateRenderTarget <公开 折叠>
    {
        @ ID3D11Texture2D* pBackBuffer;
        @ m_pSwapChain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer));
        @ m_pd3dDevice->CreateRenderTargetView(pBackBuffer, nullptr, &m_mainRenderTargetView);
        @ pBackBuffer->Release();
    }

    方法 _CleanupRenderTarget <公开 折叠>
    {
        @ if (m_mainRenderTargetView) { m_mainRenderTargetView->Release(); m_mainRenderTargetView = nullptr; }
    }

    # @begin
    # <> <include>
    # ID3D11Device*            m_pd3dDevice = nullptr;
    # ID3D11DeviceContext*     m_pd3dDeviceContext = nullptr;
    # IDXGISwapChain*          m_pSwapChain = nullptr;
    # bool                     m_SwapChainOccluded = false;
    # ID3D11RenderTargetView*  m_mainRenderTargetView = nullptr;
    # <> </include>
    # @end
}

类 IM_DX12渲染器 <公开 注释 = "基于DirectX12的渲染器后端,兼容Windows 10及以上系统." 折叠 折叠2 @文档 = "category = \"渲染器\""
        @视窗.外部头文件 = "<backends/imgui_impl_dx12.h>\r\n<d3d12.h>\r\n<dxgi1_4.h>"
        @视窗.外部源文件 = "imgui\\backends\\imgui_impl_dx12.cpp"
        @视窗.外部库 = "d3d12.lib\r\nd3dcompiler.lib\r\ndxgi.lib" @视窗.预定义宏 = "ImTextureID=ImU64">
{
    变量 垂直同步 <公开 类型 = 逻辑型 值 = 真 注释 = "可以在每次渲染时变更;" 注释 = "注意: DX12关闭垂直同步后,最高帧速率仅变为屏幕刷新率的两倍." @输出名 = "m_vsync">
    变量 窗口宽度 <公开 类型 = 整数 值 = 0 @输出名 = "m_Width">
    变量 窗口高度 <公开 类型 = 整数 值 = 0 @输出名 = "m_Height">

    方法 渲染器类型 <公开 属性读 类型 = 整数 注释 = "返回渲染器类型(固定返回12)" 折叠>
    {
        返回 (12)
    }

    方法 渲染器名称 <公开 属性读 类型 = 文本型 折叠>
    {
        返回 ("DirectX 12")
    }

    方法 允许修改帧率 <公开 属性读 类型 = 逻辑型 折叠>
    {
        返回 (真)
    }

    方法 初始化 <公开 类型 = 逻辑型 注释 = "在\"创建设备\"和\"ImGui.创建环境()\"后才能调用." 折叠 @禁止流程检查 = 真>
    {
        @ ImGui_ImplDX12_InitInfo init_info = {};
        @ init_info.Device = m_pd3dDevice;
        @ init_info.CommandQueue = m_pd3dCommandQueue;
        @ init_info.NumFramesInFlight = APP_NUM_FRAMES_IN_FLIGHT;
        @ init_info.RTVFormat = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ init_info.DSVFormat = DXGI_FORMAT_UNKNOWN;
        // Allocating SRV descriptors (for textures) is up to the application, so we provide callbacks.
        // (current version of the backend will only allocate one descriptor, future versions will need to allocate more)
        @ init_info.SrvDescriptorHeap = m_pd3dSrvDescHeap;
        @ init_info.SrvDescriptorAllocFn = [](ImGui_ImplDX12_InitInfo*, D3D12_CPU_DESCRIPTOR_HANDLE* out_cpu_handle, D3D12_GPU_DESCRIPTOR_HANDLE* out_gpu_handle)
        @ {
        @     return g_pd3dSrvDescHeapAlloc.Alloc(out_cpu_handle, out_gpu_handle);
        @ };
        @ init_info.SrvDescriptorFreeFn = [](ImGui_ImplDX12_InitInfo*, D3D12_CPU_DESCRIPTOR_HANDLE cpu_handle, D3D12_GPU_DESCRIPTOR_HANDLE gpu_handle)
        @ {
        @     return g_pd3dSrvDescHeapAlloc.Free(cpu_handle, gpu_handle);
        @ };
        @ return ImGui_ImplDX12_Init(&init_info);
    }

    方法 关闭 <公开 折叠>
    {
        @ @<_WaitForLastSubmittedFrame>();
        @ ImGui_ImplDX12_Shutdown();
    }

    方法 新建帧 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX12_NewFrame()
    }

    方法 渲染数据 <公开 折叠 @嵌入式方法 = "">
    参数 绘制数据 <类型 = IM绘制数据指针 注释 = "由\"ImGui.取渲染数据()\"返回">
    {
        @ ImGui_ImplDX12_RenderDrawData(@<绘制数据>, @sn<this>.m_pd3dCommandList)
    }

    方法 创建设备对象 <公开 注释 = "用于在不丢失ImGui状态的情况下重置渲染设备" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX12_CreateDeviceObjects()
    }

    方法 销毁设备对象 <公开 注释 = "用于在不丢失ImGui状态的情况下重置渲染设备" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX12_InvalidateDeviceObjects()
    }

    # 纹理图片 ---

    方法 加载图片文件 <公开 类型 = 逻辑型 注释 = "从指定的图片文件加载纹理到渲染器中,不再使用时请调用\"释放纹理\"."
            注释 = "注意: 只能在\"IM_DX12渲染器.初始化\"之后使用,即\"准备渲染\"事件中." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ if (!m_pd3dDevice) return FALSE;
        @ PivImage image;
        @ unsigned char* image_data = image.load(@<文件名>.GetText(), 4);
        @ if (!image_data) return FALSE;
        @ @<图片信息.宽度> = image.x;
        @ @<图片信息.高度> = image.y;
        @ ID3D12Resource* my_texture = NULL;
        @ D3D12_CPU_DESCRIPTOR_HANDLE my_texture_srv_cpu_handle;
        @ D3D12_GPU_DESCRIPTOR_HANDLE my_texture_srv_gpu_handle;
        @ g_pd3dSrvDescHeapAlloc.Alloc(&my_texture_srv_cpu_handle, &my_texture_srv_gpu_handle);
        @ @<_加载纹理>(image_data, my_texture_srv_cpu_handle, &my_texture, @<图片信息.宽度>, @<图片信息.高度>);
        @ @<图片信息.纹理ID> = static_cast<UINT64>(my_texture_srv_gpu_handle.ptr);
        @ @<图片信息._内部数据> = my_texture;
        @ return TRUE;
    }

    方法 加载图片资源 <公开 类型 = 逻辑型 注释 = "将程序文件中的图片资源加载到渲染器中,不再使用时请调用\"释放纹理\"."
            注释 = "注意: 只能在\"IM_DX12渲染器.初始化\"之后使用,即\"准备渲染\"事件中." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片资源 <类型 = 视窗文件资源 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ if (!m_pd3dDevice) return FALSE;
        @ HMODULE hModule = g_objVolApp.GetInstanceHandle();
        @ HRSRC hSrc = ::FindResourceW(hModule, MAKEINTRESOURCE((WORD)@<图片资源>), RT_RCDATA);
        @ if (!hSrc) return FALSE;
        @ HGLOBAL resdata = ::LoadResource(hModule, hSrc);
        @ if (!resdata) return FALSE;
        @ unsigned char* data = reinterpret_cast<unsigned char*>(::LockResource(resdata));
        @ int len = static_cast<int>(::SizeofResource(hModule, hSrc));
        @ PivImage image;
        @ unsigned char* image_data = image.load(data, len, 4);
        @ if (!image_data) return FALSE;
        @ @<图片信息.宽度> = image.x;
        @ @<图片信息.高度> = image.y;
        @ ID3D12Resource* my_texture = NULL;
        @ D3D12_CPU_DESCRIPTOR_HANDLE my_texture_srv_cpu_handle;
        @ D3D12_GPU_DESCRIPTOR_HANDLE my_texture_srv_gpu_handle;
        @ g_pd3dSrvDescHeapAlloc.Alloc(&my_texture_srv_cpu_handle, &my_texture_srv_gpu_handle);
        @ @<_加载纹理>(image_data, my_texture_srv_cpu_handle, &my_texture, @<图片信息.宽度>, @<图片信息.高度>);
        @ @<图片信息.纹理ID> = static_cast<UINT64>(my_texture_srv_gpu_handle.ptr);
        @ @<图片信息._内部数据> = my_texture;
        @ return TRUE;
    }

    方法 加载图片字节集 <公开 类型 = 逻辑型 注释 = "从指定的图片字节集加载纹理到渲染器中,不再使用时请调用\"释放纹理\"."
            注释 = "注意: 只能在\"IM_DX12渲染器.初始化\"之后使用,即\"准备渲染\"事件中." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片数据 <类型 = 字节集类 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ if (!m_pd3dDevice) return FALSE;
        @ PivImage image;
        @ unsigned char* image_data = image.load(@<图片数据>.GetPtr(), static_cast<int>(@<图片数据>.GetSize()), 4);
        @ if (!image_data) return FALSE;
        @ @<图片信息.宽度> = image.x;
        @ @<图片信息.高度> = image.y;
        @ ID3D12Resource* my_texture = NULL;
        @ D3D12_CPU_DESCRIPTOR_HANDLE my_texture_srv_cpu_handle;
        @ D3D12_GPU_DESCRIPTOR_HANDLE my_texture_srv_gpu_handle;
        @ g_pd3dSrvDescHeapAlloc.Alloc(&my_texture_srv_cpu_handle, &my_texture_srv_gpu_handle);
        @ @<_加载纹理>(image_data, my_texture_srv_cpu_handle, &my_texture, @<图片信息.宽度>, @<图片信息.高度>);
        @ @<图片信息.纹理ID> = static_cast<UINT64>(my_texture_srv_gpu_handle.ptr);
        @ @<图片信息._内部数据> = my_texture;
        @ return TRUE;
    }

    方法 释放纹理 <公开 注释 = "释放图片纹理和对应的内存,之后不能再使用这个纹理ID." 折叠>
    参数 图片信息 <类型 = IM图片信息类 注释 = "提供由\"本对象.加载图片××\"返回图片的信息,释放后会清空信息.">
    {
        如果 (图片信息._内部数据 != 0)
        {
            @ reinterpret_cast<ID3D12Resource*>(@<图片信息._内部数据>)->Release();
        }
        图片信息.重置为空对象 ()
    }

    方法 _加载纹理 <注释 = "仅限内部嵌入式使用" 折叠>
    参数 图片指针 <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/unsigned char*" @输出名 = "image_data">
    参数 srv_cpu_handle <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/D3D12_CPU_DESCRIPTOR_HANDLE"
            @输出名 = "srv_cpu_handle">
    参数 out_tex_resource <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/ID3D12Resource**" @输出名 = "out_tex_resource">
    参数 宽度 <类型 = 整数 @输出名 = "image_width">
    参数 高度 <类型 = 整数 @输出名 = "image_height">
    {
        // Create texture resource
        @ D3D12_HEAP_PROPERTIES props;
        @ memset(&props, 0, sizeof(D3D12_HEAP_PROPERTIES));
        @ props.Type = D3D12_HEAP_TYPE_DEFAULT;
        @ props.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
        @ props.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;

        @ D3D12_RESOURCE_DESC desc;
        @ ZeroMemory(&desc, sizeof(desc));
        @ desc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
        @ desc.Alignment = 0;
        @ desc.Width = image_width;
        @ desc.Height = image_height;
        @ desc.DepthOrArraySize = 1;
        @ desc.MipLevels = 1;
        @ desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ desc.SampleDesc.Count = 1;
        @ desc.SampleDesc.Quality = 0;
        @ desc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
        @ desc.Flags = D3D12_RESOURCE_FLAG_NONE;

        @ ID3D12Resource* pTexture = NULL;
        @ m_pd3dDevice->CreateCommittedResource(&props, D3D12_HEAP_FLAG_NONE, &desc,
        @     D3D12_RESOURCE_STATE_COPY_DEST, NULL, IID_PPV_ARGS(&pTexture));

        // Create a temporary upload resource to move the data in
        @ UINT uploadPitch = (image_width * 4 + D3D12_TEXTURE_DATA_PITCH_ALIGNMENT - 1u) & ~(D3D12_TEXTURE_DATA_PITCH_ALIGNMENT - 1u);
        @ UINT uploadSize = image_height * uploadPitch;
        @ desc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
        @ desc.Alignment = 0;
        @ desc.Width = uploadSize;
        @ desc.Height = 1;
        @ desc.DepthOrArraySize = 1;
        @ desc.MipLevels = 1;
        @ desc.Format = DXGI_FORMAT_UNKNOWN;
        @ desc.SampleDesc.Count = 1;
        @ desc.SampleDesc.Quality = 0;
        @ desc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
        @ desc.Flags = D3D12_RESOURCE_FLAG_NONE;

        @ props.Type = D3D12_HEAP_TYPE_UPLOAD;
        @ props.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
        @ props.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;

        @ ID3D12Resource* uploadBuffer = NULL;
        @ HRESULT hr = m_pd3dDevice->CreateCommittedResource(&props, D3D12_HEAP_FLAG_NONE, &desc,
        @     D3D12_RESOURCE_STATE_GENERIC_READ, NULL, IID_PPV_ARGS(&uploadBuffer));
        @ IM_ASSERT(SUCCEEDED(hr));

        // Write pixels into the upload resource
        @ void* mapped = NULL;
        @ D3D12_RANGE range = { 0, uploadSize };
        @ hr = uploadBuffer->Map(0, &range, &mapped);
        @ IM_ASSERT(SUCCEEDED(hr));
        @ for (int y = 0; y < image_height; y++)
        @     memcpy(reinterpret_cast<void*>(reinterpret_cast<uintptr_t>(mapped) + y * uploadPitch), image_data + y * image_width * 4, image_width * 4);
        @ uploadBuffer->Unmap(0, &range);

        // Copy the upload resource content into the real resource
        @ D3D12_TEXTURE_COPY_LOCATION srcLocation = {};
        @ srcLocation.pResource = uploadBuffer;
        @ srcLocation.Type = D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT;
        @ srcLocation.PlacedFootprint.Footprint.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ srcLocation.PlacedFootprint.Footprint.Width = image_width;
        @ srcLocation.PlacedFootprint.Footprint.Height = image_height;
        @ srcLocation.PlacedFootprint.Footprint.Depth = 1;
        @ srcLocation.PlacedFootprint.Footprint.RowPitch = uploadPitch;

        @ D3D12_TEXTURE_COPY_LOCATION dstLocation = {};
        @ dstLocation.pResource = pTexture;
        @ dstLocation.Type = D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX;
        @ dstLocation.SubresourceIndex = 0;

        @ D3D12_RESOURCE_BARRIER barrier = {};
        @ barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
        @ barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
        @ barrier.Transition.pResource = pTexture;
        @ barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
        @ barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_DEST;
        @ barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;

        // Create a temporary command queue to do the copy with
        @ ID3D12Fence* fence = NULL;
        @ hr = m_pd3dDevice->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fence));
        @ IM_ASSERT(SUCCEEDED(hr));

        @ HANDLE event = CreateEvent(0, 0, 0, 0);
        @ IM_ASSERT(event != NULL);

        @ D3D12_COMMAND_QUEUE_DESC queueDesc = {};
        @ queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
        @ queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
        @ queueDesc.NodeMask = 1;

        @ ID3D12CommandQueue* cmdQueue = NULL;
        @ hr = m_pd3dDevice->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&cmdQueue));
        @ IM_ASSERT(SUCCEEDED(hr));

        @ ID3D12CommandAllocator* cmdAlloc = NULL;
        @ hr = m_pd3dDevice->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&cmdAlloc));
        @ IM_ASSERT(SUCCEEDED(hr));

        @ ID3D12GraphicsCommandList* cmdList = NULL;
        @ hr = m_pd3dDevice->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, cmdAlloc, NULL, IID_PPV_ARGS(&cmdList));
        @ IM_ASSERT(SUCCEEDED(hr));

        @ cmdList->CopyTextureRegion(&dstLocation, 0, 0, 0, &srcLocation, NULL);
        @ cmdList->ResourceBarrier(1, &barrier);

        @ hr = cmdList->Close();
        @ IM_ASSERT(SUCCEEDED(hr));

        // Execute the copy
        @ cmdQueue->ExecuteCommandLists(1, (ID3D12CommandList* const*)&cmdList);
        @ hr = cmdQueue->Signal(fence, 1);
        @ IM_ASSERT(SUCCEEDED(hr));

        // Wait for everything to complete
        @ fence->SetEventOnCompletion(1, event);
        @ WaitForSingleObject(event, INFINITE);

        // Tear down our temporary command queue and release the upload resource
        @ cmdList->Release();
        @ cmdAlloc->Release();
        @ cmdQueue->Release();
        @ CloseHandle(event);
        @ fence->Release();
        @ uploadBuffer->Release();

        // Create a shader resource view for the texture
        @ D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc;
        @ ZeroMemory(&srvDesc, sizeof(srvDesc));
        @ srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
        @ srvDesc.Texture2D.MipLevels = desc.MipLevels;
        @ srvDesc.Texture2D.MostDetailedMip = 0;
        @ srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
        @ m_pd3dDevice->CreateShaderResourceView(pTexture, &srvDesc, srv_cpu_handle);

        // Return results
        @ *out_tex_resource = pTexture;
    }

    # Win32 ---

    方法 创建设备 <公开 类型 = 逻辑型 注释 = "CreateDeviceD3D" 折叠 @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数>
    {
        @ m_hwnd = (HWND)@<窗口句柄>;
        // Setup swap chain
        @ DXGI_SWAP_CHAIN_DESC1 sd = {};
        @ {
        @     ZeroMemory(&sd, sizeof(sd));
        @     sd.BufferCount = APP_NUM_BACK_BUFFERS;
        @     sd.Width = 0;
        @     sd.Height = 0;
        @     sd.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @     sd.Flags = DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT;
        @     sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
        @     sd.SampleDesc.Count = 1;
        @     sd.SampleDesc.Quality = 0;
        @     sd.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
        @     sd.AlphaMode = DXGI_ALPHA_MODE_UNSPECIFIED;
        @     sd.Scaling = DXGI_SCALING_STRETCH;
        @     sd.Stereo = FALSE;
        @ }

        // [DEBUG] Enable debug interface
        @ #ifdef DX12_ENABLE_DEBUG_LAYER
        @ ID3D12Debug* pdx12Debug = nullptr;
        @ if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&pdx12Debug))))
        @     pdx12Debug->EnableDebugLayer();
        @ #endif

        // Create device
        @ D3D_FEATURE_LEVEL featureLevel = D3D_FEATURE_LEVEL_11_0;
        @ if (D3D12CreateDevice(nullptr, featureLevel, IID_PPV_ARGS(&m_pd3dDevice)) != S_OK)
        @     return FALSE;

        // [DEBUG] Setup debug interface to break on any warnings/errors
        @ #ifdef DX12_ENABLE_DEBUG_LAYER
        @ if (pdx12Debug != nullptr)
        @ {
        @     ID3D12InfoQueue* pInfoQueue = nullptr;
        @     m_pd3dDevice->QueryInterface(IID_PPV_ARGS(&pInfoQueue));
        @     pInfoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, true);
        @     pInfoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, true);
        @     pInfoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_WARNING, true);
        @     pInfoQueue->Release();
        @     pdx12Debug->Release();
        @ }
        @ #endif

        @ {
        @     D3D12_DESCRIPTOR_HEAP_DESC desc = {};
        @     desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
        @     desc.NumDescriptors = APP_NUM_BACK_BUFFERS;
        @     desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
        @     desc.NodeMask = 1;
        @     if (m_pd3dDevice->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&m_pd3dRtvDescHeap)) != S_OK)
        @         return FALSE;
        @     SIZE_T rtvDescriptorSize = m_pd3dDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
        @     D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = m_pd3dRtvDescHeap->GetCPUDescriptorHandleForHeapStart();
        @     for (UINT i = 0; i < APP_NUM_BACK_BUFFERS; i++)
        @     {
        @         m_mainRenderTargetDescriptor[i] = rtvHandle;
        @         rtvHandle.ptr += rtvDescriptorSize;
        @     }
        @ }

        @ {
        @     D3D12_DESCRIPTOR_HEAP_DESC desc = {};
        @     desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
        @     desc.NumDescriptors = APP_SRV_HEAP_SIZE;
        @     desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
        @     if (m_pd3dDevice->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&m_pd3dSrvDescHeap)) != S_OK)
        @         return FALSE;
        @     g_pd3dSrvDescHeapAlloc.Create(m_pd3dDevice, m_pd3dSrvDescHeap);
        @ }

        @ {
        @     D3D12_COMMAND_QUEUE_DESC desc = {};
        @     desc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
        @     desc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
        @     desc.NodeMask = 1;
        @     if (m_pd3dDevice->CreateCommandQueue(&desc, IID_PPV_ARGS(&m_pd3dCommandQueue)) != S_OK)
        @         return FALSE;
        @ }

        @ for (UINT i = 0; i < APP_NUM_FRAMES_IN_FLIGHT; i++)
        @     if (m_pd3dDevice->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&m_frameContext[i].CommandAllocator)) != S_OK)
        @         return FALSE;

        @ if (m_pd3dDevice->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, m_frameContext[0].CommandAllocator, nullptr, IID_PPV_ARGS(&m_pd3dCommandList)) != S_OK ||
        @     m_pd3dCommandList->Close() != S_OK)
        @     return FALSE;

        @ if (m_pd3dDevice->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&m_fence)) != S_OK)
        @     return FALSE;

        @ m_fenceEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);
        @ if (m_fenceEvent == nullptr) return FALSE;

        @ {
        @     IDXGIFactory4* dxgiFactory = nullptr;
        @     IDXGISwapChain1* swapChain1 = nullptr;
        @     if (CreateDXGIFactory1(IID_PPV_ARGS(&dxgiFactory)) != S_OK)
        @         return FALSE;
        @     if (dxgiFactory->CreateSwapChainForHwnd(m_pd3dCommandQueue, m_hwnd, &sd, nullptr, nullptr, &swapChain1) != S_OK)
        @         return FALSE;
        @     if (swapChain1->QueryInterface(IID_PPV_ARGS(&m_pSwapChain)) != S_OK)
        @         return FALSE;
        @     swapChain1->Release();
        @     dxgiFactory->Release();
        @     m_pSwapChain->SetMaximumFrameLatency(APP_NUM_BACK_BUFFERS);
        @     m_hSwapChainWaitableObject = m_pSwapChain->GetFrameLatencyWaitableObject();
        @ }

        @ this->@<_CreateRenderTarget>();
        @ return TRUE;
    }

    方法 释放设备 <公开 折叠>
    {
        @ @<_CleanupRenderTarget>();
        @ if (m_pSwapChain) { m_pSwapChain->SetFullscreenState(false, nullptr); m_pSwapChain->Release(); m_pSwapChain = nullptr; }
        @ if (m_hSwapChainWaitableObject != nullptr) { CloseHandle(m_hSwapChainWaitableObject); }
        @ for (UINT i = 0; i < APP_NUM_FRAMES_IN_FLIGHT; i++)
        @     if (m_frameContext[i].CommandAllocator) { m_frameContext[i].CommandAllocator->Release(); m_frameContext[i].CommandAllocator = nullptr; }
        @ if (m_pd3dCommandQueue) { m_pd3dCommandQueue->Release(); m_pd3dCommandQueue = nullptr; }
        @ if (m_pd3dCommandList) { m_pd3dCommandList->Release(); m_pd3dCommandList = nullptr; }
        @ if (m_pd3dRtvDescHeap) { m_pd3dRtvDescHeap->Release(); m_pd3dRtvDescHeap = nullptr; }
        @ if (m_pd3dSrvDescHeap) { m_pd3dSrvDescHeap->Release(); m_pd3dSrvDescHeap = nullptr; }
        @ if (m_fence) { m_fence->Release(); m_fence = nullptr; }
        @ if (m_fenceEvent) { CloseHandle(m_fenceEvent); m_fenceEvent = nullptr; }
        @ if (m_pd3dDevice) { m_pd3dDevice->Release(); m_pd3dDevice = nullptr; }

        @ g_pd3dSrvDescHeapAlloc.Destroy();

        @ #ifdef DX12_ENABLE_DEBUG_LAYER
        @ IDXGIDebug1* pDebug = nullptr;
        @ if (SUCCEEDED(DXGIGetDebugInterface1(0, IID_PPV_ARGS(&pDebug))))
        @ {
        @     pDebug->ReportLiveObjects(DXGI_DEBUG_ALL, DXGI_DEBUG_RLO_SUMMARY);
        @     pDebug->Release();
        @ }
        @ #endif
    }

    方法 渲染 <公开 折叠>
    参数 背景颜色 <类型 = ImVec4 @输出名 = "clear_color">
    {
        @ ImGui::Render();

        @ FrameContext* frameCtx = (FrameContext*)@<_WaitForNextFrameResources>();
        @ UINT backBufferIdx = m_pSwapChain->GetCurrentBackBufferIndex();
        @ frameCtx->CommandAllocator->Reset();

        @ D3D12_RESOURCE_BARRIER barrier = {};
        @ barrier.Type                   = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
        @ barrier.Flags                  = D3D12_RESOURCE_BARRIER_FLAG_NONE;
        @ barrier.Transition.pResource   = m_mainRenderTargetResource[backBufferIdx];
        @ barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
        @ barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;
        @ barrier.Transition.StateAfter  = D3D12_RESOURCE_STATE_RENDER_TARGET;
        @ m_pd3dCommandList->Reset(frameCtx->CommandAllocator, nullptr);
        @ m_pd3dCommandList->ResourceBarrier(1, &barrier);

        @ const float clear_color_with_alpha[4] = { clear_color.x * clear_color.w, clear_color.y * clear_color.w, clear_color.z * clear_color.w, clear_color.w };
        @ m_pd3dCommandList->ClearRenderTargetView(m_mainRenderTargetDescriptor[backBufferIdx], clear_color_with_alpha, 0, nullptr);
        @ m_pd3dCommandList->OMSetRenderTargets(1, &m_mainRenderTargetDescriptor[backBufferIdx], FALSE, nullptr);
        @ m_pd3dCommandList->SetDescriptorHeaps(1, &m_pd3dSrvDescHeap);
        @ ImGui_ImplDX12_RenderDrawData(ImGui::GetDrawData(), m_pd3dCommandList);
        @ barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
        @ barrier.Transition.StateAfter  = D3D12_RESOURCE_STATE_PRESENT;
        @ m_pd3dCommandList->ResourceBarrier(1, &barrier);
        @ m_pd3dCommandList->Close();

        @ m_pd3dCommandQueue->ExecuteCommandLists(1, (ID3D12CommandList* const*)&m_pd3dCommandList);

        // Update and Render additional Platform Windows
        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     ImGui::UpdatePlatformWindows();
        @     ImGui::RenderPlatformWindowsDefault();
        @ }

        // Present
        @ HRESULT hr = m_pSwapChain->Present(m_vsync, 0);
        @ m_SwapChainOccluded = (hr == DXGI_STATUS_OCCLUDED);

        @ UINT64 fenceValue = m_fenceLastSignaledValue + 1;
        @ m_pd3dCommandQueue->Signal(m_fence, fenceValue);
        @ m_fenceLastSignaledValue = fenceValue;
        @ frameCtx->FenceValue = fenceValue;
    }

    方法 重置尺寸 <公开 折叠>
    {
        @ if (m_pd3dDevice != nullptr)
        @ {
        @     @<_WaitForLastSubmittedFrame>();
        @     @<_CleanupRenderTarget>();
        @     HRESULT result = m_pSwapChain->ResizeBuffers(0, m_Width, m_Height, DXGI_FORMAT_UNKNOWN, DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT);
        @     assert(SUCCEEDED(result) && "Failed to resize swapchain.");
        @     @<_CreateRenderTarget>();
        @ }
    }

    方法 是否不可视 <公开 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    {
        // Handle window screen locked
        @ bool ret = false;
        @ if ((m_SwapChainOccluded && m_pSwapChain->Present(0, DXGI_PRESENT_TEST) == DXGI_STATUS_OCCLUDED) || ::IsIconic(m_hwnd))
        @ {
        @     ::Sleep(10);
        @     ret = true;
        @ }
        @ m_SwapChainOccluded = false;
        @ return ret;
    }

    方法 帧前处理 <公开 折叠>
    {

    }

    方法 准备 <公开>

    # SDL ---

    方法 创建设备_SDL2 <公开 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ @sn<this>.@<创建设备>(@<窗口句柄>)
    }

    方法 创建设备_SDL3 <公开 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ @sn<this>.@<创建设备>(@<窗口句柄>)
    }

    方法 渲染_SDL <公开 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 背景颜色 <类型 = ImVec4>
    {
        @ @sn<this>.@<渲染>(@<背景颜色>)
    }

    # ---

    方法 _CreateRenderTarget <公开 折叠>
    {
        @ for (INT i = 0; i < APP_NUM_BACK_BUFFERS; i++)
        @ {
        @     ID3D12Resource* pBackBuffer = nullptr;
        @     m_pSwapChain->GetBuffer(i, IID_PPV_ARGS(&pBackBuffer));
        @     m_pd3dDevice->CreateRenderTargetView(pBackBuffer, nullptr, m_mainRenderTargetDescriptor[i]);
        @     m_mainRenderTargetResource[i] = pBackBuffer;
        @ }
    }

    方法 _CleanupRenderTarget <公开 折叠>
    {
        @ @<_WaitForLastSubmittedFrame>();
        @ for (UINT i = 0; i < APP_NUM_BACK_BUFFERS; i++)
        @     if (m_mainRenderTargetResource[i]) { m_mainRenderTargetResource[i]->Release(); m_mainRenderTargetResource[i] = nullptr; }
    }

    方法 _WaitForLastSubmittedFrame <公开 折叠>
    {
        @ FrameContext* frameCtx = &m_frameContext[m_frameIndex % APP_NUM_FRAMES_IN_FLIGHT];

        @ UINT64 fenceValue = frameCtx->FenceValue;
        @ if (fenceValue == 0)
        @     return; // No fence was signaled
        @ frameCtx->FenceValue = 0;
        @ if (m_fence->GetCompletedValue() >= fenceValue)
        @     return;

        @ m_fence->SetEventOnCompletion(fenceValue, m_fenceEvent);
        @ ::WaitForSingleObject(m_fenceEvent, INFINITE);
    }

    方法 _WaitForNextFrameResources <公开 类型 = 变整数 返回值注释 = "FrameContext*" 折叠 @禁止流程检查 = 真>
    {
        @ UINT nextFrameIndex = m_frameIndex + 1;
        @ m_frameIndex = nextFrameIndex;

        @ HANDLE waitableObjects[] = { m_hSwapChainWaitableObject, nullptr };
        @ DWORD numWaitableObjects = 1;

        @ FrameContext* frameCtx = &m_frameContext[nextFrameIndex % APP_NUM_FRAMES_IN_FLIGHT];
        @ UINT64 fenceValue = frameCtx->FenceValue;
        @ if (fenceValue != 0) // means no fence was signaled
        @ {
        @     frameCtx->FenceValue = 0;
        @     m_fence->SetEventOnCompletion(fenceValue, m_fenceEvent);
        @     waitableObjects[1] = m_fenceEvent;
        @     numWaitableObjects = 2;
        @ }

        @ WaitForMultipleObjects(numWaitableObjects, waitableObjects, TRUE, INFINITE);

        @ return reinterpret_cast<INT_P>(frameCtx);
    }

    # @begin
    # <> <global>
    # <> <include>
    # // Simple free list based allocator
    # struct ExampleDescriptorHeapAllocator
    # {
    #     ID3D12DescriptorHeap*       Heap = nullptr;
    #     D3D12_DESCRIPTOR_HEAP_TYPE  HeapType = D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES;
    #     D3D12_CPU_DESCRIPTOR_HANDLE HeapStartCpu;
    #     D3D12_GPU_DESCRIPTOR_HANDLE HeapStartGpu;
    #     UINT                        HeapHandleIncrement;
    #     ImVector<int>               FreeIndices;
    #
    #     void Create(ID3D12Device* device, ID3D12DescriptorHeap* heap)
    #     {
    #         IM_ASSERT(Heap == nullptr && FreeIndices.empty());
    #         Heap = heap;
    #         D3D12_DESCRIPTOR_HEAP_DESC desc = heap->GetDesc();
    #         HeapType = desc.Type;
    #         HeapStartCpu = Heap->GetCPUDescriptorHandleForHeapStart();
    #         HeapStartGpu = Heap->GetGPUDescriptorHandleForHeapStart();
    #         HeapHandleIncrement = device->GetDescriptorHandleIncrementSize(HeapType);
    #         FreeIndices.reserve((int)desc.NumDescriptors);
    #         for (int n = desc.NumDescriptors; n > 0; n--)
    #             FreeIndices.push_back(n - 1);
    #     }
    #     void Destroy()
    #     {
    #         Heap = nullptr;
    #         FreeIndices.clear();
    #     }
    #     void Alloc(D3D12_CPU_DESCRIPTOR_HANDLE* out_cpu_desc_handle, D3D12_GPU_DESCRIPTOR_HANDLE* out_gpu_desc_handle)
    #     {
    #         IM_ASSERT(FreeIndices.Size > 0);
    #         int idx = FreeIndices.back();
    #         FreeIndices.pop_back();
    #         out_cpu_desc_handle->ptr = HeapStartCpu.ptr + (idx * HeapHandleIncrement);
    #         out_gpu_desc_handle->ptr = HeapStartGpu.ptr + (idx * HeapHandleIncrement);
    #     }
    #     void Free(D3D12_CPU_DESCRIPTOR_HANDLE out_cpu_desc_handle, D3D12_GPU_DESCRIPTOR_HANDLE out_gpu_desc_handle)
    #     {
    #         int cpu_idx = (int)((out_cpu_desc_handle.ptr - HeapStartCpu.ptr) / HeapHandleIncrement);
    #         int gpu_idx = (int)((out_gpu_desc_handle.ptr - HeapStartGpu.ptr) / HeapHandleIncrement);
    #         IM_ASSERT(cpu_idx == gpu_idx);
    #         FreeIndices.push_back(cpu_idx);
    #     }
    # };
    # static ExampleDescriptorHeapAllocator g_pd3dSrvDescHeapAlloc;
    # <> </include>
    # <> </global>
    #
    # <> <include>
    # #ifdef DX12_ENABLE_DEBUG_LAYER
    # #include <dxgidebug.h>
    # #pragma comment(lib, "dxguid.lib")
    # #endif
    #
    # static constexpr int APP_NUM_FRAMES_IN_FLIGHT = 2;
    # static constexpr int APP_NUM_BACK_BUFFERS = 2;
    # static constexpr int APP_SRV_HEAP_SIZE = 64;
    #
    # struct FrameContext
    # {
    #     ID3D12CommandAllocator*  CommandAllocator;
    #     UINT64                   FenceValue;
    # };
    #
    #
    # FrameContext                 m_frameContext[APP_NUM_FRAMES_IN_FLIGHT] = {};
    # UINT                         m_frameIndex = 0;
    #
    # ID3D12Device*                m_pd3dDevice = nullptr;
    # ID3D12DescriptorHeap*        m_pd3dRtvDescHeap = nullptr;
    # ID3D12DescriptorHeap*        m_pd3dSrvDescHeap = nullptr;
    #
    # ID3D12CommandQueue*          m_pd3dCommandQueue = nullptr;
    # ID3D12GraphicsCommandList*   m_pd3dCommandList = nullptr;
    # ID3D12Fence*                 m_fence = nullptr;
    # HANDLE                       m_fenceEvent = nullptr;
    # UINT64                       m_fenceLastSignaledValue = 0;
    # IDXGISwapChain3*             m_pSwapChain = nullptr;
    # bool                         m_SwapChainOccluded = false;
    # HANDLE                       m_hSwapChainWaitableObject = nullptr;
    # ID3D12Resource*              m_mainRenderTargetResource[APP_NUM_BACK_BUFFERS] = {};
    # D3D12_CPU_DESCRIPTOR_HANDLE  m_mainRenderTargetDescriptor[APP_NUM_BACK_BUFFERS] = {};
    # int                          m_descriptor_index = 0;
    # HWND                         m_hwnd = nullptr;
    # <> </include>
    # @end
}

类 IM_OpenGL渲染器 <公开 注释 = "基于现代OpenGL的渲染器后端,支持桌面OpenGL版本: 2.x 3.x 4.x" 折叠 折叠2 @文档 = "category = \"渲染器\""
        @视窗.外部头文件 = "wingdi.h\r\n<backends/imgui_impl_opengl3.h>\r\n<glad/glad.h>"
        @视窗.外部源文件 = "imgui\\backends\\imgui_impl_opengl3.cpp\r\nFrameWork\\glad\\glad.c"
        @视窗.外部库 = "Opengl32.lib">
{
    变量 窗口宽度 <公开 类型 = 整数 值 = 0 @输出名 = "m_Width">
    变量 窗口高度 <公开 类型 = 整数 值 = 0 @输出名 = "m_Height">

    方法 垂直同步 <公开 属性写 注释 = "OpenGL可以随时后续切换垂直同步的开关" 折叠 "">
    参数 是否开启 <类型 = 逻辑型>
    {
        @ typedef void*(WINAPI *PFNWGLGETPROCADDRESS)(const char*);
        @ typedef BOOL(WINAPI *PFNWGLSWAPINTERVALEXT)(int);
        @ static PFNWGLGETPROCADDRESS _wglGetProcAddress = (PFNWGLGETPROCADDRESS)::GetProcAddress(::GetModuleHandleW(L"opengl32.dll"), "wglGetProcAddress");
        @ static PFNWGLSWAPINTERVALEXT _wglSwapIntervalEXT = (PFNWGLSWAPINTERVALEXT)_wglGetProcAddress("wglSwapIntervalEXT");
        @ if (_wglSwapIntervalEXT)
        @     _wglSwapIntervalEXT(@<是否开启>);
    }

    方法 渲染器类型 <公开 属性读 类型 = 整数 注释 = "返回渲染器类型(固定返回0,表示OpenGL渲染器)" 折叠>
    {
        返回 (0)
    }

    方法 渲染器名称 <公开 属性读 类型 = 文本型 折叠>
    {
        返回 ("OpenGL")
    }

    方法 允许修改帧率 <公开 属性读 类型 = 逻辑型 折叠>
    {
        返回 (真)
    }

    方法 初始化 <公开 类型 = 逻辑型 注释 = "在\"创建设备\"和\"ImGui.创建环境()\"后才能调用." 折叠 @禁止流程检查 = 真>
    参数 GLSL版本 <类型 = 文本型 注释 = "请提供一个\"#version XXX\"的GLSL版本,留空为默认值\"#version 130\"."
            注释 = "下列是OpenGL和GLSL版本的对应表:" 注释 = "// OpenGL    GLSL      GLSL" 注释 = "// version   version   string"
            注释 = "//----------------------------------------" 注释 = "//  2.0       110       \"#version 110\""
            注释 = "//  2.1       120       \"#version 120\"" 注释 = "//  3.0       130       \"#version 130\""
            注释 = "//  3.1       140       \"#version 140\"" 注释 = "//  3.2       150       \"#version 150\""
            注释 = "//  3.3       330       \"#version 330 core\""
            注释 = "//  4.0       400       \"#version 400 core\""
            注释 = "//  4.1       410       \"#version 410 core\""
            注释 = "//  4.2       420       \"#version 410 core\""
            注释 = "//  4.3       430       \"#version 430 core\""
            注释 = "//  ES 2.0    100       \"#version 100\"      = WebGL 1.0"
            注释 = "//  ES 3.0    300       \"#version 300 es\"   = WebGL 2.0" @默认值 = "#version 330 core">
    {
        @ return ImGui_ImplOpenGL3_Init(@<GLSL版本>.IsEmpty() ? nullptr : PivW2U(@<GLSL版本>).c_str());
    }

    方法 关闭 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplOpenGL3_Shutdown()
    }

    方法 新建帧 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplOpenGL3_NewFrame()
    }

    方法 渲染数据 <公开 折叠 @嵌入式方法 = "">
    参数 绘制数据 <类型 = IM绘制数据指针 注释 = "由\"ImGui.取渲染数据()\"返回">
    {
        @ ImGui_ImplOpenGL3_RenderDrawData(@<绘制数据>)
    }

    方法 加载字体纹理 <公开 注释 = "(可选项)已在\"初始化/关闭/新建帧\"时自动调用" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplOpenGL3_CreateFontsTexture()
    }

    方法 销毁字体纹理 <公开 注释 = "(可选项)已在\"初始化/关闭/新建帧\"时自动调用" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplOpenGL3_DestroyFontsTexture()
    }

    方法 创建设备对象 <公开 注释 = "(可选项)已在\"初始化/关闭/新建帧\"时自动调用" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplOpenGL3_CreateDeviceObjects()
    }

    方法 销毁设备对象 <公开 注释 = "(可选项)已在\"初始化/关闭/新建帧\"时自动调用" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplOpenGL3_DestroyDeviceObjects()
    }

    # 纹理图片 ---

    方法 加载图片文件 <公开 类型 = 逻辑型 注释 = "从指定的图片文件加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ PivImage image;
        @ unsigned char* image_data = image.load(@<文件名>.GetText(), 4);
        @ if (!image_data) return FALSE;
        @ @<图片信息.纹理ID> = @<_加载纹理>(image_data, image.x, image.y);
        @ @<图片信息.宽度> = image.x;
        @ @<图片信息.高度> = image.y;
        @ return TRUE;
    }

    方法 加载图片资源 <公开 类型 = 逻辑型 注释 = "将程序文件中的图片资源加载到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片资源 <类型 = 视窗文件资源 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ HMODULE hModule = g_objVolApp.GetInstanceHandle();
        @ HRSRC hSrc = ::FindResourceW(hModule, MAKEINTRESOURCE((WORD)@<图片资源>), RT_RCDATA);
        @ if (!hSrc) return FALSE;
        @ HGLOBAL resdata = ::LoadResource(hModule, hSrc);
        @ if (!resdata) return FALSE;
        @ unsigned char* data = reinterpret_cast<unsigned char*>(::LockResource(resdata));
        @ int len = static_cast<int>(::SizeofResource(hModule, hSrc));
        @ PivImage image;
        @ unsigned char* image_data = image.load(data, len, 4);
        @ if (!image_data) return FALSE;
        @ @<图片信息.纹理ID> = @<_加载纹理>(image_data, image.x, image.y);
        @ @<图片信息.宽度> = image.x;
        @ @<图片信息.高度> = image.y;
        @ return TRUE;
    }

    方法 加载图片字节集 <公开 类型 = 逻辑型 注释 = "从指定的图片字节集加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片数据 <类型 = 字节集类 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ PivImage image;
        @ unsigned char* image_data = image.load(@<图片数据>.GetPtr(), static_cast<int>(@<图片数据>.GetSize()), 4);
        @ if (!image_data) return FALSE;
        @ @<图片信息.纹理ID> = @<_加载纹理>(image_data, image.x, image.y);
        @ @<图片信息.宽度> = image.x;
        @ @<图片信息.高度> = image.y;
        @ return TRUE;
    }

    方法 _加载纹理 <类型 = 无符号长整数 折叠 @禁止流程检查 = 真>
    参数 image_data <类型 = PIV.类型.字节集指针 @输出名 = "image_data">
    参数 image_width <类型 = 整数 @输出名 = "image_width">
    参数 image_height <类型 = 整数 @输出名 = "image_height">
    {
        // Create a OpenGL texture identifier
        @ GLuint image_texture;
        @ glGenTextures(1, &image_texture);
        @ glBindTexture(GL_TEXTURE_2D, image_texture);

        // Setup filtering parameters for display
        @ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        @ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

        // Upload pixels into texture
        @ glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
        @ glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image_width, image_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image_data);
        @ return image_texture;
    }

    方法 释放纹理 <公开 注释 = "释放图片纹理和对应的内存,之后不能再使用这个纹理ID." 折叠>
    参数 图片信息 <类型 = IM图片信息类 注释 = "提供由\"本对象.加载图片××\"返回的图片信息">
    {
        如果 (图片信息.纹理ID != 0)
        {
            @ glDeleteTextures(1, reinterpret_cast<GLuint*>(&@<图片信息.纹理ID>));
        }
        图片信息.重置为空对象 ()
    }

    # Win32平台 ---

    方法 创建设备 <公开 类型 = 逻辑型 折叠 折叠2 @视窗.外部库 = "OpenGL32.lib" @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数>
    {
        @ m_hwnd = (HWND)@<窗口句柄>;
        @ @<_CreateDeviceWGL>(m_hwnd, &m_MainWindow);
        @ if (!g_hRC)
        @     g_hRC = wglCreateContext(m_MainWindow.hDC);
        @ wglMakeCurrent(m_MainWindow.hDC, g_hRC);
        @ if (!gladLoadGL())
        @ {
        @     this->@<释放设备>();
        @     return FALSE;
        @ }
        @ return TRUE;
    }

    方法 释放设备 <公开 折叠>
    {
        @ wglMakeCurrent(nullptr, nullptr);
        @ ::ReleaseDC(m_hwnd, m_MainWindow.hDC);
        @ m_MainWindow.hDC = nullptr;
        @ m_hwnd = nullptr;
        @ if (g_hRC)
        @ {
        @     wglDeleteContext(g_hRC);
        @     g_hRC = nullptr;
        @ }
    }

    方法 重置尺寸 <公开 折叠>
    {
        // @ glViewport(0, 0, m_Width, m_Height);
    }

    方法 渲染 <公开 折叠>
    参数 背景颜色 <类型 = ImVec4 @输出名 = "clear_color">
    {
        @ ImGui::Render();
        @ glViewport(0, 0, m_Width, m_Height);
        @ glClearColor(clear_color.x * clear_color.w, clear_color.y * clear_color.w, clear_color.z * clear_color.w, clear_color.w);
        @ glClear(GL_COLOR_BUFFER_BIT);
        @ ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     ImGui::UpdatePlatformWindows();
        @     ImGui::RenderPlatformWindowsDefault();
        @     wglMakeCurrent(m_MainWindow.hDC, g_hRC);
        @ }
        @ ::SwapBuffers(m_MainWindow.hDC);
    }

    方法 准备 <公开 折叠>
    {
        // Win32+GL needs specific hooks for viewport, as there are specific things needed to tie Win32 and GL api.
        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
        @     IM_ASSERT(platform_io.Renderer_CreateWindow == NULL);
        @     IM_ASSERT(platform_io.Renderer_DestroyWindow == NULL);
        @     IM_ASSERT(platform_io.Renderer_SwapBuffers == NULL);
        @     IM_ASSERT(platform_io.Platform_RenderWindow == NULL);
        @     platform_io.Renderer_CreateWindow = Hook_Renderer_CreateWindow;
        @     platform_io.Renderer_DestroyWindow = Hook_Renderer_DestroyWindow;
        @     platform_io.Renderer_SwapBuffers = Hook_Renderer_SwapBuffers;
        @     platform_io.Platform_RenderWindow = Hook_Platform_RenderWindow;
        @ }
    }

    方法 是否不可视 <公开 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    {
        @ if (::IsIconic(m_hwnd))
        @ {
        @     ::Sleep(10);
        @     return true;
        @ }
        @ return false;
    }

    方法 帧前处理 <公开 折叠>
    {

    }

    # GLFW平台 ---

    方法 创建设备_GLFW <公开 类型 = 逻辑型 注释 = "*适用于GLFW平台" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ gladLoadGL() != 0
    }

    方法 渲染_GLFW <公开 折叠>
    参数 窗口句柄 <类型 = 变整数>
    参数 背景颜色 <类型 = ImVec4 @输出名 = "clear_color">
    {
        @ ImGui::Render();
        @ glfwGetFramebufferSize(reinterpret_cast<GLFWwindow*>(@<窗口句柄>), &m_Width, &m_Height);
        @ glViewport(0, 0, m_Width, m_Height);
        @ glClearColor(clear_color.x * clear_color.w, clear_color.y * clear_color.w, clear_color.z * clear_color.w, clear_color.w);
        @ glClear(GL_COLOR_BUFFER_BIT);
        @ ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     GLFWwindow* backup_current_context = glfwGetCurrentContext();
        @     ImGui::UpdatePlatformWindows();
        @     ImGui::RenderPlatformWindowsDefault();
        @     glfwMakeContextCurrent(backup_current_context);
        @ }

        @ glfwSwapBuffers(reinterpret_cast<GLFWwindow*>(@<窗口句柄>)); // 双缓冲: 交换缓冲区
    }

    方法 释放设备_GLFW <公开>

    # SDL平台 ---

    方法 创建设备_SDL2 <公开 类型 = 逻辑型 折叠 @视窗.外部头文件 = "<SDL_opengl.h>" @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ gladLoadGL() != 0
    }

    方法 创建设备_SDL3 <公开 类型 = 逻辑型 折叠 @视窗.外部头文件 = "<SDL3/SDL_opengl.h>" @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ gladLoadGL() != 0
    }

    方法 渲染_SDL <公开 折叠>
    参数 窗口句柄 <类型 = 变整数>
    参数 背景颜色 <类型 = ImVec4>
    {
        @ ImGui::Render();
        @ glClearColor(@<背景颜色>.x * @<背景颜色>.w, @<背景颜色>.y * @<背景颜色>.w, @<背景颜色>.z * @<背景颜色>.w, @<背景颜色>.w);
        @ glClear(GL_COLOR_BUFFER_BIT);
        @ ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     SDL_Window* backup_current_window = SDL_GL_GetCurrentWindow();
        @     SDL_GLContext backup_current_context = SDL_GL_GetCurrentContext();
        @     ImGui::UpdatePlatformWindows();
        @     ImGui::RenderPlatformWindowsDefault();
        @     SDL_GL_MakeCurrent(backup_current_window, backup_current_context);
        @ }
        @ SDL_GL_SwapWindow(reinterpret_cast<SDL_Window*>(@<窗口句柄>));
    }

    # ---

    方法 _CreateDeviceWGL <静态 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 hWnd <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/HWND" @输出名 = "hWnd">
    参数 data <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/WGL_WindowData*" @输出名 = "data">
    {
        @ HDC hDc = ::GetDC(hWnd);
        @ PIXELFORMATDESCRIPTOR pfd = {sizeof(pfd), 1, PFD_DRAW_TO_WINDOW | PFD_DRAW_TO_BITMAP | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER | PFD_STEREO_DONTCARE,
        @                              PFD_TYPE_RGBA, 32, 8, 16, 8, 8, 8, 0, 8, 24, 64, 16, 16, 16, 32, 8, 4, PFD_MAIN_PLANE, 0, 0, 0, 0};
        @ const int pf = ::ChoosePixelFormat(hDc, &pfd);
        @ if (pf == 0 || ::SetPixelFormat(hDc, pf, &pfd) == FALSE)
        @     return FALSE;
        @ ::ReleaseDC(hWnd, hDc);
        @ data->hDC = ::GetDC(hWnd);
        @ return TRUE;
    }

    # ---
    # @begin
    # <> <global>
    # <> <include>
    # static HGLRC g_hRC;
    # <> </include>
    # <> </global>
    # <> <include>
    # HWND m_hwnd = NULL;
    # struct WGL_WindowData { HDC hDC; };
    # WGL_WindowData m_MainWindow { 0 };
    # static void Hook_Renderer_CreateWindow(ImGuiViewport* viewport)
    # {
    #     WGL_WindowData* data = IM_NEW(WGL_WindowData);
    #     @<_CreateDeviceWGL>(reinterpret_cast<HWND>(viewport->PlatformHandle), data);
    #     viewport->RendererUserData = data;
    # }
    # static void Hook_Renderer_DestroyWindow(ImGuiViewport* viewport)
    # {
    #     if (viewport->RendererUserData != NULL)
    #     {
    #         WGL_WindowData* data = reinterpret_cast<WGL_WindowData*>(viewport->RendererUserData);
    #         wglMakeCurrent(NULL, NULL);
    #         ::ReleaseDC(reinterpret_cast<HWND>(viewport->PlatformHandle), data->hDC);
    #         IM_DELETE(data);
    #         viewport->RendererUserData = NULL;
    #     }
    # }
    # static void Hook_Platform_RenderWindow(ImGuiViewport* viewport, void*)
    # {
    #     if (WGL_WindowData* data = reinterpret_cast<WGL_WindowData*>(viewport->RendererUserData))
    #         wglMakeCurrent(data->hDC, g_hRC);
    # }
    # static void Hook_Renderer_SwapBuffers(ImGuiViewport* viewport, void*)
    # {
    #     if (WGL_WindowData* data = reinterpret_cast<WGL_WindowData*>(viewport->RendererUserData))
    #         ::SwapBuffers(data->hDC);
    # }
    # <> </include>
    # @end
}

类 IM_Vulkan渲染器 <公开 注释 = "基于Vulkan的渲染器后端,Vulkan是OpenGL的下一代GPU API,目的就是取代OpenGL." 折叠 折叠2
        @文档 = "category = \"渲染器\"" @视窗.预定义宏 = "ImTextureID=ImU64"
        @视窗.外部头文件 = "<backends/imgui_impl_vulkan.h>" @视窗.外部源文件 = "imgui\\backends\\imgui_impl_vulkan.cpp"
        @视窗.外部库 = "FrameWork\\vulkan\\$(p)\\vulkan-1.lib" @视窗.附属文件 = "FrameWork\\vulkan\\$(p)\\vulkan-1.dll">
{
    变量 垂直同步 <公开 类型 = 逻辑型 值 = 真 注释 = "必须在\"创建设备_GLFW/创建设备_SDL2\"之前设置,后续更改无效." @输出名 = "m_vsync">
    变量 窗口宽度 <公开 类型 = 整数 值 = 0 @输出名 = "m_Width">
    变量 窗口高度 <公开 类型 = 整数 值 = 0 @输出名 = "m_Height">
    变量 最大图像数 <公开 类型 = 整数 值 = 1000 注释 = "最大允许加载的图像纹理数量,必须在初始化之前设置." @输出名 = "m_MaxCount">
    变量 _已创建 <类型 = 逻辑型 值 = 假>

    方法 渲染器类型 <公开 属性读 类型 = 整数 注释 = "返回渲染器类型(固定返回1,表示Vulkan渲染器)" 折叠>
    {
        返回 (1)
    }

    方法 渲染器名称 <公开 属性读 类型 = 文本型 折叠>
    {
        返回 ("Vulkan")
    }

    方法 允许修改帧率 <公开 属性读 类型 = 逻辑型 折叠>
    {
        返回 (取反 (_已创建))
    }

    方法 初始化 <公开 类型 = 逻辑型 注释 = "在\"创建设备\"和\"ImGui.创建环境()\"后才能调用." 折叠 @禁止流程检查 = 真>
    {
        @ #ifdef VK_USE_PLATFORM_WIN32_KHR
        @ ImGui::GetPlatformIO().Platform_CreateVkSurface = @<_ImGui_ImplWin32_CreateVkSurface>;
        @ #endif

        @ ImGui_ImplVulkan_InitInfo init_info = {};
        @ init_info.Instance = m_Instance;
        @ init_info.PhysicalDevice = m_PhysicalDevice;
        @ init_info.Device = m_Device;
        @ init_info.QueueFamily = m_QueueFamily;
        @ init_info.Queue = m_Queue;
        @ init_info.PipelineCache = m_PipelineCache;
        @ init_info.DescriptorPool = m_DescriptorPool;
        @ init_info.RenderPass = m_MainWindowData.RenderPass;
        @ init_info.Subpass = 0;
        @ init_info.MinImageCount = m_MinImageCount;
        @ init_info.ImageCount = m_MainWindowData.ImageCount;
        @ init_info.MSAASamples = VK_SAMPLE_COUNT_1_BIT;
        @ init_info.Allocator = m_Allocator;
        @ init_info.CheckVkResultFn = @sn<current_class>::check_vk_result;
        @ return ImGui_ImplVulkan_Init(&init_info);
    }

    方法 新建帧 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplVulkan_NewFrame()
    }

    方法 关闭 <公开 折叠>
    {
        @ VkResult err = vkDeviceWaitIdle(m_Device);
        @ check_vk_result(err);
        @ ImGui_ImplVulkan_Shutdown();
    }

    方法 渲染数据 <公开 折叠 @嵌入式方法 = "">
    参数 绘制数据 <类型 = IM绘制数据指针 注释 = "由\"ImGui.取渲染数据()\"返回">
    {
        @ ImGui_ImplVulkan_RenderDrawData(@<绘制数据>)
    }

    方法 加载字体纹理 <公开 注释 = "(可选项)已在\"新建帧\"时自动调用" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplVulkan_CreateFontsTexture()
    }

    方法 销毁字体纹理 <公开 注释 = "(可选项)用户无需调用" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplVulkan_DestroyFontsTexture()
    }

    # 纹理图片 ---

    方法 加载图片文件 <公开 类型 = 逻辑型 注释 = "从指定的图片文件加载纹理到渲染器中,不再使用时请调用\"释放纹理\"."
            注释 = "注意: 只能在\"IM_Vulkan渲染器.初始化\"之后使用,即\"准备渲染\"事件中." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ if (m_Device == VK_NULL_HANDLE) return FALSE;
        @ PivImage image;
        @ unsigned char* image_data = image.load(@<文件名>.GetText(), 4);
        @ @<图片信息.宽度> = image.x;
        @ @<图片信息.高度> = image.y;
        @ if (!image_data) return FALSE;
        @ MyTextureData* tex_data = new MyTextureData{};
        @ @<图片信息._内部数据> = tex_data;
        @ tex_data->Width = image.x;
        @ tex_data->Height = image.y;
        @ tex_data->Channels = 4;
        @ @<_加载纹理>(image_data, tex_data);
        @ @<图片信息.纹理ID> = reinterpret_cast<UINT64>(tex_data->DS);
        @ return TRUE;
    }

    方法 加载图片资源 <公开 类型 = 逻辑型 注释 = "将程序文件中的图片资源加载到渲染器中,不再使用时请调用\"释放纹理\"."
            注释 = "注意: 只能在\"IM_Vulkan渲染器.初始化\"之后使用,即\"准备渲染\"事件中." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片资源 <类型 = 视窗文件资源 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ if (m_Device == VK_NULL_HANDLE) return FALSE;
        @ HMODULE hModule = g_objVolApp.GetInstanceHandle();
        @ HRSRC hSrc = ::FindResourceW(hModule, MAKEINTRESOURCE((WORD)@<图片资源>), RT_RCDATA);
        @ if (!hSrc) return FALSE;
        @ HGLOBAL resdata = ::LoadResource(hModule, hSrc);
        @ if (!resdata) return FALSE;
        @ unsigned char* data = reinterpret_cast<unsigned char*>(::LockResource(resdata));
        @ int len = static_cast<int>(::SizeofResource(hModule, hSrc));
        @ PivImage image;
        @ unsigned char* image_data = image.load(data, len, 4);
        @ if (!image_data) return FALSE;
        @ @<图片信息.宽度> = image.x;
        @ @<图片信息.高度> = image.y;
        @ MyTextureData* tex_data = new MyTextureData{};
        @ tex_data->Width = @<图片信息.宽度>;
        @ tex_data->Height = @<图片信息.高度>;
        @ tex_data->Channels = 4;
        @ @<图片信息._内部数据> = tex_data;
        @ @<_加载纹理>(image_data, tex_data);
        @ @<图片信息.纹理ID> = reinterpret_cast<UINT64>(tex_data->DS);
        @ return TRUE;
    }

    方法 加载图片字节集 <公开 类型 = 逻辑型 注释 = "从指定的图片字节集加载纹理到渲染器中,不再使用时请调用\"释放纹理\"."
            注释 = "注意: 只能在\"IM_Vulkan渲染器.初始化\"之后使用,即\"准备渲染\"事件中." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片数据 <类型 = 字节集类 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ if (m_Device == VK_NULL_HANDLE) return FALSE;
        @ PivImage image;
        @ unsigned char* image_data = image.load(@<图片数据>.GetPtr(), static_cast<int>(@<图片数据>.GetSize()), 4);
        @ if (!image_data) return FALSE;
        @ @<图片信息.宽度> = image.x;
        @ @<图片信息.高度> = image.y;
        @ MyTextureData* tex_data = new MyTextureData{};
        @ @<图片信息._内部数据> = tex_data;
        @ tex_data->Width = @<图片信息.宽度>;
        @ tex_data->Height = @<图片信息.高度>;
        @ tex_data->Channels = 4;
        @ @<_加载纹理>(image_data, tex_data);
        @ @<图片信息.纹理ID> = reinterpret_cast<UINT64>(tex_data->DS);
        @ return TRUE;
    }

    方法 释放纹理 <公开 注释 = "释放图片纹理和对应的内存,之后不能再使用这个纹理ID." 折叠>
    参数 图片信息 <类型 = IM图片信息类 注释 = "提供由\"本对象.加载图片××\"返回图片的信息,释放后会清空信息.">
    {
        如果 (图片信息._内部数据 != 0)
        {
            @ MyTextureData* tex_data = reinterpret_cast<MyTextureData*>(@<图片信息._内部数据>);
            @ vkFreeMemory(m_Device, tex_data->UploadBufferMemory, nullptr);
            @ vkDestroyBuffer(m_Device, tex_data->UploadBuffer, nullptr);
            @ vkDestroySampler(m_Device, tex_data->Sampler, nullptr);
            @ vkDestroyImageView(m_Device, tex_data->ImageView, nullptr);
            @ vkDestroyImage(m_Device, tex_data->Image, nullptr);
            @ vkFreeMemory(m_Device, tex_data->ImageMemory, nullptr);
            @ ImGui_ImplVulkan_RemoveTexture(tex_data->DS);
            @ delete tex_data;
        }
        图片信息.重置为空对象 ()
    }

    方法 _加载纹理 <注释 = "仅限内部嵌入式使用" 折叠>
    参数 image_data <类型 = PIV.类型.字节集指针 @输出名 = "image_data">
    参数 tex_data <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/MyTextureData*" @输出名 = "tex_data">
    {
        // Calculate allocation size (in number of bytes)
        @ size_t image_size = tex_data->Width * tex_data->Height * tex_data->Channels;
        @ VkResult err;

        // Create the Vulkan image.
        @ {
        @     VkImageCreateInfo info = {};
        @     info.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
        @     info.imageType = VK_IMAGE_TYPE_2D;
        @     info.format = VK_FORMAT_R8G8B8A8_UNORM;
        @     info.extent.width = tex_data->Width;
        @     info.extent.height = tex_data->Height;
        @     info.extent.depth = 1;
        @     info.mipLevels = 1;
        @     info.arrayLayers = 1;
        @     info.samples = VK_SAMPLE_COUNT_1_BIT;
        @     info.tiling = VK_IMAGE_TILING_OPTIMAL;
        @     info.usage = VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT;
        @     info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
        @     info.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
        @     err = vkCreateImage(m_Device, &info, m_Allocator, &tex_data->Image);
        @     check_vk_result(err);
        @     VkMemoryRequirements req;
        @     vkGetImageMemoryRequirements(m_Device, tex_data->Image, &req);
        @     VkMemoryAllocateInfo alloc_info = {};
        @     alloc_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
        @     alloc_info.allocationSize = req.size;
        @     alloc_info.memoryTypeIndex = @<_findMemoryType>(req.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
        @     err = vkAllocateMemory(m_Device, &alloc_info, m_Allocator, &tex_data->ImageMemory);
        @     check_vk_result(err);
        @     err = vkBindImageMemory(m_Device, tex_data->Image, tex_data->ImageMemory, 0);
        @     check_vk_result(err);
        @ }

        // Create the Image View
        @ {
        @     VkImageViewCreateInfo info = {};
        @     info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
        @     info.image = tex_data->Image;
        @     info.viewType = VK_IMAGE_VIEW_TYPE_2D;
        @     info.format = VK_FORMAT_R8G8B8A8_UNORM;
        @     info.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        @     info.subresourceRange.levelCount = 1;
        @     info.subresourceRange.layerCount = 1;
        @     err = vkCreateImageView(m_Device, &info, m_Allocator, &tex_data->ImageView);
        @     check_vk_result(err);
        @ }

        // Create Sampler
        @ {
        @     VkSamplerCreateInfo sampler_info{};
        @     sampler_info.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
        @     sampler_info.magFilter = VK_FILTER_LINEAR;
        @     sampler_info.minFilter = VK_FILTER_LINEAR;
        @     sampler_info.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
        @     sampler_info.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT; // outside image bounds just use border color
        @     sampler_info.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
        @     sampler_info.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;
        @     sampler_info.minLod = -1000;
        @     sampler_info.maxLod = 1000;
        @     sampler_info.maxAnisotropy = 1.0f;
        @     err = vkCreateSampler(m_Device, &sampler_info, m_Allocator, &tex_data->Sampler);
        @     check_vk_result(err);
        @ }

        // Create Descriptor Set using ImGUI's implementation
        @ tex_data->DS = ImGui_ImplVulkan_AddTexture(tex_data->Sampler, tex_data->ImageView, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);

        // Create Upload Buffer
        @ {
        @     VkBufferCreateInfo buffer_info = {};
        @     buffer_info.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
        @     buffer_info.size = image_size;
        @     buffer_info.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
        @     buffer_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
        @     err = vkCreateBuffer(m_Device, &buffer_info, m_Allocator, &tex_data->UploadBuffer);
        @     check_vk_result(err);
        @     VkMemoryRequirements req;
        @     vkGetBufferMemoryRequirements(m_Device, tex_data->UploadBuffer, &req);
        @     VkMemoryAllocateInfo alloc_info = {};
        @     alloc_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
        @     alloc_info.allocationSize = req.size;
        @     alloc_info.memoryTypeIndex = @<_findMemoryType>(req.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
        @     err = vkAllocateMemory(m_Device, &alloc_info, m_Allocator, &tex_data->UploadBufferMemory);
        @     check_vk_result(err);
        @     err = vkBindBufferMemory(m_Device, tex_data->UploadBuffer, tex_data->UploadBufferMemory, 0);
        @     check_vk_result(err);
        @ }

        // Upload to Buffer:
        @ {
        @     void* map = NULL;
        @     err = vkMapMemory(m_Device, tex_data->UploadBufferMemory, 0, image_size, 0, &map);
        @     check_vk_result(err);
        @     memcpy(map, image_data, image_size);
        @     VkMappedMemoryRange range[1] = {};
        @     range[0].sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
        @     range[0].memory = tex_data->UploadBufferMemory;
        @     range[0].size = image_size;
        @     err = vkFlushMappedMemoryRanges(m_Device, 1, range);
        @     check_vk_result(err);
        @     vkUnmapMemory(m_Device, tex_data->UploadBufferMemory);
        @ }

        // Create a command buffer that will perform following steps when hit in the command queue.
        // TODO: this works in the example, but may need input if this is an acceptable way to access the pool/create the command buffer.
        @ VkCommandPool command_pool = m_MainWindowData.Frames[m_MainWindowData.FrameIndex].CommandPool;
        @ VkCommandBuffer command_buffer;
        @ {
        @     VkCommandBufferAllocateInfo alloc_info{};
        @     alloc_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
        @     alloc_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        @     alloc_info.commandPool = command_pool;
        @     alloc_info.commandBufferCount = 1;

        @     err = vkAllocateCommandBuffers(m_Device, &alloc_info, &command_buffer);
        @     check_vk_result(err);

        @     VkCommandBufferBeginInfo begin_info = {};
        @     begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        @     begin_info.flags |= VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
        @     err = vkBeginCommandBuffer(command_buffer, &begin_info);
        @     check_vk_result(err);
        @ }

        // Copy to Image
        @ {
        @     VkImageMemoryBarrier copy_barrier[1] = {};
        @     copy_barrier[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
        @     copy_barrier[0].dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        @     copy_barrier[0].oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
        @     copy_barrier[0].newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
        @     copy_barrier[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        @     copy_barrier[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        @     copy_barrier[0].image = tex_data->Image;
        @     copy_barrier[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        @     copy_barrier[0].subresourceRange.levelCount = 1;
        @     copy_barrier[0].subresourceRange.layerCount = 1;
        @     vkCmdPipelineBarrier(command_buffer, VK_PIPELINE_STAGE_HOST_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, NULL, 0, NULL, 1, copy_barrier);

        @     VkBufferImageCopy region = {};
        @     region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        @     region.imageSubresource.layerCount = 1;
        @     region.imageExtent.width = tex_data->Width;
        @     region.imageExtent.height = tex_data->Height;
        @     region.imageExtent.depth = 1;
        @     vkCmdCopyBufferToImage(command_buffer, tex_data->UploadBuffer, tex_data->Image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region);

        @     VkImageMemoryBarrier use_barrier[1] = {};
        @     use_barrier[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
        @     use_barrier[0].srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        @     use_barrier[0].dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
        @     use_barrier[0].oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
        @     use_barrier[0].newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
        @     use_barrier[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        @     use_barrier[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        @     use_barrier[0].image = tex_data->Image;
        @     use_barrier[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        @     use_barrier[0].subresourceRange.levelCount = 1;
        @     use_barrier[0].subresourceRange.layerCount = 1;
        @     vkCmdPipelineBarrier(command_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0, 0, NULL, 0, NULL, 1, use_barrier);
        @ }

        // End command buffer
        @ {
        @     VkSubmitInfo end_info = {};
        @     end_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
        @     end_info.commandBufferCount = 1;
        @     end_info.pCommandBuffers = &command_buffer;
        @     err = vkEndCommandBuffer(command_buffer);
        @     check_vk_result(err);
        @     err = vkQueueSubmit(m_Queue, 1, &end_info, VK_NULL_HANDLE);
        @     check_vk_result(err);
        @     err = vkDeviceWaitIdle(m_Device);
        @     check_vk_result(err);
        @ }
    }

    方法 _findMemoryType <类型 = PIV.类型.uint32_t 注释 = "仅限内部嵌入式使用" 折叠 @禁止流程检查 = 真>
    参数 type_filter <类型 = PIV.类型.uint32_t @输出名 = "type_filter">
    参数 properties <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/VkMemoryPropertyFlags" @输出名 = "properties">
    {
        @ VkPhysicalDeviceMemoryProperties mem_properties;
        @ vkGetPhysicalDeviceMemoryProperties(m_PhysicalDevice, &mem_properties);
        @ for (uint32_t i = 0; i < mem_properties.memoryTypeCount; i++)
        @     if ((type_filter & (1 << i)) && (mem_properties.memoryTypes[i].propertyFlags & properties) == properties)
        @         return i;
        @ return 0xFFFFFFFF; // Unable to find memoryType
    }

    # Win32平台 ---

    方法 创建设备 <公开 类型 = 逻辑型 折叠 @禁止流程检查 = 真 @视窗.预定义宏 = "VK_USE_PLATFORM_WIN32_KHR">
    参数 窗口句柄 <类型 = 变整数>
    {
        @ ImVector<const char*> extensions;
        @ extensions.push_back("VK_KHR_surface");
        @ extensions.push_back("VK_KHR_win32_surface");
        @ @<_SetupVulkan>(extensions);

        // Create Window Surface
        @ VkSurfaceKHR surface;
        @ VkWin32SurfaceCreateInfoKHR createInfo = {};
        @ createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
        @ createInfo.hwnd = (HWND)@<窗口句柄>;
        @ createInfo.hinstance = ::GetModuleHandle(nullptr);
        @ if (vkCreateWin32SurfaceKHR(m_Instance, &createInfo, nullptr, &surface) != VK_SUCCESS)
        @     return FALSE;

        @ m_MainWindowData.Surface = surface;
        @ @<_SetupVulkanWindow>(m_Width, m_Height);

        @ return TRUE;
    }

    方法 释放设备 <公开 折叠>
    {
        @ ImGui_ImplVulkanH_DestroyWindow(m_Instance, m_Device, &m_MainWindowData, m_Allocator);
        @ @<_CleanupVulkan>();
    }

    方法 重置尺寸 <公开 折叠>
    {
        @ if (m_Device != VK_NULL_HANDLE && m_Width > 0 && m_Height > 0 &&
        @    (m_SwapChainRebuild || m_MainWindowData.Width != m_Width || m_MainWindowData.Height != m_Height))
        @ {
        @     ImGui_ImplVulkan_SetMinImageCount(m_MinImageCount);
        @     ImGui_ImplVulkanH_CreateOrResizeWindow(m_Instance, m_PhysicalDevice, m_Device, &m_MainWindowData,
        @                                            m_QueueFamily, m_Allocator, m_Width, m_Height, m_MinImageCount);
        @     m_MainWindowData.FrameIndex = 0;
        @     m_SwapChainRebuild = false;
        @ }
    }

    方法 渲染 <公开 折叠>
    参数 背景颜色 <类型 = ImVec4 @输出名 = "clear_color">
    {
        @ ImGui::Render();
        @ ImDrawData* main_draw_data = ImGui::GetDrawData();
        @ const bool main_is_minimized = (main_draw_data->DisplaySize.x <= 0.0f || main_draw_data->DisplaySize.y <= 0.0f);
        @ m_MainWindowData.ClearValue.color.float32[0] = clear_color.x * clear_color.w;
        @ m_MainWindowData.ClearValue.color.float32[1] = clear_color.y * clear_color.w;
        @ m_MainWindowData.ClearValue.color.float32[2] = clear_color.z * clear_color.w;
        @ m_MainWindowData.ClearValue.color.float32[3] = clear_color.w;

        @ if (!main_is_minimized)
        @     @<_FrameRender>(main_draw_data);

        // Update and Render additional Platform Windows
        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     ImGui::UpdatePlatformWindows();
        @     ImGui::RenderPlatformWindowsDefault();
        @ }

        // Present Main Platform Window
        @ if (!main_is_minimized)
        @     @<_FramePresent>();
    }

    方法 准备 <公开 折叠>
    {

    }

    方法 是否不可视 <公开 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    {
        @ FALSE
    }

    方法 帧前处理 <公开 折叠>
    {

    }

    # GLFW

    方法 创建设备_GLFW <公开 类型 = 逻辑型 折叠 @禁止流程检查 = 真 @视窗.预定义宏 = "GLFW_INCLUDE_VULKAN">
    参数 窗口句柄 <类型 = 变整数>
    {
        @ if (!glfwVulkanSupported()) return FALSE;

        @ ImVector<const char*> extensions;
        @ uint32_t extensions_count = 0;
        @ const char** glfw_extensions = glfwGetRequiredInstanceExtensions(&extensions_count);
        @ for (uint32_t i = 0; i < extensions_count; i++)
        @     extensions.push_back(glfw_extensions[i]);
        @ @<_SetupVulkan>(extensions);

        // Create Window Surface ---
        @ VkSurfaceKHR surface;
        @ VkResult err = glfwCreateWindowSurface(m_Instance, reinterpret_cast<GLFWwindow*>(@<窗口句柄>), m_Allocator, &surface);
        @ check_vk_result(err);

        // Create Framebuffers
        @ int w, h;
        @ glfwGetFramebufferSize(reinterpret_cast<GLFWwindow*>(@<窗口句柄>), &w, &h);
        @ m_MainWindowData.Surface = surface;
        @ @<_SetupVulkanWindow>(w, h);
        @ return TRUE;
    }

    方法 渲染_GLFW <公开 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    参数 背景颜色 <类型 = ImVec4>
    {
        @ @sn<this>.@<渲染>(@<背景颜色>)
    }

    方法 释放设备_GLFW <公开 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.@<释放设备>()
    }

    # SDL

    方法 创建设备_SDL2 <公开 类型 = 逻辑型 折叠 @视窗.外部头文件 = "<SDL_vulkan.h>" @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数>
    {
        @ SDL_Window* window = reinterpret_cast<SDL_Window*>(@<窗口句柄>);
        @ ImVector<const char*> extensions;
        @ uint32_t extensions_count = 0;
        @ SDL_Vulkan_GetInstanceExtensions(window, &extensions_count, nullptr);
        @ extensions.resize(extensions_count);
        @ SDL_Vulkan_GetInstanceExtensions(window, &extensions_count, extensions.Data);
        @ @<_SetupVulkan>(extensions);

        // Create Window Surface ---
        @ VkSurfaceKHR surface;
        @ if (SDL_Vulkan_CreateSurface(window, m_Instance, &surface) == 0)
        @     return FALSE;

        // Create Framebuffers
        @ int width, height;
        @ SDL_GetWindowSize(window, &width, &height);
        @ m_MainWindowData.Surface = surface;
        @ @<_SetupVulkanWindow>(width, height);
        @ return TRUE;
    }

    方法 创建设备_SDL3 <公开 类型 = 逻辑型 折叠 @视窗.外部头文件 = "<SDL3/SDL_vulkan.h>" @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ SDL_Window* window = reinterpret_cast<SDL_Window*>(@<窗口句柄>);
        @ ImVector<const char*> extensions;
        @ {
        @     uint32_t sdl_extensions_count = 0;
        @     const char* const* sdl_extensions = SDL_Vulkan_GetInstanceExtensions(&sdl_extensions_count);
        @     for (uint32_t n = 0; n < sdl_extensions_count; n++)
        @         extensions.push_back(sdl_extensions[n]);
        @ }
        @ @<_SetupVulkan>(extensions);

        // Create Window Surface ---
        @ VkSurfaceKHR surface;
        @ if (SDL_Vulkan_CreateSurface(window, m_Instance, m_Allocator, &surface) == 0)
        @     return FALSE;

        // Create Framebuffers
        @ int width, height;
        @ SDL_GetWindowSize(window, &width, &height);
        @ m_MainWindowData.Surface = surface;
        @ @<_SetupVulkanWindow>(width, height);
        @ return TRUE;
    }

    方法 渲染_SDL <公开 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 背景颜色 <类型 = ImVec4>
    {
        @ @sn<this>.@<渲染>(@<背景颜色>)
    }

    # ---

    方法 _SetupVulkan <注释 = "仅限内部嵌入使用" 折叠>
    参数 instance_extensions <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/ImVector<const char*>"
            @输出名 = "instance_extensions">
    {
        @ VkResult err;
        @ #ifdef IMGUI_IMPL_VULKAN_USE_VOLK
        @ volkInitialize();
        @ #endif

        // Create Vulkan Instance
        @ {
        @     VkInstanceCreateInfo create_info = {};
        @     create_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;

        @     // Enumerate available extensions
        @     uint32_t properties_count;
        @     ImVector<VkExtensionProperties> properties;
        @     vkEnumerateInstanceExtensionProperties(nullptr, &properties_count, nullptr);
        @     properties.resize(properties_count);
        @     err = vkEnumerateInstanceExtensionProperties(nullptr, &properties_count, properties.Data);
        @     check_vk_result(err);

        @     // Enable required extensions
        @     for (const VkExtensionProperties& p : properties) {
        @         if (strcmp(p.extensionName, VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME) == 0) {
        @             instance_extensions.push_back(VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);  break;
        @         }
        @     }
        @ #ifdef VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME
        @     for (const VkExtensionProperties& p : properties) {
        @         if (strcmp(p.extensionName, VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME) == 0) {
        @             instance_extensions.push_back(VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME);
        @             create_info.flags |= VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR;  break;
        @         }
        @     }
        @ #endif

        @     // Enabling validation layers
        @ #ifdef APP_USE_VULKAN_DEBUG_REPORT
        @     const char* layers[] = { "VK_LAYER_KHRONOS_validation" };
        @     create_info.enabledLayerCount = 1;
        @     create_info.ppEnabledLayerNames = layers;
        @     instance_extensions.push_back("VK_EXT_debug_report");
        @ #endif

        @     // Create Vulkan Instance
        @     create_info.enabledExtensionCount = (uint32_t)instance_extensions.Size;
        @     create_info.ppEnabledExtensionNames = instance_extensions.Data;
        @     err = vkCreateInstance(&create_info, m_Allocator, &m_Instance);
        @     check_vk_result(err);
        @ #ifdef IMGUI_IMPL_VULKAN_USE_VOLK
        @     volkLoadInstance(m_Instance);
        @ #endif

        @     // Setup the debug report callback
        @ #ifdef APP_USE_VULKAN_DEBUG_REPORT
        @     auto f_vkCreateDebugReportCallbackEXT = (PFN_vkCreateDebugReportCallbackEXT)vkGetInstanceProcAddr(m_Instance, "vkCreateDebugReportCallbackEXT");
        @     IM_ASSERT(f_vkCreateDebugReportCallbackEXT != nullptr);
        @     VkDebugReportCallbackCreateInfoEXT debug_report_ci = {};
        @     debug_report_ci.sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
        @     debug_report_ci.flags = VK_DEBUG_REPORT_ERROR_BIT_EXT | VK_DEBUG_REPORT_WARNING_BIT_EXT | VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT;
        @     debug_report_ci.pfnCallback = debug_report;
        @     debug_report_ci.pUserData = nullptr;
        @     err = f_vkCreateDebugReportCallbackEXT(m_Instance, &debug_report_ci, g_Allocator, &g_DebugReport);
        @     check_vk_result(err);
        @ #endif
        @ }

        // Select Physical Device (GPU)
        @ m_PhysicalDevice = ImGui_ImplVulkanH_SelectPhysicalDevice(m_Instance);
        @ IM_ASSERT(m_PhysicalDevice != VK_NULL_HANDLE);

        // Select graphics queue family
        @ m_QueueFamily = ImGui_ImplVulkanH_SelectQueueFamilyIndex(m_PhysicalDevice);
        @ IM_ASSERT(m_QueueFamily != (uint32_t)-1);

        // Create Logical Device (with 1 queue)
        @ {
        @     ImVector<const char*> device_extensions;
        @     device_extensions.push_back("VK_KHR_swapchain");

        @     // Enumerate physical device extension
        @     uint32_t properties_count;
        @     ImVector<VkExtensionProperties> properties;
        @     vkEnumerateDeviceExtensionProperties(m_PhysicalDevice, nullptr, &properties_count, nullptr);
        @     properties.resize(properties_count);
        @     vkEnumerateDeviceExtensionProperties(m_PhysicalDevice, nullptr, &properties_count, properties.Data);
        @ #ifdef VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME
        @     for (const VkExtensionProperties& p : properties) {
        @         if (strcmp(p.extensionName, VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME) == 0) {
        @             device_extensions.push_back(VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME); break;
        @         }
        @     }
        @ #endif

        @     const float queue_priority[] = { 1.0f };
        @     VkDeviceQueueCreateInfo queue_info[1] = {};
        @     queue_info[0].sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
        @     queue_info[0].queueFamilyIndex = m_QueueFamily;
        @     queue_info[0].queueCount = 1;
        @     queue_info[0].pQueuePriorities = queue_priority;
        @     VkDeviceCreateInfo create_info = {};
        @     create_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
        @     create_info.queueCreateInfoCount = sizeof(queue_info) / sizeof(queue_info[0]);
        @     create_info.pQueueCreateInfos = queue_info;
        @     create_info.enabledExtensionCount = (uint32_t)device_extensions.Size;
        @     create_info.ppEnabledExtensionNames = device_extensions.Data;
        @     err = vkCreateDevice(m_PhysicalDevice, &create_info, m_Allocator, &m_Device);
        @     check_vk_result(err);
        @     vkGetDeviceQueue(m_Device, m_QueueFamily, 0, &m_Queue);
        @ }

        // Create Descriptor Pool
        // If you wish to load e.g. additional textures you may need to alter pools sizes and maxSets.
        @ {
        @     VkDescriptorPoolSize pool_sizes[] =
        @     {
        @         { VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, IMGUI_IMPL_VULKAN_MINIMUM_IMAGE_SAMPLER_POOL_SIZE },
        @     };
        @     VkDescriptorPoolCreateInfo pool_info = {};
        @     pool_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
        @     pool_info.flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;
        @     pool_info.maxSets = m_MaxCount;
        @     for (VkDescriptorPoolSize& pool_size : pool_sizes)
        @         pool_info.maxSets += pool_size.descriptorCount;
        @     pool_info.poolSizeCount = (uint32_t)IM_ARRAYSIZE(pool_sizes);
        @     pool_info.pPoolSizes = pool_sizes;
        @     err = vkCreateDescriptorPool(m_Device, &pool_info, m_Allocator, &m_DescriptorPool);
        @     check_vk_result(err);
        @ }
    }

    方法 _SetupVulkanWindow <注释 = "仅限内部嵌入使用" 折叠>
    参数 width <类型 = 整数 @输出名 = "width">
    参数 height <类型 = 整数 @输出名 = "height">
    {
        @ // Check for WSI support
        @ VkBool32 res;
        @ vkGetPhysicalDeviceSurfaceSupportKHR(m_PhysicalDevice, m_QueueFamily, m_MainWindowData.Surface, &res);
        @ if (res != VK_TRUE) exit(-1);

        @ // Select Surface Format
        @ const VkFormat requestSurfaceImageFormat[] = { VK_FORMAT_B8G8R8A8_UNORM, VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_B8G8R8_UNORM, VK_FORMAT_R8G8B8_UNORM };
        @ const VkColorSpaceKHR requestSurfaceColorSpace = VK_COLORSPACE_SRGB_NONLINEAR_KHR;
        @ m_MainWindowData.SurfaceFormat = ImGui_ImplVulkanH_SelectSurfaceFormat(m_PhysicalDevice, m_MainWindowData.Surface, requestSurfaceImageFormat, (size_t)IM_ARRAYSIZE(requestSurfaceImageFormat), requestSurfaceColorSpace);

        @ // Select Present Mode
        @ ImVector<VkPresentModeKHR> present_modes;
        @ if (!m_vsync) {
        @     present_modes.push_back(VK_PRESENT_MODE_MAILBOX_KHR);
        @     present_modes.push_back(VK_PRESENT_MODE_IMMEDIATE_KHR);
        @ }
        @ present_modes.push_back(VK_PRESENT_MODE_FIFO_KHR);
        @ m_MainWindowData.PresentMode = ImGui_ImplVulkanH_SelectPresentMode(m_PhysicalDevice, m_MainWindowData.Surface, present_modes.Data, present_modes.size());

        _已创建 = 真

        @ // Create SwapChain, RenderPass, Framebuffer, etc.
        @ IM_ASSERT(m_MinImageCount >= 2);
        @ ImGui_ImplVulkanH_CreateOrResizeWindow(m_Instance, m_PhysicalDevice, m_Device, &m_MainWindowData, m_QueueFamily, m_Allocator, width, height, m_MinImageCount);
    }

    方法 _CleanupVulkan <注释 = "仅限内部嵌入使用" 折叠>
    {
        @ vkDestroyDescriptorPool(m_Device, m_DescriptorPool, m_Allocator);

        @ #ifdef APP_USE_VULKAN_DEBUG_REPORT
        @     // Remove the debug report callback
        @     auto f_vkDestroyDebugReportCallbackEXT = (PFN_vkDestroyDebugReportCallbackEXT)vkGetInstanceProcAddr(m_Instance, "vkDestroyDebugReportCallbackEXT");
        @     f_vkDestroyDebugReportCallbackEXT(m_Instance, m_DebugReport, m_Allocator);
        @ #endif // APP_USE_VULKAN_DEBUG_REPORT

        @ vkDestroyDevice(m_Device, m_Allocator);
        @ vkDestroyInstance(m_Instance, m_Allocator);
    }

    方法 _FrameRender <注释 = "仅限内部嵌入使用" 折叠>
    参数 draw_data <类型 = IM绘制数据指针 @输出名 = "draw_data">
    {
        @ VkSemaphore image_acquired_semaphore  = m_MainWindowData.FrameSemaphores[m_MainWindowData.SemaphoreIndex].ImageAcquiredSemaphore;
        @ VkSemaphore render_complete_semaphore = m_MainWindowData.FrameSemaphores[m_MainWindowData.SemaphoreIndex].RenderCompleteSemaphore;
        @ VkResult err = vkAcquireNextImageKHR(m_Device, m_MainWindowData.Swapchain, UINT64_MAX, image_acquired_semaphore, VK_NULL_HANDLE, &m_MainWindowData.FrameIndex);
        @ if (err == VK_ERROR_OUT_OF_DATE_KHR || err == VK_SUBOPTIMAL_KHR)
        @     m_SwapChainRebuild = true;
        @ if (err == VK_ERROR_OUT_OF_DATE_KHR)
        @     return;
        @ if (err != VK_SUBOPTIMAL_KHR)
        @     check_vk_result(err);

        @ ImGui_ImplVulkanH_Frame* fd = &m_MainWindowData.Frames[m_MainWindowData.FrameIndex];
        @ {
        @     err = vkWaitForFences(m_Device, 1, &fd->Fence, VK_TRUE, UINT64_MAX);    // wait indefinitely instead of periodically checking
        @     check_vk_result(err);

        @     err = vkResetFences(m_Device, 1, &fd->Fence);
        @     check_vk_result(err);
        @ }
        @ {
        @     err = vkResetCommandPool(m_Device, fd->CommandPool, 0);
        @     check_vk_result(err);
        @     VkCommandBufferBeginInfo info = {};
        @     info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        @     info.flags |= VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
        @     err = vkBeginCommandBuffer(fd->CommandBuffer, &info);
        @     check_vk_result(err);
        @ }
        @ {
        @     VkRenderPassBeginInfo info = {};
        @     info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
        @     info.renderPass = m_MainWindowData.RenderPass;
        @     info.framebuffer = fd->Framebuffer;
        @     info.renderArea.extent.width = m_MainWindowData.Width;
        @     info.renderArea.extent.height = m_MainWindowData.Height;
        @     info.clearValueCount = 1;
        @     info.pClearValues = &m_MainWindowData.ClearValue;
        @     vkCmdBeginRenderPass(fd->CommandBuffer, &info, VK_SUBPASS_CONTENTS_INLINE);
        @ }

        // Record dear imgui primitives into command buffer
        @ ImGui_ImplVulkan_RenderDrawData(draw_data, fd->CommandBuffer);

        // Submit command buffer
        @ vkCmdEndRenderPass(fd->CommandBuffer);
        @ {
        @     VkPipelineStageFlags wait_stage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
        @     VkSubmitInfo info = {};
        @     info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
        @     info.waitSemaphoreCount = 1;
        @     info.pWaitSemaphores = &image_acquired_semaphore;
        @     info.pWaitDstStageMask = &wait_stage;
        @     info.commandBufferCount = 1;
        @     info.pCommandBuffers = &fd->CommandBuffer;
        @     info.signalSemaphoreCount = 1;
        @     info.pSignalSemaphores = &render_complete_semaphore;

        @     err = vkEndCommandBuffer(fd->CommandBuffer);
        @     check_vk_result(err);
        @     err = vkQueueSubmit(m_Queue, 1, &info, fd->Fence);
        @     check_vk_result(err);
        @ }
    }

    方法 _FramePresent <注释 = "仅限内部嵌入使用" 折叠>
    {
        @ if (m_SwapChainRebuild) return;
        @ VkSemaphore render_complete_semaphore = m_MainWindowData.FrameSemaphores[m_MainWindowData.SemaphoreIndex].RenderCompleteSemaphore;
        @ VkPresentInfoKHR info = {};
        @ info.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
        @ info.waitSemaphoreCount = 1;
        @ info.pWaitSemaphores = &render_complete_semaphore;
        @ info.swapchainCount = 1;
        @ info.pSwapchains = &m_MainWindowData.Swapchain;
        @ info.pImageIndices = &m_MainWindowData.FrameIndex;
        @ VkResult err = vkQueuePresentKHR(m_Queue, &info);
        @ if (err == VK_ERROR_OUT_OF_DATE_KHR || err == VK_SUBOPTIMAL_KHR)
        @     m_SwapChainRebuild = true;
        @ if (err == VK_ERROR_OUT_OF_DATE_KHR)
        @     return;
        @ if (err != VK_SUBOPTIMAL_KHR)
        @     check_vk_result(err);
        @ m_MainWindowData.SemaphoreIndex = (m_MainWindowData.SemaphoreIndex + 1) % m_MainWindowData.SemaphoreCount; // Now we can use the next set of semaphores
    }

    方法 _ImGui_ImplWin32_CreateVkSurface <静态 类型 = 整数 注释 = "仅限内部嵌入使用" 折叠 @禁止流程检查 = 真>
    参数 viewport <类型 = IM视口指针 @输出名 = "viewport">
    参数 vk_instance <类型 = 无符号长整数 @输出名 = "vk_instance">
    参数 vk_allocator <类型 = 通用指针 @输出名 = "vk_allocator" @视窗.前缀文本 = "const ">
    参数 out_vk_surface <类型 = 无符号长整数 @输出名 = "out_vk_surface" @视窗.后缀文本 = "*">
    {
        @ #ifdef VK_USE_PLATFORM_WIN32_KHR
        @ VkWin32SurfaceCreateInfoKHR createInfo = {};
        @ createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
        @ createInfo.hwnd = (HWND)viewport->PlatformHandleRaw;
        @ createInfo.hinstance = ::GetModuleHandle(nullptr);
        @ return (int)vkCreateWin32SurfaceKHR((VkInstance)vk_instance, &createInfo, (VkAllocationCallbacks*)vk_allocator, (VkSurfaceKHR*)out_vk_surface);
        @ #else
        @ return 0;
        @ #endif
    }

    # ---
    # @begin
    # <> <include>
    # VkAllocationCallbacks*   m_Allocator        = nullptr;
    # VkInstance               m_Instance         = VK_NULL_HANDLE;
    # VkPhysicalDevice         m_PhysicalDevice   = VK_NULL_HANDLE;
    # VkDevice                 m_Device           = VK_NULL_HANDLE;
    # uint32_t                 m_QueueFamily      = (uint32_t)-1;
    # VkQueue                  m_Queue            = VK_NULL_HANDLE;
    # VkDebugReportCallbackEXT m_DebugReport      = VK_NULL_HANDLE;
    # VkPipelineCache          m_PipelineCache    = VK_NULL_HANDLE;
    # VkDescriptorPool         m_DescriptorPool   = VK_NULL_HANDLE;
    # ImGui_ImplVulkanH_Window m_MainWindowData   = {};
    # uint32_t                 m_MinImageCount    = 2;
    # bool                     m_SwapChainRebuild = false;
    # struct MyTextureData // A struct to manage data related to one image in vulkan
    # {
    #     VkDescriptorSet DS;         // Descriptor set: this is what you'll pass to Image()
    #     int             Width;
    #     int             Height;
    #     int             Channels;
    #
    #     // Need to keep track of these to properly cleanup
    #     VkImageView     ImageView;
    #     VkImage         Image;
    #     VkDeviceMemory  ImageMemory;
    #     VkSampler       Sampler;
    #     VkBuffer        UploadBuffer;
    #     VkDeviceMemory  UploadBufferMemory;
    #     MyTextureData() { memset(this, 0, sizeof(*this)); }
    # };
    # static void check_vk_result(VkResult err)
    # {
    #     if (err == 0) return;
    #     if (err < 0) abort();
    # }
    # #ifdef APP_USE_VULKAN_DEBUG_REPORT
    # static VKAPI_ATTR VkBool32 VKAPI_CALL debug_report(VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage, void* pUserData)
    # {
    #     (void)flags; (void)object; (void)location; (void)messageCode; (void)pUserData; (void)pLayerPrefix; // Unused arguments
    #     fprintf(stderr, "[vulkan] Debug report from ObjectType: %i\nMessage: %s\n\n", objectType, pMessage);
    #     return VK_FALSE;
    # }
    # #endif // APP_USE_VULKAN_DEBUG_REPORT
    # <> </include>
    # @end
    #
}

类 "// IM_SDL3_GPU渲染器" <公开 注释 = "基于SDL3 GPU API的渲染器后端(有问题,待修复)" 折叠 折叠2 @文档 = "category = \"渲染器\""
        @视窗.外部头文件 = "<backends/imgui_impl_sdlgpu3.h>" @视窗.外部源文件 = "imgui\\backends\\imgui_impl_sdlgpu3.cpp">
{
    变量 垂直同步 <公开 类型 = 逻辑型 值 = 真 注释 = "可以在每次渲染时变更" @输出名 = "m_vsync">
    变量 窗口宽度 <公开 类型 = 整数 值 = 0 @输出名 = "m_Width">
    变量 窗口高度 <公开 类型 = 整数 值 = 0 @输出名 = "m_Height">

    方法 渲染器类型 <公开 属性读 类型 = 整数 注释 = "返回渲染器类型(固定返回8)" 折叠>
    {
        返回 (8)
    }

    方法 渲染器名称 <公开 属性读 类型 = 文本型 折叠>
    {
        返回 ("SDL3 GPU")
    }

    方法 允许修改帧率 <公开 属性读 类型 = 逻辑型 折叠>
    {
        返回 (真)
    }

    方法 初始化 <公开 类型 = 逻辑型 注释 = "在\"创建设备\"和\"ImGui.创建环境()\"后才能调用." 折叠 @禁止流程检查 = 真>
    {
        @ ImGui_ImplSDLGPU3_InitInfo init_info = {};
        @ init_info.Device = m_gpu_device;
        @ init_info.ColorTargetFormat = SDL_GetGPUSwapchainTextureFormat(m_gpu_device, m_window);
        @ init_info.MSAASamples = SDL_GPU_SAMPLECOUNT_1;
        @ return ImGui_ImplSDLGPU3_Init(&init_info);
    }

    方法 关闭 <公开 折叠>
    {
        @ SDL_WaitForGPUIdle(m_gpu_device);
        @ ImGui_ImplSDLGPU3_Shutdown();
    }

    方法 新建帧 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplSDLGPU3_NewFrame()
    }

    方法 重置尺寸 <公开>
    {

    }

    # 纹理图片 ---

    方法 加载图片文件 <公开 类型 = 逻辑型 注释 = "从指定的图片文件加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        // @ if (!m_pd3dDevice) return FALSE;
        // @ PivImage image;
        // @ unsigned char* image_data = image.load(@<文件名>.GetText(), 4);
        // @ if (!image_data) return FALSE;
        // @ @<图片信息.宽度> = image.x;
        // @ @<图片信息.高度> = image.y;
        // @ @<图片信息.纹理ID> = @<_加载纹理>(image_data, image.x, image.y);
        @ return TRUE;
    }

    方法 加载图片资源 <公开 类型 = 逻辑型 注释 = "将程序文件中的图片资源加载到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片资源 <类型 = 视窗文件资源 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        // @ HMODULE hModule = g_objVolApp.GetInstanceHandle();
        // @ HRSRC hSrc = ::FindResourceW(hModule, MAKEINTRESOURCE((WORD)@<图片资源>), RT_RCDATA);
        // @ if (!hSrc) return FALSE;
        // @ HGLOBAL resdata = ::LoadResource(hModule, hSrc);
        // @ if (!resdata) return FALSE;
        // @ PivImage image;
        // @ unsigned char* image_data = image.load(reinterpret_cast<unsigned char*>(::LockResource(resdata)), static_cast<int>(::SizeofResource(hModule, hSrc)), 4);
        // @ if (!image_data) return FALSE;
        // @ @<图片信息.宽度> = image.x;
        // @ @<图片信息.高度> = image.y;
        // @ @<图片信息.纹理ID> = @<_加载纹理>(image_data, image.x, image.y);
        @ return TRUE;
    }

    方法 加载图片字节集 <公开 类型 = 逻辑型 注释 = "从指定的图片字节集加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片数据 <类型 = 字节集类 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        // @ PivImage image;
        // @ unsigned char* image_data = image.load(@<图片数据>.GetPtr(), static_cast<int>(@<图片数据>.GetSize()), 4);
        // @ if (!image_data) return FALSE;
        // @ @<图片信息.宽度> = image.x;
        // @ @<图片信息.高度> = image.y;
        // @ @<图片信息.纹理ID> = @<_加载纹理>(image_data, image.x, image.y);
        @ return TRUE;
    }

    方法 "//_加载纹理" <类型 = 无符号长整数 折叠 @禁止流程检查 = 真>
    参数 image_data <类型 = PIV.类型.字节集指针 @输出名 = "image_data">
    参数 image_width <类型 = 整数 @输出名 = "image_width">
    参数 image_height <类型 = 整数 @输出名 = "image_height">
    {
        @ SDL_Surface* surface = SDL_CreateSurfaceFrom(image_width, image_height, SDL_PIXELFORMAT_RGBA32, (void*)image_data, 4 * image_width);
        @ if (surface == nullptr)
        @ {
        @     //fprintf(stderr, "Failed to create SDL surface: %s\n", SDL_GetError());
        @     return 0;
        @ }

        @ SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
        @ if (texture == nullptr)
        @     //fprintf(stderr, "Failed to create SDL texture: %s\n", SDL_GetError());

        @ return (UINT64)texture;
    }

    方法 释放纹理 <公开 注释 = "释放图片纹理和对应的内存,之后不能再使用这个纹理ID." 折叠>
    参数 图片信息 <类型 = IM图片信息类 注释 = "提供由\"本对象.加载图片××\"返回的图片信息,释放后会清空信息.">
    {
        // 如果 (图片信息.纹理ID != 0)
        {
            // @ reinterpret_cast<ID3D11ShaderResourceView*>(@<图片信息.纹理ID>)->Release();
        }
        图片信息.重置为空对象 ()
    }

    # SDL ---

    方法 创建设备_SDL3 <公开 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ m_window = (SDL_Window*)@<窗口句柄>;
        // Create GPU Device
        @ m_gpu_device = SDL_CreateGPUDevice(SDL_GPU_SHADERFORMAT_SPIRV | SDL_GPU_SHADERFORMAT_DXIL | SDL_GPU_SHADERFORMAT_METALLIB, true, nullptr);
        @ if (m_gpu_device == nullptr)
        @ {
        @     // printf("Error: SDL_CreateGPUDevice(): %s\n", SDL_GetError());
        @     return FALSE;
        @ }

        // Claim window for GPU Device
        @ if (!SDL_ClaimWindowForGPUDevice(m_gpu_device, m_window))
        @ {
        @     // printf("Error: SDL_ClaimWindowForGPUDevice(): %s\n", SDL_GetError());
        @     return FALSE;
        @ }
        @ SDL_SetGPUSwapchainParameters(m_gpu_device, m_window, SDL_GPU_SWAPCHAINCOMPOSITION_SDR, SDL_GPU_PRESENTMODE_VSYNC);
        // SDL_GPU_PRESENTMODE_VSYNC SDL_GPU_PRESENTMODE_IMMEDIATE SDL_GPU_PRESENTMODE_MAILBOX
        @ return TRUE;
    }

    方法 渲染_SDL <公开 折叠>
    参数 窗口句柄 <类型 = 变整数>
    参数 背景颜色 <类型 = ImVec4 @输出名 = "clear_color">
    {
        // Rendering
        @ ImGui::Render();
        @ ImDrawData* draw_data = ImGui::GetDrawData();
        @ const bool is_minimized = (draw_data->DisplaySize.x <= 0.0f || draw_data->DisplaySize.y <= 0.0f);

        @ SDL_GPUCommandBuffer* command_buffer = SDL_AcquireGPUCommandBuffer(m_gpu_device); // Acquire a GPU command buffer

        @ SDL_GPUTexture* swapchain_texture;
        @ SDL_AcquireGPUSwapchainTexture(command_buffer, m_window, &swapchain_texture, nullptr, nullptr); // Acquire a swapchain texture

        @ if (swapchain_texture != nullptr && !is_minimized)
        @ {
        @     // This is mandatory: call ImGui_ImplSDLGPU3_PrepareDrawData() to upload the vertex/index buffer!
        @     Imgui_ImplSDLGPU3_PrepareDrawData(draw_data, command_buffer);

        @     // Setup and start a render pass
        @     SDL_GPUColorTargetInfo target_info = {};
        @     target_info.texture = swapchain_texture;
        @     target_info.clear_color = SDL_FColor { clear_color.x, clear_color.y, clear_color.z, clear_color.w };
        @     target_info.load_op = SDL_GPU_LOADOP_CLEAR;
        @     target_info.store_op = SDL_GPU_STOREOP_STORE;
        @     target_info.mip_level = 0;
        @     target_info.layer_or_depth_plane = 0;
        @     target_info.cycle = false;
        @     SDL_GPURenderPass* render_pass = SDL_BeginGPURenderPass(command_buffer, &target_info, 1, nullptr);

        @     // Render ImGui
        @     ImGui_ImplSDLGPU3_RenderDrawData(draw_data, command_buffer, render_pass);

        @     SDL_EndGPURenderPass(render_pass);
        @ }

        // Update and Render additional Platform Windows
        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     ImGui::UpdatePlatformWindows();
        @     ImGui::RenderPlatformWindowsDefault();
        @ }

        // Submit the command buffer
        @ SDL_SubmitGPUCommandBuffer(command_buffer);
    }

    方法 释放设备 <公开 折叠>
    {
        @ SDL_ReleaseWindowFromGPUDevice(m_gpu_device, m_window);
    }

    # @begin
    # <> <include>
    # SDL_Window* m_window = nullptr;
    # SDL_GPUDevice* m_gpu_device = nullptr;
    # <> </include>
    # @end
}

#
