<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv">

类 调试信息类 <公开 注释 = "支持无符号数值和别名类型的调试输出" 注释 = "注意: const char*文本指针统一按UTF-8转换,所以本身是ANSI编码的会输出为乱码." 折叠
        @文档 = "category = \"调试信息\"" @全局类 = 真 "@视窗.外部头文件.全局-1200" = "src\\detail\\piv_debug.hpp">
{
    方法 输出调试 <公开 静态 注释 = "向系统调试器内输出所指定数据的调试用文本并自动换行" 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_obj_param_pointer = true\r\nreq_str_param_text_pointer = true">
    参数 所欲输出的数据 <注释 = "  每个所输出数据后附加一个\", \"文本用作分隔,输出行的最后添加一个换行符." 注释 = "  支持所有基本数值类型(能正确输出无符号数);"
            注释 = "  支持火山对象类,自定义类型需要覆盖虚拟方法\"取展示内容\"来提供输出内容;"
            注释 = "  支持C++标准库的常用STL类型,如vector、string、string_view、set、map、array" 注释 = "等等(需要以别名类型封装);"
            注释 = "  其他别名类型,可以通过重载下面的函数来输出内容(可参考\"ULID类\"的源码):"
            注释 = "  void PivDumpStr(CVolString &strDebug, INT nMaxDumpSize, T* value)" 编辑时信息 = "1B285, 0, 0, 0"
            @匹配类型 = 通用型 @可扩展 = "">
    {
        @ _DEBUG_STATMENT (PivDebugTrace (FALSE, 0, 0, _T (@sn<pm_types>), @<所欲输出的数据>))
    }

    方法 可跳转输出调试 <公开 静态 注释 = "向系统调试器内输出所指定数据的调试用文本并自动换行." 注释 = "本方法输出行的首部将携带当前源码位置,在输出窗口中双击此行即可跳转到该源码位置." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "req_obj_param_pointer = true\r\nreq_str_param_text_pointer = true">
    参数 所欲输出的数据 <注释 = "  每个所输出数据后附加一个\", \"文本用作分隔,输出行的最后添加一个换行符." 注释 = "  支持所有基本数值类型(能正确输出无符号数);"
            注释 = "  支持火山对象类,自定义类型需要覆盖虚拟方法\"取展示内容\"来提供输出内容;"
            注释 = "  支持C++标准库的常用STL类型,如vector、string、string_view、set、map、array" 注释 = "等等(需要以别名类型封装);"
            注释 = "  其他别名类型,可以通过重载下面的函数来输出内容(可参考\"ULID类\"的源码):"
            注释 = "  void PivDumpStr(CVolString &strDebug, INT nMaxDumpSize, T* value)" 编辑时信息 = "B554A, 0, 0, 0"
            @匹配类型 = 通用型 @可扩展 = "">
    {
        @ _DEBUG_STATMENT (PivDebugTraceWithSourcePos (_CT (@sn<current_source_file>), _CT (@sn<current_source_line>), FALSE, 0, 0, _T (@sn<pm_types>), @<所欲输出的数据>))
    }
}

类 编译参数类 <公开 注释 = "用于设置MSVC的编译参数" 折叠 @文档 = "category = \"编译参数\"" @禁止创建对象 = 真>
{
    方法 禁用随机基址 <公开 静态 注释 = "禁用随机基址" "@视窗.附加编译参数.release-default" = "link: /DYNAMICBASE:NO">

    方法 禁用数据执行保护 <公开 静态 注释 = "禁用数据执行保护(DEP),只适用于32位程序,64位程序无法禁用DEP." @视窗.附加编译参数 = "link: /NXCOMPAT:NO">

    方法 启用大地址 <公开 静态 注释 = "可以让32位程序处理超过2GB的地址." 注释 = "32位程序默认只能使用2GB内存,启用此参数后可以在64位系统中使用将近4GB的内存."
            注释 = "32位系统则需要设置/3GB的启动参数,让32位程序使用3GB内存." @视窗.附加编译参数.win32 = "link: /LARGEADDRESSAWARE:NO">

    方法 设置校验和 <公开 静态 注释 = "将在.exe文件头中设置校验和" @视窗.附加编译参数.exe = "link: /RELEASE">
}

类 标准异常管理类 <公开 注释 = "用于管理由std标准库抛出的异常." 折叠 @文档 = "category = \"标准库\"" @视窗.外部头文件 = "<exception>" @全局类 = 真>
{
    方法 开始俘获标准异常 <公开 静态 注释 = "开始俘获标准异常,后面需要接着\"俘获标准异常\"." 折叠
            @嵌入式方法 = "name = try_std\r\nhas_body = true\r\nnext = \"catch_std\"">
    {
        @ try
    }

    方法 俘获标准异常 <公开 静态 注释 = "俘获所抛出的标准异常对象,前面需要\"开始俘获标准异常\"." 注释 = "内部可用方法\"取被俘获标准异常\"." 折叠
            @嵌入式方法 = "name = catch_std\r\nhas_body = true\r\nprev = \"try_std\"">
    {
        @ catch (const std::exception& _std_e_catched)
    }

    方法 取被俘获标准异常 <公开 静态 类型 = 文本型 注释 = "获取异常的描述文本,只能在\"俘获标准异常\"方法的子语句体中使用." 折叠
            @嵌入式方法 = "parent=\"catch_std\"">
    {
        @ @an<CVolString> (_std_e_catched.what ())
    }
}

类 结构类辅助 <公开 注释 = "结构类转换到结构体的辅助类." 注释 = "火山的结构类不等于结构体,但结构类内有一个名称为\"S\"的C++结构体," 注释 = "本类可以让结构类和结构体互相转换."
        折叠 @文档 = "category = \"数据处理\"" @禁止创建对象 = 真>
{
    方法 分配 <公开 静态 类型 = 变整数 注释 = "分配一个结构体指针" 返回值注释 = "返回结构体指针,内容为空." 折叠 @嵌入式方法 = "">
    参数 结构类 <注释 = "结构类的实例变量" @匹配类型 = 通用类>
    {
        @ reinterpret_cast<INT_P>(new @pdt<结构类>::S{})
    }

    方法 释放 <公开 静态 注释 = "结构体用完需要手动释放指针,否则会造成内存泄漏." 折叠 @嵌入式方法 = "">
    参数 结构类 <注释 = "结构类的实例变量" @匹配类型 = 通用类>
    参数 结构体指针 <类型 = 变整数 注释 = "欲释放的结构体指针">
    {
        @ delete reinterpret_cast<@pdt<结构类>::S *>(@<结构体指针>)
    }

    方法 写到结构体 <公开 静态 类型 = 变整数 注释 = "将结构类的内容填写到结构体中,然后返回结构体指针." 返回值注释 = "返回结构体指针,已填入结构类的内容." 折叠 @嵌入式方法 = "">
    参数 结构类 <注释 = "结构类的实例变量" @匹配类型 = 通用类>
    参数 结构体指针 <类型 = 变整数 注释 = "结构体的指针,需要提前\"分配\".">
    {
        @ @<结构类>.GetStruct (reinterpret_cast<@pdt<结构类>::S *>(@<结构体指针>))
    }

    方法 取结构体数据 <公开 静态 注释 = "从结构体指针中获取数据,并填写到结构类中." 折叠 @嵌入式方法 = "">
    参数 结构类 <注释 = "结构类的实例变量" @匹配类型 = 通用类>
    参数 结构体指针 <类型 = 变整数 注释 = "结构体的指针">
    {
        @ @<结构类>.SetStruct (reinterpret_cast<@pdt<结构类>::S *>(@<结构体指针>))
    }
}

类 数组P <公开 注释 = "\"数组类辅助操作\"的上位替代,部分参考了\"龙纹\"的\"FP函数扩展\"模块."
        注释 = "本类需要求std:++17,最低VS版本要求为Visual Studio 2017." 折叠 @文档 = "category = \"数组操作\"" @禁止创建对象 = 真
        @视窗.外部头文件 = "src\\piv_array.hpp" @视窗.附加编译参数 = "cpp: /std:c++17" @视窗.需求VS版本 = "15-">
{
    方法 创建数组类 <公开 静态 注释 = "语法糖,快速创建一个任意类型的数组类." 注释 = "例: 整数数组 = 数组P.创建数组类 (整数数组类, 1, 2, 3)" 折叠 @嵌入式方法 = "">
    参数 数组类型 <注释 = "提供所欲创建的数组类型,可以是任意类型的数组类." @匹配类型 = 通用类 @需求类型 = 数据类型 @返回值类型 = 0>
    参数 成员值 <注释 = "提供数组类的初始值,可以连续提供多个成员值." @匹配类型 = 通用型 @可扩展 = "">
    {
        @ piv::arr::CreateArray<@<数组类型>> (@<成员值>)
    }

    方法 连续加入成员 <公开 静态 注释 = "注意: 数组类的\"加入成员\"已经支持可变参数,本方法已无存在的意义!!!" 注释 = "语法糖,将多个成员值连续加入到一个任意类型的数组类中."
            注释 = "例: 数组P.连续加入成员 (整数数组, 1, 2, 3)" 折叠 @嵌入式方法 = "">
    参数 欲操作的数组 <注释 = "提供所欲连续加入成员的数组类,可以是任意类型的数组类." @匹配类型 = 通用类>
    参数 成员值 <注释 = "提供所欲加入到数组类中的值,可以连续提供多个成员值." @匹配类型 = 通用型 @可扩展 = "">
    {
        @ piv::arr::AddManyValues (@<欲操作的数组>, @<成员值>)
    }

    方法 取对象数组数据 <公开 静态 类型 = 字节集类 注释 = "基于流操作获取指定对象数组类中所有成员的内容数据." 返回值注释 = "返回对象数组数据,如果提供的参数不是对象数组类,将返回空字节集."
            折叠 @嵌入式方法 = "">
    参数 对象数组 <注释 = "提供所欲获取所有成员内容数据的数组类,必须为\"对象数组类\"、" 注释 = "\"字节集数组类\",以及基于\"对象数组模板类\"的自定义数组类." @匹配类型 = 通用类>
    {
        @ piv::arr::SaveObjArrToData (@<对象数组>)
    }

    方法 置对象数组数据 <公开 静态 类型 = 逻辑型 注释 = "基于流操作,将对象数组的内容数据设置到指定的对象数组类中." 返回值注释 = "返回操作是否成功,不论成败,提供的对象数组都会先被清空."
            折叠 @嵌入式方法 = "">
    参数 对象数组 <注释 = "提供所欲设置成员内容数据的数组类,必须为\"对象数组类\"、" 注释 = "\"字节集数组类\",以及基于\"对象数组模板类\"的自定义数组类." @匹配类型 = 通用类>
    参数 数组数据 <类型 = 字节集类 注释 = "本参数用作提供对象数组的所有成员内容数据,该数据必须为" 注释 = "\"数组P.取对象数组数据\"方法返回,否则将导致不可预知的后果.">
    参数 成员类型 <注释 = "本参数提供对象数组类的成员类型名称" @匹配类型 = 通用类 @需求类型 = 数据类型>
    {
        @ piv::arr::LoadObjArrData (@<对象数组>, @<数组数据>, @<成员类型> ())
    }

    方法 取数组前面 <公开 静态 注释 = "将数组类的前N个成员提取到新的数组类中." 返回值注释 = "返回提取的新数组类,类型与欲提取的数组类相同." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组类 <注释 = "所欲提取前N个成员的数组类,可以是任意类型的数组类." @匹配类型 = 通用类 @返回值类型 = 0>
    参数 提取数量 <类型 = 整数 注释 = "所欲提取的成员数量,如果提供的数量大于成员数,将返回原数组." "">
    {
        @ piv::arr::GetArrayFront (@<所欲操作数组类>, @<提取数量>)
    }

    方法 取数组后面 <公开 静态 注释 = "将数组类的后N个成员提取到新的数组类中." 返回值注释 = "返回提取的新数组类,类型与欲提取的数组类相同." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组类 <注释 = "所欲提取后N个成员的数组类,可以是任意类型的数组类." @匹配类型 = 通用类 @返回值类型 = 0>
    参数 提取数量 <类型 = 整数 注释 = "所欲提取的成员数量,如果提供的数量大于成员数,将返回原数组." "">
    {
        @ piv::arr::GetArrayBack (@<所欲操作数组类>, @<提取数量>)
    }

    方法 求和 <公开 静态 注释 = "累加通用基本型数组类中的成员,支持文本相加." 注释 = "使用此方法必须保证数组非空,否则报错." 折叠 @嵌入式方法 = "">
    参数 欲操作的数组 <注释 = "提供所欲操作的数值型和文本型数组类" @匹配类型 = 通用类>
    参数 返回类型 <注释 = "提供数组类的成员类型,同时也是方法返回值的类型." @匹配类型 = 通用基本型 @需求类型 = 数据类型 @返回值类型 = 0>
    {
        @ piv::arr::Sum<@<返回类型>> (@<欲操作的数组>)
    }

    方法 求最大值 <公开 静态 注释 = "返回通用基本型数组类中最大的成员值." 注释 = "使用此方法必须保证数组非空,否则报错." 折叠 @嵌入式方法 = "">
    参数 欲操作的数组 <注释 = "提供所欲操作的数值型和文本型数组类" @匹配类型 = 通用类>
    参数 返回类型 <注释 = "提供数组类的成员类型,同时也是返回值的类型." @匹配类型 = 通用基本型 @需求类型 = 数据类型 @返回值类型 = 0>
    {
        @ piv::arr::MaxImum<@<返回类型>> (@<欲操作的数组>)
    }

    方法 求最小值 <公开 静态 注释 = "返回通用基本型数组类中最小的成员值." 注释 = "使用此方法必须保证数组非空,否则报错." 折叠 @嵌入式方法 = "">
    参数 欲操作的数组 <注释 = "提供所欲操作的数值型和文本型数组类" @匹配类型 = 通用类>
    参数 返回类型 <注释 = "提供数组类的成员类型,同时也是返回值的类型." @匹配类型 = 通用基本型 @需求类型 = 数据类型 @返回值类型 = 0>
    {
        @ piv::arr::MinImum<@<返回类型>> (@<欲操作的数组>)
    }

    方法 展示数组 <公开 静态 类型 = 文本型 注释 = "将一个通用基本型数组类格式化输出." 注释 = "例: 数组P.展示数组 (整数数组)" 注释 = "输出: {1, 2, 3}" 折叠
            @嵌入式方法 = "">
    参数 所欲操作数组类 <注释 = "提供所欲格式化输出的数组类,必须是数值型或文本型数组类." @匹配类型 = 通用类>
    {
        @ piv::arr::FormatArray (@<所欲操作数组类>)
    }

    方法 打乱数组 <公开 静态 注释 = "随机地打乱火山数组类中所有成员的顺序." 注释 = "注: 随机算法为std::mt19937,成员的每个排列都拥有相同的出现概率." @嵌入式方法 = "">
    参数 欲操作的数组 <注释 = "支持火山所有的数组类(不支持std::vector)" @匹配类型 = 通用类>
    {
        @ piv::arr::Shuffle(@<欲操作的数组>)
    }
}

类 数组类辅助操作 <公开 注释 = "本类是过时功能,请改用\"数组P\"." 注释 = "  如想使用本类,请在项目属性的编译时预定义宏中添加" 注释 = "PIV_ENABLE_OBSOLETE"
        折叠 @文档 = "category = \"数组操作\"" @全局类 = 真 @编译条件 = "PIV_ENABLE_OBSOLETE">
{
    方法 创建文本型数组类 <公开 静态 类型 = 文本数组类 注释 = "创建一个文本型数组类,并连续加入多个成员." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 欲添加的数据 <类型 = 文本型 @可扩展 = "d_text = \"); arr.data ().Add (\"">
    {
        @ [] {
        @     @dt<文本数组类> arr;
        @     arr.data ().Add (@<欲添加的数据>);
        @     return arr;
        @ } ()
    }

    方法 创建数值型数组类 <公开 静态 注释 = "创建一个指定基本数值类型的数组类,并连续加入多个成员." 返回值注释 = "返回创建的数组类." 折叠 @嵌入式方法 = "">
    参数 数值类型数组类 <注释 = "  所欲创建的数组类类型,必须为下列基本数值类型的数组类:" 注释 = "  字节数组类、短整数数组类、字符数组类"
            注释 = "  整数数组类、长整数数组类、小数数组类" @匹配类型 = 通用类 @需求类型 = 数据类型 @返回值类型 = 0>
    参数 欲添加的数据 <折叠2 @可扩展 = "d_text = \"); arr.data ().Add (\"" @匹配类型 = 通用基本型>
    {
        @ [] {
        @     @<数值类型数组类> arr;
        @     arr.data ().Add (@<欲添加的数据>);
        @     return arr;
        @ } ()
    }

    方法 数组连续加入字节集 <公开 静态 注释 = "可一次性加入多个成员到字节集数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 字节集数组类>
    参数 值 <类型 = 字节集类 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.Add (v, NULL); }
    }

    方法 数组连续加入对象 <公开 静态 注释 = "可一次性加入多个成员到对象数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 对象数组类>
    参数 值 <类型 = 对象类 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>().Add (v, NULL); }
    }

    方法 数组连续加入字节 <公开 静态 注释 = "可一次性加入多个成员到字节数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 字节数组类>
    参数 值 <类型 = 字节 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }

    方法 数组连续加入短整数 <公开 静态 注释 = "可一次性加入多个成员到短整数数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 短整数数组类>
    参数 值 <类型 = 短整数 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }

    方法 数组连续加入字符 <公开 静态 注释 = "可一次性加入多个成员到字符数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 字符数组类>
    参数 值 <类型 = 字符 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }

    方法 数组连续加入整数 <公开 静态 注释 = "可一次性加入多个成员到整数数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 整数数组类>
    参数 值 <类型 = 整数 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }

    方法 数组连续加入变整数 <公开 静态 注释 = "可一次性加入多个成员到变整数数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 变整数数组类>
    参数 值 <类型 = 变整数 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }

    方法 数组连续加入长整数 <公开 静态 注释 = "可一次性加入多个成员到长整数数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 长整数数组类>
    参数 值 <类型 = 长整数 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }

    方法 数组连续加入小数 <公开 静态 注释 = "可一次性加入多个成员到小数数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 小数数组类>
    参数 值 <类型 = 小数 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }

    方法 数组连续加入逻辑型 <公开 静态 注释 = "可一次性加入多个成员到逻辑型数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 逻辑型数组类>
    参数 值 <类型 = 逻辑型 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }

    方法 数组连续加入文本 <公开 静态 注释 = "可一次性加入多个成员到文本数组类尾部." 折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 所欲操作数组 <类型 = 文本数组类>
    参数 值 <类型 = 文本型 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }
}

类 文件枚举类 <公开 注释 = "枚举文件和目录,需要带上类名调用." 注释 = "" 折叠 @文档 = "category = \"文件操作\"" @禁止创建对象 = 真>
{
    方法 枚举目录EX <公开 静态 类型 = 整数 注释 = "枚举某个目录下的所有信息." 返回值注释 = "成功返回目录数量,失败返回0." 折叠>
    参数 欲寻找的目录 <类型 = 文本型 注释 = "所欲寻找的文件目录,路径不以反斜杠结尾会自动添加." "">
    参数 目录信息数组 <类型 = 目录信息数组类 注释 = "用于装载目录信息数组的变量,寻找到的信息都放在这个数组类里返回." 注释 = "请确保提供的数组为空.">
    参数 是否遍历子目录 <类型 = 逻辑型 注释 = "是否枚举所有的下级目录,默认不枚举." @默认值 = 假>
    参数 欲跳过文件的属性 <类型 = 整数 注释 = "  参数值可以为\"文件属性\"类中各个常量值的和,用作同时指定多个匹配属性.凡是文件具有本参数中所指定的任"
            注释 = "一属性,则认为其未通过匹配(将其跳过). 本参数优先级在\"欲寻找文件的属性\"参数及\"找到文件\"事件之前."
            注释 = "  默认值6等于\"文件属性.系统文件 + 文件属性.隐藏文件\"." @默认值 = 6>
    {
        变量 查找文件 <类型 = 文件查找类>
        变量 文件名 <类型 = 文本型>
        变量 子目录 <类型 = 文本型>
        变量 目录信息 <类型 = 目录信息类>
        如果 (是否遍历子目录 == 假)
        {
            目录信息数组.删除所有成员 ()

        }
        目录信息.目录路径 = 欲寻找的目录
        检查加入路径字符 (目录信息.目录路径)
        文件名 = 查找文件.寻找文件 (目录信息.目录路径 + "*.*", , 欲跳过文件的属性)
        判断循环 (文本是否为空 (文件名) == 假)
        {
            目录信息.总文件尺寸 = 目录信息.总文件尺寸 + 取文件尺寸 (目录信息.目录路径 + 文件名)
            目录信息.文件数组.加入成员 (文件名)
            全局处理事件 ()
            文件名 = 查找文件.寻找文件 ("", , 欲跳过文件的属性)

        }
        目录信息.文件数量 = 目录信息.文件数组.取成员数 ()
        子目录 = 查找文件.寻找文件 (目录信息.目录路径 + "*", 文件属性.子目录, 欲跳过文件的属性)
        判断循环 (文本是否为空 (子目录) == 假)
        {
            目录信息.子目录数组.加入成员 (子目录)
            全局处理事件 ()
            子目录 = 查找文件.寻找文件 ("", 文件属性.子目录, 欲跳过文件的属性)
        }
        目录信息.子目录数量 = 目录信息.子目录数组.取成员数 ()
        目录信息数组.加入成员 (目录信息)
        如果 (是否遍历子目录)
        {
            子目录 = 查找文件.寻找文件 (目录信息.目录路径 + "*", 文件属性.子目录, 欲跳过文件的属性)
            判断循环 (文本是否为空 (子目录) == 假)
            {
                枚举目录EX (目录信息.目录路径 + 子目录, 目录信息数组, 是否遍历子目录, 欲跳过文件的属性)
                全局处理事件 ()
                子目录 = 查找文件.寻找文件 ("", 文件属性.子目录, 欲跳过文件的属性)

            }
        }
        返回 (目录信息数组.取成员数 ())
    }

    方法 枚举文件 <公开 静态 类型 = 整数 注释 = "通过通配符,枚举某个目录下指定文件名和类型的所有文件." 返回值注释 = "成功返回文件数量,失败返回0." 折叠>
    参数 欲寻找的目录 <类型 = 文本型 注释 = "所欲寻找的文件目录,路径不以反斜杠结尾会自动添加." "">
    参数 欲寻找的文件名 <类型 = 文本型 注释 = "如果寻找全部文件可以填入\"*.*\"，或填\"*.txt\"只找txt文件.">
    参数 文件数组 <类型 = 文本数组类 注释 = "用于装载文件数组的变量,寻找到的文件都放在这个数组里返回." 注释 = "请确保提供的数组为空.">
    参数 是否带路径 <类型 = 逻辑型 注释 = "指定返回的子目录是否带完整路径." @默认值 = 真>
    参数 是否遍历子目录 <类型 = 逻辑型 注释 = "是否枚举所有的下级目录,默认不枚举." @默认值 = 假>
    参数 欲跳过文件的属性 <类型 = 整数 注释 = "  参数值可以为\"文件属性\"类中各个常量值的和,用作同时指定多个匹配属性.凡是文件具有本参数中所指定的任"
            注释 = "一属性,则认为其未通过匹配(将其跳过). 本参数优先级在\"欲寻找文件的属性\"参数及\"找到文件\"事件之前."
            注释 = "  默认值6等于\"文件属性.系统文件 + 文件属性.隐藏文件\"." @默认值 = 6>
    {
        变量 查找文件 <类型 = 文件查找类>
        变量 父目录 <类型 = 文本型>
        变量 找到文件 <类型 = 文本型>
        如果 (是否遍历子目录 == 假)
        {
            文件数组.删除所有成员 ()

        }
        父目录 = 欲寻找的目录
        检查加入路径字符 (父目录)
        找到文件 = 查找文件.寻找文件 (父目录 + 欲寻找的文件名, -1, 欲跳过文件的属性)
        判断循环 (文本是否为空 (找到文件) == 假)
        {
            如果 (是否带路径)
            {
                插入文本 (找到文件, 0, 父目录)

            }
            文件数组.加入成员 (找到文件)
            // 全局处理事件 ()
            找到文件 = 查找文件.寻找文件 ("", -1, 欲跳过文件的属性)

        }
        如果 (是否遍历子目录)
        {
            找到文件 = 查找文件.寻找文件 (父目录 + "*", 文件属性.子目录, 欲跳过文件的属性)
            判断循环 (文本是否为空 (找到文件) == 假)
            {
                枚举文件 (父目录 + 找到文件, 欲寻找的文件名, 文件数组, 是否带路径, 是否遍历子目录, 欲跳过文件的属性)
                // 全局处理事件 ()
                找到文件 = 查找文件.寻找文件 ("", 文件属性.子目录, 欲跳过文件的属性)

            }

        }
        返回 (文件数组.取成员数 ())
    }

    方法 枚举子目录 <公开 静态 类型 = 整数 注释 = "取一个文件夹下级子目录.通过是否遍历子目录参数,可以枚举该文件夹的所有子目录." 返回值注释 = "成功返回子目录数量,失败返回0." 折叠>
    参数 父文件夹路径 <类型 = 文本型 注释 = "不需要填写*号,路径不以反斜杠结尾会自动添加.">
    参数 子目录数组 <类型 = 文本数组类 注释 = "保存找到的子目录,请确保提供的数组为空.">
    参数 是否带路径 <类型 = 逻辑型 注释 = "指定返回的子目录是否带完整路径." @默认值 = 真>
    参数 是否遍历子目录 <类型 = 逻辑型 注释 = "是否枚举所有的下级目录,默认不枚举." @默认值 = 假>
    参数 欲跳过文件的属性 <类型 = 整数 注释 = "  参数值可以为\"文件属性\"类中各个常量值的和,用作同时指定多个匹配属性.凡是文件具有本参数中所指定的任"
            注释 = "一属性,则认为其未通过匹配(将其跳过). 本参数优先级在\"欲寻找文件的属性\"参数及\"找到文件\"事件之前."
            注释 = "  默认值6等于\"文件属性.系统文件 + 文件属性.隐藏文件\"." @默认值 = 6>
    {
        变量 查找文件 <类型 = 文件查找类>
        变量 父目录 <类型 = 文本型>
        变量 子目录名 <类型 = 文本型>
        变量 本级子目录列表 <类型 = 文本数组类>
        变量 目录总数 <类型 = 整数>
        变量 子目录数 <类型 = 整数>
        如果 (是否遍历子目录 == 假)
        {
            子目录数组.删除所有成员 ()
        }
        父目录 = 父文件夹路径
        检查加入路径字符 (父目录)
        子目录名 = 查找文件.寻找文件 (父目录 + "*", 文件属性.子目录, 欲跳过文件的属性)
        判断循环 (文本是否为空 (子目录名) == 假)
        {
            本级子目录列表.加入成员 (子目录名)
            如果 (是否带路径)
            {
                插入文本 (子目录名, 0, 父目录)
            }
            子目录数组.加入成员 (子目录名)
            全局处理事件 ()
            子目录名 = 查找文件.寻找文件 ("", 文件属性.子目录, 欲跳过文件的属性)

        }
        子目录数 = 本级子目录列表.取成员数 ()
        目录总数 = 子目录数
        如果 (是否遍历子目录)
        {
            变量 索引 <类型 = 整数>
            循环 (0, 子目录数, 索引, 1)
            {
                目录总数 = 目录总数 + 枚举子目录 (父目录 + 本级子目录列表.取成员 (索引), 子目录数组, 是否带路径, 是否遍历子目录, 欲跳过文件的属性)

            }
        }
        返回 (目录总数)
    }

    方法 是否有子目录 <公开 静态 类型 = 逻辑型 注释 = "判断一个目录下是否有下级子目录." 折叠>
    参数 欲判断目录 <类型 = 文本型 注释 = "所欲判断的目录,目录不以反斜杠结尾会自动添加">
    {
        变量 查找文件 <类型 = 文件查找类>
        变量 父目录 <类型 = 文本型>
        父目录 = 欲判断目录
        检查加入路径字符 (父目录)
        返回 (取反 (文本是否为空 (查找文件.寻找文件 (父目录 + "*", 文件属性.子目录))))
    }
}

类 目录信息类 <公开 基础类 = 扩展对象类 注释 = "\"文件枚举类.枚举目录EX\"返回的信息" 折叠 @文档 = "category = \"文件操作.辅助类\"">
{
    变量 目录路径 <公开 类型 = 文本型>
    变量 子目录数量 <公开 类型 = 整数>
    变量 子目录数组 <公开 类型 = 文本数组类>
    变量 总文件尺寸 <公开 类型 = 长整数>
    变量 文件数量 <公开 类型 = 整数>
    变量 文件数组 <公开 类型 = 文本数组类>

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<目录信息类> 总共 6 个成员:\r\n"
        加入文本 (展示内容, "1. 目录路径: " + 取调试文本2 (最大展示数据尺寸, 目录路径) + "\r\n")
        加入文本 (展示内容, "2. 子目录数量: " + 取调试文本2 (最大展示数据尺寸, 子目录数量) + "\r\n")
        加入文本 (展示内容, "3. 子目录数组: " + 取调试文本2 (最大展示数据尺寸, 子目录数组) + "\r\n")
        加入文本 (展示内容, "4. 总文件尺寸: " + 取调试文本2 (最大展示数据尺寸, 总文件尺寸) + "\r\n")
        加入文本 (展示内容, "5. 文件数量: " + 取调试文本2 (最大展示数据尺寸, 文件数量) + "\r\n")
        加入文本 (展示内容, "6. 文件数组: " + 取调试文本2 (最大展示数据尺寸, 文件数组))
    }
}

类 目录信息数组类 <公开 基础类 = 对象数组模板类 注释 = "\"文件枚举类.枚举目录EX\"返回的信息" @文档 = "category = \"文件操作.辅助类\""
        @模板实现类 = "目录信息类">

#
