<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv" @视窗.外部头文件 = "src\\piv_url.hpp">

# URL编解码 =====

类 URL编解码类 <公开 注释 = "URL编解码,源码修改自HP-Socket." 折叠 @文档 = "category = \"网络辅助\"" @禁止创建对象 = 真>
{
    方法 编码 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行URL编码,返回编码后的数据." 折叠 @禁止流程检查 = 真>
    参数 欲编码数据 <类型 = 字节集类 注释 = "提供所欲进行编码的数据">
    参数 不编码保留字符 <类型 = 逻辑型 注释 = "是否不编码保留字符(;/?:@=&),保留字符在URL中有特殊含义" @默认值 = 假>
    {
        @ size_t DestLen = piv::encoding::GuessUrlEncodeBound(@<欲编码数据>.GetPtr(),
        @                                                     static_cast<size_t>(@<欲编码数据>.GetSize()), @<不编码保留字符>);
        @ if (DestLen > static_cast<size_t>(@<欲编码数据>.GetSize())) {
        @     @an<CVolMem> encode;
        @     piv::encoding::UrlEncode(@<欲编码数据>.GetPtr(), static_cast<size_t>(@<欲编码数据>.GetSize()),
        @                               encode.Alloc(static_cast<INT_P>(DestLen), TRUE), DestLen, @<不编码保留字符>);
        @     return encode;
        @ }
        @ return @<欲编码数据>;
    }

    方法 编码2 <公开 静态 注释 = "将指定数据进行URL编码,并在参数中返回编码后的数据." 折叠 @禁止流程检查 = 真>
    参数 欲编码数据 <类型 = 字节集类 注释 = "提供所欲进行编码的数据">
    参数 编码数据 <类型 = 字节集类 注释 = "返回编码后的数据">
    参数 不编码保留字符 <类型 = 逻辑型 注释 = "是否不编码保留字符(;/?:@=&),保留字符在URL中有特殊含义" @默认值 = 假>
    {
        @ size_t DestLen = piv::encoding::GuessUrlEncodeBound(@<欲编码数据>.GetPtr(),
        @                                                     static_cast<size_t>(@<欲编码数据>.GetSize()), @<不编码保留字符>);
        @ if (DestLen > static_cast<size_t>(@<欲编码数据>.GetSize())) {
        @     piv::encoding::UrlEncode(@<欲编码数据>.GetPtr(), static_cast<size_t>(@<欲编码数据>.GetSize()),
        @                              @<编码数据>.Alloc(static_cast<INT_P>(DestLen), TRUE), DestLen, @<不编码保留字符>);
        @ else
        @     @<编码数据> = @<欲编码数据>;
    }

    方法 编码文本 <公开 静态 类型 = 文本型 注释 = "将指定文本进行URL编码,返回编码后的文本." 折叠 @禁止流程检查 = 真>
    参数 欲编码文本 <类型 = 文本型 注释 = "提供所欲进行编码的文本">
    参数 是否UTF8 <类型 = 逻辑型 注释 = "将文本内容以UTF-8格式进行URL编码,否则为多字节." @默认值 = 真>
    参数 不编码保留字符 <类型 = 逻辑型 注释 = "是否不编码保留字符(;/?:@=&),保留字符在URL中有特殊含义" @默认值 = 假>
    {
        @ if (!piv::encoding::UrlEncodeNeed(@<欲编码文本>.GetText(), static_cast<size_t>(@<欲编码文本>.GetLength())))
        @     return @<欲编码文本>;
        @ size_t DestLen;
        @ if (@<是否UTF8>) {
        @     PivW2U urlstr{@<欲编码文本>.GetText()};
        @     DestLen = piv::encoding::GuessUrlEncodeBound(reinterpret_cast<BYTE *>(urlstr.data()),
        @                                                  urlstr.size_bytes(), @<不编码保留字符>);
        @     @an<CVolMem> buffer;
        @     piv::encoding::UrlEncode(reinterpret_cast<BYTE *>(urlstr.data()), urlstr.size_bytes(),
        @                              buffer.Alloc(static_cast<INT_P>(DestLen), TRUE), DestLen, @<不编码保留字符>);
        @     return *PivU2Ws{reinterpret_cast<const char *>(buffer.GetPtr()), DestLen};
        @ } else {
        @     PivW2A urlstr{@<欲编码文本>.GetText()};
        @     DestLen = piv::encoding::GuessUrlEncodeBound(reinterpret_cast<BYTE *>(urlstr.data()),
        @                                                  urlstr.size_bytes(), @<不编码保留字符>);
        @     @an<CVolMem> buffer;
        @     piv::encoding::UrlEncode(reinterpret_cast<BYTE *>(urlstr.data()), urlstr.size_bytes(),
        @                               buffer.Alloc(static_cast<INT_P>(DestLen), TRUE), DestLen, @<不编码保留字符>);
        @     return *PivA2Ws{reinterpret_cast<const char *>(buffer.GetPtr()), DestLen};
        @ }
    }

    方法 编码到文本 <公开 静态 类型 = 文本型 注释 = "将指定的编码的数据进行URL编码,返回编码后的文本." 折叠 @嵌入式方法 = "">
    参数 欲编码数据 <类型 = 字节集类 注释 = "提供所欲进行编码的数据">
    参数 是否UTF8 <类型 = 逻辑型 注释 = "将文本内容以UTF-8格式进行URL编码,否则为多字节." @默认值 = 真>
    参数 不编码保留字符 <类型 = 逻辑型 注释 = "是否不编码保留字符(;/?:@=&),保留字符在URL中有特殊含义" @默认值 = 假>
    {
        @ piv::encoding::UrlStrEncode(@<欲编码数据>, @an<CVolString>{}, @<是否UTF8>, @<不编码保留字符>)
    }

    # ---

    方法 解码 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行URL解码,返回解码后的数据." 折叠 @禁止流程检查 = 真>
    参数 欲解码数据 <类型 = 字节集类 注释 = "提供所欲进行解码的数据">
    {
        @ size_t DestLen = piv::encoding::GuessUrlDecodeBound(@<欲解码数据>.GetPtr(),
        @                                                     static_cast<size_t>(@<欲解码数据>.GetSize()));
        @ if (DestLen < @<欲解码数据>.GetSize()) {
        @     @an<CVolMem> decode;
        @     piv::encoding::UrlDecode(@<欲解码数据>.GetPtr(), static_cast<size_t>(@<欲解码数据>.GetSize()),
        @                              decode.Alloc(static_cast<INT_P>(DestLen), TRUE), DestLen);
        @     return decode;
        @ }
        @ return @<欲解码数据>;
    }

    方法 解码2 <公开 静态 注释 = "将指定数据进行URL解码,并在参数中返回解码后的数据." 折叠 @禁止流程检查 = 真>
    参数 欲解码数据 <类型 = 字节集类 注释 = "提供所欲进行解码的数据">
    参数 解码数据 <类型 = 字节集类 注释 = "返回解码后的数据">
    {
        @ size_t DestLen = piv::encoding::GuessUrlDecodeBound(@<欲解码数据>.GetPtr(),
        @                                                     static_cast<size_t>(@<欲解码数据>.GetSize()));
        @ if (DestLen > @<欲解码数据>.GetSize())
        @     piv::encoding::UrlDecode(@<欲解码数据>.GetPtr(), static_cast<size_t>(@<欲解码数据>.GetSize()),
        @                              @<解码数据>.Alloc(static_cast<INT_P>(DestLen), TRUE), DestLen);
        @ else
        @     @<解码数据> = @<欲解码数据>;
    }

    方法 解码文本 <公开 静态 类型 = 文本型 注释 = "将指定文本进行URL解码,返回解码后的文本." 折叠 @禁止流程检查 = 真>
    参数 欲解码文本 <类型 = 文本型 注释 = "提供所欲进行解码的文本">
    参数 是否UTF8 <类型 = 逻辑型 注释 = "URL编码文本是否为UTF-8格式,否则为多字节." @默认值 = 真>
    {
        @ size_t DestLen;
        @ if (@<是否UTF8>) {
        @     PivW2U urlstr {@<欲解码文本>.GetText()};
        @     DestLen = piv::encoding::GuessUrlDecodeBound(reinterpret_cast<BYTE *>(urlstr.data()), urlstr.size_bytes());
        @     if (DestLen < static_cast<size_t>(urlstr.size_bytes())) {
        @         @an<CVolMem> buffer;
        @         piv::encoding::UrlDecode(reinterpret_cast<BYTE *>(urlstr.data()), urlstr.size_bytes(),
        @                                  reinterpret_cast<BYTE *>(buffer.Alloc(static_cast<INT_P>(DestLen), TRUE)), DestLen);
        @         return *PivU2Ws {reinterpret_cast<const char *>(buffer.GetPtr()), DestLen};
        @     }
        @ } else {
        @     PivW2A urlstr {@<欲解码文本>.GetText()};
        @     DestLen = piv::encoding::GuessUrlDecodeBound(reinterpret_cast<BYTE *>(urlstr.data()), urlstr.size_bytes());
        @     if (DestLen < static_cast<size_t>(urlstr.size_bytes())) {
        @         @an<CVolMem> buffer;
        @         piv::encoding::UrlDecode(reinterpret_cast<BYTE *>(urlstr.data()), urlstr.size_bytes(),
        @                                  reinterpret_cast<BYTE *>(buffer.Alloc(static_cast<INT_P>(DestLen), TRUE)), DestLen);
        @         return *PivA2Ws {reinterpret_cast<const char *>(buffer.GetPtr()), DestLen};
        @     }
        @ }
        @ return @<欲解码文本>;
    }

    方法 解码到文本 <公开 静态 类型 = 文本型 注释 = "将指定的编码的数据进行URL解码,返回解码后的文本." 折叠 @嵌入式方法 = "">
    参数 欲解码数据 <类型 = 字节集类 注释 = "提供所欲进行编码的数据">
    参数 是否UTF8 <类型 = 逻辑型 注释 = "URL编码文本是否为UTF-8格式,否则为多字节." @默认值 = 真>
    {
        @ piv::encoding::UrlStrDecode(@<欲解码数据>, @<是否UTF8>, @an<CVolString>{})
    }
}

# URL地址 =====

类 URL地址构造类 <公开 注释 = "用于快捷生成正确URL编码的URL地址" 折叠 @文档 = "category = \"网络辅助\"" @别名 = "PivUrlCreaterW">
{
    方法 是否为空 <公开 静态 类型 = 逻辑型 注释 = "返回本对象是否为空" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址构造类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.IsEmpty ()
    }

    方法 清空 <公开 静态 注释 = "清空已生成的地址" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址构造类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.Clear ()
    }

    方法 取地址 <公开 静态 类型 = 文本型 注释 = "返回URL地址的文本参考,传递给网页访问方法." 注释 = "注: 本方法不会产生文本复制." 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = URL地址构造类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.data ()
    }

    方法 域名 <公开 静态 类型 = URL地址构造类 注释 = "设置URL域名(不含路径和参数),会覆盖之前置入的域名." 注释 = "前面必须有协议,后面按需填写端口号,暂不支持中文域名."
            注释 = "例: \"https:://baidu.com\"、\"http:://192.168.1.1:8086\"" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = URL地址构造类 注释 = "所欲操作本对象,本参数无需填写.">
    参数 所欲设置的域名 <注释 = "所欲设置的URL域名,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.SetHost (@<所欲设置的域名>)
    }

    方法 路径 <公开 静态 类型 = URL地址构造类 注释 = "设置URL路径,会覆盖之前置入的路径." 注释 = "请以\'/\'字符开头,支持中文路径(会自动URL编码)."
            注释 = "例: \"/\"、\"/new\"" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = URL地址构造类 注释 = "所欲操作本对象,本参数无需填写.">
    参数 所欲设置的路径 <注释 = "所欲设置的URL路径,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.SetPath (@<所欲设置的路径>)
    }

    方法 添加参数 <公开 静态 类型 = URL地址构造类 注释 = "添加一组查询参数键值对,并对不安全字符进行URL编码." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = URL地址构造类 注释 = "所欲操作本对象,本参数无需填写.">
    参数 键 <注释 = "所欲添加的参数键名,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 值 <注释 = "所欲添加的参数值,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否UTF8编码 <类型 = 逻辑型 注释 = "将文本内容以UTF-8格式进行URL编码,否则为多字节." @默认值 = 真>
    {
        @ @<所欲操作本对象>.AddParam (@<键>, @<值>, @<是否UTF8编码>)
    }
}

# ---

类 URL地址解析类 <公开 注释 = "解析URL中各字段的文本和参数,本类内部使用的编码为UTF-16LE."
        注释 = "<scheme>://<user>:<password>@<host>:<port>/<path>?<query>#<fragment>" 折叠
        @文档 = "category = \"网络辅助\"" @别名 = "PivUrlParserW">
{
    方法 解析 <公开 静态 注释 = "解析URL地址,本方法可以解析不完整的URL地址," 注释 = "比如你可以只解析路径和参数." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    参数 URL地址 <注释 = "所欲解析的URL地址,支持类型:" 注释 = " 文本型、字节集类、标准文本类W、文本视图类" @匹配类型 = 通用型>
    参数 缓存地址数据 <类型 = 逻辑型 注释 = "真: 将提供的URL地址数据复制到本对象的内部;" 注释 = "假: 本对象会使用文本视图指向提供的URL地址,请确保提供的\"URL地址\"是变量,"
            注释 = "且该变量的的生命周期不能短于本对象;" 注释 = "如果解析时产生了编码转换,则一定会缓存文本数据,可以使用\"是否有缓存\"判断.">
    参数 简易解析 <类型 = 逻辑型 注释 = "为真时只解析路径和参数,加快解析速度." @默认值 = 假>
    {
        @ @<所欲操作本对象>.Parse (@<URL地址>, @<缓存地址数据>, @<简易解析>)
    }

    方法 是否有缓存 <公开 静态 类型 = 逻辑型 注释 = "判断本对象是否缓存了URL地址数据." 注释 = "返回假表示本对象不拥有表单的文本数据,当\"解析\"时"
            注释 = "提供的文本变量被销毁,则请勿再使用本对象." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.HasBuffer ()
    }

    方法 取参数视图 <公开 静态 类型 = 文本视图类W 注释 = "获取指定名称的参数值,本方法不会对参数值进行URL解码." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    参数 名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否UTF8 <类型 = 逻辑型 注释 = "URL编码文本是否为UTF-8格式,否则为多字节." @默认值 = 真>
    {
        @ @dt<文本视图类W> {@<所欲操作本对象>.GetParam (@<名称>, @<是否UTF8>)}
    }

    方法 取参数文本 <公开 静态 类型 = 文本型 注释 = "将指定名称的参数值进行URL解码,返回文本型." 返回值注释 = "成功返回参数值文本,否则返回空文本." 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    参数 名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否UTF8 <类型 = 逻辑型 注释 = "URL编码文本是否为UTF-8格式,否则为多字节." @默认值 = 真>
    {
        @ @<所欲操作本对象>.GetParamVolStr (@<名称>, @<是否UTF8>)
    }

    方法 取指定参数 <公开 静态 类型 = 标准文本类W 注释 = "将指定名称的参数值进行URL解码,返回标准文本类." 返回值注释 = "成功返回参数值文本,否则返回空文本." 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    参数 名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否UTF8 <类型 = 逻辑型 注释 = "URL编码文本是否为UTF-8格式,否则为多字节." @默认值 = 真>
    {
        @ @<所欲操作本对象>.GetDecodeParam (@<名称>, @<是否UTF8>)
    }

    方法 清空 <公开 静态 注释 = "清空本对象已解析的URL数据." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.Clear ()
    }

    # ---

    方法 URL地址 <公开 静态 类型 = 文本视图类W 注释 = "返回文本视图,其中包含完整的URL地址." 返回值注释 = "本方法不会产生文本复制" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类W> {@<所欲操作本对象>.Url ()}
    }

    方法 协议 <公开 静态 类型 = 文本视图类W 注释 = "返回文本视图,其中包含URL的协议(scheme),如\"https\"" 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类W> {@<所欲操作本对象>.Scheme ()}
    }

    方法 账户 <公开 静态 类型 = 文本视图类W 注释 = "返回文本视图,其中包含URL的用户名(user),账户应当使用URL编码." 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类W> {@<所欲操作本对象>.User ()}
    }

    方法 密码 <公开 静态 类型 = 文本视图类W 注释 = "返回文本视图,其中包含URL的密码(password),密码必须使用URL编码." 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类W> {@<所欲操作本对象>.Password ()}
    }

    方法 域名 <公开 静态 类型 = 文本视图类W 注释 = "返回文本视图,其中包含URL的域名(host),如\"www.baidu.com\"" 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类W> {@<所欲操作本对象>.Host ()}
    }

    方法 端口 <公开 静态 类型 = 文本视图类W 注释 = "返回文本视图,其中包含URL的端口(port),如\"80\"." 返回值注释 = "本方法不会产生文本复制" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类W> {@<所欲操作本对象>.Port ()}
    }

    方法 路径 <公开 静态 类型 = 文本视图类W 注释 = "返回文本视图,其中包含URL的路径(path),如\"/index\"" 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类W> {@<所欲操作本对象>.Path ()}
    }

    方法 参数 <公开 静态 类型 = 文本视图类W 注释 = "返回文本视图,其中包含URL的查询参数文本(query)." 返回值注释 = "本方法不会产生文本复制" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类W> {@<所欲操作本对象>.Query ()}
    }

    方法 片段 <公开 静态 类型 = 文本视图类W 注释 = "返回文本视图,其中包含URL的片段(fragment),片段用于在网页中滚动到指定的位置." 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类W> {@<所欲操作本对象>.Fragment ()}
    }

    方法 段落 <公开 静态 类型 = 文本视图类W 注释 = "等同于\"片段\",仅保留以兼容旧代码." 返回值注释 = "本方法不会产生文本复制" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类W> {@<所欲操作本对象>.Fragment ()}
    }

    # ---

    方法 取协议 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的协议(scheme),如\"https\"" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetScheme ()
    }

    方法 取账户 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL解码后的用户名(user)." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    参数 是否UTF8 <类型 = 逻辑型 注释 = "URL编码文本是否为UTF-8格式,否则为多字节." @默认值 = 真>
    {
        @ @<所欲操作本对象>.GetUser ( @<是否UTF8>)
    }

    方法 取密码 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL解码后的密码(password)." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    参数 是否UTF8 <类型 = 逻辑型 注释 = "URL编码文本是否为UTF-8格式,否则为多字节." @默认值 = 真>
    {
        @ @<所欲操作本对象>.GetPassword (@<是否UTF8>)
    }

    方法 取域名 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的域名(host),如\"www.baidu.com\"" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetHost ()
    }

    方法 取端口 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的端口(port),如\"80\"." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetPort ()
    }

    方法 取路径 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的路径(path),如\"/index\"" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetPath ()
    }

    方法 取参数 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的查询参数文本(query)." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetQuery ()
    }

    方法 取片段 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的片段(fragment),片段用于在网页中滚动到指定的位置." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetFragment ()
    }

    方法 取段落 <公开 静态 类型 = 文本型 注释 = "等同于\"取片段\",仅保留以兼容旧代码." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetFragment ()
    }
}

类 URL地址解析类U <公开 注释 = "解析URL中各字段的文本和参数,本类内部使用的编码为UTF-8."
        注释 = "<scheme>://<user>:<password>@<host>:<port>/<path>?<query>#<fragment>" 折叠
        @文档 = "category = \"网络辅助\"" @别名 = "PivUrlParserU">
{
    方法 解析 <公开 静态 注释 = "解析URL地址,本方法可以解析不完整的URL地址," 注释 = "比如你可以只解析路径和参数." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    参数 URL地址 <注释 = "所欲解析的URL地址,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 缓存地址数据 <类型 = 逻辑型 注释 = "真: 将提供的URL地址数据复制到本对象的内部;" 注释 = "假: 本对象会使用文本视图指向提供的URL地址,请确保提供的\"URL地址\"是变量,"
            注释 = "且该变量的的生命周期不能短于本对象;" 注释 = "如果解析时产生了编码转换,则一定会缓存文本数据,可以使用\"是否有缓存\"判断.">
    参数 简易解析 <类型 = 逻辑型 注释 = "为真时只解析路径和参数,加快解析速度." @默认值 = 假>
    {
        @ @<所欲操作本对象>.Parse (@<URL地址>, @<缓存地址数据>, @<简易解析>)
    }

    方法 是否有缓存 <公开 静态 类型 = 逻辑型 注释 = "判断本对象是否缓存了URL地址数据." 注释 = "返回假表示本对象不拥有表单的文本数据,如果\"解析\"时"
            注释 = "提供的文本变量被销毁,则请勿再使用本对象." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.HasBuffer ()
    }

    方法 取参数视图 <公开 静态 类型 = 文本视图类U 注释 = "获取指定名称的参数值,本方法不会对参数值进行URL解码." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    参数 名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ @dt<文本视图类U> {@<所欲操作本对象>.GetParam (@<名称>, true)}
    }

    方法 取参数文本 <公开 静态 类型 = 文本型 注释 = "将指定名称的参数值进行URL解码,返回UTF-16LE文本型." 返回值注释 = "成功返回参数值文本,否则返回空文本." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    参数 名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.GetParamVolStr (@<名称>, true)
    }

    方法 取指定参数 <公开 静态 类型 = 标准文本类U 注释 = "将指定名称的参数值进行URL解码,返回标准文本类U." 返回值注释 = "成功返回参数值文本,否则返回空文本." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    参数 名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.GetDecodeParam (@<名称>, true)
    }

    方法 解码账户 <公开 静态 类型 = 标准文本类U 注释 = "获取URL解码后的用户名(user)" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.DecodeUser (true)
    }

    方法 解码密码 <公开 静态 类型 = 标准文本类U 注释 = "获取URL解码后的密码(password)" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.DecodePassword (true)
    }

    方法 清空 <公开 静态 注释 = "清空本对象已解析的URL数据." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.Clear ()
    }

    # ---

    方法 URL地址 <公开 静态 类型 = 文本视图类U 注释 = "返回文本视图,其中包含完整的URL地址." 返回值注释 = "本方法不会产生文本复制" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类U> {@<所欲操作本对象>.Url ()}
    }

    方法 协议 <公开 静态 类型 = 文本视图类U 注释 = "返回文本视图,其中包含URL的协议(scheme),如\"https\"" 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类U> {@<所欲操作本对象>.Scheme ()}
    }

    方法 账户 <公开 静态 类型 = 文本视图类U 注释 = "返回文本视图,其中包含URL的用户名(user),账户应当使用URL编码." 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类U> {@<所欲操作本对象>.User ()}
    }

    方法 密码 <公开 静态 类型 = 文本视图类U 注释 = "返回文本视图,其中包含URL的密码(password),密码必须使用URL编码." 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类U> {@<所欲操作本对象>.Password ()}
    }

    方法 域名 <公开 静态 类型 = 文本视图类U 注释 = "返回文本视图,其中包含URL的域名(host),如\"www.baidu.com\"" 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类U> {@<所欲操作本对象>.Host ()}
    }

    方法 端口 <公开 静态 类型 = 文本视图类U 注释 = "返回文本视图,其中包含URL的端口(port),如\"80\"." 返回值注释 = "本方法不会产生文本复制" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类U> {@<所欲操作本对象>.Port ()}
    }

    方法 路径 <公开 静态 类型 = 文本视图类U 注释 = "返回文本视图,其中包含URL的路径(path),如\"/index\"" 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类U> {@<所欲操作本对象>.Path ()}
    }

    方法 参数 <公开 静态 类型 = 文本视图类U 注释 = "返回文本视图,其中包含URL的查询参数文本(query)." 返回值注释 = "本方法不会产生文本复制" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类U> {@<所欲操作本对象>.Query ()}
    }

    方法 片段 <公开 静态 类型 = 文本视图类U 注释 = "返回文本视图,其中包含URL的片段(fragment),片段用于在网页中滚动到指定的位置." 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类U> {@<所欲操作本对象>.Fragment ()}
    }

    方法 段落 <公开 静态 类型 = 文本视图类U 注释 = "等同于\"片段\",仅保留以兼容旧代码." 返回值注释 = "本方法不会产生文本复制" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类U> {@<所欲操作本对象>.Fragment ()}
    }

    # ---

    方法 取协议 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的协议(scheme),如\"https\"" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetScheme ()
    }

    方法 取账户 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL解码后的用户名(user)." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetUser (true)
    }

    方法 取密码 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL解码后的密码(password)." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    参数 URL解码 <类型 = 逻辑型 注释 = "对参数值进行URL解码" @默认值 = 假>
    {
        @ @<所欲操作本对象>.GetPassword (true)
    }

    方法 取域名 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的域名(host),如\"www.baidu.com\"" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetHost ()
    }

    方法 取端口 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的端口(port),如\"80\"." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetPort ()
    }

    方法 取路径 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的路径(path),如\"/index\"" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetPath ()
    }

    方法 取参数 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的查询参数文本(query)." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetQuery ()
    }

    方法 取片段 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的片段(fragment),片段用于在网页中滚动到指定的位置." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetFragment ()
    }

    方法 取段落 <公开 静态 类型 = 文本型 注释 = "等同于\"取片段\",仅保留以兼容旧代码." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetFragment ()
    }
}

类 URL地址解析类A <公开 注释 = "解析URL中各字段的文本和参数,本类内部使用的编码为ANSI本地多字节."
        注释 = "<scheme>://<user>:<password>@<host>:<port>/<path>?<query>#<fragment>" 折叠
        @文档 = "category = \"网络辅助\"" @别名 = "PivUrlParserA">
{
    方法 解析 <公开 静态 注释 = "解析URL地址,本方法可以解析不完整的URL地址," 注释 = "比如你可以只解析路径和参数." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    参数 URL地址 <注释 = "所欲解析的URL地址,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 缓存地址数据 <类型 = 逻辑型 注释 = "真: 将提供的URL地址数据复制到本对象的内部;" 注释 = "假: 本对象会使用文本视图指向提供的URL地址,请确保提供的\"URL地址\"是变量,"
            注释 = "且该变量的的生命周期不能短于本对象;" 注释 = "如果解析时产生了编码转换,则一定会缓存文本数据,可以使用\"是否有缓存\"判断.">
    参数 简易解析 <类型 = 逻辑型 注释 = "为真时只解析路径和参数,加快解析速度." @默认值 = 假>
    {
        @ @<所欲操作本对象>.Parse (@<URL地址>, @<缓存地址数据>, @<简易解析>)
    }

    方法 是否有缓存 <公开 静态 类型 = 逻辑型 注释 = "判断本对象是否缓存了URL地址数据." 注释 = "返回假表示本对象不拥有表单的文本数据,如果\"解析\"时"
            注释 = "提供的文本变量被销毁,则请勿再使用本对象." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.HasBuffer ()
    }

    方法 取参数视图 <公开 静态 类型 = 文本视图类A 注释 = "获取指定名称的参数值,本方法不会对参数值进行URL解码." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    参数 名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    {
        @ @dt<文本视图类A> {@<所欲操作本对象>.GetParam (@<名称>, true)}
    }

    方法 取参数文本 <公开 静态 类型 = 文本型 注释 = "将指定名称的参数值进行URL解码,返回UTF-16LE文本型." 返回值注释 = "成功返回参数值文本,否则返回空文本." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    参数 名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.GetParamVolStr (@<名称>, false)
    }

    方法 取指定参数 <公开 静态 类型 = 标准文本类A 注释 = "将指定名称的参数值进行URL解码,返回标准文本类A." 返回值注释 = "成功返回参数值文本,否则返回空文本." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    参数 名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.GetDecodeParam (@<名称>, false)
    }

    方法 解码账户 <公开 静态 类型 = 标准文本类A 注释 = "获取URL解码后的用户名(user)" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.DecodeUser (false)
    }

    方法 解码密码 <公开 静态 类型 = 标准文本类A 注释 = "获取URL解码后的密码(password)" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.DecodePassword (false)
    }

    方法 清空 <公开 静态 注释 = "清空本对象已解析的URL数据." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.Clear ()
    }

    # ---

    方法 URL地址 <公开 静态 类型 = 文本视图类A 注释 = "返回文本视图,其中包含完整的URL地址." 返回值注释 = "本方法不会产生文本复制" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类A> {@<所欲操作本对象>.Url ()}
    }

    方法 协议 <公开 静态 类型 = 文本视图类A 注释 = "返回文本视图,其中包含URL的协议(scheme),如\"https\"" 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类A> {@<所欲操作本对象>.Scheme ()}
    }

    方法 账户 <公开 静态 类型 = 文本视图类A 注释 = "返回文本视图,其中包含URL的用户名(user),账户应当使用URL编码." 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类A> {@<所欲操作本对象>.User ()}
    }

    方法 密码 <公开 静态 类型 = 文本视图类A 注释 = "返回文本视图,其中包含URL的密码(password),密码必须使用URL编码." 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类A> {@<所欲操作本对象>.Password ()}
    }

    方法 域名 <公开 静态 类型 = 文本视图类A 注释 = "返回文本视图,其中包含URL的域名(host),如\"www.baidu.com\"" 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类A> {@<所欲操作本对象>.Host ()}
    }

    方法 端口 <公开 静态 类型 = 文本视图类A 注释 = "返回文本视图,其中包含URL的端口(port),如\"80\"." 返回值注释 = "本方法不会产生文本复制" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类A> {@<所欲操作本对象>.Port ()}
    }

    方法 路径 <公开 静态 类型 = 文本视图类A 注释 = "返回文本视图,其中包含URL的路径(path),如\"/index\"" 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类A> {@<所欲操作本对象>.Path ()}
    }

    方法 参数 <公开 静态 类型 = 文本视图类A 注释 = "返回文本视图,其中包含URL的查询参数文本(query)." 返回值注释 = "本方法不会产生文本复制" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类A> {@<所欲操作本对象>.Query ()}
    }

    方法 片段 <公开 静态 类型 = 文本视图类A 注释 = "返回文本视图,其中包含URL的片段(fragment),片段用于在网页中滚动到指定的位置." 返回值注释 = "本方法不会产生文本复制" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类A> {@<所欲操作本对象>.Fragment ()}
    }

    方法 段落 <公开 静态 类型 = 文本视图类A 注释 = "等同于\"片段\",仅保留以兼容旧代码." 返回值注释 = "本方法不会产生文本复制" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @dt<文本视图类A> {@<所欲操作本对象>.Fragment ()}
    }

    # ---

    方法 取协议 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的协议(scheme),如\"https\"" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetScheme ()
    }

    方法 取账户 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL解码后的用户名(user)." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetUser (false)
    }

    方法 取密码 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL解码后的密码(password)." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetPassword (false)
    }

    方法 取域名 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的域名(host),如\"www.baidu.com\"" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetHost ()
    }

    方法 取端口 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的端口(port),如\"80\"." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetPort ()
    }

    方法 取路径 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的路径(path),如\"/index\"" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetPath ()
    }

    方法 取参数 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的查询参数文本(query)." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetQuery ()
    }

    方法 取片段 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含URL的片段(fragment),片段用于在网页中滚动到指定的位置." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetFragment ()
    }

    方法 取段落 <公开 静态 类型 = 文本型 注释 = "等同于\"取片段\",仅保留以兼容旧代码." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = URL地址解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetFragment ()
    }
}

# 表单参数 =====

类 表单构造类 <公开 注释 = "用于快捷填写网络POST请求的表单参数,本类内部使用的编码为UTF-16LE(非常不常用)."
        注释 = "注意: 仅限x-www-form-urlencoded格式的表单." 折叠 @文档 = "category = \"网络辅助\"" @别名 = "PivFormCreaterW">
{
    方法 数据 <公开 静态 类型 = 字节集类 注释 = "返回表单的字节集数据,用于提交参数." 注释 = "注意: 本方法参考返回内部的字节集数据,不会产生内存复制." 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = 表单构造类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetMem ()
    }

    方法 清空 <公开 静态 注释 = "清空本表单的所有参数内容" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单构造类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.Clear ()
    }

    方法 添加参数 <公开 静态 类型 = 表单构造类 注释 = "添加一组参数键值对,并对不安全字符进行URL编码." 注释 = "注意: 本方法支持链式语法" 返回值注释 = "返回自身(支持链式语法)"
            折叠 @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = 表单构造类 注释 = "所欲操作本对象,本参数无需填写.">
    参数 键 <注释 = "所欲添加的参数键名,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 值 <注释 = "所欲添加的参数值,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否UTF8 <类型 = 逻辑型 注释 = "将参数值以UTF-8格式进行URL编码,否则为多字节." @默认值 = 真>
    {
        @ @<所欲操作本对象>.AddParam (@<键>, @<值>, @<是否UTF8>)
    }

    方法 到文本型 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含了表单的当前内容." 注释 = "注意: 本方法会产生文本复制" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单构造类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.ToStr ()
    }

    方法 到文本视图 <公开 静态 类型 = 文本视图类W 注释 = "返回一个文本视图,其中包含了表单的当前内容." 注释 = "注意: 默认情况下本方法不会产生文本复制,"
            注释 = "请确保本对象的生命周期大于返回的文本视图." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = 表单构造类 注释 = "所欲操作本对象,本参数无需填写.">
    参数 缓存文本数据 <类型 = 逻辑型 注释 = "  默认为假,返回的文本视图指向当前的标准文本,必须保证" 注释 = "当前对象不能比文本视图短."
            注释 = "  为真时,将使用智能指针在文本视图中复制并缓存当前的" 注释 = "文本数据,返回的文本视图不再与当前对象关联." @默认值 = 假>
    {
        @ @dt<文本视图类W> {@<所欲操作本对象>.ToStrView (), @<缓存文本数据>}
    }

    方法 置预分配尺寸 <公开 静态 注释 = "设置内部字节集的预分配尺寸,在\"添加参数\"前提供一个足够大" 注释 = "的尺寸可以减少内存分配." 注释 = "本对象的默认值为2048,一般够用."
            折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单构造类 注释 = "所欲操作本对象,本参数无需填写.">
    参数 所欲设置的预分配尺寸 <类型 = 变整数 注释 = "提供所欲设置的预分配尺寸,必须大于等于0.">
    {
        @ @<所欲操作本对象>.SetAlignSize (@<所欲设置的预分配尺寸>)
    }

    方法 是否为空 <公开 静态 类型 = 逻辑型 注释 = "返回当前表单是否为空" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单构造类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.IsEmpty ()
    }
}

类 表单构造类U <公开 注释 = "用于快捷填写网络POST请求的表单参数,本类内部使用的编码为UTF-8(最常用)." 注释 = "注意: 仅限x-www-form-urlencoded格式的表单."
        折叠 @文档 = "category = \"网络辅助\"" @别名 = "PivFormCreaterU">
{
    方法 数据 <公开 静态 类型 = 字节集类 注释 = "返回表单的字节集数据,用于提交参数." 注释 = "注意: 本方法参考返回内部的字节集数据,不会产生内存复制." 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = 表单构造类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetMem ()
    }

    方法 清空 <公开 静态 注释 = "清空本表单的所有参数内容" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单构造类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.Clear ()
    }

    方法 添加参数 <公开 静态 类型 = 表单构造类U 注释 = "添加一组参数键值对,并对不安全字符进行URL编码." 注释 = "注意: 本方法支持链式语法" 返回值注释 = "返回自身(支持链式语法)"
            折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = 表单构造类U 注释 = "所欲操作本对象,本参数无需填写.">
    参数 键 <注释 = "所欲添加的参数键名,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 值 <注释 = "所欲添加的参数值,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.AddParam (@<键>, @<值>, true)
    }

    方法 到文本型 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含了表单的当前内容." 注释 = "注意: 本方法会产生文本复制和编码转换" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单构造类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.ToStr ()
    }

    方法 到文本视图 <公开 静态 类型 = 文本视图类U 注释 = "返回一个文本视图,其中包含了表单的当前内容." 注释 = "注意: 默认情况下本方法不会产生文本复制,"
            注释 = "请确保本对象的生命周期大于返回的文本视图." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单构造类U 注释 = "所欲操作本对象,本参数无需填写.">
    参数 缓存文本数据 <类型 = 逻辑型 注释 = "  默认为假,返回的文本视图指向当前的标准文本,必须保证" 注释 = "当前对象不能比文本视图短."
            注释 = "  为真时,将使用智能指针在文本视图中复制并缓存当前的" 注释 = "文本数据,返回的文本视图不再与当前对象关联." @默认值 = 假>
    {
        @ @dt<文本视图类U> {@<所欲操作本对象>.ToStrView (), @<缓存文本数据>}
    }

    方法 置预分配尺寸 <公开 静态 注释 = "设置内部字节集的预分配尺寸,在\"添加参数\"前提供一个足够大" 注释 = "的尺寸可以减少内存分配." 注释 = "本对象的默认值为2048,一般够用."
            折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单构造类U 注释 = "所欲操作本对象,本参数无需填写.">
    参数 所欲设置的预分配尺寸 <类型 = 变整数 注释 = "提供所欲设置的预分配尺寸,必须大于等于0.">
    {
        @ @<所欲操作本对象>.SetAlignSize (@<所欲设置的预分配尺寸>)
    }

    方法 是否为空 <公开 静态 类型 = 逻辑型 注释 = "返回当前表单是否为空" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单构造类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.IsEmpty ()
    }
}

类 表单构造类A <公开 注释 = "用于快捷填写网络POST请求的表单参数,本类内部使用的编码为ANSI本地多字节(常用)."
        注释 = "注意: 仅限x-www-form-urlencoded格式的表单." 折叠 @文档 = "category = \"网络辅助\"" @别名 = "PivFormCreaterA">
{
    方法 数据 <公开 静态 类型 = 字节集类 注释 = "返回表单的字节集数据,用于提交参数." 注释 = "注意: 本方法参考返回内部的字节集数据,不会产生内存复制." 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = 表单构造类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.GetMem ()
    }

    方法 清空 <公开 静态 注释 = "清空本表单的所有参数内容" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单构造类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.Clear ()
    }

    方法 添加参数 <公开 静态 类型 = 表单构造类A 注释 = "添加一组参数键值对,并对不安全字符进行URL编码." 注释 = "注意: 本方法支持链式语法" 返回值注释 = "返回自身(支持链式语法)"
            折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = 表单构造类A 注释 = "所欲操作本对象,本参数无需填写.">
    参数 键 <注释 = "所欲添加的参数键名,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 值 <注释 = "所欲添加的参数值,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.AddParam (@<键>, @<值>, false)
    }

    方法 到文本型 <公开 静态 类型 = 文本型 注释 = "返回一个文本型,其中包含了表单的当前内容." 注释 = "注意: 本方法会产生文本复制和编码转换" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单构造类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.ToStr ()
    }

    方法 到文本视图 <公开 静态 类型 = 文本视图类A 注释 = "返回一个文本视图,其中包含了表单的当前内容." 注释 = "注意: 默认情况下本方法不会产生文本复制,"
            注释 = "请确保本对象的生命周期大于返回的文本视图." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = 表单构造类A 注释 = "所欲操作本对象,本参数无需填写.">
    参数 缓存文本数据 <类型 = 逻辑型 注释 = "  默认为假,返回的文本视图指向当前的标准文本,必须保证" 注释 = "当前对象不能比文本视图短."
            注释 = "  为真时,将使用智能指针在文本视图中复制并缓存当前的" 注释 = "文本数据,返回的文本视图不再与当前对象关联." @默认值 = 假>
    {
        @ @dt<文本视图类A> {@<所欲操作本对象>.ToStrView (), @<缓存文本数据>}
    }

    方法 置预分配尺寸 <公开 静态 注释 = "设置内部字节集的预分配尺寸,在\"添加参数\"前提供一个足够大" 注释 = "的尺寸可以减少内存分配." 注释 = "本对象的默认值为2048,一般够用."
            折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单构造类A 注释 = "所欲操作本对象,本参数无需填写.">
    参数 所欲设置的预分配尺寸 <类型 = 变整数 注释 = "提供所欲设置的预分配尺寸,必须大于等于0.">
    {
        @ @<所欲操作本对象>.SetAlignSize (@<所欲设置的预分配尺寸>)
    }

    方法 是否为空 <公开 静态 类型 = 逻辑型 注释 = "返回当前表单是否为空" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单构造类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.IsEmpty ()
    }
}

# ---

类 表单解析类 <公开 注释 = "用于在服务端解析POST的表单参数,本类内部使用的编码为UTF-16LE(不常用)." 注释 = "注意: 仅限x-www-form-urlencoded格式的表单."
        折叠 @文档 = "category = \"网络辅助\"" @别名 = "PivFormParserW">
{
    方法 解析 <公开 静态 类型 = 逻辑型 注释 = "解析所指定表单的参数." 注释 = "注意: 本方法只支持解析\"key1=value1&key=value2\"这样的键值对,"
            注释 = "不能JSON等类型." 返回值注释 = "返回是否解析成功" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = 表单解析类 注释 = "所欲操作本对象,本参数无需填写.">
    参数 表单数据 <注释 = "所欲解析的表单参数,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 缓存地址数据 <类型 = 逻辑型 注释 = "真: 将提供的表单数据复制到本对象的内部;" 注释 = "假: 本对象会使用文本视图指向提供表单数据,请确保提供的\"表单数据\"是变量,"
            注释 = "且该变量的的生命周期不能短于本对象;" 注释 = "如果解析时产生了编码转换,则一定会缓存文本数据,可以使用\"是否有缓存\"判断.">
    {
        @ @<所欲操作本对象>.Parse (@<表单数据>, @<缓存地址数据>)
    }

    方法 是否有缓存 <公开 静态 类型 = 逻辑型 注释 = "判断本对象是否缓存了表单数据." 注释 = "返回假表示本对象不拥有表单的文本数据,如果\"解析\"时"
            注释 = "提供的文本变量被销毁,则请勿再使用本对象." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.HasBuffer ()
    }

    方法 取参数 <公开 静态 类型 = 标准文本类W 注释 = "获取指定名称的参数值并进行URL解码,以\"标准文本类\"返回解码后的参数值." 返回值注释 = "成功返回参数值文本,否则返回空文本."
            折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = 表单解析类 注释 = "所欲操作本对象,本参数无需填写.">
    参数 参数名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否UTF8 <类型 = 逻辑型 注释 = "URL编码文本是否为UTF-8格式,否则为多字节." @默认值 = 真>
    {
        @ @<所欲操作本对象>.GetDecodeParam (@<参数名称>, @<是否UTF8>)
    }

    方法 取参数视图 <公开 静态 类型 = 文本视图类W 注释 = "返回一个文本视图,其中包含指定名称的参数值." 注释 = "本方法不会产生文本复制,也不会进行URL解码,"
            注释 = "本对象被销毁或清空后请勿再使用返回的文本视图." 返回值注释 = "成功返回参数值文本视图,否则返回空视图." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = 表单解析类 注释 = "所欲操作本对象,本参数无需填写.">
    参数 参数名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否UTF8 <类型 = 逻辑型 注释 = "URL编码文本是否为UTF-8格式,否则为多字节." @默认值 = 真>
    {
        @ @dt<文本视图类W> {@<所欲操作本对象>.GetParam (@<参数名称>, @<是否UTF8>)}
    }

    方法 取参数文本 <公开 静态 类型 = 文本型 注释 = "获取指定名称的参数值并进行URL解码,以\"文本型\"返回解码后的参数值." 返回值注释 = "成功返回参数值文本,否则返回空文本." 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = 表单解析类 注释 = "所欲操作本对象,本参数无需填写.">
    参数 参数名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否UTF8 <类型 = 逻辑型 注释 = "URL编码文本是否为UTF-8格式,否则为多字节." @默认值 = 真>
    {
        @ @<所欲操作本对象>.GetParamStr (@<参数名称>, @<是否UTF8>, @an<CVolString>{})
    }

    方法 取所有键名 <公开 静态 类型 = 整数 注释 = "获取所有的参数名称(键名),返回键名的数量." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单解析类 注释 = "所欲操作本对象,本参数无需填写.">
    参数 键名数组 <类型 = 文本视图数组类W 注释 = "存放参数名称的数组">
    {
        @ static_cast<INT>(@<所欲操作本对象>.EnumKey(@<键名数组>))
    }

    方法 清空 <公开 静态 注释 = "清空本对象已解析的表单数据" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单解析类 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.Clear ()
    }
}

类 表单解析类U <公开 注释 = "用于在服务端解析POST的表单参数,本类内部使用的编码为UTF-8(最常用)." 注释 = "注意: 仅限x-www-form-urlencoded格式的表单." 折叠
        @文档 = "category = \"网络辅助\"" @别名 = "PivFormParserU">
{
    方法 解析 <公开 静态 类型 = 逻辑型 注释 = "解析所指定表单的参数." 注释 = "注意: 本方法只支持解析\"key1=value1&key=value2\"这样的键值对,"
            注释 = "不能JSON等类型." 返回值注释 = "返回是否解析成功" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = 表单解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    参数 表单数据 <注释 = "所欲解析的表单参数,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 缓存地址数据 <类型 = 逻辑型 注释 = "真: 将提供的表单数据复制到本对象的内部;" 注释 = "假: 本对象会使用文本视图指向提供表单数据,请确保提供的\"表单数据\"是变量,"
            注释 = "且该变量的的生命周期不能短于本对象;" 注释 = "如果解析时产生了编码转换,则一定会缓存文本数据,可以使用\"是否有缓存\"判断.">
    {
        @ @<所欲操作本对象>.Parse (@<表单数据>, @<缓存地址数据>)
    }

    方法 是否有缓存 <公开 静态 类型 = 逻辑型 注释 = "判断本对象是否缓存了表单数据." 注释 = "返回假表示本对象不拥有表单的文本数据,如果\"解析\"时"
            注释 = "提供的文本变量被销毁,则请勿再使用本对象." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.HasBuffer ()
    }

    方法 取参数 <公开 静态 类型 = 标准文本类U 注释 = "获取指定名称的参数值并进行URL解码,以\"标准文本型类U\"返回解码后的参数值." 返回值注释 = "成功返回参数值文本,否则返回空文本."
            折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    参数 参数名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.GetDecodeParam (@<参数名称>, true)
    }

    方法 取参数视图 <公开 静态 类型 = 文本视图类U 注释 = "返回一个文本视图,其中包含指定名称的参数值." 注释 = "本方法不会产生文本复制,也不会进行URL解码,"
            注释 = "本对象被销毁或清空后请勿再使用返回的文本视图." 返回值注释 = "成功返回参数值文本视图,否则返回空视图." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    参数 参数名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ @dt<文本视图类U> {@<所欲操作本对象>.GetParam (@<参数名称>, true)}
    }

    方法 取参数文本 <公开 静态 类型 = 文本型 注释 = "获取指定名称的参数值并进行URL解码,以\"文本型\"返回解码后的参数值." 返回值注释 = "成功返回参数值文本,否则返回空文本." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    参数 参数名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.GetParamStr (@<参数名称>, true, @an<CVolString>{})
    }

    方法 取所有键名 <公开 静态 类型 = 整数 注释 = "获取所有的参数名称(键名),返回键名的数量." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    参数 键名数组 <类型 = 文本视图数组类U 注释 = "存放参数名称的数组">
    {
        @ static_cast<INT>(@<所欲操作本对象>.EnumKey(@<键名数组>))
    }

    方法 清空 <公开 静态 注释 = "清空本对象已解析的表单数据" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单解析类U 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.Clear ()
    }
}

类 表单解析类A <公开 注释 = "用于在服务端解析POST的表单参数,本类内部使用的编码为ANSI本地多字节(常用)." 注释 = "注意: 仅限x-www-form-urlencoded格式的表单."
        折叠 @文档 = "category = \"网络辅助\"" @别名 = "PivFormParserA">
{
    方法 解析 <公开 静态 类型 = 逻辑型 注释 = "解析所指定表单的参数." 注释 = "注意: 本方法只支持解析\"key1=value1&key=value2\"这样的键值对,"
            注释 = "不能JSON等类型." 返回值注释 = "返回是否解析成功" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = 表单解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    参数 表单数据 <注释 = "所欲解析的表单参数,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 缓存地址数据 <类型 = 逻辑型 注释 = "真: 将提供的表单数据复制到本对象的内部;" 注释 = "假: 本对象会使用文本视图指向提供表单数据,请确保提供的\"表单数据\"是变量,"
            注释 = "且该变量的的生命周期不能短于本对象;" 注释 = "如果解析时产生了编码转换,则一定会缓存文本数据,可以使用\"是否有缓存\"判断.">
    {
        @ @<所欲操作本对象>.Parse (@<表单数据>, @<缓存地址数据>)
    }

    方法 是否有缓存 <公开 静态 类型 = 逻辑型 注释 = "判断本对象是否缓存了表单数据." 注释 = "返回假表示本对象不拥有表单的文本数据,如果\"解析\"时"
            注释 = "提供的文本变量被销毁,则请勿再使用本对象." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.HasBuffer ()
    }

    方法 取参数 <公开 静态 类型 = 标准文本类A 注释 = "获取指定名称的参数值并进行URL解码,以\"标准文本类A\"返回解码后的参数值." 返回值注释 = "成功返回参数值文本,否则返回空文本."
            折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    参数 参数名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.GetDecodeParam (@<参数名称>, false)
    }

    方法 取参数视图 <公开 静态 类型 = 文本视图类A 注释 = "返回一个文本视图,其中包含指定名称的参数值." 注释 = "本方法不会产生文本复制,也不会进行URL解码,"
            注释 = "本对象被销毁或清空后请勿再使用返回的文本视图." 返回值注释 = "成功返回参数值文本视图,否则返回空视图." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    参数 参数名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    {
        @ @dt<文本视图类A> {@<所欲操作本对象>.GetParam (@<参数名称>, false)}
    }

    方法 取参数文本 <公开 静态 类型 = 文本型 注释 = "获取指定名称的参数值并进行URL解码,以\"文本型\"返回解码后的参数值." 返回值注释 = "成功返回参数值文本,否则返回空文本." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    参数 参数名称 <注释 = "所欲获取的参数名称,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.GetParamStr (@<参数名称>, false, @an<CVolString>{})
    }

    方法 取所有键名 <公开 静态 类型 = 整数 注释 = "获取所有的参数名称(键名),返回键名的数量." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    参数 键名数组 <类型 = 文本视图数组类A 注释 = "存放参数名称的数组">
    {
        @ static_cast<INT>(@<所欲操作本对象>.EnumKey(@<键名数组>))
    }

    方法 清空 <公开 静态 注释 = "清空本对象已解析的表单数据" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = 表单解析类A 注释 = "所欲操作本对象,本参数无需填写.">
    {
        @ @<所欲操作本对象>.Clear ()
    }
}
