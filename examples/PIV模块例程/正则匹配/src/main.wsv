<火山程序 类型 = "通常" 版本 = 1 />

包 火山.程序

# @ #pragma optimize( "", off) // 禁止编译优化,编译优化会删除部分无用代码,从而导致测试结果不准确

类 启动类 <公开 基础类 = 窗口程序类 折叠>
{
    变量 主窗口对象 <类型 = 我的主窗口>

    方法 启动方法 <公开 类型 = 整数>
    {
        主窗口对象.创建主窗口 ()
        返回 (1)
    }
}

# ======
# 由于官方的标准正则速度不理想，DEELX 正则带 DLL，所以一直想封装一个新的正则库。
# 但看了两个 GitHub 排名靠前的正则库都各有问题：
#   1. Google RE2：Golang 语言同作者的力作，Golang 里的正则也是基于 RE2 实现，但 RE2 的问题是不支持 UTF-16LE 编码。
#   2. Intel hyperscan：目前最快的正则库，但它的快是依赖 CPU 的 SIMD 指令集实现，也就是这个库不兼容老 CPU。
# 后来在查资料的时候，发现了这篇《C/C++正则表达式库的简单测试》https://zhuanlan.zhihu.com/p/553248950
# 文章作者写了个文本编辑器EDX，并开源了他写的正则库，在这个测试中，他的 simple_regex 只比 RE2 稍慢。
# simple_regex 的源码比较简单，于是我修改成PIV模块的这个新正则库。
# PivRegex 相比 simple_regex 的修改：
#   1. 增加单行模式，正则替换功能；
#   2. 修改了忽略大小写的实现(原本的遇到中文就会出错)
#
# ======

类 我的主窗口 <基础类 = 窗口 注释 = "请编译发布版测试" 折叠 折叠2 @视窗.布局 = "client_size = \"705, 390\"" 标题 = "正则匹配">
{
    变量 按钮1 <类型 = 按钮 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 101\r\npos = \"578, 24, 120, 32\"" 标题 = "取匹配数">
    变量 按钮2 <类型 = 按钮 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 102\r\npos = \"578, 82, 120, 32\"" 标题 = "取匹配文本">
    变量 按钮3 <类型 = 按钮 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 103\r\npos = \"578, 140, 120, 32\"" 标题 = "正则替换">
    变量 超级列表框_结果 <类型 = 超级列表框 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 104\r\npos = \"10, 10, 560, 340\"" "类型" = 报表列表框
            报表列 = "0\n-1\n0\n100\n规则\n0\n-1\n0\n150\nPIV正则\n0\n-1\n0\n150\nSTD正则\n0\n-1\n0\n150\nDeelx正则"
            表项 = "0\n-1\n-1\n0\n0\naax\n\n0\n-1\n-1\n0\n0\nhuck\n\n0\n-1\n-1\n0\n0\ning\n\n0\n-1\n-1\n0\n0\ning2\n\n0\n-1\n-1\n0\n0\ninn\n\n0\n-1\n-1\n0\n0\nmix\n\n0\n-1\n-1\n0\n0\nshing\n\n0\n-1\n-1\n0\n0\ntom\n\n0\n-1\n-1\n0\n0\nTom\n\n0\n-1\n-1\n0\n0\ntom2\n\n0\n-1\n-1\n0\n0\ntom4\n\n0\n-1\n-1\n0\n0\ntwain\n\n0\n-1\n-1\n0\n0\nTwain\n\n0\n-1\n-1\n0\n0\nword\n\n0\n-1\n-1\n0\n0\n邮箱(10w)\n"
            允许编辑 = 假 显示表格线 = 真>
    变量 标签1 <类型 = 标签 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 105\r\npos = \"10, 359, 560, 24\""
            标题 = "注: 测试结果为执行耗时，单位为纳秒(1毫秒=1,000,000纳秒)">
    变量 按钮4 <类型 = 按钮 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 106\r\npos = \"578, 200, 120, 32\"" 标题 = "PIV高级替换">
    变量 窗口1 <类型 = 正则窗口>
    变量 主线程处理 <静态 类型 = 高级主线程处理器>
    变量 匹配内容 <静态 类型 = 文本型>

    方法 我的主窗口_创建完毕 <接收事件 类型 = 整数 注释 = "当本组件及其中所有子组件均被创建完毕后发送此事件." 折叠>
    参数 来源对象 <类型 = 我的主窗口 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    {
        挂接事件 (主线程处理)  // 静态成员要使用接收事件,必须手动挂接
        // 从压缩包中解压出文本
        变量 马克吐温节选 <静态 类型 = 视窗文件资源 值 = "3200.7z" 注释 = "解压后约5M多的txt文本">
        变量 解压结果 <类型 = 存档解压键值类>
        如果 (存档读写类.解压资源到内存 (马克吐温节选, 解压结果) == 假)
        {
            信息框 ("初始化失败，即将退出.")
            关闭窗口 ()
        }
        添加文本指针内容 (匹配内容, 解压结果.取值 ("3200.txt").取字节集指针 ())
        返回 (0)
    }

    方法 按钮_被单击 <接收事件 类型 = 整数 注释 = "当按钮被单击后发送此事件" 折叠>
    参数 来源对象 <类型 = 按钮 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    {
        如果 (来源对象 == 按钮1)
        {
            如果 (为调试版 ())
            {
                信息框 ("请编译发布版进行测试，调试版下测试耗时很长，且结果不准确。")
            }
            否则
            {
                启动线程 (匹配测试1, 0)
            }
        }
        否则 (来源对象 == 按钮2)
        {
            如果 (为调试版 ())
            {
                信息框 ("请编译发布版进行测试，调试版下测试耗时很长，且结果不准确。")
            }
            否则
            {
                启动线程 (匹配测试2, 0)
            }
        }
        否则 (来源对象 == 按钮3)
        {
            如果 (为调试版 ())
            {
                信息框 ("请编译发布版进行测试，调试版下测试耗时很长，且结果不准确。")
            }
            否则
            {
                启动线程 (替换测试1, 0)
            }
        }
        否则 (来源对象 == 按钮4)
        {
            如果 (窗口1.是否为空 ())
            {
                窗口1.创建窗口 ()
            }

        }
        返回 (0)
    }

    方法 匹配测试1 <静态 类型 = 整数 注释 = "本测试只获取匹配的数量,未获取匹配文本." 折叠>
    参数 参数 <类型 = 变整数>
    {
        主线程处理.发送通知 (1)

        主线程处理.发送通知 (0, 0, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.匹配 (匹配内容, 正则规则.aax, 假))))
        主线程处理.发送通知 (0, 1, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.匹配 (匹配内容, 正则规则.huck, 假))))
        主线程处理.发送通知 (0, 2, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.匹配 (匹配内容, 正则规则.ing, 假))))
        主线程处理.发送通知 (0, 3, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.匹配 (匹配内容, 正则规则.ing2, 假))))
        主线程处理.发送通知 (0, 4, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.匹配 (匹配内容, 正则规则.inn, 假))))
        主线程处理.发送通知 (0, 5, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.匹配 (匹配内容, 正则规则.mix, 假))))
        主线程处理.发送通知 (0, 6, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.匹配 (匹配内容, 正则规则.shing, 假))))
        主线程处理.发送通知 (0, 7, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.匹配 (匹配内容, 正则规则.tom, 真))))
        主线程处理.发送通知 (0, 8, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.匹配 (匹配内容, 正则规则.tom, 假))))
        主线程处理.发送通知 (0, 9, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.匹配 (匹配内容, 正则规则.tom2, 假))))
        主线程处理.发送通知 (0, 10, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.匹配 (匹配内容, 正则规则.tom4, 假))))
        主线程处理.发送通知 (0, 11, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.匹配 (匹配内容, 正则规则.twain, 假))))
        主线程处理.发送通知 (0, 12, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.匹配 (匹配内容, 正则规则.twain, 真))))
        主线程处理.发送通知 (0, 13, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.匹配 (匹配内容, 正则规则.word, 假))))
        主线程处理.发送通知 (0, 14, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.完全匹配 ("xelloss@vip.qq.com", 正则规则.邮箱))))

        主线程处理.发送通知 (0, 0, 2, 文本到对象 (取千位分隔数值文本 (STD正则.匹配 (匹配内容, 正则规则.aax, 假))))
        主线程处理.发送通知 (0, 1, 2, 文本到对象 (取千位分隔数值文本 (STD正则.匹配 (匹配内容, 正则规则.huck, 假))))
        主线程处理.发送通知 (0, 2, 2, 文本到对象 (取千位分隔数值文本 (STD正则.匹配 (匹配内容, 正则规则.ing, 假))))
        主线程处理.发送通知 (0, 3, 2, 文本到对象 (取千位分隔数值文本 (STD正则.匹配 (匹配内容, 正则规则.ing2, 假))))
        主线程处理.发送通知 (0, 4, 2, 文本到对象 (取千位分隔数值文本 (STD正则.匹配 (匹配内容, 正则规则.inn, 假))))
        主线程处理.发送通知 (0, 5, 2, 文本到对象 (取千位分隔数值文本 (STD正则.匹配 (匹配内容, 正则规则.mix, 假))))
        主线程处理.发送通知 (0, 6, 2, 文本到对象 (取千位分隔数值文本 (STD正则.匹配 (匹配内容, 正则规则.shing, 假))))
        主线程处理.发送通知 (0, 7, 2, 文本到对象 (取千位分隔数值文本 (STD正则.匹配 (匹配内容, 正则规则.tom, 真))))
        主线程处理.发送通知 (0, 8, 2, 文本到对象 (取千位分隔数值文本 (STD正则.匹配 (匹配内容, 正则规则.tom, 假))))
        主线程处理.发送通知 (0, 9, 2, 文本到对象 (取千位分隔数值文本 (STD正则.匹配 (匹配内容, 正则规则.tom2, 假))))
        主线程处理.发送通知 (0, 10, 2, 文本到对象 (取千位分隔数值文本 (STD正则.匹配 (匹配内容, 正则规则.tom4, 假))))
        主线程处理.发送通知 (0, 11, 2, 文本到对象 (取千位分隔数值文本 (STD正则.匹配 (匹配内容, 正则规则.twain, 假))))
        主线程处理.发送通知 (0, 12, 2, 文本到对象 (取千位分隔数值文本 (STD正则.匹配 (匹配内容, 正则规则.twain, 真))))
        主线程处理.发送通知 (0, 13, 2, 文本到对象 (取千位分隔数值文本 (STD正则.匹配 (匹配内容, 正则规则.word, 假))))
        主线程处理.发送通知 (0, 14, 2, 文本到对象 (取千位分隔数值文本 (STD正则.完全匹配 ("xelloss@vip.qq.com", 正则规则.邮箱))))

        主线程处理.发送通知 (0, 0, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.匹配 (匹配内容, 正则规则.aax, 假))))
        主线程处理.发送通知 (0, 1, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.匹配 (匹配内容, 正则规则.huck, 假))))
        主线程处理.发送通知 (0, 2, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.匹配 (匹配内容, 正则规则.ing, 假))))
        主线程处理.发送通知 (0, 3, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.匹配 (匹配内容, 正则规则.ing2, 假))))
        主线程处理.发送通知 (0, 4, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.匹配 (匹配内容, 正则规则.inn, 假))))
        主线程处理.发送通知 (0, 5, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.匹配 (匹配内容, 正则规则.mix, 假))))
        主线程处理.发送通知 (0, 6, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.匹配 (匹配内容, 正则规则.shing, 假))))
        主线程处理.发送通知 (0, 7, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.匹配 (匹配内容, 正则规则.tom, 真))))
        主线程处理.发送通知 (0, 8, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.匹配 (匹配内容, 正则规则.tom, 假))))
        主线程处理.发送通知 (0, 9, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.匹配 (匹配内容, 正则规则.tom2, 假))))
        主线程处理.发送通知 (0, 10, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.匹配 (匹配内容, 正则规则.tom4, 假))))
        主线程处理.发送通知 (0, 11, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.匹配 (匹配内容, 正则规则.twain, 假))))
        主线程处理.发送通知 (0, 12, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.匹配 (匹配内容, 正则规则.twain, 真))))
        主线程处理.发送通知 (0, 13, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.匹配 (匹配内容, 正则规则.word, 假))))
        主线程处理.发送通知 (0, 14, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.完全匹配 ("xelloss@vip.qq.com", 正则规则.邮箱))))

        主线程处理.发送通知 (2)
        返回 (0)
    }

    方法 匹配测试2 <静态 类型 = 整数 注释 = "本测试会用文本数组获取所有匹配内容,实测只慢一点点." 折叠>
    参数 参数 <类型 = 变整数>
    {
        主线程处理.发送通知 (1)

        主线程处理.发送通知 (0, 0, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.取匹配文本 (匹配内容, 正则规则.aax, 假))))
        主线程处理.发送通知 (0, 1, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.取匹配文本 (匹配内容, 正则规则.huck, 假))))
        主线程处理.发送通知 (0, 2, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.取匹配文本 (匹配内容, 正则规则.ing, 假))))
        主线程处理.发送通知 (0, 3, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.取匹配文本 (匹配内容, 正则规则.ing2, 假))))
        主线程处理.发送通知 (0, 4, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.取匹配文本 (匹配内容, 正则规则.inn, 假))))
        主线程处理.发送通知 (0, 5, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.取匹配文本 (匹配内容, 正则规则.mix, 假))))
        主线程处理.发送通知 (0, 6, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.取匹配文本 (匹配内容, 正则规则.shing, 假))))
        主线程处理.发送通知 (0, 7, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.取匹配文本 (匹配内容, 正则规则.tom, 真))))
        主线程处理.发送通知 (0, 8, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.取匹配文本 (匹配内容, 正则规则.tom, 假))))
        主线程处理.发送通知 (0, 9, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.取匹配文本 (匹配内容, 正则规则.tom2, 假))))
        主线程处理.发送通知 (0, 10, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.取匹配文本 (匹配内容, 正则规则.tom4, 假))))
        主线程处理.发送通知 (0, 11, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.取匹配文本 (匹配内容, 正则规则.twain, 假))))
        主线程处理.发送通知 (0, 12, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.取匹配文本 (匹配内容, 正则规则.twain, 真))))
        主线程处理.发送通知 (0, 13, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.取匹配文本 (匹配内容, 正则规则.word, 假))))
        主线程处理.发送通知 (0, 14, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.完全匹配 ("xelloss@vip.qq.com", 正则规则.邮箱))))

        主线程处理.发送通知 (0, 0, 2, 文本到对象 (取千位分隔数值文本 (STD正则.取匹配文本 (匹配内容, 正则规则.aax, 假))))
        主线程处理.发送通知 (0, 1, 2, 文本到对象 (取千位分隔数值文本 (STD正则.取匹配文本 (匹配内容, 正则规则.huck, 假))))
        主线程处理.发送通知 (0, 2, 2, 文本到对象 (取千位分隔数值文本 (STD正则.取匹配文本 (匹配内容, 正则规则.ing, 假))))
        主线程处理.发送通知 (0, 3, 2, 文本到对象 (取千位分隔数值文本 (STD正则.取匹配文本 (匹配内容, 正则规则.ing2, 假))))
        主线程处理.发送通知 (0, 4, 2, 文本到对象 (取千位分隔数值文本 (STD正则.取匹配文本 (匹配内容, 正则规则.inn, 假))))
        主线程处理.发送通知 (0, 5, 2, 文本到对象 (取千位分隔数值文本 (STD正则.取匹配文本 (匹配内容, 正则规则.mix, 假))))
        主线程处理.发送通知 (0, 6, 2, 文本到对象 (取千位分隔数值文本 (STD正则.取匹配文本 (匹配内容, 正则规则.shing, 假))))
        主线程处理.发送通知 (0, 7, 2, 文本到对象 (取千位分隔数值文本 (STD正则.取匹配文本 (匹配内容, 正则规则.tom, 真))))
        主线程处理.发送通知 (0, 8, 2, 文本到对象 (取千位分隔数值文本 (STD正则.取匹配文本 (匹配内容, 正则规则.tom, 假))))
        主线程处理.发送通知 (0, 9, 2, 文本到对象 (取千位分隔数值文本 (STD正则.取匹配文本 (匹配内容, 正则规则.tom2, 假))))
        主线程处理.发送通知 (0, 10, 2, 文本到对象 (取千位分隔数值文本 (STD正则.取匹配文本 (匹配内容, 正则规则.tom4, 假))))
        主线程处理.发送通知 (0, 11, 2, 文本到对象 (取千位分隔数值文本 (STD正则.取匹配文本 (匹配内容, 正则规则.twain, 假))))
        主线程处理.发送通知 (0, 12, 2, 文本到对象 (取千位分隔数值文本 (STD正则.取匹配文本 (匹配内容, 正则规则.twain, 真))))
        主线程处理.发送通知 (0, 13, 2, 文本到对象 (取千位分隔数值文本 (STD正则.取匹配文本 (匹配内容, 正则规则.word, 假))))
        主线程处理.发送通知 (0, 14, 2, 文本到对象 (取千位分隔数值文本 (STD正则.完全匹配 ("xelloss@vip.qq.com", 正则规则.邮箱))))

        主线程处理.发送通知 (0, 0, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.取匹配文本 (匹配内容, 正则规则.aax, 假))))
        主线程处理.发送通知 (0, 1, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.取匹配文本 (匹配内容, 正则规则.huck, 假))))
        主线程处理.发送通知 (0, 2, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.取匹配文本 (匹配内容, 正则规则.ing, 假))))
        主线程处理.发送通知 (0, 3, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.取匹配文本 (匹配内容, 正则规则.ing2, 假))))
        主线程处理.发送通知 (0, 4, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.取匹配文本 (匹配内容, 正则规则.inn, 假))))
        主线程处理.发送通知 (0, 5, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.取匹配文本 (匹配内容, 正则规则.mix, 假))))
        主线程处理.发送通知 (0, 6, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.取匹配文本 (匹配内容, 正则规则.shing, 假))))
        主线程处理.发送通知 (0, 7, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.取匹配文本 (匹配内容, 正则规则.tom, 真))))
        主线程处理.发送通知 (0, 8, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.取匹配文本 (匹配内容, 正则规则.tom, 假))))
        主线程处理.发送通知 (0, 9, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.取匹配文本 (匹配内容, 正则规则.tom2, 假))))
        主线程处理.发送通知 (0, 10, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.取匹配文本 (匹配内容, 正则规则.tom4, 假))))
        主线程处理.发送通知 (0, 11, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.取匹配文本 (匹配内容, 正则规则.twain, 假))))
        主线程处理.发送通知 (0, 12, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.取匹配文本 (匹配内容, 正则规则.twain, 真))))
        主线程处理.发送通知 (0, 13, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.取匹配文本 (匹配内容, 正则规则.word, 假))))
        主线程处理.发送通知 (0, 14, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.完全匹配 ("xelloss@vip.qq.com", 正则规则.邮箱))))

        主线程处理.发送通知 (2)
        返回 (0)
    }

    方法 替换测试1 <静态 类型 = 整数 注释 = "本测试进行了正则替换." 折叠>
    参数 参数 <类型 = 变整数>
    {
        主线程处理.发送通知 (1)

        主线程处理.发送通知 (0, 0, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.正则替换 (匹配内容, 正则规则.aax, "PIV模块", 假))))
        主线程处理.发送通知 (0, 1, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.正则替换 (匹配内容, 正则规则.huck, "PIV模块", 假))))
        主线程处理.发送通知 (0, 2, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.正则替换 (匹配内容, 正则规则.ing, "PIV模块", 假))))
        主线程处理.发送通知 (0, 3, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.正则替换 (匹配内容, 正则规则.ing2, "PIV模块", 假))))
        主线程处理.发送通知 (0, 4, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.正则替换 (匹配内容, 正则规则.inn, "PIV模块", 假))))
        主线程处理.发送通知 (0, 5, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.正则替换 (匹配内容, 正则规则.mix, "PIV模块", 假))))
        主线程处理.发送通知 (0, 6, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.正则替换 (匹配内容, 正则规则.shing, "PIV模块", 假))))
        主线程处理.发送通知 (0, 7, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.正则替换 (匹配内容, 正则规则.tom, "PIV模块", 真))))
        主线程处理.发送通知 (0, 8, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.正则替换 (匹配内容, 正则规则.tom, "PIV模块", 假))))
        主线程处理.发送通知 (0, 9, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.正则替换 (匹配内容, 正则规则.tom, "PIV模块", 假))))
        主线程处理.发送通知 (0, 10, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.正则替换 (匹配内容, 正则规则.tom4, "PIV模块", 假))))
        主线程处理.发送通知 (0, 11, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.正则替换 (匹配内容, 正则规则.twain, "PIV模块", 假))))
        主线程处理.发送通知 (0, 12, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.正则替换 (匹配内容, 正则规则.twain, "PIV模块", 真))))
        主线程处理.发送通知 (0, 13, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.正则替换 (匹配内容, 正则规则.word, "PIV模块", 假))))
        主线程处理.发送通知 (0, 14, 1, 文本到对象 (取千位分隔数值文本 (PIV正则.完全匹配 ("xelloss@vip.qq.com", 正则规则.邮箱))))

        主线程处理.发送通知 (0, 0, 2, 文本到对象 (取千位分隔数值文本 (STD正则.正则替换 (匹配内容, 正则规则.aax, "PIV模块", 假))))
        主线程处理.发送通知 (0, 1, 2, 文本到对象 (取千位分隔数值文本 (STD正则.正则替换 (匹配内容, 正则规则.huck, "PIV模块", 假))))
        主线程处理.发送通知 (0, 2, 2, 文本到对象 (取千位分隔数值文本 (STD正则.正则替换 (匹配内容, 正则规则.ing, "PIV模块", 假))))
        主线程处理.发送通知 (0, 3, 2, 文本到对象 (取千位分隔数值文本 (STD正则.正则替换 (匹配内容, 正则规则.ing2, "PIV模块", 假))))
        主线程处理.发送通知 (0, 4, 2, 文本到对象 (取千位分隔数值文本 (STD正则.正则替换 (匹配内容, 正则规则.inn, "PIV模块", 假))))
        主线程处理.发送通知 (0, 5, 2, 文本到对象 (取千位分隔数值文本 (STD正则.正则替换 (匹配内容, 正则规则.mix, "PIV模块", 假))))
        主线程处理.发送通知 (0, 6, 2, 文本到对象 (取千位分隔数值文本 (STD正则.正则替换 (匹配内容, 正则规则.shing, "PIV模块", 假))))
        主线程处理.发送通知 (0, 7, 2, 文本到对象 (取千位分隔数值文本 (STD正则.正则替换 (匹配内容, 正则规则.tom, "PIV模块", 真))))
        主线程处理.发送通知 (0, 8, 2, 文本到对象 (取千位分隔数值文本 (STD正则.正则替换 (匹配内容, 正则规则.tom, "PIV模块", 假))))
        主线程处理.发送通知 (0, 9, 2, 文本到对象 (取千位分隔数值文本 (STD正则.正则替换 (匹配内容, 正则规则.tom2, "PIV模块", 假))))
        主线程处理.发送通知 (0, 10, 2, 文本到对象 (取千位分隔数值文本 (STD正则.正则替换 (匹配内容, 正则规则.tom4, "PIV模块", 假))))
        主线程处理.发送通知 (0, 11, 2, 文本到对象 (取千位分隔数值文本 (STD正则.正则替换 (匹配内容, 正则规则.twain, "PIV模块", 假))))
        主线程处理.发送通知 (0, 12, 2, 文本到对象 (取千位分隔数值文本 (STD正则.正则替换 (匹配内容, 正则规则.twain, "PIV模块", 真))))
        主线程处理.发送通知 (0, 13, 2, 文本到对象 (取千位分隔数值文本 (STD正则.正则替换 (匹配内容, 正则规则.word, "PIV模块", 假))))
        主线程处理.发送通知 (0, 14, 2, 文本到对象 (取千位分隔数值文本 (STD正则.完全匹配 ("xelloss@vip.qq.com", 正则规则.邮箱))))

        主线程处理.发送通知 (0, 0, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.正则替换 (匹配内容, 正则规则.aax, "PIV模块", 假))))
        主线程处理.发送通知 (0, 1, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.正则替换 (匹配内容, 正则规则.huck, "PIV模块", 假))))
        主线程处理.发送通知 (0, 2, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.正则替换 (匹配内容, 正则规则.ing, "PIV模块", 假))))
        主线程处理.发送通知 (0, 3, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.正则替换 (匹配内容, 正则规则.ing2, "PIV模块", 假))))
        主线程处理.发送通知 (0, 4, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.正则替换 (匹配内容, 正则规则.inn, "PIV模块", 假))))
        主线程处理.发送通知 (0, 5, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.正则替换 (匹配内容, 正则规则.mix, "PIV模块", 假))))
        主线程处理.发送通知 (0, 6, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.正则替换 (匹配内容, 正则规则.shing, "PIV模块", 假))))
        主线程处理.发送通知 (0, 7, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.正则替换 (匹配内容, 正则规则.tom, "PIV模块", 真))))
        主线程处理.发送通知 (0, 8, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.正则替换 (匹配内容, 正则规则.tom, "PIV模块", 假))))
        主线程处理.发送通知 (0, 9, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.正则替换 (匹配内容, 正则规则.tom2, "PIV模块", 假))))
        主线程处理.发送通知 (0, 10, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.正则替换 (匹配内容, 正则规则.tom4, "PIV模块", 假))))
        主线程处理.发送通知 (0, 11, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.正则替换 (匹配内容, 正则规则.twain, "PIV模块", 假))))
        主线程处理.发送通知 (0, 12, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.正则替换 (匹配内容, 正则规则.twain, "PIV模块", 真))))
        主线程处理.发送通知 (0, 13, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.正则替换 (匹配内容, 正则规则.word, "PIV模块", 假))))
        主线程处理.发送通知 (0, 14, 3, 文本到对象 (取千位分隔数值文本 (DEELX正则.完全匹配 ("xelloss@vip.qq.com", 正则规则.邮箱))))

        主线程处理.发送通知 (2)
        返回 (0)
    }

    方法 高级主线程处理器_接收到通知 <接收事件 类型 = 整数 注释 = "在其它线程中调用本对象的\"发送通知\"/\"投递通知\"方法后,本事件将被触发."
            注释 = "本事件的接收方法将始终在程序的UI主线程中执行." 注释 = "本事件中的参数值为调用\"发送通知\"/\"投递通知\"方法时所提供的对应参数值."
            返回值注释 = "如果本事件由\"发送通知\"方法调用触发,事件处理方法的返回值将返回到\"发送通知\"方法的调用方." 折叠>
    参数 来源对象 <类型 = 高级主线程处理器 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    参数 通知码 <类型 = 变整数>
    参数 参数1 <类型 = 变整数>
    参数 参数2 <类型 = 变整数>
    参数 参数对象 <类型 = 对象包装类 注释 = "包装中为发送/投递通知时所提供对象的复制对象,如果未提供则为空(\"参数对象.是否为空\"方法返回真).">
    {
        如果 (来源对象 == 主线程处理)
        {
            如果 (通知码 == 0)
            {
                超级列表框_结果.置标题 ((整数)参数1, (整数)参数2, 对象到文本 (参数对象.取对象 ()))
            }
            否则 (通知码 == 1)
            {
                按钮1.禁止 = 真
                按钮2.禁止 = 真
                按钮3.禁止 = 真
                变量 行 <类型 = 整数>
                变量 列 <类型 = 整数>
                循环 (0, 超级列表框_结果.取表项数 (), 行, 1)
                {
                    循环 (1, 4, 列, 1)
                    {
                        超级列表框_结果.置标题 (行, 列, "")
                    }
                }
            }
            否则 (通知码 == 2)
            {
                按钮1.禁止 = 假
                按钮2.禁止 = 假
                按钮3.禁止 = 假
            }
            处理事件 ()
        }
        返回 (0)
    }
}

类 正则窗口 <公开 基础类 = 窗口 折叠 隐藏值属性 = "0" @视窗.布局 = "client_size = \"600, 420\"">
{
    变量 编辑框1 <类型 = 编辑框 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 101\r\npos = \"10, 10, 580, 360\"" 是否允许多行 = 真
            输入方式 = 只读方式 滚动条 = 纵向滚动条>
    变量 按钮1 <类型 = 按钮 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 102\r\npos = \"140, 380, 100, 32\"" 标题 = "显示原文">
    变量 按钮2 <类型 = 按钮 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 103\r\npos = \"315, 380, 100, 32\"" 标题 = "正则替换后">
    变量 原文 <类型 = 文本型 @视窗.值文件 = "02.txt">
    变量 替换后 <类型 = 文本型>

    方法 按钮_被单击 <接收事件 类型 = 整数 注释 = "当按钮被单击后发送此事件" 折叠>
    参数 来源对象 <类型 = 按钮 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    {
        如果 (来源对象 == 按钮1)
        {
            编辑框1.内容 = 原文
        }
        否则 (来源对象 == 按钮2)
        {
            如果 (文本是否为空 (替换后) == 真)
            {
                变量 正则 <类型 = 正则查找类>
                变量 章节 <类型 = 整数 值 = 1>
                如果 (正则.查找 (原文, "^([^　].*)"))
                {
                    正则.替换 (取格式文本 ("第%s章 \\1", 数值到大写 (章节, 真)))
                    章节 = 章节 + 1
                    判断循环 (正则.查找下一个 () == 真)
                    {
                        正则.替换 (取格式文本 ("\r\n\r\n第%s章 \\1", 数值到大写 (章节, 真)))
                        章节 = 章节 + 1
                    }
                }
                替换后 = 正则.取替换文本 ()
            }
            调试输出 (到字节集 (原文), 到字节集 (替换后))

            编辑框1.内容 = 替换后
        }
        返回 (0)
    }

    方法 正则窗口_创建完毕 <接收事件 类型 = 整数 注释 = "当本组件及其中所有子组件均被创建完毕后发送此事件." 折叠>
    参数 来源对象 <类型 = 正则窗口 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    {
        编辑框1.内容 = 原文
        返回 (0)
    }
}

类 PIV正则 <注释 = "PIV模块的正则库,魔改了国人开源的简单正则表达式实现.">
{
    方法 匹配 <公开 静态 类型 = 长整数 返回值注释 = "耗时" 折叠>
    参数 内容 <类型 = 文本型>
    参数 表达式 <类型 = 文本型>
    参数 忽略大小写 <类型 = 逻辑型>
    {
        变量 启动时间 <类型 = 长整数>
        启动时间 = 取现行纳秒时间戳 ()
        变量 正则 <类型 = 正则查找类>
        变量 匹配数量 <类型 = 整数>
        如果 (正则.查找 (内容, 表达式, 选择 (忽略大小写, 正则匹配标志.忽略大小写, 0)) == 真)
        {
            匹配数量 = 1
            判断循环 (正则.查找下一个 () == 真)
            {
                匹配数量 = 匹配数量 + 1
            }
        }
        返回 (取现行纳秒时间戳 () - 启动时间)
    }

    方法 完全匹配 <公开 静态 类型 = 长整数 注释 = "十万次" 返回值注释 = "耗时" 折叠>
    参数 内容 <类型 = 文本型>
    参数 表达式 <类型 = 文本型>
    {
        变量 启动时间 <类型 = 长整数>
        变量 匹配结果 <类型 = 逻辑型>
        启动时间 = 取现行纳秒时间戳 ()
        计次循环 (10000 * 10)
        {
            匹配结果 = 正则匹配类.完全匹配 (内容, 表达式)
        }
        返回 (取现行纳秒时间戳 () - 启动时间)
    }

    方法 取匹配文本 <公开 静态 类型 = 长整数 返回值注释 = "耗时">
    参数 内容 <类型 = 文本型>
    参数 表达式 <类型 = 文本型>
    参数 忽略大小写 <类型 = 逻辑型>
    {
        变量 启动时间 <类型 = 长整数>
        启动时间 = 取现行纳秒时间戳 ()
        变量 正则 <类型 = 正则查找类>
        变量 匹配结果 <类型 = 文本数组类>
        如果 (正则.查找 (内容, 表达式, 选择 (忽略大小写, 正则匹配标志.忽略大小写, 0)) == 真)
        {
            匹配结果.加入成员 (正则.取匹配文本 ())
            判断循环 (正则.查找下一个 () == 真)
            {
                匹配结果.加入成员 (正则.取匹配文本 ())
            }
        }
        返回 (取现行纳秒时间戳 () - 启动时间)
    }

    方法 正则替换 <公开 静态 类型 = 长整数 返回值注释 = "耗时" 折叠>
    参数 内容 <类型 = 文本型>
    参数 表达式 <类型 = 文本型>
    参数 替换格式 <类型 = 文本型>
    参数 忽略大小写 <类型 = 逻辑型>
    {
        变量 启动时间 <类型 = 长整数>
        启动时间 = 取现行纳秒时间戳 ()
        变量 替换结果 <类型 = 文本型>
        正则匹配类.正则替换 (内容, 表达式, 替换格式, 替换结果, , , 选择 (忽略大小写, 正则匹配标志.忽略大小写, 0))
        返回 (取现行纳秒时间戳 () - 启动时间)
    }
}

类 STD正则 <注释 = "官方\"标准正则表达式支持库\",为std::regex的封装.">
{
    方法 匹配 <公开 静态 类型 = 长整数 返回值注释 = "耗时" 折叠>
    参数 内容 <类型 = 文本型>
    参数 表达式 <类型 = 文本型>
    参数 忽略大小写 <类型 = 逻辑型>
    {
        变量 启动时间 <类型 = 长整数>
        启动时间 = 取现行纳秒时间戳 ()
        变量 正则 <类型 = 火山.视窗.正则.正则表达式类>
        变量 匹配数量 <类型 = 整数>
        如果 (正则.匹配 (内容, 表达式, 选择 (忽略大小写, 位或 (火山.视窗.正则.正则表达式选项.不区分大小写, 火山.视窗.正则.正则表达式选项.ECMA语法), 火山.视窗.正则.正则表达式选项.ECMA语法)) == 真)
        {
            匹配数量 = 1
            判断循环 (正则.到下一个匹配 () == 真)
            {
                匹配数量 = 匹配数量 + 1
            }
        }
        返回 (取现行纳秒时间戳 () - 启动时间)
    }

    方法 完全匹配 <公开 静态 类型 = 长整数 注释 = "十万次" 返回值注释 = "耗时" 折叠>
    参数 内容 <类型 = 文本型>
    参数 表达式 <类型 = 文本型>
    {
        变量 启动时间 <类型 = 长整数>
        变量 匹配结果 <类型 = 逻辑型>
        启动时间 = 取现行纳秒时间戳 ()
        变量 正则 <类型 = 火山.视窗.正则.正则表达式类>
        计次循环 (10000 * 10)
        {
            匹配结果 = 正则.完全匹配 (内容, 表达式)
        }
        返回 (取现行纳秒时间戳 () - 启动时间)
    }

    方法 取匹配文本 <公开 静态 类型 = 长整数 返回值注释 = "耗时">
    参数 内容 <类型 = 文本型>
    参数 表达式 <类型 = 文本型>
    参数 忽略大小写 <类型 = 逻辑型>
    {
        变量 启动时间 <类型 = 长整数>
        启动时间 = 取现行纳秒时间戳 ()
        变量 正则 <类型 = 火山.视窗.正则.正则表达式类>
        变量 匹配结果 <类型 = 文本数组类>
        如果 (正则.匹配 (内容, 表达式, 选择 (忽略大小写, 位或 (火山.视窗.正则.正则表达式选项.不区分大小写, 火山.视窗.正则.正则表达式选项.ECMA语法), 火山.视窗.正则.正则表达式选项.ECMA语法)) == 真)
        {
            匹配结果.加入成员 (正则.取子匹配文本 (0))
            判断循环 (正则.到下一个匹配 () == 真)
            {
                匹配结果.加入成员 (正则.取子匹配文本 (0))
            }
        }
        返回 (取现行纳秒时间戳 () - 启动时间)
    }

    方法 正则替换 <公开 静态 类型 = 长整数 返回值注释 = "耗时">
    参数 内容 <类型 = 文本型>
    参数 表达式 <类型 = 文本型>
    参数 替换格式 <类型 = 文本型>
    参数 忽略大小写 <类型 = 逻辑型>
    {
        变量 启动时间 <类型 = 长整数>
        启动时间 = 取现行纳秒时间戳 ()
        变量 正则 <类型 = 火山.视窗.正则.正则表达式类>
        变量 替换结果 <类型 = 文本型>
        替换结果 = 正则.替换 (内容, 表达式, 替换格式, 选择 (忽略大小写, 位或 (火山.视窗.正则.正则表达式选项.不区分大小写, 火山.视窗.正则.正则表达式选项.ECMA语法), 火山.视窗.正则.正则表达式选项.ECMA语法))
        调试输出 (替换结果)
        返回 (取现行纳秒时间戳 () - 启动时间)
    }
}

类 DEELX正则 <注释 = "官方\"正则表达式支持库\",deelx正则库的封装.">
{
    方法 匹配 <公开 静态 类型 = 长整数 返回值注释 = "耗时" 折叠>
    参数 内容 <类型 = 文本型>
    参数 表达式 <类型 = 文本型>
    参数 忽略大小写 <类型 = 逻辑型>
    {
        变量 启动时间 <类型 = 长整数>
        启动时间 = 取现行纳秒时间戳 ()
        变量 正则 <类型 = 火山.视窗.正则表达式.正则表达式类>
        变量 匹配数量 <类型 = 整数>
        正则.匹配 (内容, 表达式, 选择 (忽略大小写, 火山.视窗.正则表达式.正则匹配模式.忽略大小写, 火山.视窗.正则表达式.正则匹配模式.多行模式))
        {
            匹配数量 = 匹配数量 + 1
        }
        返回 (取现行纳秒时间戳 () - 启动时间)
    }

    方法 完全匹配 <公开 静态 类型 = 长整数 注释 = "十万次" 返回值注释 = "耗时" 折叠>
    参数 内容 <类型 = 文本型>
    参数 表达式 <类型 = 文本型>
    {
        变量 启动时间 <类型 = 长整数>
        变量 匹配结果 <类型 = 逻辑型>
        启动时间 = 取现行纳秒时间戳 ()
        计次循环 (10000 * 10)
        {
            变量 正则 <类型 = 火山.视窗.正则表达式.正则表达式类>
            正则.匹配 (内容, 表达式)
            {
                匹配结果 = 文本比较 (内容, 正则.取匹配文本 ()) == 0
                跳出循环
            }
        }
        返回 (取现行纳秒时间戳 () - 启动时间)
    }

    方法 取匹配文本 <公开 静态 类型 = 长整数 返回值注释 = "耗时">
    参数 内容 <类型 = 文本型>
    参数 表达式 <类型 = 文本型>
    参数 忽略大小写 <类型 = 逻辑型>
    {
        变量 启动时间 <类型 = 长整数>
        启动时间 = 取现行纳秒时间戳 ()
        变量 正则 <类型 = 火山.视窗.正则表达式.正则表达式类>
        变量 匹配结果 <类型 = 文本数组类>
        正则.匹配 (内容, 表达式, 选择 (忽略大小写, 火山.视窗.正则表达式.正则匹配模式.忽略大小写, 火山.视窗.正则表达式.正则匹配模式.多行模式))
        {
            匹配结果.加入成员 (正则.取匹配文本 ())
        }
        返回 (取现行纳秒时间戳 () - 启动时间)
    }

    方法 正则替换 <公开 静态 类型 = 长整数 返回值注释 = "耗时" 折叠>
    参数 内容 <类型 = 文本型>
    参数 表达式 <类型 = 文本型>
    参数 替换格式 <类型 = 文本型>
    参数 忽略大小写 <类型 = 逻辑型>
    {
        变量 启动时间 <类型 = 长整数>
        启动时间 = 取现行纳秒时间戳 ()
        变量 正则 <类型 = 正则查找类>
        变量 替换结果 <类型 = 文本型>
        替换结果 = 正则工具类.正则文本替换 (内容, 表达式, 替换格式, , , 选择 (忽略大小写, 火山.视窗.正则表达式.正则匹配模式.忽略大小写, 火山.视窗.正则表达式.正则匹配模式.多行模式))
        返回 (取现行纳秒时间戳 () - 启动时间)
    }
}

类 正则规则 <折叠>
{
    常量 aax <公开 类型 = 文本型 值 = "[a-q][^u-z]{13}x">
    常量 huck <公开 类型 = 文本型 值 = "Huck[a-zA-Z]+|Saw[a-zA-Z]+">
    常量 ing <公开 类型 = 文本型 值 = "\\s[a-zA-Z]{0,12}ing\\s">
    常量 ing2 <公开 类型 = 文本型 值 = "[a-zA-Z]+ing">
    常量 inn <公开 类型 = 文本型 值 = "([A-Za-z]awyer|[A-Za-z]inn)\\s">
    常量 mix <公开 类型 = 文本型 值 = "[\"\'][^\"\']{0,30}[?!\\.][\"\']">
    常量 shing <公开 类型 = 文本型 值 = "[a-z]shing">
    常量 tom <公开 类型 = 文本型 值 = "Tom|Sawyer|Huckleberry|Finn" 注释 = "加上忽略大小写">
    常量 tom2 <公开 类型 = 文本型 值 = ".{0,2}(Tom|Sawyer|Huckleberry|Finn)">
    常量 tom4 <公开 类型 = 文本型 值 = ".{2,4}(Tom|Sawyer|Huckleberry|Finn)">
    常量 twain <公开 类型 = 文本型 值 = "Twain" 注释 = "加上忽略大小写">
    常量 word <公开 类型 = 文本型 值 = "\\b\\w+nn\\b">
    常量 邮箱 <公开 类型 = 文本型 值 = "^([\\w-]+(\\.[\\w-]+)*)@[\\w-]+(\\.[\\w-]+)+$">

    #
}
