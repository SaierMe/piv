<火山程序 类型 = "通常" 版本 = 1 />

包 火山.程序

类 启动类 <公开 基础类 = 窗口程序类 折叠>
{
    变量 主窗口对象 <公开 类型 = 我的主窗口>

    方法 启动方法 <公开 类型 = 整数>
    {
        主窗口对象.创建主窗口 ()
        返回 (1)
    }
}

# ===
# 注意: 火山本身的语法检查不能检查出线程对象中的部分错误
# 比如提供的参数类型和数量和绑定的方法不一致,此时会出现大量的英文报错
# 如果遇到这种情况,请自己检查好代码

类 我的主窗口 <基础类 = 窗口 @视窗.布局 = "client_size = \"500, 300\"" 标题 = "线程例子">
{
    变量 标签3 <类型 = 标签 隐藏值属性 = "0" @视窗.布局 = "id = 101\r\npos = \"21, 171, 300, 24\"">
    变量 按钮1 <类型 = 按钮 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 102\r\npos = \"365, 27, 100, 32\"" 标题 = "暂停线程">
    变量 标签1 <类型 = 标签 隐藏值属性 = "0" @视窗.布局 = "id = 103\r\npos = \"21, 35, 300, 24\"">
    变量 标签2 <类型 = 标签 隐藏值属性 = "0" @视窗.布局 = "id = 104\r\npos = \"21, 103, 300, 24\"">
    变量 按钮2 <类型 = 按钮 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 105\r\npos = \"365, 227, 100, 32\"" 标题 = "更多示例">
    变量 ""
    变量 互斥锁 <静态 类型 = 互斥对象类>
    变量 退出线程 <静态 类型 = 同步事件类>
    变量 暂停线程 <静态 类型 = 同步事件类>
    变量 内容 <类型 = 文本型>
    变量 UI处理器 <类型 = 高级主线程处理器>

    方法 我的主窗口_创建完毕 <接收事件 类型 = 整数 注释 = "当本组件及其中所有子组件均被创建完毕后发送此事件." 折叠>
    参数 来源对象 <类型 = 我的主窗口 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    {
        变量 提示文本 <类型 = 文本型 值 = "静态死循环: ">
        // 默认是将参数值拷贝给线程,如果要让线程访问同样的参数,必须加上"引用"
        启动静态线程 (静态死循环, 提示文本, 引用 (本对象))

        启动无参数动态线程 (本对象, "loop")

        启动无参数无返回值动态线程 (本对象, 动态死循环2)
        // 上面两种写法都可以在线程里访问"我的主窗口"中的成员
        // 静态方法通过引用传递的窗口实例访问
        // 而动态则本身就有窗口实例的访问权限

        返回 (0)
    }

    方法 静态死循环 <静态 类型 = 整数 折叠>
    参数 提示文本 <类型 = 文本型>
    参数 窗口 <类型 = 我的主窗口>
    {
        判断循环 (退出线程.限时等待 (0) == 假)
        {
            变量 次数 <静态 类型 = 整数>
            次数 = 次数 + 1
            // 线程中不应操作窗口组件,所以这里投递到主线程进行处理
            如果 (暂停线程.限时等待 (0) == 真)
            {
                窗口.UI处理器.发送通知 (1, , , 文本到对象 (提示文本 + "进入暂停"))
                如果 (暂停线程.等待 (假) == 真)
                {
                    窗口.UI处理器.发送通知 (1, , , 文本到对象 (提示文本 + "继续执行"))
                }
            }
            延时 (1000)
            窗口.UI处理器.发送通知 (1, , , 文本到对象 (取格式文本 ("%s%d 次循环", 提示文本, 次数)))

        }
        返回 (0)
    }

    方法 动态死循环 <类型 = 整数 注释 = "非静态方法必须设置输出名和强制输出" 折叠 @输出名 = "loop" @强制输出 = 真>
    {
        // 关闭程序时,会因为窗口类被销毁而异常结束,一样会结束该线程
        变量 次数 <类型 = 整数>
        判断循环 (真)
        {
            延时 (1000)
            互斥锁.加锁 ()  // 执行时自动加锁,离开作用域或异常结束时自动解锁
            次数 = 次数 + 1
            置文本 (内容, 取格式文本 ("动态死循环: %04d 次循环", 次数))  // 修改外部变量
            互斥锁.解锁 ()
            UI处理器.发送通知 (2)  // 这一句不能锁住

        }
        返回 (0)
    }

    方法 动态死循环2 <注释 = "没有参数和返回值的话,可以不设置输出名" 折叠>
    {
        // 跟"启动线程"不同,关闭窗口后本线程也会自动退出
        变量 次数 <类型 = 整数 值 = 1>
        判断循环 (真)
        {
            延时 (2000)
            提交到主线程 ()  // 子语句体在主线程中运行,可以直接操作界面
            {
                调试检查 (是否为主线程 () == 真)  // 位于主线程
                // "提交到主线程"是同步执行的方法,可以安全地使用线程函数中的局部变量
                // 如果用了非线程局部的变量,请酌情加锁(主要看是否有线程竞争)
                标签3.标题 = 取格式文本 ("动态死循环2: %04d 次循环", 次数)

            }
            调试检查 (是否为主线程 () == 假)  // 非主线程
            次数 = 次数 + 1

        }
    }

    方法 更多示例 <折叠>
    {
        变量 未来响应 <类型 = 未来请求响应类>
        异步线程类.启动静态异步 (真, 未来响应, 网页请求1, "https://baidu.com")  // 第一个参数可以选择是否立即执行异步线程

        变量 承诺文本 <类型 = 承诺文本类>
        变量 未来文本 <类型 = 未来文本类>
        如果 (承诺文本.取未来对象 (未来文本) == 真)  // 要先从承诺对象中获取未来对象
        {
            启动静态线程 (静态2, 承诺文本)
            变量 未来值 <类型 = 文本型>
            未来文本.取值 (未来值)
            调试输出 (未来值)

        }

        变量 请求结果 <类型 = 网络请求响应类>
        如果 (未来响应.取值 (请求结果) == 真)  // 取值会阻塞当前线程,直到异步线程执行完毕
        {
            调试输出 (取格式文本 ("响应码: %d, 请求耗时: %d", 请求结果.响应码, 请求结果.请求耗时))

        }

        变量 线程对象 <类型 = 标准线程对象>
        变量 启动时间 <类型 = 长整数>
        启动时间 = 取现行纳秒时间戳 ()
        变量 返回结果 <类型 = 文本型>
        线程对象.关联静态方法 (静态1, 文本到UTF8 ("我是传入的数据"), 引用 (返回结果))  // 关联后会立即执行线程
        线程对象.加入 ()  // 阻塞当前线程,直到线程结束
        调试输出 (取现行纳秒时间戳 () - 启动时间, 返回结果)

    }

    方法 我的主窗口_将被销毁 <接收事件 类型 = 整数 注释 = "当本组件被销毁前发送此事件" 折叠>
    参数 来源对象 <类型 = 我的主窗口 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    {
        退出线程.放行 ()  // 退出静态死循环
        返回 (0)
    }

    方法 按钮_被单击 <接收事件 类型 = 整数 注释 = "当按钮被单击后发送此事件" 折叠>
    参数 来源对象 <类型 = 按钮 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    {
        如果 (来源对象 == 按钮1)
        {
            如果 (来源对象.标题 == "暂停线程")
            {
                暂停线程.放行 ()
                来源对象.标题 = "继续线程"
            }
            否则
            {
                暂停线程.放行 ()
                来源对象.标题 = "暂停线程"
            }

        }
        否则 (来源对象 == 按钮2)
        {
            来源对象.禁止 = 真
            更多示例 ()
            来源对象.禁止 = 假
        }
        返回 (0)
    }

    方法 高级主线程处理器_接收到通知 <接收事件 类型 = 整数 注释 = "在其它线程中调用本对象的\"发送通知\"/\"投递通知\"方法后,本事件将被触发."
            注释 = "本事件的接收方法将始终在程序的UI主线程中执行." 注释 = "本事件中的参数值为调用\"发送通知\"/\"投递通知\"方法时所提供的对应参数值."
            返回值注释 = "如果本事件由\"发送通知\"方法调用触发,事件处理方法的返回值将返回到\"发送通知\"方法的调用方." 折叠>
    参数 来源对象 <类型 = 高级主线程处理器 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    参数 通知码 <类型 = 变整数>
    参数 参数1 <类型 = 变整数>
    参数 参数2 <类型 = 变整数>
    参数 参数对象 <类型 = 对象包装类 注释 = "包装中为发送/投递通知时所提供对象的复制对象,如果未提供则为空(\"参数对象.是否为空\"方法返回真).">
    {
        如果 (来源对象 == UI处理器)
        {
            分支判断 ((整数)通知码)
            {
                分支 (1)
                {
                    标签1.标题 = 对象到文本 (参数对象.取对象 ())
                }
                分支 (2)
                {
                    // 只要有线程竞争,主线程中也应该加锁
                    // 而本案例的这个"内容"变量实际上不会出现同时读写,所以也可以不加锁
                    互斥锁.互斥自动锁 ()
                    标签2.标题 = 内容
                }
            }

        }
        返回 (0)
    }

    方法 静态1 <静态 折叠>
    参数 传入 <类型 = 字节集类>
    参数 传出 <类型 = 文本型>
    {
        传出 = UTF8到文本 (传入)
        延时 (2000)
    }

    方法 静态2 <静态 折叠>
    参数 承诺值 <类型 = 承诺文本类>
    {
        承诺值.置值 ("我是承诺文本")
    }

    方法 网页请求1 <静态 类型 = 网络请求响应类 折叠>
    参数 网址 <类型 = 文本型>
    {
        变量 网络访问 <类型 = 网络同步访问类>
        返回 (网络访问.网页访问 (网址))
    }
}

类 未来请求响应类 <基础类 = 未来对象模板类 注释 = "定义\"网络请求响应类\"的未来对象" @模板实现类 = "网络请求响应类">
{

    #
}
