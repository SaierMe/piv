<火山程序 类型 = "通常" 版本 = 1 />

包 火山.程序 <注释 = "libgo协程例子">

# 注意: 火山本身的语法检查不能检查出协程中的部分错误
# 比如提供的参数类型和数量和绑定的方法不一致,此时会出现大量的英文报错
# 如果遇到这种情况,请自己检查好代码

类 启动类 <公开 基础类 = 程序类 折叠>
{
    变量 协程基本操作 <类型 = 协程基本操作例子>
    变量 信道例子 <类型 = 协程信道例子>
    变量 协程池例子 <类型 = 协程池操作例子>

    方法 启动方法 <公开 类型 = 整数>
    {
        协程基本操作.测试例子 ()
        延时 (1000)
        标准输出行 (, "\r\n请按任意键执行下一个例子...")
        标准输入 ()

        信道例子.测试例子 ()
        延时 (1000)
        标准输出行 (, "\r\n请按任意键执行下一个例子...")
        标准输入 ()

        协程池例子.测试例子 ()
        延时 (1000)

        标准输出行 (, "\r\n请按任意键退出...")
        标准输入 ()

        返回 (1)
    }
}

类 协程基本操作例子 <注释 = "最基础和常用的协程操作">
{
    变量 "// 定时器" <类型 = 协程定时器 注释 = "定时器有内存泄漏的bug,注释掉">
    变量 调度器 <类型 = 协程调度器>

    方法 测试例子 <公开>
    {
        Go协程.创建静态协程 (静态方法A, 123, 456)
        Go协程.创建无参数静态协程 (静态方法B)

        变量 函数 <类型 = 通用函数对象>
        函数 = 绑定动态方法 (本对象, "funA", "执行了方法A 1")
        Go协程.创建协程任务 (函数)
        Go协程.创建协程任务 (绑定动态方法 (本对象, "funA", "执行了方法A 2"))  // 也可以这样写
        Go协程.创建动态协程 (本对象, "funA", "执行了方法A 3")  // 这个写法结果也是跟上面一样

        Go协程.启动调度器 (0, 0)  // 协程必须启动调度器后才开始执行

        // 创建一个额外的调度器,如果不使用下一句代码,那"调度器"变量跟"Go协程"里的默认调度器一样
        调度器 = 协程调度器.创建调度器 ()
        调度器.启动 (1, 0)  // 这里只需要1个线程进行调度
        // 使用调度器跟Go协程的主要区别是可以定义协程栈大小的上限
        调度器.创建协程任务 (10 * 1024 * 1024, 绑定无参数静态方法 (静态方法C))  // 创建10MB大栈的协程

        变量 "// 定时ID" <类型 = 协程定时ID>
        // 定时ID = 定时器.创建任务 (500, 绑定静态方法 (定时任务, 500))
        // 定时ID.撤销任务 ()  // 任务被撤销,所以不会执行了
        // 定时器.创建静态任务 (1000, 定时任务, 1000)
    }

    方法 方法A <公开 折叠 @输出名 = "funA" @强制输出 = 真>
    参数 文本参数 <类型 = 文本型>
    {
        标准输出行 (, 取格式文本 ("[%s]%s", 取源类名 (), 文本参数))
    }

    方法 静态方法A <静态 类型 = 整数 折叠>
    参数 A <类型 = 整数>
    参数 B <类型 = 整数>
    {
        变量 结果 <类型 = 整数>
        结果 = A * B
        Go协程.协程延时 (100)  // 用普通的延时也可以,但不能设置 Go协程.禁止HOOK()
        标准输出行 (, 取格式文本 ("[%s]%d * %d = %d", 取源类名 (), A, B, 结果))
        返回 (结果)

    }

    方法 静态方法B <静态 折叠>
    {
        Go协程.让出调度 ()  // 让出调度后,该协程会移动到最后执行
        标准输出行 (, 取格式文本 ("[%s]执行了静态方法B", 取源类名 ()))

    }

    方法 静态方法C <静态 折叠>
    {
        标准输出行 (, 取格式文本 ("[%s]执行了超大栈堆的协程", 取源类名 ()))

    }

    方法 定时任务 <静态 折叠>
    参数 延迟时间 <类型 = 整数>
    {
        标准输出行 (, 取格式文本 ("[%s]执行定时任务,延迟时间: %d", 取源类名 (), 延迟时间))
    }
}

类 协程信道例子 <折叠>
{
    变量 小数信道 <类型 = 小数信道类 注释 = "设置了一个缓冲区" 缓冲区容量 = 1>

    方法 测试例子 <公开 折叠>
    {
        变量 整数信道 <类型 = 整数信道类>
        Go协程.创建静态协程 (写数据, 整数信道)
        Go协程.创建静态协程 (读数据, 整数信道)

        Go协程.创建无参数动态协程 (本对象, "read")
        Go协程.创建无参数动态协程 (本对象, "write")
        // 上面一个类已经启动了调度器,这里就不用启动了
    }

    方法 写数据 <静态 折叠>
    参数 整数信道 <类型 = 整数信道类>
    {
        整数信道.写 (53181552)
        标准输出行 (, 取格式文本 ("[%s]将整数写入到信道", 取源类名 ()))
    }

    方法 读数据 <静态 折叠>
    参数 整数信道 <类型 = 整数信道类>
    {
        标准输出行 (, 取格式文本 ("[%s]从信道读取了整数: %d", 取源类名 (), 整数信道.读 ()))

    }

    方法 读信道 <折叠 @输出名 = "read" @强制输出 = 真>
    {
        标准输出行 (, 取格式文本 ("[%s]从信道读取了小数: %f", 取源类名 (), 小数信道.读 ()))
    }

    方法 写信道 <折叠 @输出名 = "write" @强制输出 = 真>
    {
        小数信道.写 (2.2)
        标准输出行 (, 取格式文本 ("[%s]将小数写入到信道,因为有一个缓冲区空位,本次写入不会阻塞", 取源类名 ()))
        小数信道.写 (3.33)
        标准输出行 (, 取格式文本 ("[%s]将小数写入到信道,因为没有缓冲区空位,本次写入会阻塞协程", 取源类名 ()))

    }

    #
}

类 协程池操作例子
{
    变量 协程池 <类型 = 协程池类>
    变量 回调处理器 <类型 = 协程池回调处理器 注释 = "生命周期不能比协程池短">

    方法 测试例子 <公开>
    {
        协程池.创建 ()  // 这一句可以不调用
        协程池.最大协程数 = 1792  // 需要在"启动"之前设置,这是我测出来32位下的最大值,如果还是在这里出错,建议把值再设置小一些.
        协程池.启动 ()
        // 未设置回调触发点,所有回调直接在协程池内部调用
        计次循环 (5)
        {
            协程池.投递回调任务 (绑定无参数静态方法 (任务函数A), 绑定静态方法 (回调函数A, 取循环索引 ()))

        }
        延时 (500)
        标准输出行 (, "按任意键继续...")
        标准输入 ()

        计次循环 (5)
        {
            // 注意"投递回调任务2"的函数要求
            协程池.投递回调任务2 (整数, 绑定静态方法 (任务函数B, 取循环索引 ()), 绑定静态方法 (回调函数B, 占位符_1 (整数)))

        }

        延时 (500)
        标准输出行 (, "按任意键继续...")
        标准输入 ()

        // 设置回调处理器
        // 有了回调处理器,任务函数依然会在投递后立即执行
        // 但回调函数需要通过回调处理器调度
        协程池.加入回调触发点 (回调处理器)
        计次循环 (5)
        {
            协程池.投递回调任务 (绑定无参数静态方法 (任务函数A), 绑定静态方法 (回调函数A, 取循环索引 ()))

        }
        变量 触发数 <类型 = 整数 值 = 0>
        判断循环 (真)
        {
            触发数 = 触发数 + 回调处理器.运行 ()  // 手动触发回调
            如果 (触发数 >= 5)
            {
                跳出循环
            }
        }

        延时 (500)
        标准输出行 (, "按任意键继续...")
        标准输入 ()

        变量 信道数组 <类型 = "整数信道类 [5]">
        计次循环 (5)
        {
            协程池.投递信道任务 (信道数组 [取循环索引 ()], 绑定无参数静态方法 (信道任务))
        }
        计次循环 (5)
        {
            标准输出行 (, 取格式文本 ("[%s]信道任务返回值: %d", 取源类名 (), 信道数组 [取循环索引 ()].读 ()))
        }
    }

    方法 任务函数A <静态 折叠>
    {
        Go协程.协程延时 (100)
    }

    方法 回调函数A <静态 折叠>
    参数 索引 <类型 = 整数>
    {
        标准输出行 (, 取格式文本 ("[%s]触发了第 %d 个回调", 取源类名 (), 索引))
    }

    方法 任务函数B <静态 类型 = 整数>
    参数 索引 <类型 = 整数>
    {
        返回 (索引)
    }

    方法 回调函数B <静态>
    参数 索引 <类型 = 整数>
    {
        标准输出行 (, 取格式文本 ("[%s]触发了第 %d 个回调", 取源类名 (), 索引))
    }

    方法 信道任务 <静态 类型 = 整数>
    {
        变量 随机数 <类型 = 标准随机数类>
        返回 (随机数.取随机整数 ())

    }

    #
}

#
