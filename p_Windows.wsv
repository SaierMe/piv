<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv" "">

# 函数HOOK ===

类 简易HOOK类 <公开 注释 = "MinHook原版: https://github.com/TsudaKageyu/minhook"
        注释 = "MultiHook分支: https://github.com/m417z/minhook" 注释 = "  GitHub上非常热门的一个Inline Hook库,原作者2017年后"
        注释 = "就没有再提交更新,所以选择了MultiHook这个分支." 注释 = "  跟官方的\"硬件及键鼠和钩子操作类\"-\"系统API钩子类\"是" 注释 = "同一个开源的不同分支." 折叠
        @文档 = "category = \"HOOK\"" @视窗.外部头文件 = "minhook\\include\\MinHook.h"
        @视窗.外部源文件 = "minhook\\include\\MultiHook.c" "@视窗.外部头文件.全局-111" = "src\\piv_encoding.hpp">
{
    方法 置线程释放方法 <公开 静态 类型 = MH状态码 注释 = "设置\"启用钩子\"和\"停用钩子\"时,挂起和恢复线程的方法." 返回值注释 = "返回0表示成功,其他值为失败." 折叠
            @嵌入式方法 = "">
    参数 释放方法 <类型 = MH线程释放方法 注释 = "所欲设置的方法." @默认值 = MH线程释放方法.快速释放>
    {
        @ MH_SetThreadFreezeMethod((MH_THREAD_FREEZE_METHOD)@<释放方法>)
    }

    方法 取状态码描述 <公开 静态 类型 = 文本型 注释 = "将状态码翻译为文本,比如\"MH_OK\"." 折叠 @嵌入式方法 = "">
    参数 状态码 <类型 = MH状态码 注释 = "所欲翻译的状态码.">
    {
        @ @an<CVolString>{MH_StatusToString((MH_STATUS)@<状态码>)}
    }

    # MinHook ---

    方法 安装钩子 <公开 静态 类型 = MH状态码 注释 = "  创建一个钩子来拦截目标函数,钩子默认处于停用" 注释 = "状态,需要\"启用钩子\"才会开始拦截."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "提供所欲HOOK的目标函数地址,它将被钩子函数控制.">
    参数 钩子函数地址 <类型 = 变整数 注释 = "  提供钩子函数的地址,钩子函数的参数和返回值类型" 注释 = "必须跟目标函数相同.">
    参数 跳板函数地址 <类型 = 变整数 注释 = "  返回目标函数被挂钩后的跳板函数地址,在钩子函数" 注释 = "中调用跳板函数可以执行原始的目标函数." @需求类型 = 可写入变量>
    {
        @ MH_CreateHook((LPVOID)@<目标函数地址>,
        @               (LPVOID)@<钩子函数地址>, (LPVOID*)&@<跳板函数地址>)
    }

    方法 安装API钩子 <公开 静态 类型 = MH状态码 注释 = "  创建一个钩子来拦截指定的API函数,钩子默认处于" 注释 = "停用状态,需要\"启用钩子\"才会开始拦截."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 模块名称 <类型 = 文本型 注释 = "提供目标函数所在模块名称,比如\"User32.dll\".">
    参数 函数名称 <类型 = 文本型 注释 = "提供所欲HOOK的目标函数名称,比如\"MessageBoxW\".">
    参数 钩子函数地址 <类型 = 变整数 注释 = "  提供钩子函数的地址,钩子函数的参数和返回值类型" 注释 = "必须跟目标函数相同." "">
    参数 跳板函数地址 <类型 = 变整数 注释 = "  返回API被挂钩后的跳板函数地址,在钩子函数中调用" 注释 = "跳板函数可以执行API的原始函数." @需求类型 = 可写入变量>
    参数 目标函数地址 <类型 = 变整数 注释 = "  返回API的原始函数地址,可用于\"启用钩子/停用钩子\"" 注释 = "和\"卸载钩子\",启用钩子后执行该地址会进入钩子函数,"
            注释 = "因此请勿在钩子函数中执行该地址." @需求类型 = 可写入变量>
    {
        @ MH_CreateHookApiEx(@<模块名称>.GetText(),
        @                    PivW2A{@<函数名称>}.c_str(),
        @                    (LPVOID)@<钩子函数地址>, (LPVOID*)&@<跳板函数地址>, (LPVOID*)&@<目标函数地址>)
    }

    方法 安装API钩子2 <公开 静态 类型 = MH状态码 注释 = "  创建一个钩子来拦截指定的API函数,钩子默认处于" 注释 = "停用状态,需要\"启用钩子\"才会开始拦截."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠>
    参数 模块名称 <类型 = 文本型 注释 = "提供目标函数所在模块名称,比如\"User32.dll\".">
    参数 函数名称 <类型 = 文本型 注释 = "提供所欲HOOK的目标函数名称,比如\"MessageBoxW\".">
    参数 钩子信息 <类型 = HOOK信息类 注释 = "  设置和返回钩子信息,必须先设置好\"钩子\"函数," 注释 = "执行成功后会自动填入跳板和目标函数." "">
    {
        返回 (安装API钩子 (模块名称, 函数名称, 钩子信息.钩子, 钩子信息.跳板, 钩子信息.目标))
    }

    方法 卸载钩子 <公开 静态 类型 = MH状态码 注释 = "卸载一个或全部已经安装的钩子,卸载前会自动停用钩子." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲卸载钩子的目标函数地址,若提供的" 注释 = "参数为0,将一次性卸载所有已安装的钩子.">
    {
        @ MH_RemoveHook((LPVOID)@<目标函数地址>)
    }

    方法 卸载空闲钩子 <公开 静态 类型 = MH状态码 注释 = "卸载所有处于停用状态的钩子." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    {
        @ MH_RemoveDisabledHooks()
    }

    方法 启用钩子 <公开 静态 类型 = MH状态码 注释 = "  启用一个或全部已安装的钩子,钩子函数在启用后" 注释 = "才会开始拦截." 返回值注释 = "返回0表示成功,其他值为失败." 折叠
            @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲启用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性启用所有已安装的钩子.">
    {
        @ MH_EnableHook((LPVOID)@<目标函数地址>)
    }

    方法 停用钩子 <公开 静态 类型 = MH状态码 注释 = "  停用一个或全部已安装的钩子,钩子函数在停用后" 注释 = "会暂停拦截." 返回值注释 = "返回0表示成功,其他值为失败." 折叠
            @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲停用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性停用所有已安装的钩子.">
    {
        @ MH_DisableHook((LPVOID)@<目标函数地址>)
    }

    方法 请求启用钩子 <公开 静态 类型 = MH状态码 注释 = "  请求启用一个或全部已安装的钩子,后续需要调用" 注释 = "\"应用请求\"才会实际执行."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲启用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性启用所有已安装的钩子.">
    {
        @ MH_QueueEnableHook((LPVOID)@<目标函数地址>)
    }

    方法 请求停用钩子 <公开 静态 类型 = MH状态码 注释 = "  请求停用一个或全部已安装的钩子,后续需要调用" 注释 = "\"应用请求\"才会实际执行."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲停用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性停用所有已安装的钩子.">
    {
        @ MH_QueueDisableHook((LPVOID)@<目标函数地址>)
    }

    方法 应用请求 <公开 静态 类型 = MH状态码 注释 = "一次性应用所有请求的更改." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    {
        @ MH_ApplyQueued()
    }

    # @begin
    # <> <include>
    # static void @an<_sOnBeforeAppInit> () { MH_Initialize (); }
    # static void @an<_sOnAfterAppExit> () { MH_Uninitialize (); }
    # <> </include>
    # @end
}

类 多重HOOK类 <公开 注释 = "  MultiHook 这个分支在原版的基础上增加了给同一个函数" 注释 = "安装多个钩子的功能,这些多重钩子可以同时启用和生效." 折叠
        @文档 = "category = \"HOOK\"" @强制依赖 = "简易HOOK类">
{
    方法 置线程释放方法 <公开 静态 类型 = MH状态码 注释 = "设置\"启用钩子\"和\"停用钩子\"时,挂起和恢复线程的方法." 返回值注释 = "返回0表示成功,其他值为失败." 折叠
            @嵌入式方法 = "">
    参数 释放方法 <类型 = MH线程释放方法 注释 = "所欲设置的方法." @默认值 = MH线程释放方法.快速释放>
    {
        @ MH_SetThreadFreezeMethod((MH_THREAD_FREEZE_METHOD)@<释放方法>)
    }

    方法 取状态码描述 <公开 静态 类型 = 文本型 注释 = "将状态码翻译为文本,比如\"MH_OK\"." 折叠 @嵌入式方法 = "">
    参数 状态码 <类型 = MH状态码 注释 = "所欲翻译的状态码.">
    {
        @ @an<CVolString>{MH_StatusToString((MH_STATUS)@<状态码>)}
    }

    # MultiHook ---

    方法 安装钩子 <公开 静态 类型 = MH状态码 注释 = "  创建一个自定义ID的钩子来拦截目标函数,默认处于" 注释 = "停用状态,需要\"启用钩子\"才会开始拦截."
            注释 = "  安装到同一个函数的多个钩子可以同时生效,在钩子" 注释 = "函数中只能调用同一个方法返回的跳板函数." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "  提供自定义的钩子标识符(从1开始),用于在同一个" 注释 = "目标函数上安装多个不同的钩子函数." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "提供所欲HOOK的目标函数地址,它将被钩子函数控制.">
    参数 钩子函数地址 <类型 = 变整数 注释 = "  提供钩子函数的地址,钩子函数的参数和返回值类型" 注释 = "必须跟目标函数相同.">
    参数 跳板函数地址 <类型 = 变整数 注释 = "  返回目标函数被挂钩后的跳板函数地址,在钩子函数" 注释 = "中调用跳板函数可以执行原始的目标函数." @需求类型 = 可写入变量>
    {
        @ MH_CreateHookEx((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>,
        @                 (LPVOID)@<钩子函数地址>, (LPVOID*)&@<跳板函数地址>)
    }

    方法 卸载钩子 <公开 静态 类型 = MH状态码 注释 = "卸载指定钩子ID的一个或全部已经安装的钩子." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "  所欲卸载的自定义钩子标识符(从1开始)." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲卸载钩子的目标函数地址,若提供的" 注释 = "参数为0,将一次性卸载所有已安装的钩子.">
    {
        @ MH_RemoveHookEx((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>)
    }

    方法 卸载空闲钩子 <公开 静态 类型 = MH状态码 注释 = "卸载指定钩子ID的所有处于停用状态的钩子." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "所欲卸载的自定义钩子标识符(从1开始)." @默认值 = 1>
    {
        @ MH_RemoveDisabledHooksEx((ULONG_PTR)@<钩子ID>)
    }

    方法 启用钩子 <公开 静态 类型 = MH状态码 注释 = "  启用指定钩子ID的一个或全部已安装的钩子,钩子" 注释 = "函数在启用后才会开始拦截."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "提供所欲启用的自定义钩子标识符(从1开始)." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲启用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性启用所有已安装的钩子.">
    {
        @ MH_EnableHookEx((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>)
    }

    方法 停用钩子 <公开 静态 类型 = MH状态码 注释 = "  停用指定钩子ID的一个或全部已安装的钩子,钩子" 注释 = "函数在停用后会暂停拦截."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "提供所欲停用的自定义钩子标识符(从1开始)." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲停用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性停用所有已安装的钩子.">
    {
        @ MH_DisableHookEx((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>)
    }

    方法 请求启用钩子 <公开 静态 类型 = MH状态码 注释 = "  请求启用指定钩子ID的一个或全部已安装的钩子," 注释 = "后续需要调用\"应用请求\"才会实际执行."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "提供所欲启用的自定义钩子标识符(从1开始)." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲启用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性启用所有已安装的钩子.">
    {
        @ MH_QueueEnableHookEx((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>)
    }

    方法 请求停用钩子 <公开 静态 类型 = MH状态码 注释 = "  请求停用指定钩子ID的一个或全部已安装的钩子," 注释 = "后续需要调用\"应用多重请求\"才会实际执行."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "提供所欲停用的自定义钩子标识符(从1开始)." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲停用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性停用所有已安装的钩子.">
    {
        @ MH_QueueDisableHookEx((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>)
    }

    方法 应用请求 <公开 静态 类型 = MH状态码 注释 = "一次性应用指定钩子ID所有请求的更改." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "提供所欲应用请求的自定义钩子标识符(从1开始)." @默认值 = 1>
    {
        @ MH_ApplyQueuedEx((ULONG_PTR)@<钩子ID>)
    }
}

类 MH状态码 <公开 注释 = "执行函数返回的状态码(MH_STATUS),0表示成功,其他表示失败." 折叠 @文档 = "category = \"HOOK.辅助类\"" @常量类 = 整数
        @强制依赖 = "简易HOOK类">
{
    常量 未知错误 <公开 值 = @MH_UNKNOWN 注释 = "-1 未知错误">
    常量 成功 <公开 值 = @MH_OK 注释 = "0  成功无错误">
    常量 已初始化 <公开 值 = @MH_ERROR_ALREADY_INITIALIZED 注释 = "1  MinHook已经初始化">
    常量 未初始化 <公开 值 = @MH_ERROR_NOT_INITIALIZED 注释 = "2  MinHook尚未初始化,或已经被卸载.">
    常量 已创建 <公开 值 = @MH_ERROR_ALREADY_CREATED 注释 = "3  目标函数已经安装了钩子">
    常量 未创建 <公开 值 = @MH_ERROR_NOT_CREATED 注释 = "4  目标函数尚未安装钩子">
    常量 已启用 <公开 值 = @MH_ERROR_ENABLED 注释 = "5  目标函数的钩子已被启用">
    常量 已停用 <公开 值 = @MH_ERROR_DISABLED 注释 = "6  目标函数的钩子已被停用">
    常量 不可执行 <公开 值 = @MH_ERROR_NOT_EXECUTABLE 注释 = "7  函数指针无效,指向的地址不是可执行区域.">
    常量 不支持的函数 <公开 值 = @MH_ERROR_UNSUPPORTED_FUNCTION 注释 = "8  目标函数不能安装钩子">
    常量 内存分配失败 <公开 值 = @MH_ERROR_MEMORY_ALLOC 注释 = "9  内存分配失败">
    常量 内存受保护 <公开 值 = @MH_ERROR_MEMORY_PROTECT 注释 = "10 更改内存的保护属性失败">
    常量 找不到模块 <公开 值 = @MH_ERROR_MODULE_NOT_FOUND 注释 = "11 指定的模块可能未加载">
    常量 找不到函数 <公开 值 = @MH_ERROR_FUNCTION_NOT_FOUND 注释 = "12 模块中找不到指定的函数">
    常量 互斥锁错误 <公开 值 = @MH_ERROR_MUTEX_FAILURE 注释 = "13 创建或等待主互斥锁时失败">
}

类 MH线程释放方法 <公开 注释 = "\"置线程释放方法\"的参数(MH_THREAD_FREEZE_METHOD)" 折叠 @文档 = "category = \"HOOK.辅助类\""
        @常量类 = 整数 @强制依赖 = "简易HOOK类">
{
    常量 原始方法 <公开 值 = @MH_FREEZE_METHOD_ORIGINAL 注释 = "  MinHook原来提供的方法,使用CreateToolhelp32Snapshot,"
            注释 = "有文档和支持所有的Windows版本,但速度很慢和可靠性较低.">
    常量 快速释放 <公开 值 = @MH_FREEZE_METHOD_FAST_UNDOCUMENTED 注释 = "  使用NtGetNextThread,速度更快且可靠性更高,但没有文档."
            注释 = "支持Windows Vista之后的系统,旧系统会自动回退到原始方法.">
    常量 不作释放 <公开 值 = @MH_FREEZE_METHOD_NONE_UNSAFE 注释 = "  不挂起线程也不调整指令指针寄存器.除非你了解它的含义并"
            注释 = "确定它是安全的,否则不要使用本方法.">
}

类 HOOK信息类 <公开 基础类 = 扩展对象类 注释 = "为了方便用户使用而定义的一个类型." 注释 = "用来记录HOOK的相关信息,比如函数地址和多重钩子ID." 折叠
        @文档 = "category = \"HOOK.辅助类\"">
{
    变量 ID <公开 类型 = 变整数 注释 = "多重钩子ID">
    变量 钩子 <公开 类型 = 变整数 注释 = "钩子函数地址">
    变量 跳板 <公开 类型 = 变整数 注释 = "跳板函数地址">
    变量 目标 <公开 类型 = 变整数 注释 = "目标函数地址">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        加入格式文本 (展示内容, "<HOOK信息类> 总共 4 个成员:\r\n1. ID: 0x%p\r\n2. 钩子: 0x%p\r\n3. 跳板: 0x%p\r\n4. 目标: 0x%p", ID, 钩子, 跳板, 目标)
    }
}

类 HOOK信息数组类 <公开 基础类 = 对象数组模板类 注释 = "\"HOOK信息类\"的数组" 折叠2 @文档 = "category = \"HOOK.辅助类\""
        @模板实现类 = "HOOK信息类">

# ===

类 窗口操作类 <公开 注释 = "通过窗口句柄操作Win32窗口" 折叠 @文档 = "category = \"界面操作\"">
{
    方法 取窗口类名 <公开 静态 类型 = 文本型 注释 = "获取指定窗口句柄的窗口类名" 折叠 @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数>
    {
        @ wchar_t ClassName[257] = {0};
        @ int len = ::GetClassNameW((HWND)@<窗口句柄>, ClassName, 256);
        @ if (len)
        @     return @an<CVolString>(ClassName, len);
        @ else
        @     return @an<CVolString>("");
    }

    方法 寻找窗口句柄 <公开 静态 类型 = 变整数 注释 = "寻找与指定窗口类名和窗口标题匹配的顶级窗口的句柄" 折叠 @嵌入式方法 = "">
    参数 窗口类名 <类型 = 文本型 注释 = "提供所欲寻找的窗口类名,不区分大小写,空对象表示匹配所有类名." @默认值 = 空对象>
    参数 窗口标题 <类型 = 文本型 注释 = "提供所欲寻找的窗口标题,不区分大小写,空对象表示匹配所有标题." @默认值 = 空对象>
    {
        @ (INT_P)::FindWindowW (@<窗口类名>.GetTextMaybeNull(), @<窗口标题>.GetTextMaybeNull())
    }

    方法 调用窗口过程 <公开 静态 类型 = 变整数 注释 = "将消息信息传递到指定的窗口过程" 返回值注释 = "返回消息的处理结果" 折叠 @嵌入式方法 = "">
    参数 上个窗口过程 <类型 = 变整数 注释 = "上一个窗口过程的指针">
    参数 窗口句柄 <类型 = 变整数 注释 = "接收消息的窗口句柄">
    参数 信息值 <类型 = 整数>
    参数 参数1 <类型 = 变整数>
    参数 参数2 <类型 = 变整数>
    {
        @ (INT_P)::CallWindowProcW ((WNDPROC)@<上个窗口过程>, (HWND)@<窗口句柄>, (UINT)@<信息值>, (WPARAM)@<参数1>, (LPARAM)@<参数2>)
    }

    方法 置窗口属性值 <公开 静态 类型 = 变整数 注释 = "修改指定窗口的属性值,并返回之前的属性值." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 属性索引 <类型 = 整数>
    参数 新属性值 <类型 = 变整数>
    {
        @ (INT_P)::SetWindowLongPtrW ((HWND)@<窗口句柄>, @<属性索引>, (LONG_PTR)@<新属性值>)
    }

    方法 取窗口属性值 <公开 静态 类型 = 变整数 注释 = "获取指定窗口的属性值" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 属性索引 <类型 = 整数>
    {
        @ (INT_P)::GetWindowLongPtrW ((HWND)@<窗口句柄>, @<属性索引>)
    }

    方法 取窗口标题 <公开 静态 类型 = 文本型 注释 = "获取指定窗口的标题" 折叠 @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数>
    {
        @ @an<CVolString> title;
        @ title.SetLength(GetWindowTextLengthW((HWND)@<窗口句柄>));
        @ ::GetWindowTextW((HWND)@<窗口句柄>, (LPTSTR)title.GetText(), (int)title.GetLength());
        @ return title;
    }

    方法 置窗口标题 <公开 静态 类型 = 逻辑型 注释 = "设置指定窗口的标题" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 标题 <类型 = 文本型>
    {
        @ ::SetWindowTextW((HWND)@<窗口句柄>, @<标题>.GetText())
    }

    方法 发送信息 <公开 静态 类型 = 变整数 注释 = "将指定信息发送到指定的窗口中,并等待且取回信息反馈值." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 信息值 <类型 = 整数>
    参数 参数1 <类型 = 变整数>
    参数 参数2 <类型 = 变整数>
    {
        @ (INT_P)::SendMessage((HWND)@<窗口句柄>, (UINT)@<信息值>, (WPARAM)@<参数1>, (LPARAM)@<参数2>)
    }

    方法 投递信息 <公开 静态 类型 = 逻辑型 注释 = "将指定信息发送到指定的窗口中,不等待直接返回." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 信息值 <类型 = 整数>
    参数 参数1 <类型 = 变整数>
    参数 参数2 <类型 = 变整数>
    {
        @ ::PostMessage((HWND)@<窗口句柄>, (UINT)@<信息值>, (WPARAM)@<参数1>, (LPARAM)@<参数2>)
    }

    方法 加载图标文件 <公开 静态 类型 = 逻辑型 注释 = "从文件加载图标并设置到窗口标题" 折叠 @禁止流程检查 = 真>
    参数 主窗口句柄 <类型 = 变整数>
    参数 图标文件 <类型 = 文本型>
    {
        @ HANDLE hIcon = ::LoadImageW(NULL, @<图标文件>.GetText(), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE | LR_LOADFROMFILE);
        @ if (hIcon) {
        @     ::SendMessage((HWND)@<主窗口句柄>, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
        @     ::SendMessage((HWND)@<主窗口句柄>, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 加载图标对象 <公开 静态 类型 = 逻辑型 注释 = "从图标对象类加载图标到窗口中" 折叠 @禁止流程检查 = 真>
    参数 主窗口句柄 <类型 = 变整数>
    参数 所欲设置的图标 <类型 = 图标对象类>
    {
        @ HICON hIcon = (HICON)@<所欲设置的图标>.GetGDIHandle();
        @ if (hIcon) {
        @     ::SendMessage((HWND)@<主窗口句柄>, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
        @     ::SendMessage((HWND)@<主窗口句柄>, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 加载图标文件2 <公开 静态 类型 = 变整数 注释 = "从文件加载图标,返回图标句柄." 折叠 @嵌入式方法 = "">
    参数 图标文件 <类型 = 文本型>
    {
        @ (INT_P)::LoadImageW(NULL, @<图标文件>.GetText(), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE | LR_LOADFROMFILE)
    }
}

类 窗口子类化 <公开 注释 = "窗口子类化API" 折叠 @文档 = "category = \"界面操作\"">
{
    方法 安装窗口子类 <公开 静态 类型 = 逻辑型 注释 = "安装或更新窗口的子类回调函数." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 注释 = "所欲安装或更新窗口子类的窗口句柄">
    参数 子类回调函数 <@匹配方法 = "子类回调函数模板">
    参数 子类ID <类型 = 变整数 注释 = "子类回调函数加上子类ID作为子类的唯一标识符">
    参数 引用数据 <类型 = 变整数 注释 = "传递到子类回调函数的自定义数据" @默认值 = 0>
    {
        @ ::SetWindowSubclass((HWND)@<窗口句柄>, (SUBCLASSPROC)&@<子类回调函数>, (UINT_PTR)@<子类ID>, (DWORD_PTR)@<引用数据>)
    }

    方法 移除窗口子类 <公开 静态 类型 = 逻辑型 注释 = "从窗口中移除指定的子类回调函数." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 子类回调函数 <@匹配方法 = "子类回调函数模板">
    参数 子类ID <类型 = 变整数>
    {
        @ ::RemoveWindowSubclass((HWND)@<窗口句柄>, (SUBCLASSPROC)&@<子类回调函数>, (UINT_PTR)@<子类ID>)
    }

    方法 调用子类过程 <公开 静态 类型 = 变整数 注释 = "在窗口的子类链中调用下一个处理程序." 注释 = "如果是子类链的最后一个处理程序,则调用窗口的原始窗口过程." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 注释 = "提供消息所对应的窗口句柄(HWND)">
    参数 消息值 <类型 = 整数 注释 = "提供消息的具体值">
    参数 消息参数1 <类型 = 变整数 注释 = "提供消息所附带的参数1的值">
    参数 消息参数2 <类型 = 变整数 注释 = "提供消息所附带的参数2的值">
    {
        @ ::DefSubclassProc((HWND)@<窗口句柄>, (UINT)@<消息值>, (WPARAM)@<消息参数1>, (LPARAM)@<消息参数2>)
    }

    方法 取子类引用数据 <公开 静态 类型 = 逻辑型 注释 = "获取先前传递给指定窗口子类回调函数的引用数据." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 子类回调函数 <@匹配方法 = "">
    参数 子类ID <类型 = 变整数>
    参数 返回引用数据 <类型 = 变整数 @需求类型 = 可写入变量>
    {
        @ ::GetWindowSubclass((HWND)@<窗口句柄>, (SUBCLASSPROC)&@<子类回调函数>, (UINT_PTR)@<子类ID>, (DWORD_PTR*)&@<返回引用数据>)
    }

    方法 子类回调函数模板 <公开 静态 类型 = 变整数 折叠>
    参数 窗口句柄 <类型 = 变整数 注释 = "提供消息所对应的窗口句柄(HWND)">
    参数 消息值 <类型 = 整数 注释 = "提供消息的具体值">
    参数 消息参数1 <类型 = 变整数 注释 = "提供消息所附带的参数1的值">
    参数 消息参数2 <类型 = 变整数 注释 = "提供消息所附带的参数2的值">
    参数 子类ID <类型 = 变整数>
    参数 引用数据 <类型 = 变整数>
    {
        返回 (0)
    }
}

类 菜单操作类 <公开 注释 = "通过菜单句柄操作Win32菜单" 折叠 @文档 = "category = \"界面操作\"">
{
    方法 创建菜单 <公开 静态 类型 = 变整数 注释 = "创建一个顶级菜单栏" 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)::CreateMenu()
    }

    方法 创建弹出菜单 <公开 静态 类型 = 变整数 注释 = "创建一个弹出式菜单" 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)::CreatePopupMenu()
    }

    方法 置窗口菜单 <公开 静态 类型 = 逻辑型 注释 = "分配一个新菜单到指定的窗口中,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 菜单句柄 <类型 = 变整数 注释 = "提供0表示删除当前的菜单">
    {
        @ ::SetMenu((HWND)@<窗口句柄>, @<菜单句柄>)
    }

    方法 取窗口菜单 <公开 静态 类型 = 变整数 注释 = "返回指定窗口已分配的菜单栏句柄" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    {
        @ (INT_P)::GetMenu((HWND)@<窗口句柄>)
    }

    方法 取菜单项数量 <公开 静态 类型 = 整数 注释 = "返回指定菜单的菜单项数量,失败返回-1." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数>
    {
        @ ::GetMenuItemCount((HMENU)@<菜单句柄>)
    }

    方法 取菜单项ID <公开 静态 类型 = 整数 注释 = "返回指定菜单项的ID,失败返回-1." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数>
    参数 索引位置 <类型 = 整数 注释 = "菜单项的从零开始的相对位置">
    {
        @ (INT)::GetMenuItemID((HMENU)@<菜单句柄>, @<索引位置>)
    }

    方法 取子菜单句柄 <公开 静态 类型 = 变整数 注释 = "返回由指定菜单项激活的下拉菜单或子菜单的句柄." 注释 = "返回0表示指定的菜单项不会激活下拉菜单或子菜单." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数>
    参数 索引位置 <类型 = 整数 注释 = "菜单项的从零开始的相对位置">
    {
        @ (INT_P)::GetSubMenu((HMENU)@<菜单句柄>, @<索引位置>)
    }

    方法 销毁菜单 <公开 静态 类型 = 逻辑型 注释 = "销毁指定的菜单,返回是否成功." 注释 = "关闭程序之前必须销毁未分配给窗口的菜单(已分配的不用手动销毁)."
            注释 = "该命令会递归删除菜单及其所有子菜单." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数>
    {
        @ ::DestroyMenu((HMENU)@<菜单句柄>)
    }

    方法 重画菜单 <公开 静态 类型 = 逻辑型 注释 = "重绘指定窗口的菜单栏,返回是否成功." 注释 = "如果在系统创建窗口后菜单栏发生更改,则必须调用此函数来绘制更改的菜单栏." 折叠
            @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    {
        @ ::DrawMenuBar((HWND)@<窗口句柄>)
    }

    方法 插入菜单项 <公开 静态 类型 = 逻辑型 注释 = "插入一个新的菜单项目,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 插入位置 <类型 = 整数 注释 = "新菜单项会插入到该位置后面,根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    参数 菜单项信息 <类型 = 菜单项信息类 注释 = "所欲插入菜单项的信息属性">
    {
        @ ::InsertMenuItemW((HMENU)@<菜单句柄>, (UINT)@<插入位置>, @<是否为位置>, &@<菜单项信息>)
    }

    方法 加入菜单项 <公开 静态 类型 = 逻辑型 注释 = "在菜单尾部加入一个菜单项,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 标志 <类型 = 整数 注释 = "请参考\"菜单项标志\"中的常量">
    参数 菜单项ID <类型 = 变整数>
    参数 菜单项标题 <类型 = 文本型 @默认值 = 空对象>
    {
        @ ::AppendMenuW((HMENU)@<菜单句柄>, (UINT)@<标志>, (UINT_PTR)@<菜单项ID>, @<菜单项标题>.GetTextMaybeNull())
    }

    方法 删除菜单项 <公开 静态 类型 = 逻辑型 注释 = "删除所指定的菜单项,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        @ ::DeleteMenu((HMENU)@<菜单句柄>, (UINT)@<菜单项>, @<是否为位置> ? MF_BYPOSITION : MF_BYCOMMAND)
    }

    方法 移除菜单项 <公开 静态 类型 = 逻辑型 注释 = "删除所指定的菜单项,返回是否成功."
            注释 = "跟\"删除菜单项\"不同,如果菜单项可以打开下拉菜单或子菜单,则本命令不会销毁菜单,从而允许重复使用菜单." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        @ ::RemoveMenu((HMENU)@<菜单句柄>, (UINT)@<菜单项>, @<是否为位置> ? MF_BYPOSITION : MF_BYCOMMAND)
    }

    方法 选中菜单项 <公开 静态 类型 = 整数 注释 = "设置或取消所指定ID菜单项目的选中状态,返回先前的选中状态."
            返回值注释 = "返回值大于0表示之前为选中状态,0表示之前未选中,指定的菜单项不存在返回-1." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否选中 <类型 = 逻辑型 注释 = "是否选中指定的菜单项">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        @ ::CheckMenuItem((HMENU)@<菜单句柄>, (UINT)@<菜单项>, (@<是否选中> ? MF_CHECKED : MF_UNCHECKED) | (@<是否为位置> ? MF_BYPOSITION : MF_BYCOMMAND))
    }

    方法 选中单选菜单项 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 首菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 尾菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 选中菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        @ ::CheckMenuRadioItem((HMENU)@<菜单句柄>, (UINT)@<首菜单项>, (UINT)@<尾菜单项>, (UINT)@<选中菜单项>, @<是否为位置> ? MF_BYPOSITION : MF_BYCOMMAND)
    }

    方法 高亮菜单项 <公开 静态 类型 = 逻辑型 注释 = "设置或取消所指定ID菜单项目的突出显示状态." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否高亮 <类型 = 逻辑型 注释 = "是否突出显示指定的菜单项">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        @ ::HiliteMenuItem((HWND)@<窗口句柄>, (HMENU)@<菜单句柄>, (UINT)@<菜单项>, (@<是否高亮> ? MF_HILITE : MF_UNHILITE) | (@<是否为位置> ? MF_BYPOSITION : MF_BYCOMMAND))
    }

    方法 置默认菜单项 <公开 静态 类型 = 逻辑型 注释 = "设置指定菜单的默认菜单项" 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        @ ::SetMenuDefaultItem((HMENU)@<菜单句柄>, (UINT)@<菜单项>, (UINT)@<是否为位置>)
    }

    方法 取默认菜单项 <公开 静态 类型 = 整数 注释 = "获取指定菜单上的默认菜单项" 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    参数 递归子菜单 <类型 = 逻辑型 注释 = "如果默认菜单项是子菜单,是否递归搜索所有的子菜单." @默认值 = 假>
    {
        @ (INT)::GetMenuDefaultItem((HMENU)@<菜单句柄>, (UINT)@<是否为位置>, @<递归子菜单> ? GMDI_GOINTOPOPUPS : 0)
    }

    方法 允许菜单项 <公开 静态 类型 = 整数 注释 = "设置或取消所指定ID菜单项的操作允许状态,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 允许状态 <类型 = 整数 注释 = "0=启用; 1=禁用并灰显; 2=禁用">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        @ ::EnableMenuItem((HMENU)@<菜单句柄>, (UINT)@<菜单项>, (UINT)(@<允许状态> | (@<是否为位置> ? MF_BYPOSITION : MF_BYCOMMAND)))
    }

    方法 是否被选中 <公开 静态 类型 = 逻辑型 注释 = "返回所指定的菜单项是否处于被选中状态,如果所指定菜单项不存在,将始终返回假." 折叠>
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        返回 (位与 (取菜单项状态 (菜单句柄, 菜单项, 是否为位置), 菜单项标志.选中) == 菜单项标志.选中)
    }

    方法 是否被允许 <公开 静态 类型 = 逻辑型 注释 = "返回所指定ID菜单项是否处于被允许操作状态,如果所指定菜单项不存在,将始终返回假." 折叠 @禁止流程检查 = 真>
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        返回 (位与 (取菜单项状态 (菜单句柄, 菜单项, 是否为位置), 位或 (菜单项标志.禁用, 菜单项标志.灰色)) != 0)
    }

    方法 取菜单项状态 <公开 静态 类型 = 整数 注释 = "返回值为\"菜单项标志\"的一或多个常量的位或值" 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        @ (INT)::GetMenuState((HMENU)@<菜单句柄>, (UINT)@<菜单项>, @<是否为位置> ? MF_BYPOSITION : MF_BYCOMMAND)
    }

    方法 取菜单项信息 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    参数 菜单项信息 <类型 = 菜单项信息类 注释 = "返回菜单项信息">
    {
        @ ::GetMenuItemInfoW((HMENU)@<菜单句柄>, (UINT)@<菜单项>, @<是否为位置>, &@<菜单项信息>)
    }

    方法 置菜单项信息 <公开 静态 类型 = 逻辑型 注释 = "If the specified item does not exist, the return value is -1."
            注释 = "If the menu item opens a submenu, the low-order byte of the return value contains the menu flags associated with the item, and the high-order byte contains the number of items in the submenu opened by the it"
            折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    参数 菜单项信息 <类型 = 菜单项信息类 注释 = "所欲设置的菜单项信息">
    {
        @ ::SetMenuItemInfoW((HMENU)@<菜单句柄>, (UINT)@<菜单项>, @<是否为位置>, &@<菜单项信息>)
    }
}

类 菜单项标志 <公开 折叠 @文档 = "category = \"界面操作.辅助类\"">
{
    常量 选中 <公开 类型 = 整数 值 = @MF_CHECKED 注释 = "选中复选框(仅适用于下拉菜单、子菜单和快捷菜单)">
    常量 禁用 <公开 类型 = 整数 值 = @MF_DISABLED 注释 = "菜单项已被禁用">
    常量 灰色 <公开 类型 = 整数 值 = @MF_GRAYED 注释 = "菜单项被禁用且显示成灰色">
    常量 高亮 <公开 类型 = 整数 值 = @MF_HILITE 注释 = "菜单项被突出显示">
    常量 "" <公开 类型 = 整数 值 = @MF_MENUBARBREAK>
    常量 "" <公开 类型 = 整数 值 = @MF_MENUBREAK>
    常量 所有者绘制 <公开 类型 = 整数 值 = @MF_OWNERDRAW>
    常量 子菜单 <公开 类型 = 整数 值 = @MF_POPUP 注释 = "菜单项是一个子菜单">
    常量 分隔线 <公开 类型 = 整数 值 = @MF_SEPARATOR 注释 = "有一条水平分界线(仅适用于下拉菜单、子菜单和快捷菜单)">
    常量 启用 <公开 类型 = 整数 值 = @MF_ENABLED 注释 = "菜单项可用,由于值为0,需要使用表达式测试: !(Flag&(MF_DISABLED | MF_GRAYED))">
    常量 文本菜单项 <公开 类型 = 整数 值 = @MF_STRING 注释 = "菜单项标题文本. 由于值为0,需要使用表达式测试: !(Flag&(MF_BITMAP | MF_OWNERDRAW))">
    常量 未选中 <公开 类型 = 整数 值 = @MF_UNCHECKED 注释 = "未选中复选框. 由于值为0,需要使用表达式测试: !(Flag&MF_CHECKED)">
    常量 未高亮 <公开 类型 = 整数 值 = @MF_UNHILITE 注释 = "菜单项未突出显示. 由于值为0,需要使用表达式测试: !(Flag&HILITE)">
}

类 菜单项状态 <公开 折叠 @文档 = "category = \"界面操作.辅助类\"">
{
    常量 选中菜单项 <公开 类型 = 整数 值 = @MFS_CHECKED 注释 = "选中复选框(仅适用于下拉菜单、子菜单和快捷菜单)">
    常量 默认菜单项 <公开 类型 = 整数 值 = @MFS_DEFAULT 注释 = "该菜单项为默认值,一个菜单只能有一个默认菜单项,以粗体突出显示.">
    常量 禁用菜单项 <公开 类型 = 整数 值 = @MFS_DISABLED 注释 = "菜单项已被禁用,并显示成灰色.">
    常量 启用菜单项 <公开 类型 = 整数 值 = @MFS_ENABLED 注释 = "启用菜单项,以便可以选择它,这是默认状态.">
    常量 灰色菜单项 <公开 类型 = 整数 值 = @MFS_GRAYED 注释 = "菜单项已被禁用,并显示成灰色.">
    常量 高亮菜单项 <公开 类型 = 整数 值 = @MFS_HILITE 注释 = "突出显示菜单项">
    常量 取消选中菜单项 <公开 类型 = 整数 值 = @MFS_UNCHECKED 注释 = "取消选中复选框">
    常量 未高亮菜单项 <公开 类型 = 整数 值 = @MFS_UNHILITE 注释 = "菜单项未突出显示,这是默认状态.">
}

类 菜单项信息类 <公开 基础类 = PIV结构模板 注释 = "MENUITEMINFOW结构体" 折叠 @文档 = "category = \"系统操作.辅助类\""
        @别名 = "MENUITEMINFOW" @模板实现类 = "菜单项信息类">
{
    变量 结构尺寸 <公开 类型 = 整数 注释 = "cbSize 必须结构尺寸" @输出名 = "cbSize">
    变量 掩码 <公开 类型 = 整数 注释 = "fMask 指定获取或设置的成员,请参考常量\"\"" @输出名 = "fMask">
    变量 菜单项类型 <公开 类型 = 整数 注释 = "fType" @输出名 = "fType">
    变量 菜单项状态 <公开 类型 = 整数 注释 = "fState 请参考常量\"菜单项状态\"" @输出名 = "fState">
    变量 ID <公开 类型 = 整数 注释 = "将fMask设置为MIIM_ID以使用" @输出名 = "wID">
    变量 菜单项数据 <公开 类型 = 变整数 注释 = "将fMask设置为MIIM_DATA以使用" @输出名 = "dwItemData">
    变量 菜单项文本长度 <公开 类型 = 整数 注释 = "cch" @输出名 = "cch">

    方法 子菜单句柄 <公开 静态 属性读 类型 = 变整数 注释 = "hSubMenu" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 菜单项信息类>
    {
        @ (INT_P)@<欲操作本对象>.hSubMenu
    }

    方法 子菜单句柄 <公开 静态 属性写 注释 = "hSubMenu" 折叠>
    参数 欲操作本对象 <类型 = 菜单项信息类>
    参数 值 <类型 = 变整数>
    {
        @ @<欲操作本对象>.hSubMenu = (HMENU)@<值>;
    }

    方法 选中复选框位图 <公开 静态 属性读 类型 = 变整数 注释 = "hbmpChecked" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 菜单项信息类>
    {
        @ (INT_P)@<欲操作本对象>.hbmpChecked
    }

    方法 选中复选框位图 <公开 静态 属性写 注释 = "hbmpChecked" 折叠>
    参数 欲操作本对象 <类型 = 菜单项信息类>
    参数 值 <类型 = 变整数>
    {
        @ @<欲操作本对象>.hbmpChecked = (HBITMAP)@<值>;
    }

    方法 取消复选框位图 <公开 静态 属性读 类型 = 变整数 注释 = "hbmpUnchecked" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 菜单项信息类>
    {
        @ (INT_P)@<欲操作本对象>.hbmpUnchecked
    }

    方法 取消复选框位图 <公开 静态 属性写 注释 = "hbmpUnchecked" 折叠>
    参数 欲操作本对象 <类型 = 菜单项信息类>
    参数 值 <类型 = 变整数>
    {
        @ @<欲操作本对象>.hbmpUnchecked = (HBITMAP)@<值>;
    }

    方法 菜单项内容 <公开 静态 属性读 类型 = 变整数 注释 = "dwTypeData 内容取决于\"菜单项类型\"的值" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 菜单项信息类>
    {
        @ (INT_P)@<欲操作本对象>.dwTypeData
    }

    方法 菜单项内容 <公开 静态 属性写 注释 = "dwTypeData 内容取决于\"菜单项类型\"的值" 折叠>
    参数 欲操作本对象 <类型 = 菜单项信息类>
    参数 值 <类型 = 变整数>
    {
        @ @<欲操作本对象>.dwTypeData = (LPWSTR)@<值>;
    }

    方法 菜单项位图 <公开 静态 属性读 类型 = 变整数 注释 = "hbmpItem" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 菜单项信息类>
    {
        @ (INT_P)@<欲操作本对象>.hbmpItem
    }

    方法 菜单项位图 <公开 静态 属性写 注释 = "hbmpItem" 折叠>
    参数 欲操作本对象 <类型 = 菜单项信息类>
    参数 值 <类型 = 变整数>
    {
        @ @<欲操作本对象>.hbmpItem = (HBITMAP)@<值>;
    }

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = 菜单项信息类>
    {
        变量 展示内容 <类型 = 文本型>
        变量 格式文本 <类型 = 文本型
                值 = "<MENUITEMINFOW> 总共 12 个成员:\r\n1. 结构尺寸(cbSize): %u\r\n2. 掩码(fMask): %u\r\n3. 菜单项类型(fType): %u\r\n4. 菜单项状态(fState): %u\r\n5. ID(wID): %u\r\n6. 子菜单句柄(hSubMenu): %I64u\r\n7. 选中复选框位图(hbmpChecked): %I64u\r\n8. 取消复选框位图(hbmpUnchecked): %I64u\r\n9. 菜单项数据(dwItemData): %I64u\r\n10. 菜单项内容(dwTypeData): %I64u\r\n11. 菜单项文本长度(cch): %u\r\n12. 菜单项位图(hbmpItem): %I64u">
        加入格式文本 (展示内容, 格式文本, 欲操作本对象.结构尺寸, 欲操作本对象.掩码, 欲操作本对象.菜单项类型, 欲操作本对象.菜单项状态, 欲操作本对象.ID, 欲操作本对象.子菜单句柄, 欲操作本对象.选中复选框位图, 欲操作本对象.取消复选框位图, 欲操作本对象.菜单项数据, 欲操作本对象.菜单项内容, 欲操作本对象.菜单项文本长度, 欲操作本对象.菜单项位图)
        返回 (展示内容)
    }

    # @begin
    # <> <global>
    # <> <include>
    # static void PivDumpStr(CVolString &strDebug, INT nMaxDumpSize, MENUITEMINFOW* value)
    # {
    #     if (value != nullptr)
    #         strDebug.AddFormatText(L"<MENUITEMINFOW> 总共 12 个成员:\r\n1. 结构尺寸(cbSize): %u\r\n2. 掩码(fMask): %u\r\n3. 菜单项类型(fType): %u\r\n4. 菜单项状态(fState): %u\r\n5. ID(wID): %u\r\n"
    #                                L"6. 子菜单句柄(hSubMenu): %I64u\r\n7. 选中复选框位图(hbmpChecked): %I64u\r\n8. 取消复选框位图(hbmpUnchecked): %I64u\r\n9. 菜单项数据(dwItemData): %I64u\r\n"
    #                                L"10. 菜单项内容(dwTypeData): %I64u\r\n11. 菜单项文本长度(cch): %u\r\n12. 菜单项位图(hbmpItem): %I64u",
    #                                value->cbSize, value->fMask, value->fType, value->fState, value->wID, value->hSubMenu,
    #                                value->hbmpChecked, value->hbmpUnchecked, value->dwItemData, value->dwTypeData, value->cch, value->hbmpItem);
    #     else
    #         strDebug.SetText(L"MENUITEMINFOW: nullptr");
    # }
    # <> </include>
    # <> </global>
    # @end
}

# 键鼠标模拟 API版 ===

类 键鼠输入 <公开 折叠 @文档 = "category = \"系统操作.发送输入\"">
{
    方法 发送输入 <公开 静态 类型 = 整数 返回值注释 = "成功返回插入的输入事件数,0为表示输入被另一个线程阻止了." @禁止流程检查 = 真>
    参数 输入数组 <类型 = 输入结构数组类>
    {
        @ return (INT)::SendInput((UINT)@<输入数组>.size(), (LPINPUT)@<输入数组>.data(), sizeof(INPUT));
    }
}

类 鼠标输入结构 <公开 基础类 = PIV结构模板 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"" @别名 = "MOUSEINPUT" @模板实现类 = "鼠标输入结构">
{
    变量 dx <公开 类型 = 整数 注释 = "鼠标x坐标" @输出名 = "dx">
    变量 dy <公开 类型 = 整数 注释 = "鼠标y坐标" @输出名 = "dy">
    变量 mouseData <公开 类型 = 整数 注释 = "按dwFlags的备注填写" @输出名 = "mouseData">
    变量 dwFlags <公开 类型 = 整数 注释 = "可使用\"鼠标事件常量类\"的位或组合值." @输出名 = "dwFlags">
    变量 time <公开 类型 = 整数 注释 = "事件的时间戳,以毫秒为单位.如果此参数为0,系统将提供自己的时间戳." @输出名 = "time">
    变量 dwExtraInfo <公开 类型 = 变整数 注释 = "与鼠标事件关联的附加值.应用程序调用GetMessageExtraInfo可获取此额外信息." @输出名 = "dwExtraInfo">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = 鼠标输入结构>
    {
        变量 格式文本 <类型 = 文本型
                值 = "<MOUSEINPUT> 总共 6 个成员:\r\n1. dx: %d\r\n2. dy: %d\r\n3. mouseData: %u\r\n4. dwFlags: %u\r\n5. time: %u\r\n6. dwExtraInfo: %I64u">
        返回 (取格式文本 (格式文本, 欲操作本对象.dx, 欲操作本对象.dy, 欲操作本对象.mouseData, 欲操作本对象.dwFlags, 欲操作本对象.time, 欲操作本对象.dwExtraInfo))
    }

    # @begin
    # <> <global>
    # <> <include>
    # static void PivDumpStr(CVolString &strDebug, INT nMaxDumpSize, MOUSEINPUT* value)
    # {
    #     if (value != nullptr)
    #         strDebug.AddFormatText(L"<MOUSEINPUT> 总共 6 个成员:\r\n1. dx: %d\r\n2. dy: %d\r\n3. mouseData: %u\r\n4. dwFlags: %u\r\n5. time: %u\r\n6. dwExtraInfo: %I64u",
    #                                value->dx, value->dy, value->mouseData, value->dwFlags, value->time, value->dwExtraInfo);
    #     else
    #         strDebug.SetText(L"MOUSEINPUT: nullptr");
    # }
    # <> </include>
    # <> </global>
    # @end
}

类 键盘输入结构 <公开 基础类 = PIV结构模板 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"" @别名 = "KEYBDINPUT" @模板实现类 = "键盘输入结构">
{
    变量 wVk <公开 类型 = 短整数 注释 = "虚拟按键代码,范围为1-254." 注释 = "如果dwFlags为KEYEVENTF_UNICODE,本成员必须为0." @输出名 = "wVk">
    变量 wScan <公开 类型 = 短整数 注释 = "按键的硬件扫描代码." 注释 = "如果dwFlags为KEYEVENTF_UNICODE,则本在成员指定发送到前台应用的UNICODE字符."
            @输出名 = "wScan">
    变量 dwFlags <公开 类型 = 整数 注释 = "为以下整数的位或组合值." 注释 = "1=KEYEVENTF_EXTENDEDKEY,扫描代码前面会有一个值为0xE0(224)的前缀字节."
            注释 = "2=KEYEVENTF_KEYUP,指定本值为释放按键,未指定本值为按下按键." 注释 = "8=KEYEVENTF_SCANCODE,指定本值后将忽略wVk,使用wScan识别按键."
            注释 = "4=KEYEVENTF_UNICODE,系统将合成VK_PACKET按键,wVk的值必须为0,本值只能与KEYEVENTF_KEYUP组合使用." @输出名 = "dwFlags">
    变量 time <公开 类型 = 整数 注释 = "事件的时间戳,以毫秒为单位.如果此参数为0,系统将提供自己的时间戳." @输出名 = "time">
    变量 dwExtraInfo <公开 类型 = 变整数 注释 = "与鼠标事件关联的附加值.应用程序调用GetMessageExtraInfo可获取此额外信息." @输出名 = "dwExtraInfo">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = 键盘输入结构>
    {
        变量 格式文本 <类型 = 文本型
                值 = "<KEYBDINPUT> 总共 5 个成员:\r\n1. wVk: %u\r\n2. wScan: %u\r\n3. dwFlags: %u\r\n4. time: %u\r\n5. dwExtraInfo: %I64u">
        返回 (取格式文本 (格式文本, 欲操作本对象.wVk, 欲操作本对象.wScan, 欲操作本对象.dwFlags, 欲操作本对象.time, 欲操作本对象.dwExtraInfo))
    }

    # @begin
    # <> <global>
    # <> <include>
    # static void PivDumpStr(CVolString &strDebug, INT nMaxDumpSize, KEYBDINPUT* value)
    # {
    #     if (value != nullptr)
    #         strDebug.AddFormatText(L"<KEYBDINPUT> 总共 5 个成员:\r\n1. wVk: %u\r\n2. wScan: %u\r\n3. dwFlags: %u\r\n4. time: %u\r\n5. dwExtraInfo: %I64u",
    #                                value->wVk, value->wScan, value->dwFlags, value->time, value->dwExtraInfo);
    #     else
    #         strDebug.SetText(L"KEYBDINPUT: nullptr");
    # }
    # <> </include>
    # <> </global>
    # @end
}

类 硬件输入结构 <公开 基础类 = PIV结构模板 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"" @别名 = "HARDWAREINPUT"
        @模板实现类 = "硬件输入结构">
{
    变量 uMsg <公开 类型 = 整数 注释 = "此消息由输入硬件生成." @输出名 = "uMsg">
    变量 wParamL <公开 类型 = 短整数 注释 = "uMsg的LPRAM参数的低位值." @输出名 = "wParamL">
    变量 wParamH <公开 类型 = 短整数 注释 = "uMsg的LPRAM参数的高位值." @输出名 = "wParamH">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = 硬件输入结构>
    {
        变量 格式文本 <类型 = 文本型 值 = "<HARDWAREINPUT> 总共 3 个成员:\r\n1. uMsg: %u\r\n2. wParamL: %u\r\n3. wParamH: %u">
        返回 (取格式文本 (格式文本, 欲操作本对象.uMsg, 欲操作本对象.wParamL, 欲操作本对象.wParamH))
    }

    # @begin
    # <> <global>
    # <> <include>
    # static void PivDumpStr(CVolString &strDebug, INT nMaxDumpSize, HARDWAREINPUT* value)
    # {
    #     if (value != nullptr)
    #         strDebug.AddFormatText(L"<HARDWAREINPUT> 总共 3 个成员:\r\n1. uMsg: %u\r\n2. wParamL: %u\r\n3. wParamH: %u",
    #                                value->uMsg, value->wParamL, value->wParamH);
    #     else
    #         strDebug.SetText(L"HARDWAREINPUT: nullptr");
    # }
    # <> </include>
    # <> </global>
    # @end
}

类 输入结构类 <公开 基础类 = PIV结构模板 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"" @别名 = "INPUT" @模板实现类 = "输入结构类">
{
    变量 类型 <公开 类型 = 整数 注释 = "0 INPUT_MOUSE    输入鼠标" 注释 = "1 INPUT_KEYBOARD 输入键盘"
            注释 = "2 INPUT_HARDWARE 输入硬件" @输出名 = "type">
    变量 鼠标 <公开 类型 = 鼠标输入结构 注释 = "鼠标输入" @输出名 = "mi">
    变量 键盘 <公开 类型 = 键盘输入结构 注释 = "键盘输入" @输出名 = "ki">
    变量 硬件 <公开 类型 = 硬件输入结构 注释 = "硬件输入" @输出名 = "hi">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = 输入结构类>
    {
        变量 展示内容 <类型 = 文本型>
        加入格式文本 (展示内容, "<INPUT> 总共 2 个成员:\r\n1. 类型(type): %d\r\n", 欲操作本对象.类型)
        如果 (欲操作本对象.类型 == 1)
        {
            加入文本 (展示内容, "2. ki\r\n")
            加入多行文本 (展示内容, 欲操作本对象.键盘.取展示内容 (), 2)
        }
        否则 (欲操作本对象.类型 == 2)
        {
            加入文本 (展示内容, "2. hi\r\n")
            加入多行文本 (展示内容, 欲操作本对象.硬件.取展示内容 (), 2)
        }
        否则 (欲操作本对象.类型 == 0)
        {
            加入文本 (展示内容, "2. mi\r\n")
            加入多行文本 (展示内容, 欲操作本对象.鼠标.取展示内容 (), 2)
        }
        返回 (展示内容)
    }

    # @begin
    # <> <global>
    # <> <include>
    # static void PivDumpStr(CVolString &strDebug, INT nMaxDumpSize, INPUT* value)
    # {
    #     if (value != nullptr) {
    #         strDebug.AddFormatText(L"<INPUT> 总共 2 个成员:\r\n1. 类型(type): %d\r\n", value->type);
    #         if (value->type == 0)
    #             strDebug.AddFromatText(L"2. 联合体(mi): %s", PivGetDumpStr(&value->mi));
    #         else if (value->type == 1)
    #             strDebug.AddFromatText(L"2. 联合体(ki): %s", PivGetDumpStr(&value->ki));
    #         else if (value->type == 2)
    #             strDebug.AddFromatText(L"2. 联合体(hi): %s", PivGetDumpStr(&value->hi));
    #     } else
    #         strDebug.SetText(L"INPUT: nullptr");
    # }
    # <> </include>
    # <> </global>
    # @end
}

类 输入结构数组类 <公开 基础类 = PIV数组模板 @文档 = "category = \"系统操作.发送输入.辅助类\"" @模板实现类 = "输入结构类">

类 鼠标事件常量类 <公开 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"">
{
    常量 鼠标移动 <公开 类型 = 整数 值 = @MOUSEEVENTF_MOVE>
    常量 按下左键 <公开 类型 = 整数 值 = @MOUSEEVENTF_LEFTDOWN>
    常量 释放左键 <公开 类型 = 整数 值 = @MOUSEEVENTF_LEFTUP>
    常量 按下右键 <公开 类型 = 整数 值 = @MOUSEEVENTF_RIGHTDOWN>
    常量 释放右键 <公开 类型 = 整数 值 = @MOUSEEVENTF_RIGHTUP>
    常量 按下中键 <公开 类型 = 整数 值 = @MOUSEEVENTF_MIDDLEDOWN>
    常量 释放中键 <公开 类型 = 整数 值 = @MOUSEEVENTF_MIDDLEUP>
    常量 按下X键 <公开 类型 = 整数 值 = @MOUSEEVENTF_XDOWN 注释 = "mouseData的值1为按下第一个X键,2为按下第二个X键">
    常量 释放X键 <公开 类型 = 整数 值 = @MOUSEEVENTF_XUP 注释 = "mouseData的值1为释放第一个X键,2为释放第二个X键">
    常量 鼠标滚轮 <公开 类型 = 整数 值 = @MOUSEEVENTF_WHEEL 注释 = "mouseData的值为滚轮的垂直移动量">
    常量 水平滚轮 <公开 类型 = 整数 值 = 0x1000 注释 = "mouseData的值为滚轮的水平移动量">
    常量 不合并消息 <公开 类型 = 整数 值 = 0x2000 注释 = "WM_MOUSEMOVE消息将不会合并,默认是合并WM_MOUSEMOVE消息.">
    常量 虚拟桌面 <公开 类型 = 整数 值 = @MOUSEEVENTF_VIRTUALDESK 注释 = "将坐标映射到整个桌面,必须与\"绝对坐标\"配合使用。">
    常量 绝对坐标 <公开 类型 = 整数 值 = @MOUSEEVENTF_ABSOLUTE 注释 = "dx和dy使用绝对坐标值,否则为相对坐标.">
}

#
