<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "源码: https://github.com/nlohmann/json" 注释 = "版本: 3.11.2" 注释 = "封装: Xelloss"
        注释 = "  1. 火山的第四个nlohmann JSON封装,集成了几个JSON模块的一些封装技巧," 注释 = "在此感谢Kyozy、到底是为了什么、350246356的开源."
        注释 = "  2. 本JSON库备注有异常的方法,除非能避免抛出异常,否则都要做异常管理," 注释 = "或者先判断操作的有效性,否则会导致程序异常退出!!!"
        注释 = "  3. 备注的异常类型前面加了*号的,表示该异常可以通过参数设置不抛出.">

类 PivJSON模板类 <公开 注释 = "包含JSON所有操作的模板类,本类不能直接使用,请使用\"PivJSON\"和\"无序PivJSON\"."
        注释 = "方法备注中带*号的异常可以通过参数避免." 折叠 @文档 = "category = \"JSON支持.PivJSON\"" @视窗.外部头文件 = "src\\piv_json.h"
        @模板基础类 = 真 @别名类型 = 本地类>
{
    方法 启用编码加速 <公开 静态 注释 = "使用simdutf加速Unicode编码转换,否则使用Windows API转换编码."
            注释 = "  1. 如果你的其他代码调用了simdutf,也会对本库产生加速效果;" 注释 = "  2. 如果你同时使用了\"火山模块\"等同样包括了simdutf功能的模块,"
            注释 = "请注意只能用其中一个模块的simdutf功能,否则会造成冲突;" @强制依赖 = "simdUTF">

    # JSON 反序列化
    # ====

    方法 是否可解析 <公开 静态 类型 = 逻辑型 注释 = "检查提供的JSON文本、JSON文件是否为有效的JSON值." 注释 = "注意: 本方法需要用类名调用."
            返回值注释 = "返回真表示提供的数据可以解析为JSON值." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 JSON数据 <注释 = "可以提供JSON文本数据或JSON文件的路径,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类W、标准文本类U、文本视图类U、字节集类" @匹配类型 = 通用型>
    参数 忽略注释 <类型 = 逻辑型 注释 = "是否忽略注释并将其当作空格处理" @默认值 = 假>
    参数 字节集编码 <类型 = 整数 注释 = "JSON数据的类型为字节集类时生效,用于指定字节集数据的编码类型;" 注释 = "若同时启用了simdutf,会忽略本参数,改为自动检测编码;"
            @默认值 = SIMD编码类型.UTF8>
    {
        @ piv::json::Accept<@m<json>>(@<JSON数据>, @<忽略注释>, @<字节集编码>)
    }

    方法 解析 <公开 静态 类型 = 逻辑型 注释 = "解析所有支持的JSON数据或JSON文件,返回是否解析成功." 注释 = "异常: *PivJSON异常_解析错误" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 JSON数据 <注释 = "所欲解析的JSON文本数据或JSON文件的路径,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类W、标准文本类U、文本视图类U、字节集类"
            @匹配类型 = 通用型>
    参数 允许异常 <类型 = 逻辑型 注释 = "真: 解析出错时抛出异常,能不改变之前的JSON值,但不俘获异常会直接异常退出;" 注释 = "假: 解析出错时将JSON对象设置为无效值;"
            @默认值 = 假>
    参数 忽略注释 <类型 = 逻辑型 注释 = "真: 忽略注释并将其当作空格处理;" 注释 = "假: 遇到注释会抛出解析错误;" @默认值 = 真>
    参数 字节集编码 <类型 = 整数 注释 = "JSON数据的类型为字节集类时生效,用于指定字节集数据的编码类型;" 注释 = "若同时启用了simdutf,会忽略本参数,改为自动检测编码;"
            @默认值 = SIMD编码类型.UTF8>
    {
        @ piv::json::Parse(@<所欲操作本对象>, @<JSON数据>, nullptr, @<允许异常>, @<忽略注释>, @<字节集编码>)
    }

    方法 解析文本 <公开 静态 类型 = 逻辑型 注释 = "解析UTF-16LE编码的JSON文本型,返回是否解析成功." 注释 = "异常: *PivJSON异常_解析错误"
            注释 = "本方法可以用\"解析\"替代,仅保留以作兼容." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 JSON文本 <类型 = 文本型 注释 = "所欲解析的JSON文本">
    参数 允许异常 <类型 = 逻辑型 注释 = "真: 解析出错时抛出异常,能不改变之前的JSON值,但不俘获异常会直接异常退出;" 注释 = "假: 解析出错时将JSON对象设置为无效值;"
            @默认值 = 假>
    参数 忽略注释 <类型 = 逻辑型 注释 = "真: 忽略注释并将其当作空格处理;" 注释 = "假: 遇到注释会抛出解析错误;" @默认值 = 真>
    {
        @ piv::json::Parse(@<所欲操作本对象>, @<JSON文本>, nullptr, @<允许异常>, @<忽略注释>, 4)
    }

    方法 解析UTF8 <公开 静态 类型 = 逻辑型 注释 = "解析UTF-8编码的JSON文本,返回是否解析成功." 注释 = "异常: *PivJSON异常_解析错误"
            注释 = "本方法可以用\"解析\"替代,仅保留以作兼容." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 JSON数据 <类型 = 字节集类 注释 = "所欲解析的UTF-8编码JSON文本">
    参数 允许异常 <类型 = 逻辑型 注释 = "真: 解析出错时抛出异常,能不改变之前的JSON值,但不俘获异常会直接异常退出;" 注释 = "假: 解析出错时将JSON对象设置为无效值;"
            @默认值 = 假>
    参数 忽略注释 <类型 = 逻辑型 注释 = "真: 忽略注释并将其当作空格处理;" 注释 = "假: 遇到注释会抛出解析错误;" @默认值 = 真>
    {
        @ piv::json::Parse(@<所欲操作本对象>, @<JSON数据>, nullptr, @<允许异常>, @<忽略注释>, 1)
    }

    方法 解析文件 <公开 静态 类型 = 逻辑型 注释 = "解析指定路径的UTF-8编码JSON文件,返回是否解析成功." 注释 = "异常: *PivJSON异常_解析错误"
            注释 = "本方法可以用\"解析\"替代,仅保留以作兼容." 折叠 @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 JSON文件 <类型 = 文本型 注释 = "JSON文件的路径,文件的编码必须为UTF-8.">
    参数 允许异常 <类型 = 逻辑型 注释 = "真: 解析出错时抛出异常,能不改变之前的JSON值,但不俘获异常会直接异常退出;" 注释 = "假: 解析出错时将JSON对象设置为无效值;"
            @默认值 = 假>
    参数 忽略注释 <类型 = 逻辑型 注释 = "真: 忽略注释并将其当作空格处理;" 注释 = "假: 遇到注释会抛出解析错误;" @默认值 = 真>
    {
        @ piv::json::ParseFile(@<所欲操作本对象>, @<JSON文件>, nullptr, @<允许异常>, @<忽略注释>)
    }

    方法 解析BJData <公开 静态 类型 = 逻辑型 注释 = "使用BJData(二进制JSON数据)序列化格式,将提供的字节集数据反序列化为JSON值."
            注释 = "异常: *PivJSON异常_解析错误" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 BJData数据 <类型 = 字节集类 注释 = "请提供由\"到BJData\"生成的二进制数据">
    参数 严格 <类型 = 逻辑型 注释 = "是否期望在EOF之前使用输入的二进制数据" @默认值 = 真>
    参数 允许异常 <类型 = 逻辑型 注释 = "真: 解析出错时抛出异常,能不改变之前的JSON值,但不俘获异常会直接异常退出;" 注释 = "假: 解析出错时将JSON对象设置为无效值;"
            @默认值 = 假>
    {
        @ piv::json::From_bjdata(@<所欲操作本对象>, @<BJData数据>, @<严格>, @<允许异常>)
    }

    方法 解析BSON <公开 静态 类型 = 逻辑型 注释 = "使用BSON(二进制JSON)序列化格式,将提供的字节集数据反序列化为JSON值." 注释 = "异常: *PivJSON异常_解析错误"
            折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 BSON数据 <类型 = 字节集类 注释 = "请提供由\"到BSON\"生成的二进制数据">
    参数 严格 <类型 = 逻辑型 注释 = "是否期望在EOF之前使用输入的二进制数据" @默认值 = 真>
    参数 允许异常 <类型 = 逻辑型 注释 = "真: 解析出错时抛出异常,能不改变之前的JSON值,但不俘获异常会直接异常退出;" 注释 = "假: 解析出错时将JSON对象设置为无效值;"
            @默认值 = 假>
    {
        @ piv::json::From_bson(@<所欲操作本对象>, @<BSON数据>, @<严格>, @<允许异常>)
    }

    方法 解析CBOR <公开 静态 类型 = 逻辑型 注释 = "使用CBOR(简明二进制对象展现)序列化格式,将提供的字节集数据反序列化为JSON值." 注释 = "异常: *PivJSON异常_解析错误"
            折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 CBOR数据 <类型 = 字节集类 注释 = "请提供由\"到CBOR\"生成的二进制数据">
    参数 严格 <类型 = 逻辑型 注释 = "是否期望在EOF之前使用输入的二进制数据" @默认值 = 真>
    参数 允许异常 <类型 = 逻辑型 注释 = "真: 解析出错时抛出异常,能不改变之前的JSON值,但不俘获异常会直接异常退出;" 注释 = "假: 解析出错时将JSON对象设置为无效值;"
            @默认值 = 假>
    参数 标签处理 <类型 = CBOR标签处理方式 注释 = "指定序列化时遇到CBOR标签时的处理方式,默认\"报错\"遇到标签会抛出解析错误异常." @默认值 = CBOR标签处理方式.报错>
    {
        @ piv::json::From_cbor(@<所欲操作本对象>, @<CBOR数据>, @<严格>, @<允许异常>, @<标签处理>)
    }

    方法 解析MsgPack <公开 静态 类型 = 逻辑型 注释 = "使用MessagePack序列化格式,将提供的字节集数据反序列化为JSON值." 注释 = "异常: *PivJSON异常_解析错误"
            折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 MsgPack数据 <类型 = 字节集类 注释 = "请提供由\"到MsgPack\"生成的二进制数据">
    参数 严格 <类型 = 逻辑型 注释 = "是否期望在EOF之前使用输入的二进制数据" @默认值 = 真>
    参数 允许异常 <类型 = 逻辑型 注释 = "真: 解析出错时抛出异常,能不改变之前的JSON值,但不俘获异常会直接异常退出;" 注释 = "假: 解析出错时将JSON对象设置为无效值;"
            @默认值 = 假>
    {
        @ piv::json::From_msgpack(@<所欲操作本对象>, @<MsgPack数据>, @<严格>, @<允许异常>)
    }

    方法 解析UBJSON <公开 静态 类型 = 逻辑型 注释 = "使用UBJSON(通用二进制JSON)序列化格式,将提供的字节集数据反序列化为JSON值."
            注释 = "异常: *PivJSON异常_解析错误" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 UBJSON数据 <类型 = 字节集类 注释 = "请提供由\"到UBJSON\"生成的二进制数据">
    参数 严格 <类型 = 逻辑型 注释 = "是否期望在EOF之前使用输入的二进制数据" @默认值 = 真>
    参数 允许异常 <类型 = 逻辑型 注释 = "真: 解析出错时抛出异常,能不改变之前的JSON值,但不俘获异常会直接异常退出;" 注释 = "假: 解析出错时将JSON对象设置为无效值;"
            @默认值 = 假>
    {
        @ piv::json::From_ubjson(@<所欲操作本对象>, @<UBJSON数据>, @<严格>, @<允许异常>)
    }

    # JSON 序列化
    # ====

    方法 到可读文本 <公开 静态 类型 = 文本型 注释 = "将JSON值序列化并转换到UTF-16LE编码,返回转换后的文本型." 注释 = "异常: *PivJSON异常_类型错误" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 缩进 <类型 = 整数 注释 = "如果缩进非负数,则数组元素和对象成员将使用该缩进级别进行打印;" 注释 = "缩进级别为0时只会插入换行符; 默认-1为最紧凑的表示;" @默认值 = -1>
    参数 缩进字符 <类型 = 字符 注释 = "当缩进大于0时用于缩进的字符,默认值为\' \'(空格);" 注释 = "只能使用ASCII字符,若填了汉字等字符会自动改为空格;" @默认值 = ' '>
    参数 确保ASCII <类型 = 逻辑型 注释 = "为真将使用\"\\uXXXX\"序列转义所有非ASCII字符" @默认值 = 假>
    参数 错误处理 <类型 = PivJSON错误处理方式 注释 = "指定遇到无效UTF-8序列时的处理方式,\"严格\"遇到错误会抛出异常," 注释 = "其余两种则可能会输出乱码."
            @默认值 = PivJSON错误处理方式.替换>
    {
        @ *PivU2Ws{piv::json::Dump(@<所欲操作本对象>, @<缩进>, @<缩进字符>, @<确保ASCII>, @<错误处理>)}
    }

    方法 到可读文本U <公开 静态 类型 = 标准文本类U 注释 = "将JSON值序列化,返回UTF-8编码的标准文本类U." 注释 = "异常: *PivJSON异常_类型错误" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 缩进 <类型 = 整数 注释 = "如果缩进非负数,则数组元素和对象成员将使用该缩进级别进行打印;" 注释 = "缩进级别为0时只会插入换行符; 默认-1为最紧凑的表示;" @默认值 = -1>
    参数 缩进字符 <类型 = 字符 注释 = "当缩进大于0时用于缩进的字符,默认值为\' \'(空格);" 注释 = "只能使用ASCII字符,若填了汉字等字符会自动改为空格;" @默认值 = ' '>
    参数 确保ASCII <类型 = 逻辑型 注释 = "为真将使用\"\\uXXXX\"序列转义所有非ASCII字符" @默认值 = 假>
    参数 错误处理 <类型 = PivJSON错误处理方式 注释 = "指定遇到无效UTF-8序列时的处理方式,\"严格\"遇到错误会抛出异常," 注释 = "其余两种则可能会输出乱码."
            @默认值 = PivJSON错误处理方式.替换>
    {
        @ piv::json::Dump(@<所欲操作本对象>, @<缩进>, @<缩进字符>, @<确保ASCII>, @<错误处理>)
    }

    方法 到UTF8 <公开 静态 类型 = 字节集类 注释 = "将JSON值序列化,返回UTF-8编码的字节集." 注释 = "异常: *PivJSON异常_类型错误" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 缩进 <类型 = 整数 注释 = "如果缩进非负数,则数组元素和对象成员将使用该缩进级别进行打印;" 注释 = "缩进级别为0时只会插入换行符; 默认-1为最紧凑的表示;" @默认值 = -1>
    参数 缩进字符 <类型 = 字符 注释 = "当缩进大于0时用于缩进的字符,默认值为\' \'(空格);" 注释 = "只能使用ASCII字符,若填了汉字等字符会自动改为空格;" @默认值 = ' '>
    参数 确保ASCII <类型 = 逻辑型 注释 = "为真将使用\"\\uXXXX\"序列转义所有非ASCII字符" @默认值 = 假>
    参数 错误处理 <类型 = PivJSON错误处理方式 注释 = "指定遇到无效UTF-8序列时的处理方式,\"严格\"遇到错误会抛出异常," 注释 = "其余两种则可能会输出乱码."
            @默认值 = PivJSON错误处理方式.替换>
    {
        @ piv::json::DumpTo<@an<CVolMem>>(@<所欲操作本对象>, @<缩进>, @<缩进字符>, @<确保ASCII>, @<错误处理>)
    }

    方法 到多字节 <公开 静态 类型 = 字节集类 注释 = "将JSON值序列化并转换到本地ANSI多字节编码,返回转换后的字节集." 注释 = "异常: *PivJSON异常_类型错误" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 缩进 <类型 = 整数 注释 = "如果缩进非负数,则数组元素和对象成员将使用该缩进级别进行打印;" 注释 = "缩进级别为0时只会插入换行符; 默认-1为最紧凑的表示;" @默认值 = -1>
    参数 缩进字符 <类型 = 字符 注释 = "当缩进大于0时用于缩进的字符,默认值为\' \'(空格);" 注释 = "只能使用ASCII字符,若填了汉字等字符会自动改为空格;" @默认值 = ' '>
    参数 确保ASCII <类型 = 逻辑型 注释 = "为真将使用\"\\uXXXX\"序列转义所有非ASCII字符" @默认值 = 假>
    参数 错误处理 <类型 = PivJSON错误处理方式 注释 = "指定遇到无效UTF-8序列时的处理方式,\"严格\"遇到错误会抛出异常," 注释 = "其余两种则可能会输出乱码."
            @默认值 = PivJSON错误处理方式.替换>
    {
        @ PivU2A{piv::json::Dump(@<所欲操作本对象>, @<缩进>, @<缩进字符>, @<确保ASCII>, @<错误处理>)}.to_volmem(CVolMem(), false)
    }

    方法 到BJData <公开 静态 类型 = 字节集类 注释 = "使用BJData序列化格式,将本对象的JSON值序列化为字节集数据."
            注释 = "注: BJData(二进制JSON数据)比JSON更紧凑,解析效率更高." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    参数 使用大小注解 <类型 = 逻辑型 注释 = "是否将大小注解添加到容器类型" @默认值 = 假>
    参数 使用类型注解 <类型 = 逻辑型 注释 = "是否将类型注解添加到容器类型" @默认值 = 假>
    {
        @ piv::json::To_bjdata(@<所欲操作本对象>, @<使用大小注解>, @<使用类型注解>)
    }

    方法 到BSON <公开 静态 类型 = 字节集类 注释 = "使用BSON序列化格式,将本对象的JSON值序列化为字节集数据."
            注释 = "注: BSON(二进制JSON)是一种二进制格式,其中零个或多个有序键/值对存储为单个实体." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    {
        @ piv::json::To_bson(@<所欲操作本对象>)
    }

    方法 到CBOR <公开 静态 类型 = 字节集类 注释 = "使用CBOR序列化格式,将本对象的JSON值序列化为字节集数据."
            注释 = "注: CBOR(简明二进制对象展现)是一种二进制序列化格式,比JSON更紧凑,解析效率更高." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    {
        @ piv::json::To_cbor(@<所欲操作本对象>)
    }

    方法 到MsgPack <公开 静态 类型 = 字节集类 注释 = "使用MessagePack序列化格式,将本对象的JSON值序列化为字节集数据."
            注释 = "注: MessagePack是一种二进制序列化格式,比JSON更紧凑,解析效率更高." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    {
        @ piv::json::To_msgpack(@<所欲操作本对象>)
    }

    方法 到UBJSON <公开 静态 类型 = 字节集类 注释 = "使用UBJSON序列化格式,将本对象的JSON值序列化为字节集数据."
            注释 = "注: UBJSON(通用二进制JSON)比JSON更紧凑,解析效率更高." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    参数 使用大小注解 <类型 = 逻辑型 注释 = "是否将大小注解添加到容器类型" @默认值 = 假>
    参数 使用类型注解 <类型 = 逻辑型 注释 = "是否将类型注解添加到容器类型" @默认值 = 假>
    {
        @ piv::json::To_ubjson(@<所欲操作本对象>, @<使用大小注解>, @<使用类型注解>)
    }

    # 置入成员值(不会抛出异常)
    # ====

    方法 置入成员 <公开 静态 类型 = 逻辑型 注释 = "将通用型值置入到通过键名、索引或路径指定的JSON成员中." 注释 = "注: 可以替代所有的\"置入XX值\"方法."
            返回值注释 = "返回是否置入成功" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 成员位置 <注释 = "所欲置入值的成员位置,支持\"整数值\"的数组索引和\"文本值\"的对象键名和路径;" 注释 = "其中路径必须以\'/\'开头,如: \"/users/0/name\";"
            注释 = "键名和路径支持以下类型(带*号表示会转换编码):" 注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 值 <注释 = "所欲置入的成员值,支持以下类型:" 注释 = " 通用数值型、JSON对象、JSON数组"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 强制置入 <类型 = 逻辑型 注释 = "1. 成员位置为\"键名/索引\"时,如果当前JSON值不是\"对象/数组\"," 注释 = "是否将JSON值重置为\"空对象/空数组\",再置入新值;"
            注释 = "2. 成员位置为\"路径\"时,本参数无意义;" @默认值 = 假>
    {
        @ piv::json::EmplaceAt(@<所欲操作本对象>, @<成员位置>, @<值>, @<强制置入>)
    }

    方法 置入文本值 <公开 静态 类型 = 逻辑型 注释 = "将文本值置入到通过键名、索引或路径指定的JSON成员中." 返回值注释 = "返回是否置入成功" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 成员位置 <注释 = "所欲置入值的成员位置,支持\"整数值\"的数组索引和\"文本值\"的对象键名和路径;" 注释 = "其中路径必须以\'/\'开头,如: \"/users/0/name\";"
            注释 = "键名和路径支持以下类型(带*号表示会转换编码):" 注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 值 <注释 = "所欲置入的文本值,支持以下类型:" 注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 强制置入 <类型 = 逻辑型 注释 = "1. 成员位置为\"键名/索引\"时,如果当前JSON值不是\"对象/数组\"," 注释 = "是否将JSON值重置为\"空对象/空数组\",再置入新值;"
            注释 = "2. 成员位置为\"路径\"时,本参数无意义;" @默认值 = 假>
    {
        @ piv::json::EmplaceAt(@<所欲操作本对象>, @<成员位置>, @<值>, @<强制置入>)
    }

    方法 置入整数值 <公开 静态 类型 = 逻辑型 注释 = "将整数值置入到通过键名、索引或路径指定的JSON成员中." 返回值注释 = "返回是否置入成功" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 成员位置 <注释 = "所欲置入值的成员位置,支持\"整数值\"的数组索引和\"文本值\"的对象键名和路径;" 注释 = "其中路径必须以\'/\'开头,如: \"/users/0/name\";"
            注释 = "键名和路径支持以下类型(带*号表示会转换编码):" 注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 值 <类型 = 整数 注释 = "所欲置入的整数值">
    参数 强制置入 <类型 = 逻辑型 注释 = "1. 成员位置为\"键名/索引\"时,如果当前JSON值不是\"对象/数组\"," 注释 = "是否将JSON值重置为\"空对象/空数组\",再置入新值;"
            注释 = "2. 成员位置为\"路径\"时,本参数无意义;" @默认值 = 假>
    {
        @ piv::json::EmplaceAt(@<所欲操作本对象>, @<成员位置>, @<值>, @<强制置入>)
    }

    方法 置入长整数值 <公开 静态 类型 = 逻辑型 注释 = "将长整数值置入到通过键名、索引或路径指定的JSON成员中." 返回值注释 = "返回是否置入成功" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 成员位置 <注释 = "所欲置入值的成员位置,支持\"整数值\"的数组索引和\"文本值\"的对象键名和路径;" 注释 = "其中路径必须以\'/\'开头,如: \"/users/0/name\";"
            注释 = "键名和路径支持以下类型(带*号表示会转换编码):" 注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 值 <类型 = 长整数 注释 = "所欲置入的长整数值">
    参数 强制置入 <类型 = 逻辑型 注释 = "1. 成员位置为\"键名/索引\"时,如果当前JSON值不是\"对象/数组\"," 注释 = "是否将JSON值重置为\"空对象/空数组\",再置入新值;"
            注释 = "2. 成员位置为\"路径\"时,本参数无意义;" @默认值 = 假>
    {
        @ piv::json::EmplaceAt(@<所欲操作本对象>, @<成员位置>, @<值>, @<强制置入>)
    }

    方法 置入小数值 <公开 静态 类型 = 逻辑型 注释 = "将小数值置入到通过键名、索引或路径指定的JSON成员中." 返回值注释 = "返回是否置入成功" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 成员位置 <注释 = "所欲置入值的成员位置,支持\"整数值\"的数组索引和\"文本值\"的对象键名和路径;" 注释 = "其中路径必须以\'/\'开头,如: \"/users/0/name\";"
            注释 = "键名和路径支持以下类型(带*号表示会转换编码):" 注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 值 <类型 = 小数 注释 = "所欲置入的小数值">
    参数 强制置入 <类型 = 逻辑型 注释 = "1. 成员位置为\"键名/索引\"时,如果当前JSON值不是\"对象/数组\"," 注释 = "是否将JSON值重置为\"空对象/空数组\",再置入新值;"
            注释 = "2. 成员位置为\"路径\"时,本参数无意义;" @默认值 = 假>
    {
        @ piv::json::EmplaceAt(@<所欲操作本对象>, @<成员位置>, @<值>, @<强制置入>)
    }

    方法 置入逻辑值 <公开 静态 类型 = 逻辑型 注释 = "将逻辑值置入到通过键名、索引或路径指定的JSON成员中." 返回值注释 = "返回是否置入成功" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 成员位置 <注释 = "所欲置入值的成员位置,支持\"整数值\"的数组索引和\"文本值\"的对象键名和路径;" 注释 = "其中路径必须以\'/\'开头,如: \"/users/0/name\";"
            注释 = "键名和路径支持以下类型(带*号表示会转换编码):" 注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 值 <类型 = 逻辑型 注释 = "所欲置入的逻辑值">
    参数 强制置入 <类型 = 逻辑型 注释 = "1. 成员位置为\"键名/索引\"时,如果当前JSON值不是\"对象/数组\"," 注释 = "是否将JSON值重置为\"空对象/空数组\",再置入新值;"
            注释 = "2. 成员位置为\"路径\"时,本参数无意义;" @默认值 = 假>
    {
        @ piv::json::EmplaceAt(@<所欲操作本对象>, @<成员位置>, @<值>, @<强制置入>)
    }

    方法 置入对象值 <公开 静态 类型 = 逻辑型 注释 = "将JSON对象置入到通过键名、索引或路径指定的JSON成员中." 返回值注释 = "返回是否置入成功" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 成员位置 <注释 = "所欲置入值的成员位置,支持\"整数值\"的数组索引和\"文本值\"的对象键名和路径;" 注释 = "其中路径必须以\'/\'开头,如: \"/users/0/name\";"
            注释 = "键名和路径支持以下类型(带*号表示会转换编码):" 注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 值 <类型 = PivJSON模板类 注释 = "所欲置入的JSON对象,如果提供的值不是对象型会返回失败.">
    参数 强制置入 <类型 = 逻辑型 注释 = "1. 成员位置为\"键名/索引\"时,如果当前JSON值不是\"对象/数组\"," 注释 = "是否将JSON值重置为\"空对象/空数组\",再置入新值;"
            注释 = "2. 成员位置为\"路径\"时,本参数无意义;" @默认值 = 假>
    {
        @ piv::json::EmplaceAt(@<所欲操作本对象>, @<成员位置>, @<值>, @<强制置入>)
    }

    方法 置入数组值 <公开 静态 类型 = 逻辑型 注释 = "将JSON数组置入到通过键名、索引或路径指定的JSON成员中." 返回值注释 = "返回是否置入成功" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 成员位置 <注释 = "所欲置入值的成员位置,支持\"整数值\"的数组索引和\"文本值\"的对象键名和路径;" 注释 = "其中路径必须以\'/\'开头,如: \"/users/0/name\";"
            注释 = "键名和路径支持以下类型(带*号表示会转换编码):" 注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 值 <类型 = PivJSON模板类 注释 = "所欲置入的JSON数组,如果提供的值不是数组型会返回失败.">
    参数 强制置入 <类型 = 逻辑型 注释 = "1. 成员位置为\"键名/索引\"时,如果当前JSON值不是\"对象/数组\"," 注释 = "是否将JSON值重置为\"空对象/空数组\",再置入新值;"
            注释 = "2. 成员位置为\"路径\"时,本参数无意义;" @默认值 = 假>
    {
        @ piv::json::EmplaceAt(@<所欲操作本对象>, @<成员位置>, @<值>, @<强制置入>)
    }

    # 取成员值(不会抛出异常)
    # ====

    方法 取成员文本 <公开 静态 类型 = 文本型 注释 = "获取指定键名或索引的文本型JSON值,如果指定的成员不存在," 注释 = "或类型不是文本,则返回自定义的默认值."
            注释 = "注: 等同于\"取成员().取文本()\",但不会抛出异常." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 键名或索引 <注释 = "支持\"整数值\"的数组索引和\"文本值\"的对象键名;" 注释 = "其中键名支持以下类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 默认值 <类型 = 文本型 注释 = "如果指定的成员不存在,则返回本参数提供的默认值." @默认值 = "">
    {
        @ piv::json::ValueStr(@<所欲操作本对象>, @<键名或索引>, @<默认值>)
    }

    方法 取成员文本U <公开 静态 类型 = 标准文本类U 注释 = "获取指定键名或索引的文本型JSON值,如果指定的成员不存在," 注释 = "或类型不是文本,则返回自定义的默认值."
            注释 = "  1. 等同于\"取成员().取文本U()\",但不会抛出异常;" 注释 = "  2. 相比\"取成员文本()\",本方法不会转换文本编码;" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 键名或索引 <注释 = "支持\"整数值\"的数组索引和\"文本值\"的对象键名;" 注释 = "其中键名支持以下类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 默认值 <注释 = "如果指定的成员不存在,则返回本参数提供的默认值." 注释 = "支持类型: *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类"
            @匹配类型 = 通用型 @默认值 = "">
    {
        @ piv::json::ValueStr(@<所欲操作本对象>, @<键名或索引>, *PivAny2Us{@<默认值>})
    }

    方法 取成员文本视图 <公开 静态 类型 = 文本视图类U 注释 = "获取指定键名或索引的文本型JSON值,如果指定的成员不存在," 注释 = "或类型不是文本,则返回空视图."
            注释 = "  1. 等同于\"取成员().取文本视图()\",但不会抛出异常;" 注释 = "  2. 相比\"取成员文本()\",本方法不会转换文本编码和产生内存复制;" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 键名或索引 <注释 = "支持\"整数值\"的数组索引和\"文本值\"的对象键名;" 注释 = "其中键名支持以下类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    {
        @ @dt<文本视图类U>{piv::json::ValueStr(@<所欲操作本对象>, @<键名或索引>, "")}
    }

    方法 取成员整数 <公开 静态 类型 = 整数 注释 = "获取指定键名或索引的整数型JSON值,如果指定的成员不存在," 注释 = "或类型不是数值,则返回自定义的默认值."
            注释 = "注: 等同于\"取成员().取整数()\",但不会抛出异常." 返回值注释 = "数值型(整数、长整数、小数等)之间可以互相转换." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 键名或索引 <注释 = "支持\"整数值\"的数组索引和\"文本值\"的对象键名;" 注释 = "其中键名支持以下类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 默认值 <类型 = 整数 注释 = "如果指定的成员不存在,则返回本参数提供的默认值." @默认值 = 0>
    {
        @ piv::json::Value<int32_t>(@<所欲操作本对象>, @<键名或索引>, @<默认值>)
    }

    方法 取成员长整数 <公开 静态 类型 = 长整数 注释 = "获取指定键名或索引的长整数JSON成员值,如果指定的成员不存在," 注释 = "或类型不是数值,则返回自定义的默认值."
            注释 = "注: 等同于\"取成员().取长整数()\",但不会抛出异常." 返回值注释 = "数值型(整数、长整数、小数等)之间可以互相转换." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 键名或索引 <注释 = "支持\"整数值\"的数组索引和\"文本值\"的对象键名;" 注释 = "其中键名支持以下类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 默认值 <类型 = 长整数 注释 = "如果指定的成员不存在,则返回本参数提供的默认值." @默认值 = 0>
    {
        @ piv::json::Value<int64_t>(@<所欲操作本对象>, @<键名或索引>, @<默认值>)
    }

    方法 取成员小数 <公开 静态 类型 = 小数 注释 = "获取指定键名或索引的小数型JSON值,如果指定的成员不存在," 注释 = "或类型不是数值,则返回自定义的默认值."
            注释 = "注: 等同于\"取成员().取小数()\",但不会抛出异常." 返回值注释 = "数值型(整数、长整数、小数等)之间可以互相转换." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 键名或索引 <注释 = "支持\"整数值\"的数组索引和\"文本值\"的对象键名;" 注释 = "其中键名支持以下类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 默认值 <类型 = 小数 注释 = "如果指定的成员不存在,则返回本参数提供的默认值." @默认值 = 0.0>
    {
        @ piv::json::Value<double>(@<所欲操作本对象>, @<键名或索引>, @<默认值>)
    }

    方法 取成员逻辑值 <公开 静态 类型 = 逻辑型 注释 = "获取指定键名或索引的逻辑型JSON成员值,如果指定的成员不存在," 注释 = "或类型不是逻辑型,则返回自定义的默认值."
            注释 = "注: 等同于\"取成员/取路径().取逻辑()\",但不会抛出异常." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 键名或索引 <注释 = "支持\"整数值\"的数组索引和\"文本值\"的对象键名;" 注释 = "其中键名支持以下类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 默认值 <类型 = 逻辑型 注释 = "如果指定的成员不存在,则返回本参数提供的默认值." @默认值 = 假>
    {
        @ piv::json::Value<bool>(@<所欲操作本对象>, @<键名或索引>, @<默认值>)
    }

    方法 取成员对象 <公开 静态 类型 = PivJSON模板类 注释 = "获取指定键名或索引的JSON对象值,如果指定的成员不存在," 注释 = "或类型不是对象,将返回一个空对象."
            注释 = "注: 等同于\"取成员()\",但不会抛出异常." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 键名或索引 <注释 = "支持\"整数值\"的数组索引和\"文本值\"的对象键名;" 注释 = "其中键名支持以下类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    {
        @ piv::json::ValueObj(@<所欲操作本对象>, @<键名或索引>)
    }

    方法 取成员数组 <公开 静态 类型 = PivJSON模板类 注释 = "获取指定键名或索引的JSON数组值,如果指定的成员不存在," 注释 = "或类型不是数组,将返回一个空对象."
            注释 = "注: 等同于\"取成员()\",但不会抛出异常." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 键名或索引 <注释 = "支持\"整数值\"的数组索引和\"文本值\"的对象键名;" 注释 = "其中键名支持以下类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    {
        @ piv::json::ValueArray(@<所欲操作本对象>, @<键名或索引>)
    }

    # 取路径值(不会抛出异常)
    # ====

    方法 取路径文本 <公开 静态 类型 = 文本型 注释 = "获取指定路径的文本型JSON值,如果指定的路径不存在," 注释 = "或值类型不是文本,则返回自定义的默认值."
            注释 = "注: 等同于\"取路径().取文本()\",但不会抛出异常." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 路径 <注释 = "所欲获取的路径,必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "支持以下文本类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 默认值 <类型 = 文本型 注释 = "如果指定的路径不存在,则返回本参数提供的默认值." @默认值 = "">
    {
        @ piv::json::ValuePathStr(@<所欲操作本对象>, @<路径>, @<默认值>)
    }

    方法 取路径文本U <公开 静态 类型 = 标准文本类U 注释 = "获取指定路径的文本型JSON值,如果指定的路径不存在," 注释 = "或值类型不是数值,则返回自定义的默认值."
            注释 = "  1. 等同于\"取路径().取文本U()\",但不会抛出异常;" 注释 = "  2. 相比\"取路径文本()\",本方法不会转换文本编码;"
            返回值注释 = "数值型(整数、长整数、小数等)之间可以互相转换." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 路径 <注释 = "所欲获取的路径,必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "支持以下文本类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 默认值 <注释 = "如果指定的成员不存在,则返回本参数提供的默认值." 注释 = "支持以下文本类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @默认值 = "" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.value(piv::json::to_pointer<@m<json>>(@<路径>), *PivAny2Us{@<默认值>})
    }

    方法 取路径文本视图 <公开 静态 类型 = 文本视图类U 注释 = "获取指定路径的整数型JSON值,如果指定的路径不存在," 注释 = "或值类型不是数值,则返回自定义的默认值."
            注释 = "  1. 等同于\"取路径().取文本视图()\",但不会抛出异常;" 注释 = "  2. 相比\"取路径文本()\",本方法不会转换文本编码和产生内存复制;"
            返回值注释 = "数值型(整数、长整数、小数等)之间可以互相转换." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 路径 <注释 = "所欲获取的路径,必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "支持以下文本类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 默认值 <注释 = "如果指定的成员不存在,则返回本参数提供的默认值." 注释 = "支持以下文本类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @默认值 = "" @匹配类型 = 通用型>
    {
        @ piv::json::ValuePathView(@<所欲操作本对象>, @<路径>, *PivAny2Us{@<默认值>})
    }

    方法 取路径整数 <公开 静态 类型 = 整数 注释 = "获取指定路径的整数型JSON值,如果指定的路径不存在," 注释 = "或值类型不是数值,则返回自定义的默认值."
            注释 = "注: 等同于\"取路径().取整数()\",但不会抛出异常." 返回值注释 = "数值型(整数、长整数、小数等)之间可以互相转换." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 路径 <注释 = "所欲获取的路径,必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "支持以下文本类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 默认值 <类型 = 整数 注释 = "如果指定的路径不存在,则返回本参数提供的默认值." @默认值 = 0>
    {
        @ piv::json::ValuePath<int32_t>(@<所欲操作本对象>, @<路径>, @<默认值>)
    }

    方法 取路径长整数 <公开 静态 类型 = 长整数 注释 = "获取指定路径的长整数JSON值,如果指定的路径不存在," 注释 = "或值类型不是数值,则返回自定义的默认值."
            注释 = "注: 等同于\"取路径().取长整数()\",但不会抛出异常." 返回值注释 = "数值型(整数、长整数、小数等)之间可以互相转换." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 路径 <注释 = "所欲获取的路径,必须以\'/\'开头,如: \"/users/0/name\",支持以下类型:"
            注释 = "*文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 默认值 <类型 = 长整数 注释 = "如果指定的路径不存在,则返回本参数提供的默认值." @默认值 = 0>
    {
        @ piv::json::ValuePath<int64_t>(@<所欲操作本对象>, @<路径>, @<默认值>)
    }

    方法 取路径小数 <公开 静态 类型 = 小数 注释 = "获取指定路径的小数型JSON值,如果指定的路径不存在," 注释 = "或值类型不是数值,则返回自定义的默认值."
            注释 = "注: 等同于\"取路径().取小数()\",但不会抛出异常." 返回值注释 = "数值型(整数、长整数、小数等)之间可以互相转换." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 路径 <注释 = "所欲获取的路径,必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "支持以下文本类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 默认值 <类型 = 小数 注释 = "如果指定的路径不存在,则返回本参数提供的默认值." @默认值 = 0.0>
    {
        @ piv::json::ValuePath<double>(@<所欲操作本对象>, @<路径>, @<默认值>)
    }

    方法 取路径逻辑值 <公开 静态 类型 = 逻辑型 注释 = "获取指定路径的逻辑型JSON值,如果指定的路径不存在," 注释 = "或值类型不是逻辑型,则返回自定义的默认值."
            注释 = "注: 等同于\"取路径().取逻辑()\",但不会抛出异常." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 路径 <注释 = "所欲获取的路径,必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "支持以下文本类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 默认值 <类型 = 逻辑型 注释 = "如果指定的路径不存在,则返回本参数提供的默认值." @默认值 = 假>
    {
        @ piv::json::ValuePath<bool>(@<所欲操作本对象>, @<路径>, @<默认值>)
    }

    方法 取路径对象 <公开 静态 类型 = PivJSON模板类 注释 = "获取指定路径的JSON对象,如果指定的路径不存在或值类型不是对象,"
            注释 = "则返回一个空对象(可以用\"是否为空\"判断)." 注释 = "注: 等同于\"取路径()\",但不会抛出异常." 返回值注释 = "返回JSON对象,如果路径不存在返回空对象." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 路径 <注释 = "所欲获取的路径,必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "支持以下文本类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    {
        @ piv::json::ValuePathObj(@<所欲操作本对象>, @<路径>)
    }

    方法 取路径数组 <公开 静态 类型 = PivJSON模板类 注释 = "获取指定路径的JSON数组,如果指定的路径不存在或值类型不是数组,"
            注释 = "则返回一个空数组(可以用\"是否为空\"判断)." 注释 = "注: 等同于\"取路径()\",但不会抛出异常." 返回值注释 = "返回JSON对象,如果路径不存在返回空数组." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 路径 <注释 = "所欲获取的路径,必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "支持以下文本类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    {
        @ piv::json::ValuePathArray(@<所欲操作本对象>, @<路径>)
    }

    # 判断类型
    # ====

    方法 取类型 <公开 静态 类型 = PivJSON值类型 注释 = "获取当前JSON值的类型,请参考\"PivJSON值类型\"的常量." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ (S_BYTE)@<所欲操作本对象>.type()
    }

    方法 取类型名 <公开 静态 类型 = 文本型 注释 = "用文本返回当前JSON值的类型名称" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    {
        @ *PivU2Ws{@<所欲操作本对象>.type_name()}
    }

    方法 是否为基本型 <公开 静态 类型 = 逻辑型 注释 = "判断当前的JSON值是否为基本类型(文本、数字、逻辑值、空值或二进制)." 返回值注释 = "返回真表示类型为基本型" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.is_primitive()
    }

    方法 是否为容器 <公开 静态 类型 = 逻辑型 注释 = "判断当前的JSON值是否为结构化类型(JSON对象和JSON数组)." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.is_structured()
    }

    方法 是否为空值 <公开 静态 类型 = 逻辑型 注释 = "判断当前的JSON值是否为\"空\"值" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.is_null()
    }

    方法 是否为逻辑型 <公开 静态 类型 = 逻辑型 注释 = "判断当前的JSON值是否为\"逻辑型\"" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.is_boolean()
    }

    方法 是否为数字 <公开 静态 类型 = 逻辑型 注释 = "判断当前JSON值的值是否为\"数字\"(整数、无符号整数、小数)." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.is_number()
    }

    方法 是否为整数 <公开 静态 类型 = 逻辑型 注释 = "判断当前的JSON值是否为\"整数\"数字(字节、短整数、整数、长整数等)." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.is_number_integer()
    }

    方法 是否为无符号整数 <公开 静态 类型 = 逻辑型 注释 = "判断当前的JSON值是否为\"无符号整数\"数字" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.is_number_unsigned()
    }

    方法 是否为小数 <公开 静态 类型 = 逻辑型 注释 = "判断当前的JSON值是否为\"小数\"数字" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.is_number_float()
    }

    方法 是否为对象 <公开 静态 类型 = 逻辑型 注释 = "判断当前的JSON值是否为\"JSON对象\"" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.is_object()
    }

    方法 是否为数组 <公开 静态 类型 = 逻辑型 注释 = "判断当前的JSON值是否为\"JSON数组\"" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.is_array()
    }

    方法 是否为文本 <公开 静态 类型 = 逻辑型 注释 = "判断当前的JSON值是否为\"文本型\"" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.is_string()
    }

    方法 是否为字节集 <公开 静态 类型 = 逻辑型 注释 = "判断当前的JSON值是否为二进制\"字节集类\"" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.is_binary()
    }

    方法 是否为无效 <公开 静态 类型 = 逻辑型 注释 = "判断当前的JSON值是否为\"无效\"(解析失败返回的值)." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.is_discarded()
    }

    # 成员(链式语法)
    # ====

    方法 成员 <公开 静态 类型 = PivJSON模板类 注释 = "链式返回指定键名的JSON对象,或指定索引的JSON数组成员的参考," 注释 = "如果指定的成员不存在会自动创建."
            注释 = "异常: *PivJSON异常_类型错误" 返回值注释 = "返回对象成员或数组成员的参考(支持链式语法)" 折叠 @嵌入式方法 = "req_cpp_bool = true"
            @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 键名或索引 <注释 = "支持\"整数值\"的数组索引和\"文本值\"的对象键名;" 注释 = "其中键名支持以下类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 允许异常 <类型 = 逻辑型 注释 = "真: 在JSON对象使用索引,或在JSON数组使用键名,将抛出类型错误异常;" 注释 = "假: 类型错误不抛出异常,但会把本对象初始化成另一种类型;"
            注释 = "比如,JSON对象使用索引后会重置为成员数为[索引+1]的数组,数组成员为空值(null);" 注释 = "JSON数组使用键名后会重置为JSON对象,并创建对应键名的空值."
            @默认值 = 假>
    {
        @ piv::json::At(@<所欲操作本对象>, @<键名或索引>, @<允许异常>)
    }

    方法 取成员 <公开 静态 类型 = PivJSON模板类 注释 = "链式返回指定键名的JSON对象,或指定索引的JSON数组成员的参考," 注释 = "如果指定的成员不存在会抛出异常."
            注释 = "异常: PivJSON异常_类型错误, PivJSON异常_超出范围" 返回值注释 = "返回对象成员或数组成员的参考(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 键名或索引 <注释 = "支持\"整数值\"的数组索引和\"文本值\"的对象键名;" 注释 = "其中键名支持以下类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.at(piv::json::to_key (@<键名或索引>))
    }

    方法 是否存在 <公开 静态 类型 = 逻辑型 注释 = "检查当前JSON对象中是否存在指定键名的成员." 返回值注释 = "存在返回真,不存在或JSON类型为数组返回假." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 键名 <注释 = "请提供\"文本值\"的对象键名,支持以下类型(带*号表示会转换编码):" 注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类"
            @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.contains(piv::json::to_key(@<键名>))
    }

    方法 索引是否有效 <公开 静态 类型 = 逻辑型 注释 = "判断指定的JSON数组索引是否有效." 注释 = "注: 本方法也可以在JSON对象上使用,但返回的结果无意义." 折叠
            @禁止流程检查 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 所欲检查索引 <类型 = 整数 注释 = "所欲判断是否有效的JSON数组索引">
    {
        @ return ((@<所欲检查索引> >= 0) && (@<所欲检查索引> < static_cast<INT>(@<所欲操作本对象>.size ())));
    }

    # 路径(链式语法)
    # ====

    方法 路径 <公开 静态 类型 = PivJSON模板类 注释 = "链式返回指定路径的JSON成员参考,如果路径中有不存在的成员," 注释 = "则会自动创建对应的成员,比\"取路径\"稍慢."
            注释 = "异常: PivJSON异常_解析错误, PivJSON异常_超出范围" 返回值注释 = "返回对象成员或数组成员的参考" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    参数 路径 <注释 = "所欲构造的路径,必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "支持以下文本类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>[piv::json::to_pointer<@m<json>>(@<路径>)]
    }

    方法 取路径 <公开 静态 类型 = PivJSON模板类 注释 = "链式返回指定路径的JSON成员参考,如果路径中有不存在的成员," 注释 = "则会抛出异常."
            注释 = "异常: PivJSON异常_解析错误, PivJSON异常_超出范围" 返回值注释 = "返回对象成员或数组成员的参考" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    参数 路径 <注释 = "所欲获取的路径,必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "支持以下文本类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类类" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.at(piv::json::to_pointer<@m<json>>(@<路径>))
    }

    方法 路径是否存在 <公开 静态 类型 = 逻辑型 注释 = "检查当前JSON对象中是否存在指定路径的成员" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 路径 <注释 = "所欲检查的路径,必须以\'/\'开头,如: \"/users/0/name\";" 注释 = "支持以下文本类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.contains(piv::json::to_pointer<@m<json>>(@<路径>))
    }

    # 增(链式语法): 增加成员值
    # ====

    方法 加入成员 <公开 静态 类型 = PivJSON模板类 注释 = "将一个或多个成员值加入到本JSON数组的尾部," 注释 = "如果自身不是\"数组\"和\"空值\"则抛出异常."
            注释 = "异常: PivJSON异常_类型错误" 返回值注释 = "返回JSON数组自身(支持链式语法)" 折叠 @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 成员值 <注释 = "所欲添加的成员值,支持以下类型(带*号表示会转换编码):" 注释 = " 通用整数型、逻辑型、小数、JSON对象、JSON数组"
            注释 = " *文本型、标准文本类U、文本视图类U、字节集类(UTF-8)、*标准文本类W、*文本视图类" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ piv::json::PushBackArgs(@<所欲操作本对象>, @<成员值>)
    }

    方法 插入成员 <公开 静态 类型 = PivJSON模板类 注释 = "将所指定的成员值插入到JSON数组所指定的索引位置," 注释 = "如果自身不是\"数组\"和\"空值\"则抛出异常."
            注释 = "异常: PivJSON异常_类型错误, PivJSON异常_无效迭代器" 返回值注释 = "返回JSON数组自身(支持链式语法)" 折叠
            @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 索引 <类型 = 变整数 注释 = "所欲插入的成员索引位置,必须大于等于0且小于等于数组成员数目,否则抛出异常.">
    参数 成员值 <注释 = "所欲添加的成员值,支持以下类型(带*号表示会转换编码):" 注释 = " 通用整数型、逻辑型、小数、JSON对象、JSON数组"
            注释 = " *文本型、标准文本类U、文本视图类U、字节集类(UTF-8)、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    参数 插入次数 <类型 = 变整数 注释 = "指定成员值的插入次数,必须大于等于1,否则抛出异常." @默认值 = 1>
    {
        @ piv::json::Insert(@<所欲操作本对象>, @<索引>, @<成员值>, @<插入次数>)
    }

    # 删(链式语法): 删除成员值
    # ====

    方法 删除 <公开 静态 注释 = "删除指定对象键名或数组索引的成员值." 注释 = "注意: 本方法不支持JSON路径."
            注释 = "异常: PivJSON异常_类型错误, PivJSON异常_超出范围" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 键名或索引 <注释 = "支持\"整数值\"的数组索引和\"文本值\"的对象键名;" 注释 = "其中键名支持以下类型(带*号表示会转换编码):"
            注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类" @匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.erase(piv::json::to_key(@<键名或索引>))
    }

    方法 清空 <公开 静态 注释 = "清除JSON值的内容并将其重置为初始值,不同值类型的初始值不一样." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.clear()
    }

    # 改(链式语法): 修改成员值
    # ====

    方法 置文本 <公开 静态 类型 = PivJSON模板类 注释 = "将当前的JSON成员设置为指定的文本值,返回自身." 返回值注释 = "返回JSON成员自身" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 值 <注释 = "所欲设置的文本值,支持以下类型(带*号表示会转换编码):" 注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类"
            @匹配类型 = 通用型>
    {
        @ (@<所欲操作本对象> = piv::json::to_value(@<值>))
    }

    方法 置数值 <公开 静态 类型 = PivJSON模板类 注释 = "将当前的JSON成员设置为指定的整数值,返回自身." 注释 = "可以替代\"置整数\"、\"置长整数\"、\"置小数\"."
            返回值注释 = "返回JSON成员自身" 折叠 @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 值 <注释 = "所欲设置的数值,可以是小数、长整数、整数、短整数、字节、逻辑型" @匹配类型 = 通用数值型>
    {
        @ (@<所欲操作本对象> = @<值>)
    }

    方法 置逻辑 <公开 静态 类型 = PivJSON模板类 注释 = "将当前的JSON成员设置为指定的逻辑值,返回自身." 返回值注释 = "返回JSON成员自身" 折叠
            @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 值 <类型 = 逻辑型 注释 = "要设置的逻辑值">
    {
        @ (@<所欲操作本对象> = @<值>)
    }

    方法 置整数 <公开 静态 类型 = PivJSON模板类 注释 = "将当前的JSON成员设置为指定的整数值,返回自身." 返回值注释 = "返回JSON成员自身" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 值 <类型 = 整数 注释 = "要设置的整数值">
    {
        @ (@<所欲操作本对象> = @<值>)
    }

    方法 置长整数 <公开 静态 类型 = PivJSON模板类 注释 = "将当前的JSON成员设置为指定的长整数值,返回自身." 返回值注释 = "返回JSON成员自身" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 值 <类型 = 长整数 注释 = "要设置的长整数">
    {
        @ (@<所欲操作本对象> = @<值>)
    }

    方法 置小数 <公开 静态 类型 = PivJSON模板类 注释 = "将当前的JSON成员设置为指定的小数值,返回自身." 返回值注释 = "返回JSON成员自身" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 值 <类型 = 小数 注释 = "要设置的小数值">
    {
        @ (@<所欲操作本对象> = @<值>)
    }

    方法 置值 <公开 静态 类型 = PivJSON模板类 注释 = "将当前的JSON成员设置为另一个JSON值,返回自身." 返回值注释 = "返回JSON成员自身" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 新值 <类型 = PivJSON模板类 注释 = "要设置的值,可以任意类型的另一个JSON值.">
    {
        @ (@<所欲操作本对象> = @<新值>)
    }

    方法 置对象 <公开 静态 类型 = PivJSON模板类 注释 = "将当前的JSON值覆盖为初始化内容的JSON对象." 返回值注释 = "返回JSON对象自身" 折叠
            @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 键值对 <注释 = "所欲设置的一或多个键值对,必须以两个参数为一组,分别提供\"键\"和\"值\"." 注释 = "1. \"键\"必须为文本值(带*号表示会转换编码):"
            注释 = "   *文本型、字节集类(UTF-8)、*标准文本类W、*文本视图类W、标准文本类U、文本视图类U;" 注释 = "2. \"值\"支持更多类型:"
            注释 = "   通用数值型、JSON对象、JSON数组、*文本型、字节集类(UTF-8)" 注释 = "   *标准文本类W、*文本视图类W、标准文本类U、文本视图类U" @匹配类型 = 通用型
            @可扩展 = "">
    {
        @ piv::json::SetObject(@<所欲操作本对象>, @<键值对>)
    }

    方法 置数组 <公开 静态 类型 = PivJSON模板类 注释 = "将当前的JSON值覆盖为所提供初始值的JSON数组." 返回值注释 = "返回JSON数组自身(支持链式语法)" 折叠
            @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 成员值 <注释 = "所欲添加的成员值,支持以下类型(带*号表示会转换编码):" 注释 = " 通用数值型、JSON对象、JSON数组、*文本型、字节集类(UTF-8)"
            注释 = " *标准文本类W、*文本视图类W、标准文本类U、文本视图类U" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ piv::json::SetArray(@<所欲操作本对象>, @<成员值>)
    }

    方法 置空 <公开 静态 类型 = PivJSON模板类 注释 = "将当前的JSON成员设置为null,返回自身." 返回值注释 = "返回JSON成员自身" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ (@<所欲操作本对象> = nullptr)
    }

    方法 置空对象 <公开 静态 类型 = PivJSON模板类 注释 = "将当前的JSON成员设置为空对象,返回自身." 返回值注释 = "返回JSON成员自身" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ (@<所欲操作本对象> = @m<json>::object())
    }

    方法 置空数组 <公开 静态 类型 = PivJSON模板类 注释 = "将当前的JSON成员设置为空数组,返回自身." 返回值注释 = "返回JSON成员自身" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ (@<所欲操作本对象> = @m<json>::array())
    }

    # 查(链式语法): 获取成员值
    # ====

    方法 到文本 <公开 静态 类型 = 文本型 注释 = "将当前的任意类型JSON值转换到文本,然后转换到火山的文本型并返回." 注释 = "注: 本方法不会抛出异常,遇到无法转换的类型将返回空文本."
            折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ *PivU2Ws{piv::json::GetString(@<所欲操作本对象>)}
    }

    方法 到文本U <公开 静态 类型 = 标准文本类U 注释 = "将当前的任意类型JSON值转换到文本,返回到\"标准文本类U\"."
            注释 = "  1. 本方法不会抛出异常,遇到无法转换的类型将返回空文本;" 注释 = "  2. 相比\"到文本\",本方法不会产生文本编码转换;"
            返回值注释 = "返回UTF-8编码的std::string封装类" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ piv::json::GetString(@<所欲操作本对象>)
    }

    方法 取文本 <公开 静态 类型 = 文本型 注释 = "以\"文本型\"返回当前的文本JSON值,本方法有编码转换," 注释 = "如果JSON值类型不是文本将抛出异常."
            注释 = "异常: PivJSON异常_类型错误" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ *PivU2Ws{@<所欲操作本对象>.get_ref<const std::string&>()}
    }

    方法 取文本U <公开 静态 类型 = 标准文本类U 注释 = "以\"标准文本类U\"返回当前的文本JSON值,本方法无编码转换," 注释 = "如果JSON值类型不是文本将抛出异常."
            注释 = "异常: PivJSON异常_类型错误" 返回值注释 = "返回UTF-8编码的std::string封装类" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.get_ref<const std::string&>()
    }

    方法 取文本视图 <公开 静态 类型 = 文本视图类U 注释 = "以\"文本视图\"返回当前的文本JSON值,本方法无编码转换," 注释 = "也不会复制内存,如果JSON值类型不是文本将抛出异常."
            注释 = "注意: 如果后续改变了JSON的成员值,则切勿继续使用返回的文本视图." 注释 = "异常: PivJSON异常_类型错误"
            返回值注释 = "返回UTF-8编码的std::string_view封装类" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @dt<文本视图类U>{@<所欲操作本对象>.get_ref<const std::string&>()}
    }

    方法 取整数 <公开 静态 类型 = 整数 注释 = "以整数型返回当前的数字JSON值,如果JSON值是其他数字类型," 注释 = "会进行适当的转换."
            注释 = "异常: PivJSON异常_类型错误" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.get<int32_t>()
    }

    方法 取长整数 <公开 静态 类型 = 长整数 注释 = "以长整数型返回当前的数字JSON值,如果JSON值是其他数字类型," 注释 = "会进行适当的转换."
            注释 = "异常: PivJSON异常_类型错误" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.get<int64_t>()
    }

    方法 取小数 <公开 静态 类型 = 小数 注释 = "以小数型返回当前的数字JSON值,如果JSON值是其他数字类型," 注释 = "会进行适当的转换."
            注释 = "异常: PivJSON异常_类型错误" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.get<double>()
    }

    方法 取逻辑 <公开 静态 类型 = 逻辑型 注释 = "以逻辑型返回当前的逻辑JSON值,如果JSON值是其他数字类型," 注释 = "会进行适当的转换."
            注释 = "异常: PivJSON异常_类型错误" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.get<bool>()
    }

    # 属性
    # ====

    方法 是否为空 <公开 静态 类型 = 逻辑型 注释 = "检查JSON值是否为空,等同于\"取成员数() == 0\"." 注释 = "注: 如果是基本型的JSON值则始终返回真."
            返回值注释 = "返回真表示JSON值的成员数为空." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.empty()
    }

    方法 取成员数 <公开 静态 类型 = 整数 注释 = "返回JSON值的成员数,例如JSON对象的键值对数量," 注释 = "以及JSON数组的成员数."
            注释 = "注: 基本型的JSON值将固定返回1,空值则返回0." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ static_cast<INT>(@<所欲操作本对象>.size())
    }

    方法 取最大成员数 <公开 静态 类型 = 变整数 注释 = "返回JSON值可以容纳的最大成员数,该上限由系统和库的实现决定."
            注释 = "注: 根据值类型返回不同的结果,JSON对象和JSON数组返回最大成员数," 注释 = "而基本型的JSON值固定返回1,空值固定为0." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ static_cast<INT_P>(@<所欲操作本对象>.max_size())
    }

    方法 取键计数 <公开 静态 类型 = 整数 注释 = "获取指定键名在JSON对象中的计数,如果JSON值类型不是对象," 注释 = "则始终返回0."
            返回值注释 = "返回指定键名在对象中存在的数量,不存在返回0." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 键名 <注释 = "所欲取计数的键名,支持以下类型(带*号表示会转换编码):" 注释 = " *文本型、字节集类(UTF-8)、标准文本类U、文本视图类U、*标准文本类W、*文本视图类"
            @匹配类型 = 通用型>
    {
        @ static_cast<INT>(@<所欲操作本对象>.count(piv::json::to_key(@<键名>)))
    }

    方法 取所有键名 <公开 静态 类型 = 整数 注释 = "获取当前JSON对象的所有键名,并返回键名的数量," 注释 = "如果JSON类型不是对象或对象为空则返回0."
            返回值注释 = "成功返回键名的数量,失败或对象为空返回0." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 键名数组 <类型 = 文本数组类 注释 = "所获取的键名会保存在此数组中" "">
    {
        @ piv::json::EnumKey(@<所欲操作本对象>, @<键名数组>.data())
    }

    方法 取所有键名视图 <公开 静态 类型 = 整数 注释 = "获取当前JSON对象的所有键名,并返回键名的数量," 注释 = "如果JSON类型不是对象或对象为空则返回0."
            注释 = "  1. 与\"取所有键名\"不同,使用\"文本视图容器类U\"保存返回的键名;"
            注释 = "  2. 本方法不会转换编码和复制文本数据,但切勿在JSON对象被修改后,继续使用返回的数组." 返回值注释 = "成功返回键名的数量,失败或对象为空返回0." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 键名数组 <类型 = 文本视图数组类U 注释 = "所获取的键名会保存在此文本视图数组中;" 注释 = "文本视图本身不拥有文本数据,而是指向JSON对象内部的数据;"
            注释 = "因此请勿在JSON对象销毁或被修改后继续使用本数组." "">
    {
        @ piv::json::EnumKey(@<所欲操作本对象>, @<键名数组>)
    }

    # 比较
    # ====

    方法 是否相等 <公开 静态 类型 = 逻辑型 注释 = "比较两个JSON值是否相等" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 所欲比较的对象 <类型 = PivJSON模板类 注释 = "所欲比较的另一个JSON值" "">
    {
        @ @<所欲操作本对象> == @<所欲比较的对象>
    }

    方法 是否不相等 <公开 静态 类型 = 逻辑型 注释 = "比较两个JSON值是否不相等" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    参数 所欲比较的对象 <类型 = PivJSON模板类 注释 = "所欲比较的另一个JSON值" "">
    {
        @ @<所欲操作本对象> != @<所欲比较的对象>
    }

    方法 是否小于 <公开 静态 类型 = 逻辑型 注释 = "比较当前的JSON值是否小于另一个JSON值" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    参数 所欲比较的对象 <类型 = PivJSON模板类 注释 = "所欲比较的另一个JSON值" "">
    {
        @ @<所欲操作本对象> < @<所欲比较的对象>
    }

    方法 是否小于等于 <公开 静态 类型 = 逻辑型 注释 = "比较当前的JSON值是否小于等于另一个JSON值" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    参数 所欲比较的对象 <类型 = PivJSON模板类 注释 = "所欲比较的另一个JSON值" "">
    {
        @ @<所欲操作本对象> <= @<所欲比较的对象>
    }

    方法 是否大于 <公开 静态 类型 = 逻辑型 注释 = "比较当前的JSON值是否大于另一个JSON值" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    参数 所欲比较的对象 <类型 = PivJSON模板类 注释 = "所欲比较的另一个JSON值" "">
    {
        @ @<所欲操作本对象> > @<所欲比较的对象>
    }

    方法 是否大于等于 <公开 静态 类型 = 逻辑型 注释 = "比较当前的JSON值是否大于等于另一个JSON值" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    参数 所欲比较的对象 <类型 = PivJSON模板类 注释 = "所欲比较的另一个JSON值" "">
    {
        @ @<所欲操作本对象> >= @<所欲比较的对象>
    }

    # 迭代器
    # ====

    方法 枚举循环 <公开 静态 注释 = "启动一个迭代器来枚举JSON中的每一个成员,在循环中可以调用\"取枚举键/取枚举键视图\"," 注释 = "和\"取枚举值\"方法来获取当前所枚举到的键值." 折叠
            @嵌入式方法 = "name = json_iterator\r\nhas_loop_body = true">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    {
        @ for (auto& _piv_json_iter : @<所欲操作本对象>.items())
    }

    方法 取枚举键 <公开 静态 类型 = 文本型 注释 = "只能在本类的\"枚举循环\"的子语句体中使用,用作取回当前枚举到的成员键或数组索引."
            注释 = "如果有多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回所处最近层\"枚举循环\"的" 注释 = "枚举成员键或数组索引."
            返回值注释 = "以文本返回JSON对象的键名,或JSON数组的索引;如果JSON是基本类型则返回空文本." 折叠 @嵌入式方法 = "parent = json_iterator">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    {
        @ *PivU2Ws{_piv_json_iter.key()}
    }

    方法 取枚举键视图 <公开 静态 类型 = 文本视图类U 注释 = "只能在本类的\"枚举循环\"的子语句体中使用,用作取回当前枚举到的成员键或数组索引."
            注释 = "如果有多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回所处最近层的枚举成员键或数组索引." 注释 = "注: 对比\"取枚举键()\",本方法不会产生文本复制和编码转换."
            返回值注释 = "以文本返回键名和索引,如果JSON值是基本型则返回空文本." 折叠 @嵌入式方法 = "parent = json_iterator">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    {
        @ @dt<文本视图类U>{_piv_json_iter.key()}
    }

    方法 取枚举值 <公开 静态 类型 = PivJSON模板类 注释 = "只能在本类的\"枚举循环\"的子语句体中使用,用作取回当前枚举到的成员值."
            注释 = "如果有多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回所处最近层的枚举成员值." 返回值注释 = "返回所枚举到的JSON值." 折叠
            @嵌入式方法 = "parent = json_iterator" @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    {
        @ _piv_json_iter.value()
    }

    # JSON补丁(https://jsonpatch.com/)
    # ====

    方法 创建补丁 <公开 静态 类型 = PivJSON模板类 注释 = "通过比较当前和目标JSON值的差异来创建JSON补丁."
            注释 = "注: 如果在当前的JSON值上应用所创建的补丁,会得到跟目标一样的JSON值." 返回值注释 = "返回所创建的补丁JSON值." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 目标 <类型 = PivJSON模板类 注释 = "所欲比较的目标JSON值">
    {
        @ @m<json>::diff(@<所欲操作本对象>, @<目标>)
    }

    方法 应用补丁 <公开 静态 注释 = "执行所指定JSON补丁中的所有操作,将JSON补丁的更改应用到当前的JSON值中," 注释 = "并使用补丁后的JSON值覆盖当前的JSON值."
            注释 = "注: JSON补丁是一种JSON文档结构,用于描述应用于JSON文档的一系列操作." 注释 = "异常: PivJSON异常_解析错误, PivJSON异常_超出范围" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    参数 JSON补丁 <类型 = PivJSON模板类 注释 = "JSON补丁必须是JSON数组,格式如:" 注释 = " ["
            注释 = "   { \"op\": \"replace\", \"path\": \"/baz\", \"value\": \"boo\" },"
            注释 = "   { \"op\": \"add\", \"path\": \"/hello\", \"value\": [\"world\"] },"
            注释 = "   { \"op\": \"remove\", \"path\": \"/foo\"}" 注释 = " ]">
    {
        @ @<所欲操作本对象>.patch_inplace(@<JSON补丁>)
    }

    方法 执行补丁 <公开 静态 类型 = PivJSON模板类 注释 = "执行指定JSON补丁中的所有操作,将JSON补丁的更改应用到当前的JSON值中," 注释 = "然后返回补丁后的JSON值."
            注释 = "注: JSON补丁是一种JSON文档结构,用于描述应用于JSON文档的一系列操作." 注释 = "异常: PivJSON异常_解析错误, PivJSON异常_超出范围"
            返回值注释 = "成功返回修补后的JSON值,需要用变量接收更改,本对象不会被改变." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    参数 JSON补丁 <类型 = PivJSON模板类 注释 = "JSON补丁必须是JSON数组,格式如:" 注释 = " ["
            注释 = "   { \"op\": \"replace\", \"path\": \"/baz\", \"value\": \"boo\" },"
            注释 = "   { \"op\": \"add\", \"path\": \"/hello\", \"value\": [\"world\"] },"
            注释 = "   { \"op\": \"remove\", \"path\": \"/foo\"}" 注释 = " ]">
    {
        @ @<所欲操作本对象>.patch(@<JSON补丁>)
    }

    方法 合并补丁 <公开 静态 注释 = "使用HTTP PATCH方法将另一个JSON值合并到当前的JSON值中."
            注释 = "规则: 如果是合并JSON对象,两个对象中不同的键值都会保留,相同的键则覆盖为补丁的值;" 注释 = "如果是合并其他的值类型,则完全覆盖为补丁的值." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数." "">
    参数 应用补丁 <类型 = PivJSON模板类 注释 = "所欲应用的补丁JSON,本方法使用的补丁就是普通的JSON;" 注释 = "而不是\"取差异()\"方法返回的那种JSON补丁.">
    {
        @ @<所欲操作本对象>.merge_patch(@<应用补丁>)
    }

    # 其他
    # ====

    方法 更新 <公开 静态 注释 = "从另一个对象更新当前的JSON对象,可以选择是否覆盖现有的键." 注释 = "本方法只能用于JSON对象,其他值类型会抛出异常."
            注释 = "异常: PivJSON异常_类型错误" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 所欲参考的对象 <类型 = PivJSON模板类 注释 = "所欲读取值的JSON对象." "">
    参数 合并对象 <类型 = 逻辑型 注释 = "真: 不覆盖现有的键,递归合并两个对象的共通键;" 注释 = "假: 当前对象的所有键都会被覆盖;" @默认值 = 假>
    {
        @ @<所欲操作本对象>.update(@<所欲参考的对象>, @<合并对象>)
    }

    方法 交换 <公开 静态 注释 = "将当前的JSON值与另一个JSON值交换" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    参数 所欲交换的对象 <类型 = PivJSON模板类 注释 = "所欲交换的JSON值" "">
    {
        @ @<所欲操作本对象>.swap(@<所欲交换的对象>)
    }

    方法 扁平化 <公开 静态 类型 = PivJSON模板类 注释 = "基于当前的JSON值创建一个扁平化的JSON对象值,其键是JSON路径," 注释 = "其值的类型都是基本型."
            返回值注释 = "返回扁平化后的JSON值,本对象的值不会被改变." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.flatten()
    }

    方法 反扁平化 <公开 静态 类型 = PivJSON模板类 注释 = "将扁平化JSON值还原为原来的任意嵌套JSON值" 返回值注释 = "返回反扁平化的JSON值,本对象的值不会被改变." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类 注释 = "所欲操作的JSON值,动态调用方法时无需填写本参数.">
    {
        @ @<所欲操作本对象>.unflatten()
    }

    # 初始化构造JSON
    # ====

    方法 元数据 <公开 静态 类型 = PivJSON模板类 注释 = "获取本JSON库的信息,包括版本号、平台和编译器等信息." 注释 = "注: 本方法需要用类名调用."
            返回值注释 = "返回JSON对象." 折叠 @嵌入式方法 = "">
    {
        @ @m<json>::meta()
    }

    方法 创建空对象 <公开 静态 类型 = PivJSON模板类 注释 = "创建一个空的JSON对象." 注释 = "注: 本方法需要用类名调用." 返回值注释 = "返回创建的JSON对象" 折叠
            @嵌入式方法 = "">
    {
        @ @m<json>::object()
    }

    方法 创建对象 <公开 静态 类型 = PivJSON模板类 注释 = "使用提供的键值对初始化构造一个JSON对象." 注释 = "注: 本方法需要用类名调用."
            返回值注释 = "返回创建的JSON对象" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 键值对 <注释 = "作为初始值的一系列键值对,必须以两个参数为一组,分别提供\"键\"和\"值\"." 注释 = "1. \"键\"必须为文本值(带*号表示会转换编码):"
            注释 = "   *文本型、字节集类(UTF-8)、*标准文本类W、*文本视图类W、标准文本类U、文本视图类U" 注释 = "2. \"值\"支持更多类型:"
            注释 = "   通用数值型、JSON对象、JSON数组、*文本型、字节集类(UTF-8)" 注释 = "   *标准文本类W、*文本视图类W、标准文本类U、文本视图类U" @匹配类型 = 通用型
            @可扩展 = "">
    {
        @ piv::json::CreateObject<@m<json>>(@<键值对>)
    }

    方法 创建空数组 <公开 静态 类型 = PivJSON模板类 注释 = "创建一个空的JSON数组." 注释 = "注: 本方法需要用类名调用." 返回值注释 = "返回创建的JSON数组" 折叠
            @嵌入式方法 = "">
    {
        @ @m<json>::array()
    }

    方法 创建数组 <公开 静态 类型 = PivJSON模板类 注释 = "使用提供的成员初始化构造一个JSON数组." 注释 = "注: 本方法需要用类名调用." 返回值注释 = "返回创建的JSON数组"
            折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 成员值 <注释 = "作为初始值的一系列数组成员,支持的成员类型(带*号表示会转换编码):" 注释 = " 通用数值型、JSON对象、JSON数组、*文本型、字节集类(UTF-8)"
            注释 = " *标准文本类W、*文本视图类W、标准文本类U、文本视图类U" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ piv::json::CreateArray<@m<json>>(@<成员值>)
    }

    方法 创建文本值 <公开 静态 类型 = PivJSON模板类 注释 = "使用提供的文本创建一个简单值的JSON." 注释 = "简单值JSON不能使用JSON对象和JSON数组的那些操作."
            注释 = "注: 本方法需要用类名调用." 返回值注释 = "返回创建的JSON值" 折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 值 <类型 = 文本型 注释 = "所欲初始化的文本">
    {
        @ @m<json>{*PivW2U{@<值>}}
    }

    方法 创建数值 <公开 静态 类型 = PivJSON模板类 注释 = "使用提供的数值创建一个简单值的JSON." 注释 = "简单值JSON不能使用JSON对象和JSON数组的那些操作."
            注释 = "注: 本方法需要用类名调用." 返回值注释 = "返回创建的JSON值" 折叠 @嵌入式方法 = "">
    参数 值 <注释 = "  所欲初始化的数值,允许的类型:" 注释 = "  字节、短整数、字符、整数、长整数、小数" @匹配类型 = 通用数值型>
    {
        @ @m<json>{@<值>}
    }

    方法 创建逻辑值 <公开 静态 类型 = PivJSON模板类 注释 = "使用提供的逻辑值创建一个简单值的JSON." 注释 = "简单值JSON不能使用JSON对象和JSON数组的那些操作."
            注释 = "注: 本方法需要用类名调用." 返回值注释 = "返回创建的JSON值" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 值 <类型 = 逻辑型 注释 = "所欲初始化的逻辑值">
    {
        @ @m<json>{@<值>}
    }

    方法 创建空值 <公开 静态 类型 = PivJSON模板类 注释 = "创建一个内容为空的简单值JSON." 注释 = "简单值JSON不能使用JSON对象和JSON数组的那些操作."
            注释 = "注: 本方法需要用类名调用." 返回值注释 = "返回创建的JSON值" 折叠 @嵌入式方法 = "">
    {
        @ @m<json>{}
    }

    # ---

    方法 取对象数据 <公开 静态 类型 = 字节集类 注释 = "获取本对象中的所有内容数据" 折叠 @禁止流程检查 = 真>
    参数 所欲操作本对象 <类型 = PivJSON模板类>
    {
        @ std::string ss = @<所欲操作本对象>.dump();
        @ return @an<CVolMem>(ss.data(), ss.size() + 1);
    }

    方法 置对象数据 <公开 静态 注释 = "设置本对象中的所有内容数据" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = PivJSON模板类>
    参数 所欲设置的内容数据 <类型 = 字节集类 注释 = "  本参数用作提供对象内容数据,该数据必须为\"取对象数据\"" 注释 = "方法所返回,否则将导致不可预知的后果.">
    {
        @ @<所欲操作本对象> = @m<json>::parse((const char*)@<所欲设置的内容数据>.GetPtr(), nullptr, false, true)
    }
}

类 PivJSON <公开 基础类 = PivJSON模板类 注释 = "  本类可以存储各种类型的JSON值,JSON对象的键值对按照插入顺序排列."
        注释 = "  备注有异常的方法,都需要做异常处理或者预先判断操作的有效性," 注释 = "否则会导致程序异常退出." 注释 = "  方法备注中带*号的异常可以通过参数避免." 折叠
        @文档 = "category = \"JSON支持.PivJSON\"" @别名 = "PivJSON" @模板实现类 = "PivJSON">
{

    # @ @def_macro json PivJSON
}

类 无序PivJSON <公开 基础类 = PivJSON模板类 注释 = "  本类可以存储各种类型的JSON值,JSON对象的键值对是无序的."
        注释 = "  备注有异常的方法,都需要做异常处理或者预先判断操作的有效性," 注释 = "否则会导致程序异常退出." 注释 = "  方法备注中带*号的异常可以通过参数避免." 折叠
        @文档 = "category = \"JSON支持.PivJSON\"" @别名 = "PivJSON_Unordered" @模板实现类 = "无序PivJSON">
{

    # @ @def_macro json PivJSON_Unordered
}

类 PivOrderJSON <公开 基础类 = PivJSON模板类 注释 = "跟\"PivJSON\"一样,为兼容之前的源码保留." 折叠
        @文档 = "category = \"JSON支持.PivJSON\"" @别名 = "PivJSON" @模板实现类 = "PivOrderJSON">
{

    # @ @def_macro json PivJSON
}

# 常量类 ===

类 PivJSON值类型 <公开 注释 = "PivJSON值的类型" 注释 = "value_t" 折叠 @文档 = "category = \"JSON支持.PivJSON.常量类\""
        @常量类 = 字节>
{
    常量 空 <公开 值 = 0 注释 = "null            空值">
    常量 对象 <公开 值 = 1 注释 = "object          对象(键值对集合)">
    常量 数组 <公开 值 = 2 注释 = "array           数组(有序的值集合)">
    常量 文本 <公开 值 = 3 注释 = "string          字符串">
    常量 逻辑 <公开 值 = 4 注释 = "boolean         逻辑值">
    常量 数字_整数 <公开 值 = 5 注释 = "number_integer  整数值">
    常量 数字_无符号 <公开 值 = 6 注释 = "number_unsigned 无符号整数值">
    常量 数字_小数 <公开 值 = 7 注释 = "number_float    浮点小数值">
    常量 字节集 <公开 值 = 8 注释 = "binary          二进制字节集">
    常量 无效 <公开 值 = 9 注释 = "discarded       解析错误返回的无效值">
}

类 PivJSON错误处理方式 <公开 注释 = "使用\"到可读文本、到UTF8\"等方法将JSON序列化时,如何处理无效UTF-8序列." 注释 = "error_handler_t" 折叠
        @文档 = "category = \"JSON支持.PivJSON.常量类\"" @常量类 = 整数>
{
    常量 严格 <公开 值 = 0 注释 = "strict  遇到无效的UTF-8时抛出\"PivJSON异常_类型错误\"">
    常量 替换 <公开 值 = 1 注释 = "replace 将无效的UTF-8序列替换为U+FFFD(\uFFFD占位符)">
    常量 忽略 <公开 值 = 2 注释 = "ignore  忽略无效的UTF-8序列,将所有字节原封不动地复制输出">
}

类 CBOR标签处理方式 <公开 注释 = "使用\"到CBOR()\"将JSON序列化为CBOR格式二进制时,如何处理标签." 注释 = "cbor_tag_handler_t" 折叠
        @文档 = "category = \"JSON支持.PivJSON.常量类\"" @常量类 = 整数>
{
    常量 报错 <公开 值 = 0 注释 = "error   遇到标签时抛出\"PivJSON异常_解析错误\"">
    常量 忽略 <公开 值 = 1 注释 = "replace 忽略标签">
    常量 存储 <公开 值 = 2 注释 = "store   将标签值存储为带子类型二进制容器(for bytes 0xd8..0xdb)">
}

类 PivJSON解析事件类型 <公开 注释 = "JSON解析的回调事件类型" 注释 = "parse_event_t(uint8_t)" 折叠
        @文档 = "category = \"JSON支持.PivJSON.常量类\"" @常量类 = 字节>
{
    常量 对象开头 <公开 值 = 0 注释 = "object_start 解析器读取到\'{\'并开始处理JSON对象">
    常量 对象结尾 <公开 值 = 1 注释 = "object_end   解析器读取到\'}\'并完成JSON对象的处理">
    常量 数组开头 <公开 值 = 2 注释 = "array_start  解析器读取到\'[\'并开始处理JSON数组">
    常量 数组结尾 <公开 值 = 3 注释 = "array_end    解析器读取到\']\'并完成JSON数组的处理">
    常量 键 <公开 值 = 4 注释 = "key          解析器读取到对象中某个值的关键字">
    常量 值 <公开 值 = 5 注释 = "value        解析器读取完一个值">
}

# 异常类型 ===

类 PivJSON异常 <公开 注释 = "JSON异常的基类,JSON的所有异常都可以用这个类型来俘获." 注释 = "但如果要获取准确的异常信息,需要用更适合的JSON异常子类型." 折叠
        @文档 = "category = \"JSON支持.PivJSON.异常类\"" @别名 = "PivJSON.exception" @别名类型 = 本地类 @强制依赖 = "PivJSON">
{
    方法 取错误信息 <公开 静态 类型 = 文本型 注释 = "返回异常的错误描述" 折叠 @嵌入式方法 = "">
    参数 异常 <类型 = PivJSON异常 注释 = "本异常实例,本参数无需填写">
    {
        @ *PivU2Ws{@<异常>.what()}
    }

    方法 取错误ID <公开 静态 类型 = 整数 注释 = "返回异常的错误ID" 折叠 @嵌入式方法 = "">
    参数 异常 <类型 = PivJSON异常 注释 = "本异常实例,本参数无需填写">
    {
        @ @<异常>.id
    }
}

类 PivJSON异常_解析错误 <公开 基础类 = PivJSON异常 注释 = "可以俘获JSON解析时抛出的异常." 注释 = "在反序列化JSON文本、CBOR、MessagePack、以及使用"
        注释 = "JSON补丁时都可能会发生解析错误." 折叠 @文档 = "category = \"JSON支持.PivJSON.异常类\"" @别名 = "PivJSON.parse_error"
        @别名类型 = 本地类>
{
    方法 取位置 <公开 静态 类型 = 变整数 注释 = "返回解析错误的字节索引位置,为输入数据最后一个读取到的字符位置."
            注释 = "注: 如果数据有n个字节,那1为首字符的索引位置,而n+1为终止null字节," 注释 = "或文件尾部的位置." 折叠 @嵌入式方法 = "">
    参数 异常 <类型 = PivJSON异常_解析错误 注释 = "本异常实例,本参数无需填写">
    {
        @ static_cast<INT_P>(@<异常>.byte)
    }
}

类 PivJSON异常_无效迭代器 <公开 基础类 = PivJSON异常 注释 = "如果传递给库函数的迭代器与预期的语义不匹配,则会抛出此异常."
        @文档 = "category = \"JSON支持.PivJSON.异常类\"" @别名 = "PivJSON.invalid_iterator" @别名类型 = 本地类>

类 PivJSON异常_类型错误 <公开 基础类 = PivJSON异常 注释 = "俘获执行类型错误的成员函数的异常." 注释 = "在类型错误的情况下抛出此异常;"
        注释 = "也就是说,一个库函数是在类型与预期语义不匹配的JSON值上执行." @文档 = "category = \"JSON支持.PivJSON.异常类\""
        @别名 = "PivJSON.type_error" @别名类型 = 本地类>

类 PivJSON异常_超出范围 <公开 基础类 = PivJSON异常 注释 = "俘获访问超出定义范围的异常." 注释 = "例如调用库函数时提供超出范围数组索引,或不存在对象键,则会引发此异常."
        @文档 = "category = \"JSON支持.PivJSON.异常类\"" @别名 = "PivJSON.out_of_range" @别名类型 = 本地类>

类 PivJSON异常_其他错误 <公开 基础类 = PivJSON异常 注释 = "俘获其他库错误的异常." 注释 = "如果出现无法归类为其他异常类型的错误,则会抛出此异常."
        @文档 = "category = \"JSON支持.PivJSON.异常类\"" @别名 = "PivJSON.other_error" @别名类型 = 本地类>

#
