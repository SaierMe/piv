<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "编码处理" 注释 = "https://github.com/SaierMe/piv" "">

类 编码P <公开 基础类 = 编码辅助类 注释 = "编码和进制相关的辅助方法(通过类名调用)" @文档 = "category = \"编码处理\"" @禁止创建对象 = 真>

类 编码辅助类 <公开 注释 = "编码和进制相关的全局辅助方法" 折叠 @文档 = "category = \"编码处理\"" @禁止创建对象 = 真 @全局类 = 真>
{
    方法 取整数值位数 <公开 静态 类型 = 整数 注释 = "计算整数值的十进制位数. 比如1000的位数是4." 返回值注释 = "返回大于0的位数,比如0的位数也是1." 折叠 @嵌入式方法 = "">
    参数 整数值 <注释 = "所欲取位数的数值,可以提供字节、字符、短整数、整数、长整数等类型." @匹配类型 = 通用整数型>
    {
        @ [](auto v) {
        @     v /= 10; INT count = 1;
        @     while (v) { v /= 10; count++; }
        @     return count;
        @ } (@<整数值>)
    }

    方法 小数向上取整 <公开 静态 类型 = 整数 注释 = "返回一个小数的整数部分,本方法返回大于所欲处理的小数值的最小整数."
            注释 = "例如,将 7.3 转换 成 8, 将 -7.3 转换成 -7." 折叠 @嵌入式方法 = "">
    参数 所欲处理的小数值 <类型 = 小数>
    {
        @ (INT)ceil (@<所欲处理的小数值>)
    }

    方法 合并长整数 <公开 静态 类型 = 长整数 注释 = "  将第一个整数放置到结果长整数的低32位,将第二个整数放置到结果" 注释 = "长整数的高32位,以此合并成一个长整数,并返回合并后的结果."
            折叠 @嵌入式方法 = "">
    参数 用作合并的整数1 <类型 = 整数>
    参数 用作合并的整数2 <类型 = 整数>
    {
        @ ((INT64) (((INT)@<用作合并的整数1>) | ((INT64) ((INT)@<用作合并的整数2>)) << 32))
    }

    方法 取高32位 <公开 静态 类型 = 整数 注释 = "获取64位长整数的高32位,对应\"合并长整数\"." 折叠 @嵌入式方法 = "">
    参数 欲取位的值 <类型 = 长整数>
    {
        @ ((INT) (((INT64) (@<欲取位的值>) >> 32) & 0xFFFFFFFF))
    }

    方法 取低32位 <公开 静态 类型 = 整数 注释 = "获取64位长整数的低32位,对应\"合并长整数\"." 折叠 @嵌入式方法 = "">
    参数 欲取位的值 <类型 = 长整数>
    {
        @ ((INT)@<欲取位的值>)
    }

    方法 取高16位 <公开 静态 类型 = 整数 注释 = "获取32位整数的高16位,对应\"合并整数\"."
            注释 = "#define HIWORD(l)   ((WORD) (((DWORD) (l) >> 16) & 0xFFFF))" 折叠 @嵌入式方法 = "">
    参数 欲取位的值 <类型 = 整数>
    {
        @ (INT)HIWORD (@<欲取位的值>)
    }

    方法 取低16位 <公开 静态 类型 = 整数 注释 = "获取32位整数的低16位,对应\"合并整数\"." 注释 = "#define LOWORD(l)   ((WORD) (l))" 折叠
            @嵌入式方法 = "">
    参数 欲取位的值 <类型 = 整数>
    {
        @ (INT)LOWORD ((DWORD)@<欲取位的值>)
    }

    方法 取高8位 <公开 静态 类型 = 短整数 注释 = "获取16位短整数的高8位,对应\"合并短整数\"."
            注释 = "#define HIBYTE(w)   ((BYTE) (((WORD) (w) >> 8) & 0xFF))" 折叠 @嵌入式方法 = "">
    参数 欲取位的值 <类型 = 整数>
    {
        @ (SHORT)HIBYTE (@<欲取位的值>)
    }

    方法 取低8位 <公开 静态 类型 = 短整数 注释 = "获取16位短整数的低8位,对应\"合并短整数\"." 注释 = "#define LOBYTE(w)   ((BYTE) (w))" 折叠
            @嵌入式方法 = "">
    参数 欲取位的值 <类型 = 整数>
    {
        @ (SHORT)LOBYTE ((WORD)@<欲取位的值>)
    }

    方法 取字符十六进制文本 <公开 静态 类型 = 文本型 注释 = "返回所指定字符所对应的十六进制文本" 折叠 @禁止流程检查 = 真>
    参数 所欲转换的字符 <类型 = 字符>
    参数 所需要的最小宽度 <类型 = 整数 注释 = "指定所需求的最小宽度(数字数目),如果有效数值宽度小于该值,则自动在首部加0."
            注释 = "为0表示去除所有的前置\'0\'数字. 字节的十六进制文本不应大于4." @默认值 = 0>
    {
        @ TCHAR buf [16];
        @ return CVolString (WordToHexStr ((WORD)@<所欲转换的字符>, @<所需要的最小宽度>, buf, NUM_ELEMENTS_OF (buf)));
    }

    方法 取短整数十六进制文本 <公开 静态 类型 = 文本型 注释 = "返回所指定短整数所对应的十六进制文本" 折叠 @禁止流程检查 = 真>
    参数 所欲转换的短整数 <类型 = 短整数>
    参数 所需要的最小宽度 <类型 = 整数 注释 = "指定所需求的最小宽度(数字数目),如果有效数值宽度小于该值,则自动在首部加0."
            注释 = "为0表示去除所有的前置\'0\'数字. 字节的十六进制文本不应大于4." @默认值 = 0>
    {
        @ TCHAR buf [16];
        @ return CVolString (WordToHexStr ((WORD)@<所欲转换的短整数>, @<所需要的最小宽度>, buf, NUM_ELEMENTS_OF (buf)));
    }

    方法 取字节十六进制文本 <公开 静态 类型 = 文本型 注释 = "返回所指定字节所对应的十六进制文本" 折叠 @禁止流程检查 = 真>
    参数 所欲转换的字节数 <类型 = 字节>
    参数 所需要的最小宽度 <类型 = 整数 注释 = "指定所需求的最小宽度(数字数目),如果有效数值宽度小于该值,则自动在首部加0."
            注释 = "为0表示去除所有的前置\'0\'数字. 字节的十六进制文本不应大于2." @默认值 = 0>
    {
        @ TCHAR buf [8];
        @ return CVolString (ByteToHexStr ((BYTE)@<所欲转换的字节数>, @<所需要的最小宽度>, buf, NUM_ELEMENTS_OF (buf)));
    }

    方法 反转字符字节序 <公开 静态 类型 = 字符 注释 = "  将所指定整数的组成字节的顺序反转,返回反转后的结果值.譬如十六进制整数0x12345678,"
            注释 = "反转后将返回0x78563412. 本命令在与类似Java这样的语言进行数据交互时很有用处." 折叠 @禁止流程检查 = 真>
    参数 所欲反转的字符 <类型 = 字符>
    {
        @ WCHAR wResult = ((@<所欲反转的字符> & 0x00FF) << 8);
        @ wResult |= ((@<所欲反转的字符> & 0xFF00) >> 8);
        @ return wResult;
    }

    方法 反转短整数字节序 <公开 静态 类型 = 短整数 注释 = "  将所指定整数的组成字节的顺序反转,返回反转后的结果值.譬如十六进制整数0x12345678,"
            注释 = "反转后将返回0x78563412. 本命令在与类似Java这样的语言进行数据交互时很有用处." 折叠 @禁止流程检查 = 真>
    参数 所欲反转的短整数 <类型 = 短整数>
    {
        @ WORD wResult = ((@<所欲反转的短整数> & 0x00FF) << 8);
        @ wResult |= ((@<所欲反转的短整数> & 0xFF00) >> 8);
        @ return (SHORT)wResult;
    }

    方法 任意进制文本到整数 <公开 静态 类型 = 整数 注释 = "任意进制文本到十进制整数." 返回值注释 = "转换完全失败会返回0." 折叠 @嵌入式方法 = "">
    参数 转换前的文本 <类型 = 文本型 注释 = "所欲转换的任意进制文本.">
    参数 转换前的进制 <类型 = 整数 注释 = "  文本的进制,范围为2-36进制."
            注释 = "  如果为0,则按文本的开头自动识别,如\"0x\"为16进制;\"0\"为8进制;\"1-9\"为10进制.">
    {
        @ (INT)wcstoul (@<转换前的文本>.GetText (), NULL, @<转换前的进制>)
    }

    方法 任意进制文本到长整数 <公开 静态 类型 = 长整数 注释 = "任意进制文本到十进制长整数." 返回值注释 = "转换完全失败会返回0." 折叠 @嵌入式方法 = "">
    参数 转换前的文本 <类型 = 文本型 注释 = "所欲转换的任意进制文本.">
    参数 转换前的进制 <类型 = 整数 注释 = "  文本的进制,范围为2-36进制."
            注释 = "  如果为0,则按文本的开头自动识别,如\"0x\"为16进制;\"0\"为8进制;\"1-9\"为10进制.">
    {
        @ (INT64)wcstoull (@<转换前的文本>.GetText (), NULL, @<转换前的进制>)
    }

    方法 任意进制文本到变整数 <公开 静态 类型 = 变整数 注释 = "任意进制文本到十进制变整数." 返回值注释 = "转换完全失败会返回0." 折叠 @禁止流程检查 = 真>
    参数 转换前的文本 <类型 = 文本型 注释 = "所欲转换的任意进制文本.">
    参数 转换前的进制 <类型 = 整数 注释 = "  文本的进制,范围为2-36进制."
            注释 = "  如果为0,则按文本的开头自动识别,如\"0x\"为16进制;\"0\"为8进制;\"1-9\"为10进制.">
    {
        @ #ifdef _PF_32_BITS
        @     return (INT_P)wcstoul (@<转换前的文本>.GetText (), NULL, @<转换前的进制>);
        @ #else
        @     return (INT_P)wcstoull (@<转换前的文本>.GetText (), NULL, @<转换前的进制>);
        @ #endif
    }

    方法 整数到任意进制文本 <公开 静态 类型 = 文本型 注释 = "十进制整数到任意进制文本." 折叠 @禁止流程检查 = 真>
    参数 转换前的整数 <类型 = 整数>
    参数 转换后的进制 <类型 = 整数 注释 = "2-36进制">
    {
        @ wchar_t buffer[32] { 0 };
        @ _itow (@<转换前的整数>, buffer, @<转换后的进制>);
        @ return @an<CVolString> (buffer).MakeUpper ();
    }

    方法 长整数到任意进制文本 <公开 静态 类型 = 文本型 注释 = "十进制整数到任意进制文本." 折叠 @禁止流程检查 = 真>
    参数 转换前的长整数 <类型 = 长整数>
    参数 转换后的进制 <类型 = 整数 注释 = "2-36进制">
    {
        @ wchar_t buffer[64] { 0 };
        @ _i64tow (@<转换前的长整数>, buffer, @<转换后的进制>);
        @ return @an<CVolString> (buffer).MakeUpper ();
    }

    方法 无符号长整数到任意进制文本 <公开 静态 类型 = 文本型 注释 = "十进制整数到任意进制文本." 折叠 @禁止流程检查 = 真>
    参数 转换前的长整数 <类型 = 长整数>
    参数 转换后的进制 <类型 = 整数 注释 = "2-36进制">
    {
        @ wchar_t buffer[64] { 0 };
        @ _ui64tow ((UINT64)@<转换前的长整数>, buffer, @<转换后的进制>);
        @ return @an<CVolString> (buffer).MakeUpper ();
    }

    方法 任意进制文本到任意进制文本 <公开 静态 类型 = 文本型 注释 = "2-36进制间的文本转换." 折叠>
    参数 转换前的文本 <类型 = 文本型>
    参数 转换前的进制 <类型 = 整数 注释 = "2-36进制">
    参数 转换后的进制 <类型 = 整数 注释 = "2-36进制">
    {
        变量 临时结果 <类型 = 长整数>
        临时结果 = 任意进制文本到长整数 (转换前的文本, 转换前的进制)
        返回 (长整数到任意进制文本 (临时结果, 转换后的进制))
    }

    方法 十六进制文本到变整数 <公开 静态 类型 = 变整数 注释 = "十六进制文本转换到十进制变整数." 折叠>
    参数 十六进制文本 <类型 = 文本型 注释 = "所欲转换的十六进制文本.">
    {
        返回 (任意进制文本到变整数 (十六进制文本, 16))
    }

    方法 取千位分隔数值文本 <公开 静态 类型 = 文本型 注释 = "使用千位分隔符格式化数值文本." 注释 = "例: 1,234,567,890." 折叠>
    参数 数值 <类型 = 长整数 注释 = "所欲格式化的数值,可以提供小于长整数的任意类型数值.">
    {
        变量 千位分隔文本 <类型 = 文本型>
        变量 文本长度 <类型 = 整数>
        变量 索引 <类型 = 整数>
        加入长整数文本 (千位分隔文本, 数值)
        文本长度 = 取文本长度 (千位分隔文本)
        如果 (文本长度 > 3)
        {
            循环 (文本长度, 0, 索引, -3)
            {
                插入字符 (千位分隔文本, 索引, ',')

            }
            如果 (是否以字符结束 (千位分隔文本, ',', 真) == 真)
            {
                删除字符 (千位分隔文本, 取文本长度 (千位分隔文本) - 1, 1)

            }
        }
        返回 (千位分隔文本)
    }

    方法 取格式字节文本 <公开 静态 类型 = 文本型 注释 = "返回适当单位的尺寸文本,根据字节数自动计算适合的单位(bytes、KB、MB、GB和TB)." 折叠
            @视窗.外部头文件 = "shlwapi.h" @视窗.外部库 = "Shlwapi.lib" @禁止流程检查 = 真>
    参数 字节数 <类型 = 长整数>
    {
        @ WCHAR szSizeStr[100] { 0 };
        @ return CVolString (::StrFormatByteSizeW (@<字节数>, szSizeStr, 100));
    }

    方法 取格式千字节文本 <公开 静态 类型 = 文本型 注释 = "返回KB单位的尺寸文本,会将字节数向上舍入取整,如小于1024也会返回\"1 KB\"." 折叠
            @视窗.外部头文件 = "shlwapi.h" @视窗.外部库 = "Shlwapi.lib" @禁止流程检查 = 真>
    参数 字节数 <类型 = 长整数>
    {
        @ WCHAR szSizeStr[100] { 0 };
        @ return CVolString (::StrFormatKBSizeW (@<字节数>, szSizeStr, 100));
    }

    方法 文本到Usc2编码 <公开 静态 类型 = 文本型 注释 = "将文本数据转换到Unicode编码." 注释 = "例: \"测试\"转换成\"\\u6d4b\\u8bd5\"" 折叠>
    参数 欲编码文本 <类型 = 文本型>
    参数 不编码ASCII字符 <类型 = 逻辑型 注释 = "不对英文字母、数字、常用标点符号进行编码" @默认值 = 真>
    参数 仅编码非常用字符 <类型 = 逻辑型 注释 = "仅编码ANSI编码不支持显示的字符" @默认值 = 假>
    {
        变量 长度 <类型 = 整数>
        变量 字符值 <类型 = 字符>
        变量 UC2编码 <类型 = 文本型>
        长度 = 取文本长度 (欲编码文本)
        置文本预分配字符数 (UC2编码, 长度 * 6)
        计次循环 (长度)
        {
            字符值 = 取字符 (欲编码文本, 取循环索引 ())
            如果 (字符值 < 128)
            {
                如果 (不编码ASCII字符)
                {
                    加入字符 (UC2编码, 字符值)
                }
                否则
                {
                    加入文本 (UC2编码, "\\u")
                    加入文本 (UC2编码, 到小写 (取字符十六进制文本 (字符值, 4)))
                }
            }
            否则
            {
                如果 (仅编码非常用字符)
                {
                    变量 测试字 <类型 = 文本型>
                    加入字符 (测试字, 字符值)
                    测试字 = 多字节到文本 (文本到多字节 (测试字, 假))
                    如果 (测试字 != "?" && 测试字 != "" && 取文本长度 (测试字) == 1)
                    {
                        加入字符 (UC2编码, 字符值)
                        到循环尾
                    }
                }
                加入文本 (UC2编码, "\\u")
                加入文本 (UC2编码, 到小写 (取字符十六进制文本 (字符值, 4)))
            }
        }
        返回 (UC2编码)
    }

    方法 Usc2编码到文本 <公开 静态 类型 = 文本型 注释 = "将Unicode编码还原为文本数据." 注释 = "例: \"\\u6d4b\\u8bd5\"转换成\"测试\"" 折叠>
    参数 解码前的文本 <类型 = 文本型>
    参数 前缀 <类型 = 文本型 @默认值 = "\\u">
    {
        变量 结果 <类型 = 文本型>
        变量 找到的位置 <类型 = 整数>
        结果 = 解码前的文本
        找到的位置 = 寻找文本 (结果, 前缀, 0)
        判断循环 (找到的位置 != -1 && 取文本长度 (结果) >= 找到的位置 + 6)
        {
            变量 字符值 <类型 = 字符>
            字符值 = (字符)十六进制文本到整数 (取文本中间 (结果, 找到的位置 + 2, 4))
            删除字符 (结果, 找到的位置, 6)
            插入字符 (结果, 找到的位置, 字符值)
            找到的位置 = 寻找文本 (结果, 前缀, 找到的位置)

        }
        返回 (结果)
    }

    方法 整数到中文小写数字 <公开 静态 类型 = 文本型 注释 = "将整数值格式化为中文小写数字." 注释 = "例: 12345 转换为“一万二千三百四十五”."
            注释 = "\"数值到大写\"的二次封装,区别是从小数改为整数值." 折叠 @禁止流程检查 = 真>
    参数 数字值 <类型 = 长整数 注释 = "进行转换的数字值,可以为字节、字符、短整数、整数、长整数等类型." "">
    {
        @ CVolString strResult;
        @ NumberToCNText ((DOUBLE)@<数字值>, TRUE, strResult);
        @ return strResult;
    }

    方法 整数到中文大写数字 <公开 静态 类型 = 文本型 注释 = "将整数值格式化为中文大写数字." 注释 = "例: 12345 转换为“壹万贰仟叁佰肆拾伍”."
            注释 = "\"数值到大写\"的二次封装,区别是从小数改为整数值." 折叠 @禁止流程检查 = 真>
    参数 数字值 <类型 = 长整数 注释 = "进行转换的数字值,可以为字节、字符、短整数、整数、长整数等类型.">
    {
        @ CVolString strResult;
        @ NumberToCNText ((DOUBLE)@<数字值>, FALSE, strResult);
        @ return strResult;
    }

    方法 小数到中文小写数字 <公开 静态 类型 = 文本型 注释 = "将小数值格式化为中文小写数字." 注释 = "例: 12345.55 转换为“一万二千三百四十五.五五”."
            注释 = "\"数值到大写\"的二次封装,区别是\"点\"改用了\".\"符号." 折叠 @禁止流程检查 = 真>
    参数 数字值 <类型 = 小数 注释 = "进行转换的数字值">
    参数 小数位数 <类型 = 整数 注释 = "指定保留的小数位数,必须大于等于0" @默认值 = 2>
    {
        @ CVolString strResult;
        @ NumberToCNText (RoundDouble (@<数字值>, @<小数位数>), TRUE, strResult);
        @ strResult.ReplaceSubText (_CT ("点"), _CT ("."), 0, 1, FALSE);
        @ return strResult;
    }

    方法 小数到中文大写数字 <公开 静态 类型 = 文本型 注释 = "将小数值格式化为中文大写数字." 注释 = "例: 12345.55 转换为“壹万贰仟叁佰肆拾伍.伍伍”."
            注释 = "\"数值到大写\"的二次封装,区别是\"点\"改用了\".\"符号." 折叠 @禁止流程检查 = 真>
    参数 数字值 <类型 = 小数 注释 = "进行转换的数字值">
    参数 小数位数 <类型 = 整数 注释 = "指定保留的小数位数,必须大于等于0" @默认值 = 2>
    {
        @ CVolString strResult;
        @ NumberToCNText (RoundDouble (@<数字值>, @<小数位数>), FALSE, strResult);
        @ strResult.ReplaceSubText (_CT ("点"), _CT ("."), 0, 1, FALSE);
        @ return strResult;
    }

    方法 小数到中文小写金额 <公开 静态 类型 = 文本型 注释 = "将小数值格式化为中文小写金额." 注释 = "例: 12345.50 转换为“人民币一万二千三百四十五元五角”."
            注释 = "\"数值到金融\"的二次封装,区别是带了\"人民币\"前缀." 折叠 @禁止流程检查 = 真>
    参数 数字值 <类型 = 小数 注释 = "进行转换的数字值">
    参数 前缀文本 <类型 = 文本型 @默认值 = "人民币">
    {
        @ CVolString strResult;
        @ NumberToCurrency (@<数字值>, TRUE, strResult);
        @ strResult.InsertText (0, @<前缀文本>.GetText ());
        @ return strResult;
    }

    方法 小数到中文大写金额 <公开 静态 类型 = 文本型 注释 = "将小数值格式化为中文大写金额." 注释 = "例: 12345.50 转换为“人民币壹万贰仟叁佰肆拾伍元伍角”."
            注释 = "\"数值到金融\"的二次封装,区别是带了\"人民币\"前缀." 折叠 @禁止流程检查 = 真>
    参数 数字值 <类型 = 小数 注释 = "进行转换的数字值">
    参数 前缀文本 <类型 = 文本型 @默认值 = "人民币">
    {
        @ CVolString strResult;
        @ NumberToCurrency (@<数字值>, FALSE, strResult);
        @ strResult.InsertText (0, @<前缀文本>.GetText ());
        @ return strResult;
    }
}

# ===

类 simdUTF <公开 注释 = "  使用SIMD指令集(SSE2, AVX2, NEON, AVX-512)加速," 注释 = "每秒数十亿字符的Unicode编码验证和转换库."
        注释 = "  源码: https://github.com/simdutf/simdutf" 注释 = "  版本: 3.2.15 2023/09/15" 折叠
        @文档 = "category = \"编码处理\"" @禁止创建对象 = 真 @视窗.外部头文件 = "src\\piv_simdutf.hpp"
        @视窗.外部源文件 = "src\\simdutf.cpp">
{

    # 常用编码转换 ---

    方法 UTF8到文本 <公开 静态 类型 = 文本型 注释 = "将所指定UTF-8格式的文本数据转换到UTF-16LE文本后返回." 折叠 @嵌入式方法 = "">
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ piv::utf::utf8_to_utf16le (@<UTF8文本>, @<是否校验文本>)
    }

    方法 文本到UTF8 <公开 静态 类型 = 字节集类 注释 = "将UTF-16LE文本转换到UTF-8字节集后返回." 折叠 @嵌入式方法 = "">
    参数 UTF16文本 <类型 = 文本型 注释 = "提供所欲转换的UTF-16LE文本">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ piv::utf::utf16le_to_utf8 (@<UTF16文本>, @<是否包括结束零字符>, @<是否校验文本>)
    }

    方法 多字节到UTF8 <公开 静态 类型 = 字节集类 注释 = "将所指定ANSI多字节数据转换到UTF-8字节集后返回." 折叠 @嵌入式方法 = "">
    参数 多字节文本 <类型 = 字节集类 注释 = "提供所欲转换的ANSI多字节编码文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ piv::utf::ansi_to_utf8 (@<多字节文本>, @<是否包括结束零字符>, @<是否校验文本>)
    }

    方法 UTF8到多字节 <公开 静态 类型 = 字节集类 注释 = "将所指定UTF-8格式数据转换到ANSI多字节后返回." 折叠 @嵌入式方法 = "">
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ piv::utf::utf8_to_ansi (@<UTF8文本>, @<是否包括结束零字符>, @<是否校验文本>)
    }

    方法 UTF8到文本_Ex <公开 静态 类型 = 整数 注释 = "将所指定UTF-8格式的文本数据转换到UTF-16LE文本." 注释 = "跟\"UTF8到文本\"的区别是在参数中返回转换后的数据."
            返回值注释 = "返回UTF-16LE文本的字符数(2字节),失败返回0." 折叠 @嵌入式方法 = "">
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据">
    参数 UTF16文本 <类型 = 文本型 注释 = "转换后的UTF-16LE文本将保存在此参数中">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ static_cast<INT>(piv::utf::utf8_to_utf16le (@<UTF8文本>, @<UTF16文本>, @<是否校验文本>))
    }

    方法 文本到UTF8_Ex <公开 静态 类型 = 整数 注释 = "将UTF-16LE文本转换到UTF-8字节集." 注释 = "跟\"文本到UTF8\"的区别是在参数中返回转换后的数据."
            返回值注释 = "返回UTF-8文本的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 UTF16文本 <类型 = 文本型 注释 = "提供所欲转换的UTF-16LE文本">
    参数 UTF8文本 <类型 = 字节集类 注释 = "转换后的UTF-8文本将保存在此参数中">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ static_cast<INT>(piv::utf::utf16le_to_utf8 (@<UTF16文本>, @<UTF8文本>, @<是否包括结束零字符>, @<是否校验文本>))
    }

    方法 多字节到UTF8_Ex <公开 静态 类型 = 整数 注释 = "将所指定ANSI多字节数据转换到UTF-8字节集." 注释 = "跟\"多字节到UTF8\"的区别是在参数中返回转换后的数据."
            返回值注释 = "返回UTF-8文本的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 多字节文本 <类型 = 字节集类 注释 = "提供所欲转换的ANSI多字节编码文本数据">
    参数 UTF8文本 <类型 = 字节集类 注释 = "转换后的UTF-8文本将保存在此参数中">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ static_cast<INT>(piv::utf::ansi_to_utf8 (@<多字节文本>, @<UTF8文本>, @<是否包括结束零字符>, @<是否校验文本>))
    }

    方法 UTF8到多字节_Ex <公开 静态 类型 = 整数 注释 = "将所指定UTF-8格式数据转换到ANSI多字节." 注释 = "跟\"UTF8到多字节\"的区别是在参数中返回转换后的数据."
            返回值注释 = "返回多字节文本的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据">
    参数 多字节文本 <类型 = 字节集类 注释 = "转换后的ANSI多字节文本将保存在此参数中">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ static_cast<INT>(piv::utf::utf8_to_ansi (@<UTF8文本>, @<多字节文本>, @<是否包括结束零字符>, @<是否校验文本>))
    }

    方法 反转文本字节序 <公开 静态 类型 = 字节集类 注释 = "  将提供的数据反转字节序,比如将输入的UTF-16LE转换为"
            注释 = "UTF-16BE,或者将UTF-16BE转换为UTF-16LE." 返回值注释 = "返回反转后的UTF-16编码数据" 折叠 @嵌入式方法 = "">
    参数 UTF16数据 <类型 = 字节集类 注释 = "所欲反转字节序的UTF-16编码数据">
    {
        @ piv::utf::change_endianness_utf16 (@<UTF16数据>)
    }

    # 编码检测 ---

    方法 自动检测编码 <公开 静态 类型 = 整数 注释 = "  自动检测文本数据的Unicode编码类型,本方法只返回一个结果." 注释 = "  本方法不支持检测ANSI的编码,统一返回0(未知)."
            返回值注释 = "请参考\"SIMD编码类型\"的常量,本方法只返回其中一个值." 折叠 @嵌入式方法 = "">
    参数 文本数据 <类型 = 字节集类 注释 = "所欲检测Unicode编码的文本数据.">
    {
        @ piv::utf::autodetect_encoding (@<文本数据>)
    }

    方法 检测编码 <公开 静态 类型 = 整数 注释 = "  检测文本数据的Unicode编码类型,如果检测的结果可能是UTF8或UTF-16LE,"
            注释 = "它将返回\"SIMD编码类型.UTF8 | SIMD编码类型.UTF-16LE\"的位或值." 注释 = "  本方法不支持检测ANSI的编码,统一返回0(未知)."
            返回值注释 = "返回的结果可能是\"SIMD编码类型\"常量的位或值,请通过\"位与\"判断类型." 折叠 @嵌入式方法 = "">
    参数 文本数据 <类型 = 字节集类>
    {
        @ piv::utf::detect_encodings (@<文本数据>)
    }

    # UTF-8转换到其他 ---

    方法 UTF8到UTF16LE <公开 静态 类型 = 字节集类 注释 = "将所指定UTF-8格式的文本数据转换到UTF-16LE字节集后返回." 折叠 @嵌入式方法 = "">
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ piv::utf::utf8_to_utf16le (@<UTF8文本>, @<是否包括结束零字符>, @<是否校验文本>)
    }

    方法 UTF8到UTF16BE <公开 静态 类型 = 字节集类 注释 = "将所指定UTF-8格式的文本数据转换到UTF-16BE字节集后返回." 折叠 @嵌入式方法 = "">
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ piv::utf::utf8_to_utf16Be (@<UTF8文本>, @<是否包括结束零字符>, @<是否校验文本>)
    }

    方法 UTF8到UTF32 <公开 静态 类型 = 字节集类 注释 = "将所指定UTF-8格式的文本数据转换到UTF-32文本数据后返回." 折叠 @嵌入式方法 = "">
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ piv::utf::utf8_to_utf32 (@<UTF8文本>, @<是否包括结束零字符>, @<是否校验文本>)
    }

    方法 UTF8到UTF16LE_Ex <公开 静态 类型 = 整数 注释 = "将所指定UTF-8格式的文本数据转换到UTF-16LE字节集."
            注释 = "跟\"UTF8到UTF16LE\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-16LE文本的字符数(2字节),失败返回0." 折叠 @嵌入式方法 = "">
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据">
    参数 UTF16文本 <类型 = 字节集类 注释 = "转换后的UTF-16LE文本将保存在此参数中">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ static_cast<INT>(piv::utf::utf8_to_utf16le (@<UTF8文本>, @<UTF16文本>, @<是否包括结束零字符>, @<是否校验文本>))
    }

    方法 UTF8到UTF16BE_Ex <公开 静态 类型 = 整数 注释 = "将所指定UTF-8格式的文本数据转换到UTF-16BE字节集."
            注释 = "跟\"UTF8到UTF16BE\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-16BE文本的字符数(2字节),失败返回0." 折叠 @嵌入式方法 = "">
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据">
    参数 UTF16文本 <类型 = 字节集类 注释 = "转换后的UTF-16BE文本将保存在此参数中">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ static_cast<INT>(piv::utf::utf8_to_utf16Be (@<UTF8文本>, @<UTF16文本>, @<是否包括结束零字符>, @<是否校验文本>))
    }

    方法 UTF8到UTF32_Ex <公开 静态 类型 = 整数 注释 = "将所指定UTF-8格式的文本数据转换到UTF-32文本数据."
            注释 = "跟\"UTF8到UTF32\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-32文本的字符数(4字节),失败返回0." 折叠 @嵌入式方法 = "">
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据">
    参数 UTF32文本 <类型 = 字节集类 注释 = "转换后的UTF-32文本将保存在此参数中">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ static_cast<INT>(piv::utf::utf8_to_utf32 (@<UTF8文本>, @<UTF32文本>, @<是否包括结束零字符>, @<是否校验文本>))
    }

    # UTF-16转换到其他 ---

    方法 文本到UTF32 <公开 静态 类型 = 字节集类 注释 = "将UTF-16LE文本转换到UTF-32字节集后返回." 折叠 @嵌入式方法 = "">
    参数 UTF16文本 <类型 = 文本型 注释 = "提供所欲转换的UTF-16LE文本">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ piv::utf::utf16le_to_utf32 (@<UTF16文本>, @<是否包括结束零字符>, @<是否校验文本>)
    }

    方法 UTF16LE到UTF8 <公开 静态 类型 = 字节集类 注释 = "将UTF-16LE文本数据转换到UTF-8字节集后返回." 折叠 @嵌入式方法 = "">
    参数 UTF16文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-16LE文本">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ piv::utf::utf16le_to_utf8 (@<UTF16文本>, @<是否包括结束零字符>, @<是否校验文本>)
    }

    方法 UTF16LE到UTF32 <公开 静态 类型 = 字节集类 注释 = "将UTF-16LE文本转换到UTF-32字节集后返回." 折叠 @嵌入式方法 = "">
    参数 UTF16文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-16LE文本">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ piv::utf::utf16le_to_utf32 (@<UTF16文本>, @<是否包括结束零字符>, @<是否校验文本>)
    }

    方法 UTF16BE到UTF8 <公开 静态 类型 = 字节集类 注释 = "将UTF-16BE文本数据转换到UTF-8字节集后返回." 折叠 @嵌入式方法 = "">
    参数 UTF16文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-16BE文本">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ piv::utf::utf16be_to_utf8 (@<UTF16文本>, @<是否包括结束零字符>, @<是否校验文本>)
    }

    方法 UTF16BE到UTF32 <公开 静态 类型 = 字节集类 注释 = "将UTF-16BE文本数据转换到UTF-32字节集后返回." 折叠 @嵌入式方法 = "">
    参数 UTF16文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-16BE文本">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ piv::utf::utf16be_to_utf32 (@<UTF16文本>, @<是否包括结束零字符>, @<是否校验文本>)
    }

    方法 文本到UTF32_Ex <公开 静态 类型 = 整数 注释 = "将UTF-16LE文本转换到UTF-32字节集后返回." 注释 = "跟\"文本到UTF32\"的区别是在参数中返回转换后的数据."
            返回值注释 = "返回UTF-32文本的字符数(4字节),失败返回0." 折叠 @嵌入式方法 = "">
    参数 UTF16文本 <类型 = 文本型 注释 = "提供所欲转换的UTF-16LE文本">
    参数 UTF32文本 <类型 = 字节集类 注释 = "转换后的UTF-32文本将保存在此参数中">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ static_cast<INT>(piv::utf::utf16le_to_utf32 (@<UTF16文本>, @<UTF32文本>, @<是否包括结束零字符>, @<是否校验文本>)
    }

    方法 UTF16LE到UTF8_Ex <公开 静态 类型 = 整数 注释 = "将UTF-16LE文本数据转换到UTF-8字节集."
            注释 = "跟\"UTF16LE到UTF8\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-8文本的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 UTF16文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-16LE文本">
    参数 UTF8文本 <类型 = 字节集类 注释 = "转换后的UTF-8文本将保存在此参数中">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ static_cast<INT>(piv::utf::utf16le_to_utf8 (@<UTF16文本>, @<UTF8文本>, @<是否包括结束零字符>, @<是否校验文本>))
    }

    方法 UTF16LE到UTF32_Ex <公开 静态 类型 = 整数 注释 = "将UTF-16LE文本转换到UTF-32字节集."
            注释 = "跟\"UTF16LE到UTF32\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-32文本的字符数(4字节),失败返回0." 折叠 @嵌入式方法 = "">
    参数 UTF16文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-16LE文本">
    参数 UTF32文本 <类型 = 字节集类 注释 = "转换后的UTF-32文本将保存在此参数中">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ static_cast<INT>(piv::utf::utf16le_to_utf32 (@<UTF16文本>, @<UTF32文本>, @<是否包括结束零字符>, @<是否校验文本>))
    }

    方法 UTF16BE到UTF8_Ex <公开 静态 类型 = 整数 注释 = "将UTF-16BE文本数据转换到UTF-8字节集."
            注释 = "跟\"UTF16BE到UTF8\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-8文本的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 UTF16文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-16BE文本">
    参数 UTF8文本 <类型 = 字节集类 注释 = "转换后的UTF-8文本将保存在此参数中">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ static_cast<INT>(piv::utf::utf16be_to_utf8 (@<UTF16文本>, @<UTF8文本>, @<是否包括结束零字符>, @<是否校验文本>))
    }

    方法 UTF16BE到UTF32_Ex <公开 静态 类型 = 整数 注释 = "将UTF-16BE文本数据转换到UTF-32字节集."
            注释 = "跟\"UTF16BE到UTF32\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-32文本的字符数(4字节),失败返回0." 折叠 @嵌入式方法 = "">
    参数 UTF16文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-16BE文本">
    参数 UTF32文本 <类型 = 字节集类 注释 = "转换后的UTF-32文本将保存在此参数中">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ static_cast<INT>(piv::utf::utf16be_to_utf32 (@<UTF16文本>, @<UTF32文本>, @<是否包括结束零字符>, @<是否校验文本>))
    }

    # UTF-32转换到其他 ---

    方法 UTF32到UTF8 <公开 静态 类型 = 字节集类 注释 = "将UTF-32文本数据转换到UTF-8字节集后返回." 折叠 @嵌入式方法 = "">
    参数 UTF32文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-32字符集文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ piv::utf::utf32_to_utf8 (@<UTF32文本>, @<是否包括结束零字符>, @<是否校验文本>)
    }

    方法 UTF32到文本 <公开 静态 类型 = 文本型 注释 = "将UTF-32文本数据转换到UTF-16LE文本后返回." 折叠 @嵌入式方法 = "">
    参数 UTF32文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-32字符集文本数据">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ piv::utf::utf32_to_utf16le (@<UTF32文本>, @<是否校验文本>)
    }

    方法 UTF32到UTF16LE <公开 静态 类型 = 文本型 注释 = "将UTF-32文本数据转换到UTF-16LE字节集后返回." 折叠 @嵌入式方法 = "">
    参数 UTF32文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-32字符集文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ piv::utf::utf32_to_utf16le (@<UTF32文本>, @<是否包括结束零字符>, @<是否校验文本>)
    }

    方法 UTF32到UTF16BE <公开 静态 类型 = 字节集类 注释 = "将UTF-32文本数据转换到UTF-16BE字节集后返回." 折叠 @嵌入式方法 = "">
    参数 UTF32文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-32字符集文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ piv::utf::utf32_to_utf16be (@<UTF32文本>, @<是否包括结束零字符>, @<是否校验文本>)
    }

    方法 UTF32到UTF8_Ex <公开 静态 类型 = 整数 注释 = "将UTF-32文本数据转换到UTF-8字节集." 注释 = "跟\"UTF32到UTF8\"的区别是在参数中返回转换后的数据."
            返回值注释 = "返回UTF-8文本的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 UTF32文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-32LE字符集文本数据">
    参数 UTF8文本 <类型 = 字节集类 注释 = "转换后的UTF-8文本将保存在此参数中">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ static_cast<INT>(piv::utf::utf32_to_utf8 (@<UTF32文本>, @<UTF8文本>, @<是否包括结束零字符>, @<是否校验文本>))
    }

    方法 UTF32到文本_Ex <公开 静态 类型 = 整数 注释 = "将UTF-32文本数据转换到UTF-16LE文本." 注释 = "跟\"UTF32到文本\"的区别是在参数中返回转换后的数据."
            返回值注释 = "返回UTF-16LE文本的字符数(2字节),失败返回0." 折叠 @嵌入式方法 = "">
    参数 UTF32文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-32字符集文本数据">
    参数 UTF16文本 <类型 = 文本型 注释 = "转换后的UTF-16LE文本将保存在此参数中">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ static_cast<INT>(piv::utf::utf32_to_utf16le (@<UTF32文本>, @<UTF16文本>, @<是否校验文本>))
    }

    方法 UTF32到UTF16LE_Ex <公开 静态 类型 = 整数 注释 = "将UTF-32文本数据转换到UTF-16LE字节集."
            注释 = "跟\"UTF32到UTF16LE\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-16LE文本的字符数(2字节),失败返回0." 折叠 @嵌入式方法 = "">
    参数 UTF32文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-32字符集文本数据">
    参数 UTF16文本 <类型 = 字节集类 注释 = "转换后的UTF-16LE文本将保存在此参数中">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ static_cast<INT>(piv::utf::utf32_to_utf16le (@<UTF32文本>, @<UTF16文本>, @<是否包括结束零字符>, @<是否校验文本>))
    }

    方法 UTF32到UTF16BE_Ex <公开 静态 类型 = 整数 注释 = "将UTF-32文本数据转换到UTF-16BE字节集."
            注释 = "跟\"UTF32到UTF16BE\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-16BE文本的字符数(2字节),失败返回0." 折叠 @嵌入式方法 = "">
    参数 UTF32文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-32字符集文本数据">
    参数 UTF16文本 <类型 = 字节集类 注释 = "转换后的UTF-16BE文本将保存在此参数中">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        @ static_cast<INT>(piv::utf::utf32_to_utf16be (@<UTF32文本>, @<UTF16文本>, @<是否包括结束零字符>, @<是否校验文本>))
    }

    # 验证文本 ---

    方法 验证UTF8 <公开 静态 类型 = 逻辑型 注释 = "验证指定的字节集是否为有效的UTF-8文本数据." 折叠 @嵌入式方法 = "">
    参数 文本数据 <类型 = 字节集类 注释 = "提供所欲验证的UTF8编码文本数据">
    {
        @ piv::utf::validate_utf8 (@<文本数据>)
    }

    方法 验证ASCII <公开 静态 类型 = 逻辑型 注释 = "验证指定的字节集是否为有效的ASCII文本数据." 注释 = "只能验证可打印的ASCII字符,数据中含中文等字符会返回假." 折叠
            @嵌入式方法 = "">
    参数 文本数据 <类型 = 字节集类 注释 = "提供所欲验证的ASCII编码文本数据">
    {
        @ piv::utf::validate_ascii (@<文本数据>)
    }

    方法 验证UTF16LE <公开 静态 类型 = 逻辑型 注释 = "验证指定的字节集是否为有效的UTF-16LE文本数据." 折叠 @嵌入式方法 = "">
    参数 文本数据 <类型 = 字节集类 注释 = "提供所欲验证的UTF-16LE编码文本数据">
    {
        @ piv::utf::validate_utf16le (@<文本数据>)
    }

    方法 验证UTF16BE <公开 静态 类型 = 逻辑型 注释 = "验证指定的字节集是否为有效的UTF-16BE文本数据." 折叠 @嵌入式方法 = "">
    参数 文本数据 <类型 = 字节集类 注释 = "提供所欲验证的UTF-16BE编码文本数据">
    {
        @ piv::utf::validate_utf16be (@<文本数据>)
    }

    方法 验证UTF32 <公开 静态 类型 = 逻辑型 注释 = "验证指定的字节集是否为有效的UTF-32文本数据." 折叠 @嵌入式方法 = "">
    参数 文本数据 <类型 = 字节集类 注释 = "提供所欲验证的UTF-32编码文本数据">
    {
        @ piv::utf::validate_utf32 (@<文本数据>)
    }

    # 获取文本长度 ---

    方法 取UTF8长度 <公开 静态 类型 = 整数 注释 = "获取UTF-8文本数据的有效字符长度(1个字符可能占1到4字节)." 折叠 @嵌入式方法 = "">
    参数 UTF8文本数据 <类型 = 字节集类 注释 = "提供所欲取字符数量的UTF-8字符集文本数据">
    {
        @ piv::utf::count_utf8 (@<UTF8文本数据>)
    }

    方法 取UTF16LE长度 <公开 静态 类型 = 整数 注释 = "获取UTF-16LE文本数据的有效字符长度(1个字符占2字节)." 折叠 @嵌入式方法 = "">
    参数 UTF16文本数据 <类型 = 字节集类 注释 = "提供所欲取字符数量的UTF-16LE字符集文本数据">
    {
        @ piv::utf::count_utf16le (@<UTF16文本数据>)
    }

    方法 取UTF16BE长度 <公开 静态 类型 = 整数 注释 = "获取UTF-16BE文本数据的有效字符长度(1个字符占2字节)." 折叠 @嵌入式方法 = "">
    参数 UTF16文本数据 <类型 = 字节集类 注释 = "提供所欲取字符数量的UTF-16BE字符集文本数据">
    {
        @ piv::utf::count_utf16be (@<UTF16文本数据>)
    }
}

类 SIMD编码类型 <公开 注释 = "\"simdUTF\"检测编码的返回值" 折叠 @文档 = "category = \"编码处理.辅助类\"">
{
    常量 未知 <公开 类型 = 整数 值 = 0>
    常量 UTF8 <公开 类型 = 整数 值 = 1>
    常量 UTF16_LE <公开 类型 = 整数 值 = 2>
    常量 UTF16_BE <公开 类型 = 整数 值 = 4>
    常量 UTF32_LE <公开 类型 = 整数 值 = 8>
    常量 UTF32_BE <公开 类型 = 整数 值 = 16>
    常量 Latin1 <公开 类型 = 整数 值 = 32>
}

# ===

类 BASE编解码类 <公开 注释 = "Base91、Base85编解码." 注释 = "源码: https://github.com/r-lyeh-archived/base"
        注释 = "针对火山对源码进行了大量修改" 折叠 @文档 = "category = \"编码处理\"" @视窗.外部头文件 = "src\\piv_encoding.hpp" @禁止创建对象 = 真
        @全局类 = 真>
{
    方法 字节集到BASE91文本 <公开 静态 类型 = 文本型 注释 = "将字节集数据转换为BASE91编码格式文本." 注释 = "保留ASCII字符为{<>\"}." 折叠 @嵌入式方法 = "">
    参数 所欲编码数据 <类型 = 字节集类>
    {
        @ piv::base91<wchar_t>{}.Encode (@<所欲编码数据>)
    }

    方法 BASE91文本到字节集 <公开 静态 类型 = 字节集类 注释 = "将BASE91编码格式文本解码为对应的字节集后返回." 注释 = "保留ASCII字符为{<>\"}." 折叠
            @嵌入式方法 = "">
    参数 BASE91编码文本 <类型 = 文本型>
    {
        @ piv::base91<wchar_t>{}.Decode (@<BASE91编码文本>)
    }

    方法 字节集到BASE85文本 <公开 静态 类型 = 文本型 注释 = "将字节集数据转换为BASE85编码格式文本." 返回值注释 = "编码失败时返回空文本" 折叠 @嵌入式方法 = "">
    参数 所欲编码数据 <类型 = 字节集类>
    参数 自动填充 <类型 = 逻辑型 注释 = "为真时将在内部自动填充编码数据,以满足字节对齐为4的倍数." 注释 = "如果为假,编码数据的长度必须为4的倍数,否则将失败返回空文本." @默认值 = 真>
    {
        @ piv::base85<wchar_t>{}.Encode (@<所欲编码数据>, @<自动填充>)
    }

    方法 BASE85文本到字节集 <公开 静态 类型 = 字节集类 注释 = "将BASE85编码格式文本解码为对应的字节集后返回." 返回值注释 = "解码失败时返回空字节集" 折叠 @嵌入式方法 = "">
    参数 BASE85编码文本 <类型 = 文本型 注释 = "BASE85文本的长度必须为5的倍数,否则将解码失败.">
    {
        @ piv::base85<wchar_t>{}.Decode (@<BASE85编码文本>)
    }
}

# ===

类 MD5校验类 <公开 注释 = "  比\"CNG加解密\"和\"OpenSSL\"的MD5略快,取文件MD5时会自动" 注释 = "分段校验,不需要打开整个文件,适合处理大文件."
        注释 = "  源码: https://github.com/ulwanski/md5" 注释 = "  针对火山对源码进行了大量修改" 折叠 @文档 = "category = \"加解密\""
        @视窗.外部头文件 = "src\\detail\\piv_md5.hpp" @禁止创建对象 = 真>
{
    常量 空数据 <公开 类型 = 文本型 值 = "D41D8CD98F00B204E9800998ECF8427E" 注释 = "这是空数据的MD5,可以通过比较判断是否成功执行了MD5校验.">

    方法 取文件MD5 <公开 静态 类型 = 文本型 注释 = "获取指定文件的MD5数据摘要(32个字符)" 返回值注释 = "打开文件失败会返回空文本" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲计算摘要的文件名">
    参数 是否大写 <类型 = 逻辑型 注释 = "默认返回大写字符,为假时返回小写字符." @默认值 = 真>
    参数 文件偏移 <类型 = 长整数 注释 = "  指定是否跳过文件开头的一部分数据,应提供大于等于0的值,0表示从文件" 注释 = "首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    {
        @ piv::GetFileMd5 (@<文件名>.GetText (), @<是否大写>, @<文件偏移>, (uint64_t)@<数据长度>)
    }

    方法 取数据MD5 <公开 静态 类型 = 文本型 注释 = "获取指定数据的MD5数据摘要(32个字符)" 返回值注释 = "可以与\"MD5校验类.空数据\"判断是否校验了有效的数据" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 是否大写 <类型 = 逻辑型 注释 = "默认返回大写字符,为假时返回小写字符." @默认值 = 真>
    {
        @ piv::GetDataMd5 (@<数据>, @<是否大写>)
    }

    方法 取资源MD5 <公开 静态 类型 = 文本型 注释 = "获取指定视窗文件资源的MD5数据摘要(32个字符)" 返回值注释 = "可以与\"MD5校验类.空数据\"判断是否校验了有效的数据" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 文件资源 <类型 = 视窗文件资源 注释 = "提供所欲计算摘要的视窗文件资源">
    参数 是否大写 <类型 = 逻辑型 注释 = "默认返回大写字符,为假时返回小写字符." @默认值 = 真>
    {
        @ piv::GetDataMd5 (@<文件资源>, @<是否大写>)
    }

    方法 取数据简短MD5 <公开 静态 类型 = 文本型 注释 = "获取指定数据的简短MD5数据摘要(6个字符)" 折叠 @嵌入式方法 = "">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    {
        @ piv::GetDataMd5sum6 (@<数据>)
    }
}

类 xxHash类 <公开 注释 = "  速度最快的摘要算法之一,工作速度接近内存的速度限制," 注释 = "其中XXH128比MD5快几倍以上."
        注释 = "  源码: https://github.com/Cyan4973/xxHash" 注释 = "  内部有4个不同版本和长度的子算法,速度比较:"
        注释 = "  XXH3(64位) > XXH128 > XXH64 > XXH32" 折叠 @文档 = "category = \"加解密\""
        @视窗.外部头文件 = "src\\detail\\piv_xxhash.hpp" @禁止创建对象 = 真>
{
    方法 取版本号 <公开 静态 类型 = 整数 注释 = "返回xxHash的版本号" 折叠 @嵌入式方法 = "">
    {
        @ (INT)XXH_INLINE_XXH_versionNumber()
    }

    方法 生成密码 <公开 静态 类型 = 字节集类 注释 = "从自定义密码种子中生成一个指定长度的密码" 返回值注释 = "返回所生成的高熵密码,失败返回空字节集." 折叠 @嵌入式方法 = "">
    参数 密码长度 <类型 = 整数 注释 = "提供所欲生成的密码长度,必须大于136">
    参数 自定义种子 <类型 = 字节集类 注释 = "提供一个自定义的密码种子,为空时将使用内部的默认密码作为种子." @默认值 = 空对象>
    {
        @ piv::hash::Generate_Secret (@<密码长度>, @<自定义种子>)
    }

    方法 生成密码_192 <公开 静态 类型 = 字节集类 注释 = "从64位整数种子值生成一个192字节长度的密码" 返回值注释 = "返回所生成的高熵密码" 折叠 @嵌入式方法 = "">
    参数 种子 <类型 = 长整数 注释 = "使用相同的种子值会生成一样的密码">
    {
        @ piv::hash::Generate_Secret_fromSeed ((uint64_t)@<种子>)
    }

    # XXH3(128位) ---

    方法 取数据XXH128 <公开 静态 类型 = 文本型 注释 = "计算指定数据的XXH3(128位)数据摘要,返回十六进制文本结果(32个字符)." 返回值注释 = "数据为空仍会返回非0的哈希值"
            折叠 @嵌入式方法 = "">
    参数 数据 <注释 = "提供所欲计算摘要的数据,支持以下数据类型:" 注释 = " 字节集类、文本型、变整数(地址)、标准文本类(A/U)、文本视图类(A/U)" @匹配类型 = 通用型>
    参数 数据长度 <类型 = 变整数 注释 = "提供所欲计算摘要的数据长度,可选计算整个数据或前面一部分." 注释 = "默认值-1表示计算整个数据,如果\"数据\"参数提供的是数据地址(变整数),"
            注释 = "则必须提供正确的长度(大于0且小于等于数据尺寸)." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ piv::hash::Get_XXH128<@an<CVolString>>(@<数据>, (size_t)@<数据长度>, (uint64_t)@<种子>)
    }

    方法 取数据XXH128_字节集 <公开 静态 类型 = 字节集类 注释 = "计算指定数据的XXH3(128位)数据摘要,返回字节集结果(16个字节)." 返回值注释 = "数据为空仍会返回非0的哈希值"
            折叠 @嵌入式方法 = "">
    参数 数据 <注释 = "提供所欲计算摘要的数据,支持以下数据类型:" 注释 = " 字节集类、文本型、变整数(地址)、标准文本类(A/U)、文本视图类(A/U)" @匹配类型 = 通用型>
    参数 数据长度 <类型 = 变整数 注释 = "提供所欲计算摘要的数据长度,可选计算整个数据或前面一部分." 注释 = "默认值-1表示计算整个数据,如果\"数据\"参数提供的是数据地址(变整数),"
            注释 = "则必须提供正确的长度(大于0且小于等于数据尺寸)." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ piv::hash::Get_XXH128<@an<CVolMem>>(@<数据>, (size_t)@<数据长度>, (uint64_t)@<种子>)
    }

    方法 取数据HMAC_XXH128 <公开 静态 类型 = 文本型 注释 = "使用密码计算指定数据的XXH3(128位)数据摘要,返回十六进制文本(32个字符)."
            返回值注释 = "数据为空仍会返回非0的哈希值" 折叠 @嵌入式方法 = "">
    参数 数据 <注释 = "提供所欲计算摘要的数据,支持以下数据类型:" 注释 = " 字节集类、文本型、变整数(地址)、标准文本类(A/U)、文本视图类(A/U)" @匹配类型 = 通用型>
    参数 数据长度 <类型 = 变整数 注释 = "提供所欲计算摘要的数据长度,可选计算整个数据或前面一部分." 注释 = "默认值-1表示计算整个数据,如果\"数据\"参数提供的是数据地址(变整数),"
            注释 = "则必须提供正确的长度(大于0且小于等于数据尺寸)." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 如果密码为空或所计算的数据长度小于240字节,将使用内部的默认密码,"
            注释 = "此时的计算结果跟\"取数据XXH128\"一样." @默认值 = 空对象>
    {
        @ piv::hash::Get_XXH128_withSecret<@an<CVolString>>(@<数据>, (size_t)@<数据长度>, @<密码>, (uint64_t)@<种子>)
    }

    方法 取数据HMAC_XXH128_字节集 <公开 静态 类型 = 字节集类 注释 = "使用密码计算指定数据的XXH3(128位)数据摘要,返回字节集(16个字节)."
            返回值注释 = "数据为空仍会返回非0的哈希值" 折叠 @嵌入式方法 = "">
    参数 数据 <注释 = "提供所欲计算摘要的数据,支持以下数据类型:" 注释 = " 字节集类、文本型、变整数(地址)、标准文本类(A/U)、文本视图类(A/U)" @匹配类型 = 通用型>
    参数 数据长度 <类型 = 变整数 注释 = "提供所欲计算摘要的数据长度,可选计算整个数据或前面一部分." 注释 = "默认值-1表示计算整个数据,如果\"数据\"参数提供的是数据地址(变整数),"
            注释 = "则必须提供正确的长度(大于0且小于等于数据尺寸)." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 如果密码为空或所计算的数据长度小于240字节,将使用内部的默认密码,"
            注释 = "此时的计算结果跟\"取数据XXH128\"一样." @默认值 = 空对象>
    {
        @ piv::hash::Get_XXH128_withSecret<@an<CVolMem>>(@<数据>, (size_t)@<数据长度>, @<密码>, (uint64_t)@<种子>)
    }

    方法 取文件XXH128 <公开 静态 类型 = 文本型 注释 = "计算指定文件的XXH3(128位)数据摘要,返回十六进制文本(32个字符)."
            返回值注释 = "文件不存在或无法访问时返回0值,但文件数据为空仍会返回非0的哈希值." 折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲计算摘要的文件名">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 本参数仅在提供的密码长度大于136字节时生效,否则使用内部的默认密码." @默认值 = 空对象>
    {
        @ piv::hash::GetFile_XXH128<@an<CVolString>>(@<文件名>, @<文件偏移>, (uint64_t)@<数据长度>, @<密码>, (uint64_t)@<种子>)
    }

    方法 取文件XXH128_字节集 <公开 静态 类型 = 字节集类 注释 = "计算指定文件的XXH3(128位)数据摘要,返回字节集结果(16个字节)."
            返回值注释 = "文件不存在或无法访问时返回0值,但文件数据为空仍会返回非0的哈希值." 折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲计算摘要的文件名">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 本参数仅在提供的密码长度大于136字节时生效,否则使用内部的默认密码." @默认值 = 空对象>
    {
        @ piv::hash::GetFile_XXH128<@an<CVolMem>>(@<文件名>, @<文件偏移>, (uint64_t)@<数据长度>, @<密码>, (uint64_t)@<种子>)
    }

    方法 取资源XXH128 <公开 静态 类型 = 文本型 注释 = "计算指定文件资源的XXH3(128位)数据摘要,返回十六进制文本(32个字符)."
            返回值注释 = "文件资源无法载入时返回0值,但文件数据为空仍会返回非0的哈希值." 折叠 @嵌入式方法 = "">
    参数 文件资源 <类型 = 视窗文件资源 注释 = "提供所欲计算摘要的视窗文件资源">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 本参数仅在提供的密码长度大于136字节时生效,否则使用内部的默认密码." @默认值 = 空对象>
    {
        @ piv::hash::GetRes_XXH128<@an<CVolString>>(@<文件资源>, @<文件偏移>, (uint64_t)@<数据长度>, @<密码>, (uint64_t)@<种子>)
    }

    方法 取资源XXH128_字节集 <公开 静态 类型 = 字节集类 注释 = "计算指定文件资源的XXH3(128位)数据摘要,返回字节集结果(16个字节)."
            返回值注释 = "文件资源无法载入时返回0值,但文件数据为空仍会返回非0的哈希值." 折叠 @嵌入式方法 = "">
    参数 文件资源 <类型 = 视窗文件资源 注释 = "提供所欲计算摘要的视窗文件资源">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 本参数仅在提供的密码长度大于136字节时生效,否则使用内部的默认密码." @默认值 = 空对象>
    {
        @ piv::hash::GetRes_XXH128<@an<CVolMem>>(@<文件资源>, @<文件偏移>, (uint64_t)@<数据长度>, @<密码>, (uint64_t)@<种子>)
    }

    # XXH3(64位) ---

    方法 取数据XXH3 <公开 静态 类型 = 长整数 注释 = "计算指定数据的XXH3(64位)数据摘要,返回64位长整数哈希值."
            返回值注释 = "数据为空仍会返回非0的哈希值,如需十六进制文本可以调用:" 返回值注释 = "取长整数十六进制文本 (哈希值, 16)" 折叠 @嵌入式方法 = "">
    参数 数据 <注释 = "提供所欲计算摘要的数据,支持以下数据类型:" 注释 = " 字节集类、文本型、变整数(地址)、标准文本类(A/U)、文本视图类(A/U)" @匹配类型 = 通用型>
    参数 数据长度 <类型 = 变整数 注释 = "提供所欲计算摘要的数据长度,可选计算整个数据或前面一部分." 注释 = "默认值-1表示计算整个数据,如果\"数据\"参数提供的是数据地址(变整数),"
            注释 = "则必须提供正确的长度(大于0且小于等于数据尺寸)." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ (INT64)piv::hash::Get_XXH3 (@<数据>, (size_t)@<数据长度>, (uint64_t)@<种子>)
    }

    方法 取数据HMAC_XXH3 <公开 静态 类型 = 长整数 注释 = "使用密码计算指定数据的XXH3(64位)数据摘要,返回64位长整数哈希值."
            返回值注释 = "数据为空仍会返回非0的哈希值,如需十六进制文本可以调用:" 返回值注释 = "取长整数十六进制文本 (哈希值, 16)" 折叠 @嵌入式方法 = "">
    参数 数据 <注释 = "提供所欲计算摘要的数据,支持以下数据类型:" 注释 = " 字节集类、文本型、变整数(地址)、标准文本类(A/U)、文本视图类(A/U)" @匹配类型 = 通用型>
    参数 数据长度 <类型 = 变整数 注释 = "提供所欲计算摘要的数据长度,可选计算整个数据或前面一部分." 注释 = "默认值-1表示计算整个数据,如果\"数据\"参数提供的是数据地址(变整数),"
            注释 = "则必须提供正确的长度(大于0且小于等于数据尺寸)." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 如果密码为空或所计算的数据长度小于240字节,将使用内部的默认密码,"
            注释 = "此时的计算结果跟\"取数据XXH128\"一样." @默认值 = 空对象>
    {
        @ (INT64)piv::hash::Get_XXH3_withSecret (@<数据>, (size_t)@<数据长度>, @<密码>, (uint64_t)@<种子>)
    }

    方法 取文件XXH3 <公开 静态 类型 = 长整数 注释 = "计算指定文件的XXH3(64位)数据摘要,返回64位长整数哈希值."
            返回值注释 = "文件不存在或无法访问时返回0值,但文件数据为空仍会返回非0的哈希值." 返回值注释 = "如需十六进制文本可以调用: 取长整数十六进制文本 (哈希值, 16)" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲计算摘要的文件名">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 本参数仅在提供的密码长度大于136字节时生效,否则使用内部的默认密码." @默认值 = 空对象>
    {
        @ (INT64)piv::hash::GetFile_XXH3 (@<文件名>, @<文件偏移>, (uint64_t)@<数据长度>, @<密码>, (uint64_t)@<种子>)
    }

    方法 取资源XXH3 <公开 静态 类型 = 长整数 注释 = "计算指定文件资源的XXH3(64位)数据摘要,返回64位长整数哈希值."
            返回值注释 = "文件资源无法载入时返回0值,但文件数据为空仍会返回非0的哈希值." 返回值注释 = "如需十六进制文本可以调用: 取长整数十六进制文本 (哈希值, 16)" 折叠
            @嵌入式方法 = "">
    参数 文件资源 <类型 = 视窗文件资源 注释 = "提供所欲计算摘要的视窗文件资源">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 本参数仅在提供的密码长度大于136字节时生效,否则使用内部的默认密码." @默认值 = 空对象>
    {
        @ (INT64)piv::hash::GetRes_XXH3 (@<文件资源>, @<文件偏移>, (uint64_t)@<数据长度>, @<密码>, (uint64_t)@<种子>)
    }

    # XXH64 ---

    方法 取数据XXH64 <公开 静态 类型 = 长整数 注释 = "计算指定数据的XXH64数据摘要,返回64位长整数哈希值." 返回值注释 = "数据为空仍会返回非0的哈希值,如需十六进制文本可以调用:"
            返回值注释 = "取长整数十六进制文本 (哈希值, 16)" 折叠 @嵌入式方法 = "">
    参数 数据 <注释 = "提供所欲计算摘要的数据,支持以下数据类型:" 注释 = " 字节集类、文本型、变整数(地址)、标准文本类(A/U)、文本视图类(A/U)" @匹配类型 = 通用型>
    参数 数据长度 <类型 = 变整数 注释 = "提供所欲计算摘要的数据长度,可选计算整个数据或前面一部分." 注释 = "默认值-1表示计算整个数据,如果\"数据\"参数提供的是数据地址(变整数),"
            注释 = "则必须提供正确的长度(大于0且小于等于数据尺寸)." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ (INT64)piv::hash::Get_XXH64 (@<数据>, (size_t)@<数据长度>, (uint64_t)@<种子>)
    }

    方法 取文件XXH64 <公开 静态 类型 = 长整数 注释 = "计算指定文件的XXH64数据摘要,返回64位长整数哈希值."
            返回值注释 = "文件不存在或无法访问时返回0值,但文件数据为空仍会返回非0的哈希值." 返回值注释 = "如需十六进制文本可以调用: 取长整数十六进制文本 (哈希值, 16)" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲计算摘要的文件名">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ (INT64)piv::hash::GetFile_XXH64 (@<文件名>, @<文件偏移>, (uint64_t)@<数据长度>, (uint64_t)@<种子>)
    }

    方法 取资源XXH64 <公开 静态 类型 = 长整数 注释 = "计算指定文件资源的XXH64数据摘要,返回64位长整数哈希值."
            返回值注释 = "文件资源无法载入时返回0值,但文件数据为空仍会返回非0的哈希值." 返回值注释 = "如需十六进制文本可以调用: 取长整数十六进制文本 (哈希值, 16)" 折叠
            @嵌入式方法 = "">
    参数 文件资源 <类型 = 视窗文件资源 注释 = "提供所欲计算摘要的视窗文件资源">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ (INT64)piv::hash::GetRes_XXH64 (@<文件资源>, @<文件偏移>, (uint64_t)@<数据长度>, (uint64_t)@<种子>)
    }

    # XXH32 ---

    方法 取数据XXH32 <公开 静态 类型 = 整数 注释 = "计算指定数据的XXH32数据摘要,返回32位整数哈希值." 返回值注释 = "数据为空仍会返回非0的哈希值,如需十六进制文本可以调用:"
            返回值注释 = "取十六进制文本 (哈希值, 8)" 折叠 @嵌入式方法 = "">
    参数 数据 <注释 = "提供所欲计算摘要的数据,支持以下数据类型:" 注释 = " 字节集类、文本型、变整数(地址)、标准文本类(A/U)、文本视图类(A/U)" @匹配类型 = 通用型>
    参数 数据长度 <类型 = 变整数 注释 = "提供所欲计算摘要的数据长度,可选计算整个数据或前面一部分." 注释 = "默认值-1表示计算整个数据,如果\"数据\"参数提供的是数据地址(变整数),"
            注释 = "则必须提供正确的长度(大于0且小于等于数据尺寸)." @默认值 = -1>
    参数 种子 <类型 = 整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ (INT)piv::hash::Get_XXH64 (@<数据>, (size_t)@<数据长度>, (uint32_t)@<种子>)
    }

    方法 取文件XXH32 <公开 静态 类型 = 整数 注释 = "计算指定文件的XXH32数据摘要,返回32位整数哈希值."
            返回值注释 = "文件不存在或无法访问时返回0值,但文件数据为空仍会返回非0的哈希值." 返回值注释 = "如需十六进制文本可以调用: 取十六进制文本 (哈希值, 8)" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲计算摘要的文件名">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ (INT)piv::hash::GetFile_XXH64 (@<文件名>, @<文件偏移>, (uint64_t)@<数据长度>, (uint32_t)@<种子>)
    }

    方法 取资源XXH32 <公开 静态 类型 = 整数 注释 = "计算指定文件资源的XXH32数据摘要,返回32位整数哈希值."
            返回值注释 = "文件资源无法载入时返回0值,但文件数据为空仍会返回非0的哈希值." 返回值注释 = "如需十六进制文本可以调用: 取十六进制文本 (哈希值, 8)" 折叠 @嵌入式方法 = "">
    参数 文件资源 <类型 = 视窗文件资源 注释 = "提供所欲计算摘要的视窗文件资源">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ (INT)piv::hash::GetRes_XXH64 (@<文件资源>, @<文件偏移>, (uint64_t)@<数据长度>, (uint32_t)@<种子>)
    }
}

# ===

类 简易加解密 <公开 注释 = "纯C++源码实现的简易加解密库." 注释 = "其中RC4的加解密支持不定长度密码,结果跟易语言一致."
        注释 = "源码: https://github.com/lsw29475/iAlgorithm" 折叠 @文档 = "category = \"加解密\"" @禁止创建对象 = 真>
{

    # AES

    方法 加密_AES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(ECB模式)." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32.">
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        返回 (加密_字节集_AES_ECB (数据, 文本到多字节 (密码, 假), 填充方式))
    }

    方法 加密_字节集_AES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(ECB模式)." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠
            @禁止流程检查 = 真 @视窗.外部头文件 = "src\\iAlgorithm\\iAes.h" @视窗.外部源文件 = "src\\iAlgorithm\\iAes.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32.">
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        @ CAES aes; @an<CVolMem> out;
        @ @an<CVolMem> key = @<密码>; int keysize = (int)key.GetSize ();
        @ if (keysize < 8) {
        @     key.AddSpace (8 - keysize, TRUE); keysize = 8;
        @ } else if (keysize < 16) {
        @     key.AddSpace (16 - keysize, TRUE); keysize = 16;
        @ } else if (keysize < 32) {
        @     key.AddSpace (32 - keysize, TRUE); keysize = 32;
        @ } else {
        @     keysize = 32;
        @ }
        @ if ( !aes.AesInit ((unsigned char*)key.GetPtr (), keysize, NULL, 0, 1) )
        @     return out;
        @ @an<CVolMem> input = @<数据>;
        @ input.SetMemAlignSize (@<数据>.GetSize () + 16);
        @ if (input.GetSize () % 16 != 0) {
        @     int nNun = 16 - input.GetSize () % 16;
        @     if (@<填充方式> == 1) {
        @         input.AddSpace (nNun, TRUE);
        @     } else if (@<填充方式> == 2) {
        @         for (int i = 0; i < nNun; i++) input.AddU8Char ( (U8CHAR)nNun);
        @     }
        @ }
        @ out.Alloc (input.GetSize (), TRUE);
        @ return aes.Encrypt_ECB ((unsigned char*)input.GetPtr (), (int)input.GetSize (),
        @                         (unsigned char*)out.GetPtr (), (int)out.GetSize ()) ? out : CVolMem ();
    }

    方法 解密_AES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(ECB模式)." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32.">
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        返回 (解密_字节集_AES_ECB (数据, 文本到多字节 (密码, 假), 填充方式))
    }

    方法 解密_字节集_AES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(ECB模式)." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠
            @禁止流程检查 = 真 @视窗.外部头文件 = "src\\iAlgorithm\\iAes.h" @视窗.外部源文件 = "src\\iAlgorithm\\iAes.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32.">
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        @ CAES aes; @an<CVolMem> out;
        @ int nSize = (int)@<数据>.GetSize ();
        @ if (nSize <= 0) return out;
        @ @an<CVolMem> key = @<密码>; int keysize = (int)key.GetSize ();
        @ if (keysize < 8) {
        @     key.AddSpace (8 - keysize, TRUE); keysize = 8;
        @ } else if (keysize < 16) {
        @     key.AddSpace (16 - keysize, TRUE); keysize = 16;
        @ } else if (keysize < 32) {
        @     key.AddSpace (32 - keysize, TRUE); keysize = 32;
        @ } else {
        @     keysize = 32;
        @ }
        @ if ( !aes.AesInit ((unsigned char*)key.GetPtr (), keysize, NULL, 0, 1) )
        @     return out;
        @ out.Alloc (nSize, TRUE);
        @ if ( !aes.Decrypt_ECB ((unsigned char*)@<数据>.GetPtr (), nSize,
        @                        (unsigned char*)out.GetPtr (), (int)out.GetSize ()) )
        @     return CVolMem ();
        @ if (@<填充方式> == 2) {
        @     S_BYTE padChar = out.Get_S_BYTE (nSize - 1);
        @     if (padChar < 8 && padChar > 0) {
        @         bool bPad = true;
        @         for (int i = nSize - padChar; i < nSize; i++) {
        @             if (out.Get_S_BYTE (i) != padChar) bPad = false;
        @         }
        @         if (bPad) out.Realloc (nSize - padChar);
        @     }
        @ }
        @ return out;
    }

    方法 加密_AES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(CBC模式)." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        返回 (加密_字节集_AES_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 加密_字节集_AES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(CBC模式)." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠
            @禁止流程检查 = 真 @视窗.外部头文件 = "src\\iAlgorithm\\iAes.h" @视窗.外部源文件 = "src\\iAlgorithm\\iAes.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        @ CAES aes; @an<CVolMem> out;
        @ @an<CVolMem> key = @<密码>; int keysize = (int)key.GetSize ();
        @ if (keysize < 8) {
        @     key.AddSpace (8 - keysize, TRUE); keysize = 8;
        @ } else if (keysize < 16) {
        @     key.AddSpace (16 - keysize, TRUE); keysize = 16;
        @ } else if (keysize < 32) {
        @     key.AddSpace (32 - keysize, TRUE); keysize = 32;
        @ } else {
        @     keysize = 32;
        @ }
        @ if ( !aes.AesInit ((unsigned char*)key.GetPtr (), keysize, NULL, 0, 2) )
        @     return out;
        @ @an<CVolMem> iv = @<向量>;
        @ if (iv.GetSize () < 16) iv.AddSpace (16 - iv.GetSize (), TRUE);
        @ aes.AesSetIv ((unsigned char*)iv.GetPtr ());
        @ @an<CVolMem> input = @<数据>;
        @ input.SetMemAlignSize (@<数据>.GetSize () + 16);
        @ if (input.GetSize () % 16 != 0) {
        @     int nNun = 16 - input.GetSize () % 16;
        @     if (@<填充方式> == 1) {
        @         input.AddSpace (nNun, TRUE);
        @     } else if (@<填充方式> == 2) {
        @         for (int i = 0; i < nNun; i++) input.AddU8Char ( (U8CHAR)nNun);
        @     }
        @ }
        @ out.Alloc (input.GetSize (), TRUE);
        @ return aes.Encrypt_CBC ((unsigned char*)input.GetPtr (), (int)input.GetSize (),
        @                         (unsigned char*)out.GetPtr (), (int)out.GetSize ()) ? out : CVolMem ();
    }

    方法 解密_AES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(CBC模式)." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        返回 (解密_字节集_AES_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 解密_字节集_AES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(CBC模式)." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠
            @禁止流程检查 = 真 @视窗.外部头文件 = "src\\iAlgorithm\\iAes.h" @视窗.外部源文件 = "src\\iAlgorithm\\iAes.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        @ CAES aes; @an<CVolMem> out;
        @ int nSize = (int)@<数据>.GetSize ();
        @ if (nSize <= 0) return out;
        @ @an<CVolMem> key = @<密码>; int keysize = (int)key.GetSize ();
        @ if (keysize < 8) {
        @     key.AddSpace (8 - keysize, TRUE); keysize = 8;
        @ } else if (keysize < 16) {
        @     key.AddSpace (16 - keysize, TRUE); keysize = 16;
        @ } else if (keysize < 32) {
        @     key.AddSpace (32 - keysize, TRUE); keysize = 32;
        @ } else {
        @     keysize = 32;
        @ }
        @ if ( !aes.AesInit ((unsigned char*)key.GetPtr (), keysize, NULL, 0, 2) )
        @     return out;
        @ @an<CVolMem> iv = @<向量>;
        @ if (iv.GetSize () < 16) iv.AddSpace (16 - iv.GetSize (), TRUE);
        @ aes.AesSetIv ((unsigned char*)iv.GetPtr ());
        @ out.Alloc (nSize, TRUE);
        @ if ( !aes.Decrypt_CBC ((unsigned char*)@<数据>.GetPtr (), nSize,
        @                        (unsigned char*)out.GetPtr (), (int)out.GetSize ()) )
        @     return CVolMem ();
        @ if (@<填充方式> == 2) {
        @     S_BYTE padChar = out.Get_S_BYTE (nSize - 1);
        @     if (padChar < 8 && padChar > 0) {
        @         bool bPad = true;
        @         for (int i = nSize - padChar; i < nSize; i++) {
        @             if (out.Get_S_BYTE (i) != padChar) bPad = false;
        @         }
        @         if (bPad) out.Realloc (nSize - padChar);
        @     }
        @ }
        @ return out;
    }

    # DEC

    方法 加密_DES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DES加密(ECB模式)." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        返回 (加密_字节集_DES_ECB (数据, 文本到多字节 (密码, 假), 填充方式))
    }

    方法 加密_字节集_DES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DES加密(ECB模式)." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠
            @禁止流程检查 = 真 @视窗.外部头文件 = "src\\iAlgorithm\\iBit.h\nsrc\\iAlgorithm\\iDes.h"
            @视窗.外部源文件 = "src\\iAlgorithm\\iBit.cpp\nsrc\\iAlgorithm\\iDes.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        @ CDES des; @an<CVolMem> out;
        @ @an<CVolMem> key = @<密码>;
        @ if (key.GetSize() < 8) key.AddSpace (8 - key.GetSize (), TRUE);
        @ if ( !des.DesInit ((unsigned char*)key.GetPtr (), 8) )
        @     return out;
        @ @an<CVolMem> input = @<数据>;
        @ input.SetMemAlignSize (@<数据>.GetSize () + 8);
        @ if (input.GetSize () % 8 != 0) {
        @     int nNun = 8 - input.GetSize () % 8;
        @     if (@<填充方式> == 2) {
        @         for (int i = 0; i < nNun; i++) input.AddU8Char ( (U8CHAR)nNun);
        @     } else if (@<填充方式> == 1) {
        @         input.AddSpace (nNun, TRUE);
        @     }
        @ }
        @ out.Alloc (input.GetSize (), TRUE);
        @ return des.Encrypt_ECB ((unsigned char*)input.GetPtr (), (int)input.GetSize (),
        @                         (unsigned char*)out.GetPtr (), (int)out.GetSize ()) ? out : CVolMem ();
    }

    方法 解密_DES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定DES加密的数据进行解密(ECB模式)." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        返回 (解密_字节集_DES_ECB (数据, 文本到多字节 (密码, 假), 填充方式))
    }

    方法 解密_字节集_DES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定DES加密的数据进行解密(ECB模式)." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠
            @禁止流程检查 = 真 @视窗.外部头文件 = "src\\iAlgorithm\\iBit.h\nsrc\\iAlgorithm\\iDes.h"
            @视窗.外部源文件 = "src\\iAlgorithm\\iBit.cpp\nsrc\\iAlgorithm\\iDes.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        @ CDES des; @an<CVolMem> out;
        @ int nSize = (int)@<数据>.GetSize ();
        @ if (nSize <= 0) return out;
        @ @an<CVolMem> key = @<密码>;
        @ if (key.GetSize() < 8) key.AddSpace (8 - key.GetSize (), TRUE);
        @ if ( !des.DesInit ((unsigned char*)key.GetPtr (), 8) )
        @     return out;
        @ out.Alloc (nSize, TRUE);
        @ if ( !des.Decrypt_ECB ((unsigned char*)@<数据>.GetPtr (), nSize,
        @                        (unsigned char*)out.GetPtr (), (int)out.GetSize ()) )
        @     return CVolMem ();
        @ if (@<填充方式> == 2) {
        @     S_BYTE padChar = out.Get_S_BYTE (nSize - 1);
        @     if (padChar < 8 && padChar > 0) {
        @         bool bPad = true;
        @         for (int i = nSize - padChar; i < nSize; i++) {
        @             if (out.Get_S_BYTE (i) != padChar) bPad = false;
        @         }
        @         if (bPad) out.Realloc (nSize - padChar);
        @     }
        @ }
        @ return out;
    }

    方法 加密_DES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DES加密(CBC模式)." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        返回 (加密_字节集_DES_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 加密_字节集_DES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DES加密(CBC模式)." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠
            @禁止流程检查 = 真 @视窗.外部头文件 = "src\\iAlgorithm\\iBit.h\nsrc\\iAlgorithm\\iDes.h"
            @视窗.外部源文件 = "src\\iAlgorithm\\iBit.cpp\nsrc\\iAlgorithm\\iDes.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        @ CDES des; @an<CVolMem> out;
        @ @an<CVolMem> key = @<密码>;
        @ if (key.GetSize() < 8) key.AddSpace (8 - key.GetSize (), TRUE);
        @ if ( !des.DesInit ((unsigned char*)key.GetPtr (), 8) )
        @     return out;
        @ @an<CVolMem> iv = @<向量>;
        @ if (iv.GetSize () < 8) iv.AddSpace (8 - iv.GetSize (), TRUE);
        @ des.DesSetIv ((unsigned char*)iv.GetPtr ());
        @ @an<CVolMem> input = @<数据>;
        @ input.SetMemAlignSize (@<数据>.GetSize () + 8);
        @ if (input.GetSize () % 8 != 0) {
        @     int nNun = 8 - input.GetSize () % 8;
        @     if (@<填充方式> == 2) {
        @         for (int i = 0; i < nNun; i++) input.AddU8Char ((U8CHAR)nNun);
        @     } else if (@<填充方式> == 1) {
        @         input.AddSpace (nNun, TRUE);
        @     }
        @ }
        @ out.Alloc (input.GetSize (), TRUE);
        @ return des.Encrypt_CBC ((unsigned char*)input.GetPtr (), (int)input.GetSize (),
        @                         (unsigned char*)out.GetPtr (), (int)out.GetSize ()) ? out : CVolMem ();
    }

    方法 解密_DES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定DES加密的数据进行解密(CBC模式)." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = PKCS7填充" 注释 = " 2 = 零填充" @默认值 = 1>
    {
        返回 (解密_字节集_DES_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 解密_字节集_DES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定DES加密的数据进行解密(CBC模式)." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠
            @禁止流程检查 = 真 @视窗.外部头文件 = "src\\iAlgorithm\\iBit.h\nsrc\\iAlgorithm\\iDes.h"
            @视窗.外部源文件 = "src\\iAlgorithm\\iBit.cpp\nsrc\\iAlgorithm\\iDes.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        @ CDES des; @an<CVolMem> out;
        @ int nSize = (int)@<数据>.GetSize ();
        @ if (nSize <= 0) return out;
        @ @an<CVolMem> key = @<密码>;
        @ if (key.GetSize() < 8) key.AddSpace (8 - key.GetSize (), TRUE);
        @ if ( !des.DesInit ((unsigned char*)key.GetPtr (), 8) )
        @     return out;
        @ @an<CVolMem> iv = @<向量>;
        @ if (iv.GetSize () < 8) iv.AddSpace (8 - iv.GetSize (), TRUE);
        @ des.DesSetIv ((unsigned char*)iv.GetPtr ());
        @ out.Alloc (nSize, TRUE);
        @ if ( !des.Decrypt_CBC ((unsigned char*)@<数据>.GetPtr (), nSize,
        @                        (unsigned char*)out.GetPtr (), (int)out.GetSize ()) )
        @     return CVolMem ();
        @ if (@<填充方式> == 2) {
        @     S_BYTE padChar = out.Get_S_BYTE (nSize - 1);
        @     if (padChar < 8 && padChar > 0) {
        @         bool bPad = true;
        @         for (int i = nSize - padChar; i < nSize; i++) {
        @             if (out.Get_S_BYTE (i) != padChar) bPad = false;
        @         }
        @         if (bPad) out.Realloc (nSize - padChar);
        @     }
        @ }
        @ return out;

    }

    # RC4

    方法 加密_RC4 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC4加密." 返回值注释 = "返回数据加密后的结果,如果加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,长度为1-256个字符.">
    {
        返回 (加密_字节集_RC4 (数据, 文本到多字节 (密码, 假)))
    }

    方法 加密_字节集_RC4 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC4加密." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠 @禁止流程检查 = 真
            @视窗.外部头文件 = "src\\iAlgorithm\\iRc4.h" @视窗.外部源文件 = "src\\iAlgorithm\\iRc4.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,长度为1-256字节.">
    {
        @ CRC4 RC4; @an<CVolMem> out;
        @ if ( !RC4.InitKey ((unsigned char*)@<密码>.GetPtr (), (int)@<密码>.GetSize ()) )
        @     return out;
        @ out.Alloc (@<数据>.GetSize (), TRUE);
        @ return RC4.EncryptData ((unsigned char*)@<数据>.GetPtr (), (int)@<数据>.GetSize (),
        @                         (unsigned char*)out.GetPtr (), (int)out.GetSize ()) ? out : CVolMem ();
    }

    方法 解密_RC4 <公开 静态 类型 = 字节集类 注释 = "将指定RC4加密的数据进行解密." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,长度为1-256个字符.">
    {
        返回 (解密_字节集_RC4 (数据, 文本到多字节 (密码, 假)))
    }

    方法 解密_字节集_RC4 <公开 静态 类型 = 字节集类 注释 = "将指定RC4加密的数据进行解密." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠 @禁止流程检查 = 真
            @视窗.外部头文件 = "src\\iAlgorithm\\iRc4.h" @视窗.外部源文件 = "src\\iAlgorithm\\iRc4.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,长度为1-256字节.">
    {
        @ CRC4 RC4; @an<CVolMem> out;
        @ if ( !RC4.InitKey ((unsigned char*)@<密码>.GetPtr (), (int)@<密码>.GetSize ()) )
        @     return out;
        @ out.Alloc (@<数据>.GetSize (), TRUE);
        @ return RC4.DecryptData ((unsigned char*)@<数据>.GetPtr (), (int)@<数据>.GetSize (),
        @                         (unsigned char*)out.GetPtr (), (int)out.GetSize ()) ? out : CVolMem ();
    }

    # MD5

    方法 取数据MD5 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的MD5数据摘要." 返回值注释 = "返回摘要计算后的结果." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据.">
    {
        返回 (取数据MD5_字节集 (数据).字节集到十六进制文本 ())
    }

    方法 取数据MD5_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的MD5数据摘要." 返回值注释 = "返回摘要计算后的结果." 折叠 @禁止流程检查 = 真
            @视窗.外部头文件 = "src\\iAlgorithm\\iMd5.h" @视窗.外部源文件 = "src\\iAlgorithm\\iMd5.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据.">
    {
        @ CMD5 hash;
        @ if ( !hash.InitHash (0) ) return CVolMem ();
        @ @an<CVolMem> DigestOut; DigestOut.Alloc (16, TRUE);
        @ return hash.CalcHash ((unsigned char*)@<数据>.GetPtr (), (int)@<数据>.GetSize (),
        @                       (unsigned char*)DigestOut.GetPtr ()) ? DigestOut : CVolMem ();
    }

    # SHA1

    方法 取数据SHA1 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的SHA1数据摘要." 返回值注释 = "返回摘要计算后的结果." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据.">
    {
        返回 (取数据SHA1_字节集 (数据).字节集到十六进制文本 ())
    }

    方法 取数据SHA1_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的SHA1数据摘要." 返回值注释 = "返回摘要计算后的结果." 折叠 @禁止流程检查 = 真
            @视窗.外部头文件 = "src\\iAlgorithm\\iSha1.h" @视窗.外部源文件 = "src\\iAlgorithm\\iSha1.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据.">
    {
        @ CSHA1 hash;
        @ if ( !hash.InitHash (0) ) return CVolMem ();
        @ @an<CVolMem> DigestOut; DigestOut.Alloc (20, TRUE);
        @ return hash.CalcHash ((unsigned char*)@<数据>.GetPtr (), (int)@<数据>.GetSize (),
        @                       (unsigned char*)DigestOut.GetPtr ()) ? DigestOut : CVolMem ();
    }

    # SHA256

    方法 取数据SHA256 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的SHA256数据摘要." 返回值注释 = "返回摘要计算后的结果." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据.">
    {
        返回 (取数据SHA256_字节集 (数据).字节集到十六进制文本 ())
    }

    方法 取数据SHA256_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的SHA256数据摘要." 返回值注释 = "返回摘要计算后的结果." 折叠 @禁止流程检查 = 真
            @视窗.外部头文件 = "src\\iAlgorithm\\iSha256.h" @视窗.外部源文件 = "src\\iAlgorithm\\iSha256.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据.">
    {
        @ CSHA256 hash;
        @ if ( !hash.InitHash (0) ) return CVolMem ();
        @ @an<CVolMem> DigestOut; DigestOut.Alloc (32, TRUE);
        @ return hash.CalcHash ((unsigned char*)@<数据>.GetPtr (), (int)@<数据>.GetSize (),
        @                       (unsigned char*)DigestOut.GetPtr ()) ? DigestOut : CVolMem ();
    }

    # SHA512

    方法 取数据SHA512 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的SHA512数据摘要." 返回值注释 = "返回摘要计算后的结果." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据.">
    {
        返回 (取数据SHA512_字节集 (数据).字节集到十六进制文本 ())
    }

    方法 取数据SHA512_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的SHA512数据摘要." 返回值注释 = "返回摘要计算后的结果." 折叠 @禁止流程检查 = 真
            @视窗.外部头文件 = "src\\iAlgorithm\\iSha512.h" @视窗.外部源文件 = "src\\iAlgorithm\\iSha512.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据.">
    {
        @ CSHA512 hash;
        @ if ( !hash.InitHash (0) ) return CVolMem ();
        @ @an<CVolMem> DigestOut; DigestOut.Alloc (64, TRUE);
        @ return hash.CalcHash ((unsigned char*)@<数据>.GetPtr (), (int)@<数据>.GetSize (),
        @                       (unsigned char*)DigestOut.GetPtr ()) ? DigestOut : CVolMem ();
    }
}
