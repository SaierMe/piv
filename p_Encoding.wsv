<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "编码处理" 注释 = "https://github.com/SaierMe/piv" "">

类 编码P <公开 基础类 = 编码辅助类 注释 = "编码和进制相关的辅助方法(通过类名调用)" 折叠 @文档 = "category = \"编码处理\"" @禁止创建对象 = 真>
{
    方法 展示字节数据 <公开 静态 类型 = 文本型 注释 = "返回类似调试输出字节集类的文本,但不展示ASCII内容." 折叠 @禁止流程检查 = 真>
    参数 数据地址 <类型 = 变整数 注释 = "所欲展示的数据地址">
    参数 数据长度 <类型 = 整数 注释 = "数据的长度">
    参数 最大展示数据尺寸 <类型 = 整数 @默认值 = 1024>
    {
        @ static const char hexUpCh[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
        @ BYTE* data = (BYTE*)@<数据地址>;
        @ int len = @<数据长度>;
        @ @an<CVolString> dump;
        @ if (@<数据长度> < @<最大展示数据尺寸>) {
        @     dump.AddFormatText(L"<字节集> 总共 %d 个字节:\r\n", len);
        @ } else {
        @     dump.AddFormatText(L"<字节集> 总共 %d 个字节,输出了 %d 个,还有 %d 个未被输出.\r\n", @<数据长度>, @<最大展示数据尺寸>, @<最大展示数据尺寸> - @<数据长度>);
        @     @<数据长度> = @<最大展示数据尺寸>;
        @ }
        @ dump.SetNumAlignChars(@<数据长度> * 4 + 128);
        @ for (int i = 0, n = 0; i < @<数据长度>;) {
        @     if (i % 16 == 0)
        @         dump.AddFormatText(L"[%08X]: ", n * 16);
        @     dump.AddChar(hexUpCh[data[i] >> 4]);
        @     dump.AddChar(hexUpCh[data[i] & 0xF]);
        @     dump.AddChar(' ');
        @     i++;
        @     if (i % 16 == 0) {
        @         dump.AddEmptyLine();
        @         n++;
        @     }
        @ }
        @ return dump;
    }

    方法 展示字节集 <公开 静态 类型 = 文本型 注释 = "返回类似调试输出字节集类的文本,但不展示ASCII内容." 折叠>
    参数 欲展示字节集 <类型 = 字节集类 注释 = "所欲展示的字节集数据">
    参数 最大展示数据尺寸 <类型 = 整数 @默认值 = 1024>
    {
        返回 (展示字节数据 (欲展示字节集.取字节集指针 (), 欲展示字节集.取字节集长度 (), 最大展示数据尺寸))
    }

    方法 字节集到二进制文本 <公开 静态 类型 = 文本型 注释 = "将字节集转换到二进制文本" 折叠>
    参数 数据 <类型 = 字节集类>
    参数 是否分隔 <类型 = 逻辑型 注释 = "是否每隔1个字节插入一个空格" @默认值 = 假>
    {
        变量 二进制文本 <类型 = 文本型>
        变量 数据长度 <类型 = 整数>
        数据长度 = 数据.取字节集长度 ()
        置文本预分配字符数 (二进制文本, 数据长度 * 8 + 选择 (是否分隔, 数据长度, 0))
        计次循环 (数据长度)
        {
            变量 值 <类型 = 字节>
            值 = 数据.取字节集数据 (取循环索引 (), 字节)
            逆向计次循环 (8)
            {
                加入字符 (二进制文本, (字符)选择 (位与 (1, 位右移 (值, 取循环索引 ())) == 1, '1', '0'))
            }
            如果 (是否分隔 && 取循环索引 () < 数据长度 - 1)
            {
                加入字符 (二进制文本, ' ')
            }
        }
        返回 (二进制文本)
    }

    方法 验证文本编码 <公开 静态 类型 = 逻辑型 注释 = "验证提供的Unicode文本是否符合指定代码页的文本编码,能判断转换到目标编码后是否会出现乱码."
            注释 = "返回真表示能完整转换到目标编码." 折叠 @禁止流程检查 = 真>
    参数 欲验证的文本 <类型 = 文本型 注释 = "提供所欲验证的UTF-16LE编码文本">
    参数 代码页 <类型 = 整数 注释 = "0表示使用本地编码,常用代码页:" 注释 = "  932 日文(Shift-JIS)" 注释 = "  936 中文简体(GB2312)"
            注释 = "  949 韩文" 注释 = "  950 中文繁体(Big5)" @默认值 = 0>
    {
        @ BOOL UsedDefaultChar = FALSE;
        @ ::WideCharToMultiByte((UINT)@<代码页>, 0, @<欲验证的文本>.GetText(), -1, NULL, 0, NULL, &UsedDefaultChar);
        @ return !UsedDefaultChar;
    }
}

类 编码辅助类 <公开 注释 = "编码和进制相关的全局辅助方法" 折叠 @文档 = "category = \"编码处理\"" @禁止创建对象 = 真 @全局类 = 真>
{
    方法 取整数值位数 <公开 静态 类型 = 整数 注释 = "计算整数值的十进制位数,比如0的位数是1,1000的位数是4," 折叠 @嵌入式方法 = "">
    参数 整数值 <注释 = "所欲取位数的数值,可以提供字节、字符、短整数、整数、长整数等类型." @匹配类型 = 通用整数型>
    {
        @ @sn<current_class_def>::GetValueDigit(@<整数值>)
    }

    方法 小数向上取整 <公开 静态 类型 = 整数 注释 = "返回一个小数的整数部分,本方法返回大于所欲处理的小数值的最小整数."
            注释 = "例如,将 7.3 转换 成 8, 将 -7.3 转换成 -7." 折叠 @嵌入式方法 = "">
    参数 所欲处理的小数值 <类型 = 小数>
    {
        @ (INT)ceil(@<所欲处理的小数值>)
    }

    方法 合并长整数 <公开 静态 类型 = 长整数 注释 = "  将第一个整数放置到结果长整数的低32位,将第二个整数放置到结果" 注释 = "长整数的高32位,以此合并成一个长整数,并返回合并后的结果."
            折叠 @嵌入式方法 = "">
    参数 用作合并的整数1 <类型 = 整数>
    参数 用作合并的整数2 <类型 = 整数>
    {
        @ (((INT64>)@<用作合并的整数1>) | ((INT64)@<用作合并的整数2> << 32))
    }

    方法 取高32位 <公开 静态 类型 = 整数 注释 = "获取64位长整数的高32位,对应\"合并长整数\"." 折叠 @嵌入式方法 = "">
    参数 欲取位的值 <类型 = 长整数>
    {
        @ ((INT)(((INT64) (@<欲取位的值>) >> 32) & 0xFFFFFFFF))
    }

    方法 取低32位 <公开 静态 类型 = 整数 注释 = "获取64位长整数的低32位,对应\"合并长整数\"." 折叠 @嵌入式方法 = "">
    参数 欲取位的值 <类型 = 长整数>
    {
        @ ((INT)@<欲取位的值>)
    }

    方法 取高16位 <公开 静态 类型 = 整数 注释 = "获取32位整数的高16位,对应\"合并整数\"."
            注释 = "#define HIWORD(l)   ((WORD) (((DWORD) (l) >> 16) & 0xFFFF))" 折叠 @嵌入式方法 = "">
    参数 欲取位的值 <类型 = 整数>
    {
        @ (INT)HIWORD(@<欲取位的值>)
    }

    方法 取低16位 <公开 静态 类型 = 整数 注释 = "获取32位整数的低16位,对应\"合并整数\"." 注释 = "#define LOWORD(l)   ((WORD) (l))" 折叠
            @嵌入式方法 = "">
    参数 欲取位的值 <类型 = 整数>
    {
        @ (INT)LOWORD((DWORD)@<欲取位的值>)
    }

    方法 取高8位 <公开 静态 类型 = 短整数 注释 = "获取16位短整数的高8位,对应\"合并短整数\"."
            注释 = "#define HIBYTE(w)   ((BYTE) (((WORD) (w) >> 8) & 0xFF))" 折叠 @嵌入式方法 = "">
    参数 欲取位的值 <类型 = 整数>
    {
        @ (SHORT)HIBYTE(@<欲取位的值>)
    }

    方法 取低8位 <公开 静态 类型 = 短整数 注释 = "获取16位短整数的低8位,对应\"合并短整数\"." 注释 = "#define LOBYTE(w)   ((BYTE) (w))" 折叠
            @嵌入式方法 = "">
    参数 欲取位的值 <类型 = 整数>
    {
        @ (SHORT)LOBYTE((WORD)@<欲取位的值>)
    }

    方法 取字符十六进制文本 <公开 静态 类型 = 文本型 注释 = "返回所指定字符所对应的十六进制文本" 折叠 @嵌入式方法 = "">
    参数 所欲转换的字符 <类型 = 字符>
    参数 所需要的最小宽度 <类型 = 整数 注释 = "指定所需求的最小宽度(数字数目),如果有效数值宽度小于该值,则自动在首部加0."
            注释 = "为0表示去除所有的前置\'0\'数字. 字节的十六进制文本不应大于4." @默认值 = 0>
    {
        @ @an<CVolString>(WordToHexStr((WORD)@<所欲转换的字符>, @<所需要的最小宽度>, PivBuffer<WCHAR>(16).GetPtr(), 16))
    }

    方法 取短整数十六进制文本 <公开 静态 类型 = 文本型 注释 = "返回所指定短整数所对应的十六进制文本" 折叠 @嵌入式方法 = "">
    参数 所欲转换的短整数 <类型 = 短整数>
    参数 所需要的最小宽度 <类型 = 整数 注释 = "指定所需求的最小宽度(数字数目),如果有效数值宽度小于该值,则自动在首部加0."
            注释 = "为0表示去除所有的前置\'0\'数字. 字节的十六进制文本不应大于4." @默认值 = 0>
    {
        @ @an<CVolString>(WordToHexStr((WORD)@<所欲转换的短整数>, @<所需要的最小宽度>, PivBuffer<WCHAR>(16).GetPtr(), 16))
    }

    方法 取字节十六进制文本 <公开 静态 类型 = 文本型 注释 = "返回所指定字节所对应的十六进制文本" 折叠 @嵌入式方法 = "">
    参数 所欲转换的字节数 <类型 = 字节>
    参数 所需要的最小宽度 <类型 = 整数 注释 = "指定所需求的最小宽度(数字数目),如果有效数值宽度小于该值,则自动在首部加0."
            注释 = "为0表示去除所有的前置\'0\'数字. 字节的十六进制文本不应大于2." @默认值 = 0>
    {
        @ @an<CVolString>(ByteToHexStr((BYTE)@<所欲转换的字节数>, @<所需要的最小宽度>, PivBuffer<WCHAR>(8).GetPtr(), 8))
    }

    方法 反转字符字节序 <公开 静态 类型 = 字符 注释 = "  将所指定整数的组成字节的顺序反转,返回反转后的结果值.譬如十六进制整数0x12345678,"
            注释 = "反转后将返回0x78563412. 本命令在与类似Java这样的语言进行数据交互时很有用处." 折叠 @禁止流程检查 = 真>
    参数 所欲反转的字符 <类型 = 字符>
    {
        @ WCHAR wResult = ((@<所欲反转的字符> & 0x00FF) << 8);
        @ wResult |= ((@<所欲反转的字符> & 0xFF00) >> 8);
        @ return wResult;
    }

    方法 反转短整数字节序 <公开 静态 类型 = 短整数 注释 = "  将所指定整数的组成字节的顺序反转,返回反转后的结果值.譬如十六进制整数0x12345678,"
            注释 = "反转后将返回0x78563412. 本命令在与类似Java这样的语言进行数据交互时很有用处." 折叠 @禁止流程检查 = 真>
    参数 所欲反转的短整数 <类型 = 短整数>
    {
        @ WORD wResult = ((@<所欲反转的短整数> & 0x00FF) << 8);
        @ wResult |= ((@<所欲反转的短整数> & 0xFF00) >> 8);
        @ return (SHORT)wResult;
    }

    方法 任意进制文本到整数 <公开 静态 类型 = 整数 注释 = "任意进制文本到十进制整数" 返回值注释 = "转换完全失败会返回0." 折叠 @嵌入式方法 = "">
    参数 转换前的文本 <类型 = 文本型 注释 = "所欲转换的任意进制文本.">
    参数 转换前的进制 <类型 = 整数 注释 = "  文本的进制,范围为2-36进制."
            注释 = "  如果为0,则按文本的开头自动识别,如\"0x\"为16进制;\"0\"为8进制;\"1-9\"为10进制.">
    {
        @ (INT)wcstoul(@<转换前的文本>.GetText(), NULL, @<转换前的进制>)
    }

    方法 任意进制文本到长整数 <公开 静态 类型 = 长整数 注释 = "任意进制文本到十进制长整数" 返回值注释 = "转换完全失败会返回0." 折叠 @嵌入式方法 = "">
    参数 转换前的文本 <类型 = 文本型 注释 = "所欲转换的任意进制文本.">
    参数 转换前的进制 <类型 = 整数 注释 = "  文本的进制,范围为2-36进制."
            注释 = "  如果为0,则按文本的开头自动识别,如\"0x\"为16进制;\"0\"为8进制;\"1-9\"为10进制.">
    {
        @ (INT64)wcstoull(@<转换前的文本>.GetText(), NULL, @<转换前的进制>)
    }

    方法 任意进制文本到变整数 <公开 静态 类型 = 变整数 注释 = "任意进制文本到十进制变整数" 返回值注释 = "转换完全失败会返回0." 折叠 @禁止流程检查 = 真>
    参数 转换前的文本 <类型 = 文本型 注释 = "所欲转换的任意进制文本.">
    参数 转换前的进制 <类型 = 整数 注释 = "  文本的进制,范围为2-36进制."
            注释 = "  如果为0,则按文本的开头自动识别,如\"0x\"为16进制;\"0\"为8进制;\"1-9\"为10进制.">
    {
        @ #ifdef _PF_32_BITS
        @     return (INT_P)wcstoul(@<转换前的文本>.GetText(), NULL, @<转换前的进制>);
        @ #else
        @     return (INT_P)wcstoull(@<转换前的文本>.GetText(), NULL, @<转换前的进制>);
        @ #endif
    }

    方法 整数到任意进制文本 <公开 静态 类型 = 文本型 注释 = "十进制整数到任意进制文本" 折叠 @禁止流程检查 = 真>
    参数 转换前的整数 <类型 = 整数>
    参数 转换后的进制 <类型 = 整数 注释 = "2-36进制">
    {
        @ wchar_t buffer[33] { 0 };
        @ _itow(@<转换前的整数>, buffer, @<转换后的进制>);
        @ return @an<CVolString>(buffer).MakeUpper();
    }

    方法 长整数到任意进制文本 <公开 静态 类型 = 文本型 注释 = "十进制长整数到任意进制文本" 折叠 @禁止流程检查 = 真>
    参数 转换前的长整数 <类型 = 长整数>
    参数 转换后的进制 <类型 = 整数 注释 = "2-36进制">
    {
        @ wchar_t buffer[65] { 0 };
        @ _i64tow(@<转换前的长整数>, buffer, @<转换后的进制>);
        @ return @an<CVolString>(buffer).MakeUpper();
    }

    方法 无符号长整数到任意进制文本 <公开 静态 类型 = 文本型 注释 = "十进制无符号长整数到任意进制文本" 折叠 @禁止流程检查 = 真>
    参数 转换前的长整数 <类型 = 长整数>
    参数 转换后的进制 <类型 = 整数 注释 = "2-36进制">
    {
        @ wchar_t buffer[65] { 0 };
        @ _ui64tow((UINT64)@<转换前的长整数>, buffer, @<转换后的进制>);
        @ return @an<CVolString>(buffer).MakeUpper();
    }

    方法 任意进制文本到任意进制文本 <公开 静态 类型 = 文本型 注释 = "2-36进制间的文本转换" 折叠>
    参数 转换前的文本 <类型 = 文本型>
    参数 转换前的进制 <类型 = 整数 注释 = "2-36进制">
    参数 转换后的进制 <类型 = 整数 注释 = "2-36进制">
    {
        变量 临时结果 <类型 = 长整数>
        临时结果 = 任意进制文本到长整数 (转换前的文本, 转换前的进制)
        返回 (长整数到任意进制文本 (临时结果, 转换后的进制))
    }

    方法 十六进制文本到变整数 <公开 静态 类型 = 变整数 注释 = "十六进制文本转换到十进制变整数" 折叠>
    参数 十六进制文本 <类型 = 文本型 注释 = "所欲转换的十六进制文本.">
    {
        返回 (任意进制文本到变整数 (十六进制文本, 16))
    }

    方法 是否为数值文本 <公开 静态 类型 = 逻辑型 注释 = "判断提供的文本是否为有效的数值" 折叠 @禁止流程检查 = 真>
    参数 数值文本 <类型 = 文本型 注释 = "所欲判断的任意进制文本">
    参数 数值进制 <类型 = 整数 注释 = "文本的进制,范围为2-36进制." 注释 = "如果为0,则按文本的开头自动识别,如\"0x\"为16进制;\"0\"为8进制;\"1-9\"为10进制."
            @默认值 = 0>
    {
        @ if (@<数值文本>.IsEmpty() == TRUE) return FALSE;
        @ wchar_t* end;
        @ wcstoull(@<数值文本>.GetText(), &end, @<数值进制>);
        @ return (end == @<数值文本>.GetText() + @<数值文本>.GetLength());
    }

    方法 取千位分隔数值文本 <公开 静态 类型 = 文本型 注释 = "使用千位分隔符格式化数值文本." 注释 = "例: 1,234,567,890." 折叠>
    参数 数值 <类型 = 长整数 注释 = "所欲格式化的数值,可以提供小于长整数的任意类型数值.">
    {
        变量 千位分隔文本 <类型 = 文本型>
        变量 文本长度 <类型 = 整数>
        变量 索引 <类型 = 整数>
        加入长整数文本 (千位分隔文本, 数值)
        文本长度 = 取文本长度 (千位分隔文本)
        如果 (文本长度 > 3)
        {
            循环 (文本长度, 0, 索引, -3)
            {
                插入字符 (千位分隔文本, 索引, ',')
            }
            如果 (是否以字符结束 (千位分隔文本, ',', 真) == 真)
            {
                删除字符 (千位分隔文本, 取文本长度 (千位分隔文本) - 1, 1)
            }
        }
        返回 (千位分隔文本)
    }

    方法 取格式字节文本 <公开 静态 类型 = 文本型 注释 = "返回适当单位的尺寸文本,根据字节数自动计算适合的单位(bytes、KB、MB、GB和TB)." 折叠 折叠2
            @视窗.外部头文件 = "shlwapi.h" @视窗.外部库 = "Shlwapi.lib" @嵌入式方法 = "">
    参数 字节数 <类型 = 长整数>
    {
        @ @an<CVolString>(::StrFormatByteSizeW(@<字节数>, PivBuffer<WCHAR>(100).GetPtr(), 100))
    }

    方法 取格式千字节文本 <公开 静态 类型 = 文本型 注释 = "返回KB单位的尺寸文本,会将字节数向上舍入取整,如小于1024也会返回\"1 KB\"." 折叠 折叠2
            @视窗.外部头文件 = "shlwapi.h" @视窗.外部库 = "Shlwapi.lib" @嵌入式方法 = "">
    参数 字节数 <类型 = 长整数>
    {
        @ @an<CVolString>(::StrFormatKBSizeW(@<字节数>, PivBuffer<WCHAR>(100).GetPtr(), 100))
    }

    方法 十六进制字符到数值 <公开 静态 类型 = 字符 注释 = "将一个十六进制字符转换到10进制数值," 注释 = "如果指定字符不是十六进制,则返回原值."
            注释 = "例: \'0\'->0, \'f\'->16" 折叠 @禁止流程检查 = 真>
    参数 字符值 <类型 = 字符>
    {
        @ if (@<字符值> >= '0' && @<字符值> <= '9')
        @     return @<字符值> - '0';
        @ if (@<字符值> >= 'a' && @<字符值> <= 'f')
        @     return @<字符值> - 'a' + 10;
        @ if (@<字符值> >= 'A' && @<字符值> <= 'F')
        @     return @<字符值> - 'A' + 10;
        @ return @<字符值>;
    }

    方法 USC2到字符 <公开 静态 类型 = 字符 注释 = "将一个USC2编码转换到Unicode字符,例: \"6d4b\"->\'测\'"
            注释 = "注意: 提供的文本应当不含\"\\u\"、\"%u\"等前缀,至少要有四个字符." 折叠 @禁止流程检查 = 真>
    参数 文本指针 <类型 = 变整数 注释 = "提供的文本至少有四个字符">
    {
        @ const WCHAR* hex = reinterpret_cast<const WCHAR*>(@<文本指针>);
        @ WCHAR dec[4];
        @ dec[0] = @<编码辅助类.十六进制字符到数值>(hex[0]);
        @ dec[1] = @<编码辅助类.十六进制字符到数值>(hex[1]);
        @ dec[2] = @<编码辅助类.十六进制字符到数值>(hex[2]);
        @ dec[3] = @<编码辅助类.十六进制字符到数值>(hex[3]);
        @ if (memcmp(dec, hex, 8) == 0)
        @     return 0;
        @ return (dec[0] << 12) | (dec[1] << 8) | (dec[2] << 4) | dec[3];
    }

    方法 文本到Usc2编码 <公开 静态 类型 = 文本型 注释 = "将文本内容转换到Usc2编码,例: \"测试\"->\"\\u6d4b\\u8bd5\"" 折叠 @禁止流程检查 = 真>
    参数 欲编码文本 <类型 = 文本型 注释 = "所欲编码的文本内容">
    参数 不编码ASCII字符 <类型 = 逻辑型 注释 = "不对英文字母、数字、半角标点符号进行编码" @默认值 = 真>
    参数 仅编码非常用字符 <类型 = 逻辑型 注释 = "仅转换GBK编码不支持显示的字符;" 注释 = "注: 本参数为真后,将无视上一个参数值,始终不编码ASCII字符." @默认值 = 假>
    参数 前缀 <类型 = 文本型 注释 = "可以自定义Usc编码的前缀,一般为\"\\u\"和\"%u\"." @默认值 = "\\u">
    {
        @ @an<CVolString> usc2;
        @ int len = static_cast<int>(@<欲编码文本>.GetLength());
        @ if (len <= 0) return usc2;
        @ static const char hexLowCh[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
        @ usc2.SetNumAlignChars(len * 6);
        @ const WCHAR* str = @<欲编码文本>.GetText();
        @ WCHAR wch;
        @ if (!@<仅编码非常用字符>) {
        @     for (int i = 0; i < len; i++) {
        @         wch = str[i];
        @         if ((@<不编码ASCII字符> == TRUE) && (str[i] < 256)) { usc2.AddChar(wch);  continue; }
        @         usc2.AddText(@<前缀>.GetText());
        @         usc2.AddChar(hexLowCh[static_cast<unsigned char>(wch >> 12)]);
        @         usc2.AddChar(hexLowCh[static_cast<unsigned char>(wch >> 8 & 0x000F)]);
        @         usc2.AddChar(hexLowCh[static_cast<unsigned char>((wch & 0x00FF) >> 4)]);
        @         usc2.AddChar(hexLowCh[static_cast<unsigned char>(wch & 0x000F)]);
        @     }
        @ } else {
        @     BOOL UsedDefaultChar = FALSE;  CHAR DefaultChar{(CHAR)0xFF};
        @     PivBuffer<CHAR, int> buffer(len * 3);
        @     int size = ::WideCharToMultiByte(936, 0, str, len, buffer.GetPtr(), len * 3, &DefaultChar, &UsedDefaultChar);
        @     if (UsedDefaultChar && size > 0) {
        @         PivBuffer<bool, int> encode(len); CHAR ch;
        @         for (int i = 0,n = 0; i < len; i++) {
        @             ch = buffer[n];
        @             if (ch > 0 && ch < 128) { encode[i] = false;  n++; }
        @             else if (ch == DefaultChar) { encode[i] = true;  n++; }
        @             else { encode[i] = false;  n+=2; }
        @         }
        @         for (int i = 0; i < len; i++) {
        @             wch = str[i];
        @             if (!encode[i]) { usc2.AddChar(wch);  continue; }
        @             usc2.AddText(@<前缀>.GetText());
        @             usc2.AddChar(hexLowCh[static_cast<unsigned char>(wch >> 12)]);
        @             usc2.AddChar(hexLowCh[static_cast<unsigned char>(wch >> 8 & 0x000F)]);
        @             usc2.AddChar(hexLowCh[static_cast<unsigned char>((wch & 0x00FF) >> 4)]);
        @             usc2.AddChar(hexLowCh[static_cast<unsigned char>(wch & 0x000F)]);
        @         }
        @         return usc2;
        @     }
        @     return @<欲编码文本>;
        @ }
        @ return usc2;
    }

    方法 Usc2编码到文本 <公开 静态 类型 = 文本型 注释 = "将Usc2编码文本还原为文本内容,例: \"\\u6d4b\\u8bd5\"->\"测试\"" 折叠 @禁止流程检查 = 真>
    参数 USC2文本 <类型 = 文本型 注释 = "请确保提供的Usc2编码文本有效,否则会返回不可预料的结果.">
    参数 前缀 <类型 = 文本型 注释 = "请提供Usc2编码的前缀,一般为\"\\u\"和\"%u\"." @默认值 = "\\u">
    {
        @ @an<CVolString> ret;
        @ INT_P Usc_len = @<USC2文本>.GetLength();
        @ INT_P Prefix_len = @<前缀>.GetLength();
        @ if (Prefix_len == 0 || Usc_len == 0) { return ret; }
        @ ret.SetNumAlignChars(Usc_len);
        @ const WCHAR* Usc = @<USC2文本>.GetText();
        @ const WCHAR* Prefix = @<前缀>.GetText();
        @ WCHAR ch;
        @ for (INT_P i = 0, n = 0; i < Usc_len; i++) {
        @     ch = Usc[i];
        @     if (Prefix[n] != ch) { n = 0; ret.AddChar(ch); continue; }
        @     if (++n < Prefix_len) { continue; }
        @     n = 0;
        @     if (Usc_len <= i + 4) { ret.AddText(Usc + i - Prefix_len + 1); break; }
        @     ch = @<编码辅助类.USC2到字符>(reinterpret_cast<INT_P>(Usc + i + 1));
        @     if (ch != 0) {
        @         ret.AddChar(ch); i+=4;
        @     } else {
        @         ret.AddText(Usc + i - Prefix_len + 1, Prefix_len);
        @     }
        @ }
        @ return ret;
    }

    方法 整数到中文小写数字 <公开 静态 类型 = 文本型 注释 = "将整数值格式化为中文小写数字." 注释 = "例: 12345 转换为“一万二千三百四十五”."
            注释 = "\"数值到大写\"的二次封装,区别是从小数改为整数值." 折叠 @禁止流程检查 = 真>
    参数 数字值 <类型 = 长整数 注释 = "进行转换的数字值,可以为字节、字符、短整数、整数、长整数等类型." "">
    {
        @ CVolString strResult;
        @ NumberToCNText ((DOUBLE)@<数字值>, TRUE, strResult);
        @ return strResult;
    }

    方法 整数到中文大写数字 <公开 静态 类型 = 文本型 注释 = "将整数值格式化为中文大写数字." 注释 = "例: 12345 转换为“壹万贰仟叁佰肆拾伍”."
            注释 = "\"数值到大写\"的二次封装,区别是从小数改为整数值." 折叠 @禁止流程检查 = 真>
    参数 数字值 <类型 = 长整数 注释 = "进行转换的数字值,可以为字节、字符、短整数、整数、长整数等类型.">
    {
        @ CVolString strResult;
        @ NumberToCNText ((DOUBLE)@<数字值>, FALSE, strResult);
        @ return strResult;
    }

    方法 小数到中文小写数字 <公开 静态 类型 = 文本型 注释 = "将小数值格式化为中文小写数字." 注释 = "例: 12345.55 转换为“一万二千三百四十五.五五”."
            注释 = "\"数值到大写\"的二次封装,区别是\"点\"改用了\".\"符号." 折叠 @禁止流程检查 = 真>
    参数 数字值 <类型 = 小数 注释 = "进行转换的数字值">
    参数 小数位数 <类型 = 整数 注释 = "指定保留的小数位数,必须大于等于0" @默认值 = 2>
    {
        @ CVolString strResult;
        @ NumberToCNText (RoundDouble (@<数字值>, @<小数位数>), TRUE, strResult);
        @ strResult.ReplaceSubText (_CT2(L"点"), _CT2(L"."), 0, 1, FALSE);
        @ return strResult;
    }

    方法 小数到中文大写数字 <公开 静态 类型 = 文本型 注释 = "将小数值格式化为中文大写数字." 注释 = "例: 12345.55 转换为“壹万贰仟叁佰肆拾伍.伍伍”."
            注释 = "\"数值到大写\"的二次封装,区别是\"点\"改用了\".\"符号." 折叠 @禁止流程检查 = 真>
    参数 数字值 <类型 = 小数 注释 = "进行转换的数字值">
    参数 小数位数 <类型 = 整数 注释 = "指定保留的小数位数,必须大于等于0" @默认值 = 2>
    {
        @ CVolString strResult;
        @ NumberToCNText (RoundDouble (@<数字值>, @<小数位数>), FALSE, strResult);
        @ strResult.ReplaceSubText (_CT2(L"点"), _CT2(L"."), 0, 1, FALSE);
        @ return strResult;
    }

    方法 小数到中文小写金额 <公开 静态 类型 = 文本型 注释 = "将小数值格式化为中文小写金额." 注释 = "例: 12345.50 转换为“人民币一万二千三百四十五元五角”."
            注释 = "\"数值到金融\"的二次封装,区别是带了\"人民币\"前缀." 折叠 @禁止流程检查 = 真>
    参数 数字值 <类型 = 小数 注释 = "进行转换的数字值">
    参数 前缀文本 <类型 = 文本型 @默认值 = "人民币">
    {
        @ CVolString strResult;
        @ NumberToCurrency (@<数字值>, TRUE, strResult);
        @ strResult.InsertText (0, @<前缀文本>.GetText ());
        @ return strResult;
    }

    方法 小数到中文大写金额 <公开 静态 类型 = 文本型 注释 = "将小数值格式化为中文大写金额." 注释 = "例: 12345.50 转换为“人民币壹万贰仟叁佰肆拾伍元伍角”."
            注释 = "\"数值到金融\"的二次封装,区别是带了\"人民币\"前缀." 折叠 @禁止流程检查 = 真>
    参数 数字值 <类型 = 小数 注释 = "进行转换的数字值">
    参数 前缀文本 <类型 = 文本型 @默认值 = "人民币">
    {
        @ CVolString strResult;
        @ NumberToCurrency (@<数字值>, FALSE, strResult);
        @ strResult.InsertText (0, @<前缀文本>.GetText ());
        @ return strResult;
    }

    # @begin
    # <> <include>
    # template <typename T>
    # static INT GetValueDigit(T value) {
    #     value /= 10; INT count = 1;
    #     while (value) { value /= 10; count++; }
    #     return count;
    # }
    # <> </include>
    # @end
}

类 位集合 <公开 注释 = "  位集合(std::bitset)表示一个N位的固定大小序列.可以用逻辑运算符" 注释 = "操作位集合,并将它与文本和整数互相转换."
        注释 = "  位集合的成员元素为二进制位,可以很方便地设置和获取二进制位的值." 注释 = "" 注释 = "注意事项:"
        注释 = " 1. 必须执行\"创建/创建自XX\"方法后,才能使用本类的其他方法;" 注释 = " 2. 赋值时,必须确保两个变量均已被创建,且二进制位数一致;" 折叠
        @文档 = "category = \"编码处理\"" @视窗.外部头文件 = "<bitset>" @别名 = "// std::bitset<N>" @别名类型 = 本地类>
{

    # 构造函数 ---

    方法 创建 <公开 静态 注释 = "构造指定位数的位集合,其中所有位均设置为假(0)." 注释 = "注意: 本类的所有创建方法都不能重复调用." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = 位集合 "">
    参数 位数 <类型 = 整数 注释 = "所欲构造的位数,1字节为8位." 注释 = "注意: 本参数不能使用整数变量,需要立即数、常量或方法返回值;">
    {
        @ std::bitset<@<位数>> @<当前对象>
    }

    方法 创建自数值 <公开 静态 注释 = "通过整数型值初始化构造位集合,位数与所提供的数值一样大(1字节为8位)." 注释 = "注意: 本类的所有创建方法都不能重复调用." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = 位集合 "">
    参数 初始化数值 <注释 = "所欲初始化到位集合的整数型值" @匹配类型 = 通用整数型>
    {
        @ std::bitset<sizeof(@pdt<初始化数值>) * 8> @<当前对象>{@<初始化数值>}
    }

    方法 创建自文本 <公开 静态 注释 = "通过文本初始化构造位集合,需要指定位数." 注释 = "注意: 本类的所有创建方法都不能重复调用." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = 位集合 "">
    参数 位数 <类型 = 整数 注释 = "所欲构造的位数,1字节为8位." 注释 = "注意: 本参数不能使用整数变量,需要立即数、常量或方法返回值;">
    参数 位文本 <类型 = 文本型 注释 = "提供用于初始化位集合的文本,比如\"100010\".">
    参数 欲初始化长度 <类型 = 变整数 注释 = "提供使用位文本的多少个字符,必须小于或等于位文本的长度,-1表示使用整个文本." @默认值 = -1>
    参数 零字符 <类型 = 字符 注释 = "位设置为0(false)的代用字符" @默认值 = '0'>
    参数 一字符 <类型 = 字符 注释 = "位设置为1(true)的代用字符" @默认值 = '1'>
    {
        @ std::bitset<@<位数>> @<当前对象>{@<位文本>.GetText(), static_cast<size_t>(@<欲初始化长度>), @<零字符>, @<一字符>}
    }

    # 元素访问 ---

    方法 取位 <公开 静态 类型 = 逻辑型 注释 = "访问指定索引位置的二进制位,返回位的值(真/假)." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = 位集合>
    参数 索引位置 <类型 = 整数 注释 = "提供所欲返回位的位置,索引位置从0开始,必须大于等于0小于位集合的位数.">
    {
        @ @<当前对象>.test(@<索引位置>)
    }

    方法 为全部真 <公开 静态 类型 = 逻辑型 注释 = "位集合的所有二进制位均设置为真时返回真" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = 位集合 "">
    {
        @ @<当前对象>.all()
    }

    方法 为任一真 <公开 静态 类型 = 逻辑型 注释 = "位集合的任一二进制位设置为真时返回真" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = 位集合 "">
    {
        @ @<当前对象>.any()
    }

    方法 为全部假 <公开 静态 类型 = 逻辑型 注释 = "位集合的所有二进制位均重置为假时返回真" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = 位集合 "">
    {
        @ @<当前对象>.none()
    }

    方法 取设置位数 <公开 静态 类型 = 整数 注释 = "返回位集合中被设置为真的二进制位数量" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = 位集合 "">
    {
        @ static_cast<INT>(@<当前对象>.count())
    }

    # 容量 ---

    方法 取位数 <公开 静态 类型 = 整数 注释 = "返回位集合的位数" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = 位集合 "">
    {
        @ static_cast<INT>(@<当前对象>.size())
    }

    # 修改 ---

    方法 按位与 <公开 静态 类型 = 位集合 注释 = "进行两个位集合之间的二进制位与运算,返回计算结果." 注释 = "注意: 两个位集合以及返回结果的位数必须一致,"
            注释 = "若要将结果赋值到变量,被赋值的变量必须首先被\"创建\"." 折叠 @嵌入式方法 = "">
    参数 位运算左值 <类型 = 位集合>
    参数 位运算右值 <类型 = 位集合>
    {
        @ @<位运算左值> & @<位运算右值>
    }

    方法 按位或 <公开 静态 类型 = 位集合 注释 = "进行两个位集合之间的二进制位或运算,返回计算结果." 注释 = "注意: 两个位集合以及返回结果的位数必须一致,"
            注释 = "若要将结果赋值到变量,被赋值的变量必须首先被\"创建\"." 折叠 @嵌入式方法 = "">
    参数 位运算左值 <类型 = 位集合>
    参数 位运算右值 <类型 = 位集合>
    {
        @ @<位运算左值> | @<位运算右值>
    }

    方法 按位异或 <公开 静态 类型 = 位集合 注释 = "进行两个位集合之间的二进制位异或运算,返回计算结果." 注释 = "注意: 两个位集合以及返回结果的位数必须一致,"
            注释 = "若要将结果赋值到变量,被赋值的变量必须首先被\"创建\"." 折叠 @嵌入式方法 = "">
    参数 位运算左值 <类型 = 位集合>
    参数 位运算右值 <类型 = 位集合>
    {
        @ @<位运算左值> ^ @<位运算右值>
    }

    方法 按位左移 <公开 静态 类型 = 位集合 注释 = "进行位集合的二进制左移(向高索引位置),返回计算结果." 注释 = "注意: 返回结果的位数跟当前对象一致,若要将结果赋值到变量,"
            注释 = "被赋值的变量必须首先被\"创建\"." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = 位集合>
    参数 位移数目 <类型 = 整数>
    {
        @ @<当前对象> << static_cast<size_t>(@<位移数目>)
    }

    方法 按位右移 <公开 静态 类型 = 位集合 注释 = "进行位集合的二进制右移(向低索引位置),返回计算结果." 注释 = "注意: 返回结果的位数跟当前对象一致,"
            注释 = "若要将结果赋值到变量,被赋值的变量必须首先被\"创建\"." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = 位集合>
    参数 位移数目 <类型 = 整数>
    {
        @ @<当前对象> >> static_cast<size_t>(@<位移数目>)
    }

    方法 按位取反 <公开 静态 类型 = 位集合 注释 = "将位集合的所有二进制位进行反转,返回反转之后的结果." 注释 = "注意: 返回结果的位数跟当前对象一致,若要将结果赋值到变量,"
            注释 = "被赋值的变量必须首先被\"创建\"." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = 位集合>
    {
        @ ~@<当前对象>
    }

    # --

    方法 自身位与 <公开 静态 类型 = 位集合 注释 = "将当前位集合与指定位集合之间进行二进制位与运算,返回自身." 注释 = "注意: 两个位集合的位数必须一致" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 当前对象 <类型 = 位集合>
    参数 位运算右值 <类型 = 位集合>
    {
        @ @<当前对象> &= @<位运算右值>
    }

    方法 自身位或 <公开 静态 类型 = 位集合 注释 = "将当前位集合与指定位集合之间进行二进制位或运算,返回自身." 注释 = "注意: 两个位集合的位数必须一致" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 当前对象 <类型 = 位集合>
    参数 位运算右值 <类型 = 位集合>
    {
        @ @<当前对象> |= @<位运算右值>
    }

    方法 自身位异或 <公开 静态 类型 = 位集合 注释 = "将当前位集合与指定位集合之间进行二进制位异或运算,返回自身." 注释 = "注意: 两个位集合的位数必须一致" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 当前对象 <类型 = 位集合>
    参数 位运算右值 <类型 = 位集合>
    {
        @ @<当前对象> ^= @<位运算右值>
    }

    方法 自身位左移 <公开 静态 类型 = 位集合 注释 = "将当前位集合的二进制左移(向高索引位置)指定数目,返回自身." 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 当前对象 <类型 = 位集合>
    参数 位移数目 <类型 = 整数>
    {
        @ @<当前对象> <<= static_cast<size_t>(@<位移数目>)
    }

    方法 自身位右移 <公开 静态 类型 = 位集合 注释 = "将当前位集合的二进制右移(向低索引位置)指定数目,返回自身." 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 当前对象 <类型 = 位集合>
    参数 位移数目 <类型 = 整数>
    {
        @ @<当前对象> >>= static_cast<size_t>(@<位移数目>)
    }

    # --

    方法 设置位 <公开 静态 类型 = 位集合 注释 = "将指定位置的二进制位设置为真,返回位集合自身." 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 当前对象 <类型 = 位集合 "">
    参数 索引位置 <类型 = 整数 注释 = "提供所欲设置的位的位置,索引位置从0开始,必须大于等于0小于位集合的位数.">
    {
        @ @<当前对象>.set(static_cast<size_t>(@<索引位置>), true)
    }

    方法 重置位 <公开 静态 类型 = 位集合 注释 = "将指定位置的二进制位重置为假,返回位集合自身." 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 当前对象 <类型 = 位集合 "">
    参数 索引位置 <类型 = 整数 注释 = "提供所欲设置的位的位置,索引位置从0开始,必须大于等于0小于位集合的位数.">
    {
        @ @<当前对象>.reset(static_cast<size_t>(@<索引位置>))
    }

    方法 反转位 <公开 静态 类型 = 位集合 注释 = "反转指定位置的二进制位(真改为假,假改为真),返回位集合自身." 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 当前对象 <类型 = 位集合 "">
    参数 索引位置 <类型 = 整数 注释 = "提供所欲翻转的位的位置,索引位置从0开始,必须大于等于0小于位集合的位数.">
    {
        @ @<当前对象>.flip(static_cast<size_t>(@<索引位置>))
    }

    方法 设置所有位 <公开 静态 类型 = 位集合 注释 = "将所有二进制位的值设置为真,返回位集合自身." 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 当前对象 <类型 = 位集合 "">
    {
        @ @<当前对象>.set()
    }

    方法 重置所有位 <公开 静态 类型 = 位集合 注释 = "将所有二进制位的值重置为假,返回位集合自身." 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 当前对象 <类型 = 位集合 "">
    {
        @ @<当前对象>.reset()
    }

    方法 反转所有位 <公开 静态 类型 = 位集合 注释 = "翻转所有二进制位的值(真改为假,假改为真),返回位集合自身." 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 当前对象 <类型 = 位集合 "">
    {
        @ @<当前对象>.flip()
    }

    # 转换 ---

    方法 到文本 <公开 静态 类型 = 文本型 注释 = "将位集合的内容转换到文本" 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = 位集合 "">
    参数 零字符 <类型 = 字符 注释 = "位设置为假(0)的代用字符" @默认值 = '0'>
    参数 一字符 <类型 = 字符 注释 = "位设置为真(1)的代用字符" @默认值 = '1'>
    {
        @ @an<CVolString>{@<当前对象>.to_string<wchar_t>(@<零字符>, @<一字符>).c_str()}
    }

    方法 到整数 <公开 静态 类型 = 整数 注释 = "将位集合的内容转换到整数." 注释 = "位集合的首位对应数值的最低有效位,而尾位对应最高有效位." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = 位集合 "">
    {
        @ static_cast<int32_t>(@<当前对象>.to_ulong())
    }

    方法 到长整数 <公开 静态 类型 = 长整数 注释 = "将位集合的内容转换到长整数." 注释 = "位集合的首位对应数值的最低有效位,而尾位对应最高有效位." 折叠 @嵌入式方法 = "">
    参数 当前对象 <类型 = 位集合 "">
    {
        @ static_cast<int64_t>(@<当前对象>.to_ullong())
    }
}

# ===

类 simdUTF <公开 注释 = "  使用SIMD指令集(SSE2, AVX2, NEON, AVX-512)加速," 注释 = "每秒数十亿字符的Unicode编码验证和转换库."
        注释 = "  源码: https://github.com/simdutf/simdutf" 折叠 @文档 = "category = \"编码处理\"" @禁止创建对象 = 真
        @视窗.外部头文件 = "src\\simdutf.h" @视窗.外部源文件 = "src\\simdutf.cpp">
{

    # 常用编码转换 ---

    方法 UTF8到文本 <公开 静态 类型 = 文本型 注释 = "将所指定UTF-8格式的文本数据转换到UTF-16LE文本后返回." 折叠>
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        变量 结果 <类型 = 文本型>
        UTF8到文本_Ex (UTF8文本, 结果, 是否校验文本)
        返回 (结果)
    }

    方法 文本到UTF8 <公开 静态 类型 = 字节集类 注释 = "将UTF-16LE文本转换到UTF-8字节集后返回." 折叠>
    参数 UTF16文本 <类型 = 文本型 注释 = "提供所欲转换的UTF-16LE文本">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        变量 结果 <类型 = 字节集类>
        文本到UTF8_Ex (UTF16文本, 结果, 是否包括结束零字符, 是否校验文本)
        返回 (结果)
    }

    方法 多字节到UTF8 <公开 静态 类型 = 字节集类 注释 = "将所指定ANSI多字节数据转换到UTF-8字节集后返回." 折叠>
    参数 多字节文本 <类型 = 字节集类 注释 = "提供所欲转换的ANSI多字节编码文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        变量 结果 <类型 = 字节集类>
        多字节到UTF8_Ex (多字节文本, 结果, 是否包括结束零字符, 是否校验文本)
        返回 (结果)
    }

    方法 UTF8到多字节 <公开 静态 类型 = 字节集类 注释 = "将所指定UTF-8格式数据转换到ANSI多字节后返回." 折叠>
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        变量 结果 <类型 = 字节集类>
        UTF8到多字节_Ex (UTF8文本, 结果, 是否包括结束零字符, 是否校验文本)
        返回 (结果)
    }

    方法 UTF8到文本_Ex <公开 静态 类型 = 整数 注释 = "将所指定UTF-8格式的文本数据转换到UTF-16LE文本." 注释 = "跟\"UTF8到文本\"的区别是在参数中返回转换后的数据."
            返回值注释 = "返回UTF-16LE文本的字符数(2字节),失败返回0." 折叠 @禁止流程检查 = 真>
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据" @输出名 = "input">
    参数 UTF16文本 <类型 = 文本型 注释 = "转换后的UTF-16LE文本将保存在此参数中" @输出名 = "output">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假 @输出名 = "validate">
    {
        @ size_t outlen = simdutf::utf16_length_from_utf8(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()));
        @ if (!outlen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ output.SetLength(outlen);
        @ outlen = validate ? simdutf::convert_utf8_to_utf16le(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()),
        @                                                      reinterpret_cast<char16_t *>(const_cast<WCHAR *>(output.GetText())))
        @                   : simdutf::convert_valid_utf8_to_utf16le(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()),
        @                                                            reinterpret_cast<char16_t *>(const_cast<WCHAR *>(output.GetText())));
        @ output.SetLength(outlen);
        @ return static_cast<INT>(outlen);
    }

    方法 文本到UTF8_Ex <公开 静态 类型 = 整数 注释 = "将UTF-16LE文本转换到UTF-8字节集." 注释 = "跟\"文本到UTF8\"的区别是在参数中返回转换后的数据."
            返回值注释 = "返回UTF-8文本的字节数,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 UTF16文本 <类型 = 文本型 注释 = "提供所欲转换的UTF-16LE文本" @输出名 = "input">
    参数 UTF8文本 <类型 = 字节集类 注释 = "转换后的UTF-8文本将保存在此参数中" @输出名 = "output">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假 @输出名 = "null_terminated">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假 @输出名 = "validate">
    {
        @ size_t outlen = simdutf::utf8_length_from_utf16le(reinterpret_cast<const char16_t *>(input.GetText()), static_cast<size_t>(input.GetLength()));
        @ if (!outlen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ output.Alloc(outlen + 1, TRUE);
        @ outlen = validate ? simdutf::convert_utf16le_to_utf8(reinterpret_cast<const char16_t *>(input.GetText()), static_cast<size_t>(input.GetLength()),
        @                                                      reinterpret_cast<char *>(output.GetPtr()))
        @                   : simdutf::convert_valid_utf16le_to_utf8(reinterpret_cast<const char16_t *>(input.GetText()), static_cast<size_t>(input.GetLength()),
        @                                                            reinterpret_cast<char *>(output.GetPtr()));
        @ output.Realloc(outlen ? (outlen + (null_terminated ? 1 : 0)) : 0);
        @ return static_cast<INT>(outlen);
    }

    方法 多字节到UTF8_Ex <公开 静态 类型 = 整数 注释 = "将所指定ANSI多字节数据转换到UTF-8字节集." 注释 = "跟\"多字节到UTF8\"的区别是在参数中返回转换后的数据."
            返回值注释 = "返回UTF-8文本的字节数,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 多字节文本 <类型 = 字节集类 注释 = "提供所欲转换的ANSI多字节编码文本数据" @输出名 = "input">
    参数 UTF8文本 <类型 = 字节集类 注释 = "转换后的UTF-8文本将保存在此参数中" @输出名 = "output">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假 @输出名 = "null_terminated">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假 @输出名 = "validate">
    {
        @ int utf16len = ::MultiByteToWideChar(CP_ACP, 0, reinterpret_cast<const char *>(input.GetPtr()), static_cast<int>(input.GetSize()), NULL, 0);
        @ if (!utf16len) {
        @     output.Empty();
        @     return 0;
        @ }
        @ PivBuffer<wchar_t, int> buf{utf16len + 1, true};
        @ ::MultiByteToWideChar(CP_ACP, 0, reinterpret_cast<const char *>(input.GetPtr()), static_cast<int>(input.GetSize()), buf.GetPtr(), utf16len);
        @ size_t outlen = simdutf::utf8_length_from_utf16le(reinterpret_cast<const char16_t *>(buf.GetPtr()), utf16len);
        @ if (!outlen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ output.Alloc(outlen + 1, TRUE);
        @ outlen = validate ? simdutf::convert_utf16le_to_utf8(reinterpret_cast<const char16_t *>(buf.GetPtr()), utf16len, reinterpret_cast<char *>(output.GetPtr()))
        @                   : simdutf::convert_valid_utf16le_to_utf8(reinterpret_cast<const char16_t *>(buf.GetPtr()), utf16len, reinterpret_cast<char *>(output.GetPtr()));
        @ output.Realloc(outlen ? (outlen + (null_terminated ? 1 : 0)) : 0);
        @ return static_cast<INT>(outlen);
    }

    方法 UTF8到多字节_Ex <公开 静态 类型 = 整数 注释 = "将所指定UTF-8格式数据转换到ANSI多字节." 注释 = "跟\"UTF8到多字节\"的区别是在参数中返回转换后的数据."
            返回值注释 = "返回多字节文本的字节数,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据" @输出名 = "input">
    参数 多字节文本 <类型 = 字节集类 注释 = "转换后的ANSI多字节文本将保存在此参数中" @输出名 = "output">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假 @输出名 = "null_terminated">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假 @输出名 = "validate">
    {
        @ size_t outlen = simdutf::utf16_length_from_utf8(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()));
        @ if (!outlen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ PivBuffer<char16_t, size_t> buf{outlen + 1, true};
        @ outlen = validate ? simdutf::convert_utf8_to_utf16le(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()), buf.GetPtr())
        @                   : simdutf::convert_valid_utf8_to_utf16le(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()), buf.GetPtr());
        @ if (!outlen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ int mbslen = ::WideCharToMultiByte(CP_ACP, 0, reinterpret_cast<const wchar_t *>(buf.GetPtr()), static_cast<int>(outlen), NULL, 0, NULL, NULL);
        @ if (!mbslen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ output.Alloc(mbslen + 1, TRUE);
        @ mbslen = ::WideCharToMultiByte(CP_ACP, 0, reinterpret_cast<const wchar_t *>(buf.GetPtr()), static_cast<int>(outlen), reinterpret_cast<char *>(output.GetPtr()), mbslen, NULL, NULL);
        @ output.Realloc(mbslen + (null_terminated ? 1 : 0));
        @ return mbslen;
    }

    方法 反转文本字节序 <公开 静态 类型 = 字节集类 注释 = "  将提供的数据反转字节序,比如将输入的UTF-16LE转换为"
            注释 = "UTF-16BE,或者将UTF-16BE转换为UTF-16LE." 返回值注释 = "返回反转后的UTF-16编码数据" 折叠 @禁止流程检查 = 真>
    参数 UTF16数据 <类型 = 字节集类 注释 = "所欲反转字节序的UTF-16编码数据" @输出名 = "input">
    {
        @ @an<CVolMem> output;
        @ output.Alloc(input.GetSize(), TRUE);
        @ simdutf::change_endianness_utf16(reinterpret_cast<const char16_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()),
        @                                  reinterpret_cast<char16_t *>(output.GetPtr()));
        @ return output;
    }

    # 编码检测 ---

    方法 自动检测编码 <公开 静态 类型 = 整数 注释 = "自动检测文本数据的Unicode编码类型,本方法只返回一个结果." 注释 = "本方法不支持检测ANSI的编码,统一返回0(未知)."
            返回值注释 = "请参考\"SIMD编码类型\"的常量,本方法只返回其中一个值." 折叠 @禁止流程检查 = 真>
    参数 文本数据 <类型 = 字节集类 注释 = "所欲检测Unicode编码的文本数据." @输出名 = "input">
    {
        @ return simdutf::autodetect_encoding(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()));
    }

    方法 检测编码 <公开 静态 类型 = 整数 注释 = "  检测文本数据的Unicode编码类型,如果检测的结果可能是UTF8或UTF-16LE,"
            注释 = "它将返回\"SIMD编码类型.UTF8 | SIMD编码类型.UTF-16LE\"的位或值." 注释 = "  本方法不支持检测ANSI的编码,统一返回0(未知)."
            返回值注释 = "返回的结果可能是\"SIMD编码类型\"常量的位或值,请通过\"位与\"判断类型." 折叠 @禁止流程检查 = 真>
    参数 文本数据 <类型 = 字节集类 @输出名 = "input">
    {
        @ return simdutf::detect_encodings(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()));

    }

    # UTF-8转换到其他 ---

    方法 UTF8到UTF16LE <公开 静态 类型 = 字节集类 注释 = "将所指定UTF-8格式的文本数据转换到UTF-16LE字节集后返回." 折叠>
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        变量 结果 <类型 = 字节集类>
        UTF8到UTF16LE_Ex (UTF8文本, 结果, 是否包括结束零字符, 是否校验文本)
        返回 (结果)
    }

    方法 UTF8到UTF16BE <公开 静态 类型 = 字节集类 注释 = "将所指定UTF-8格式的文本数据转换到UTF-16BE字节集后返回." 折叠>
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        变量 结果 <类型 = 字节集类>
        UTF8到UTF16BE_Ex (UTF8文本, 结果, 是否包括结束零字符, 是否校验文本)
        返回 (结果)
    }

    方法 UTF8到UTF32 <公开 静态 类型 = 字节集类 注释 = "将所指定UTF-8格式的文本数据转换到UTF-32文本数据后返回." 折叠>
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        变量 结果 <类型 = 字节集类>
        UTF8到UTF32_Ex (UTF8文本, 结果, 是否包括结束零字符, 是否校验文本)
        返回 (结果)
    }

    方法 UTF8到UTF16LE_Ex <公开 静态 类型 = 整数 注释 = "将所指定UTF-8格式的文本数据转换到UTF-16LE字节集."
            注释 = "跟\"UTF8到UTF16LE\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-16LE文本的字符数(2字节),失败返回0." 折叠 @禁止流程检查 = 真>
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据" @输出名 = "input">
    参数 UTF16文本 <类型 = 字节集类 注释 = "转换后的UTF-16LE文本将保存在此参数中" @输出名 = "output">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假 @输出名 = "null_terminated">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假 @输出名 = "validate">
    {
        @ size_t outlen = simdutf::utf16_length_from_utf8(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()));
        @ if (!outlen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ output.Alloc((outlen + 1) * 2, TRUE);
        @ outlen = validate ? simdutf::convert_utf8_to_utf16le(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()),
        @                                                      reinterpret_cast<char16_t *>(output.GetPtr()))
        @                   : simdutf::convert_valid_utf8_to_utf16le(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()),
        @                                                            reinterpret_cast<char16_t *>(output.GetPtr()));
        @ output.Realloc(outlen ? ((outlen + (null_terminated ? 1 : 0)) * 2) : 0);
        @ return static_cast<INT>(outlen);
    }

    方法 UTF8到UTF16BE_Ex <公开 静态 类型 = 整数 注释 = "将所指定UTF-8格式的文本数据转换到UTF-16BE字节集."
            注释 = "跟\"UTF8到UTF16BE\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-16BE文本的字符数(2字节),失败返回0." 折叠 @禁止流程检查 = 真>
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据" @输出名 = "input">
    参数 UTF16文本 <类型 = 字节集类 注释 = "转换后的UTF-16BE文本将保存在此参数中" @输出名 = "output">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假 @输出名 = "null_terminated">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假 @输出名 = "validate">
    {
        @ size_t outlen = simdutf::utf16_length_from_utf8(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()));
        @ if (!outlen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ output.Alloc((outlen + 1) * 2, TRUE);
        @ outlen = validate ? simdutf::convert_utf8_to_utf16be(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()),
        @                                                      reinterpret_cast<char16_t *>(output.GetPtr()))
        @                   : simdutf::convert_valid_utf8_to_utf16be(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()),
        @                                                            reinterpret_cast<char16_t *>(output.GetPtr()));
        @ output.Realloc(outlen ? ((outlen + (null_terminated ? 1 : 0)) * 2) : 0);
        @ return static_cast<INT>(outlen);
    }

    方法 UTF8到UTF32_Ex <公开 静态 类型 = 整数 注释 = "将所指定UTF-8格式的文本数据转换到UTF-32文本数据."
            注释 = "跟\"UTF8到UTF32\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-32文本的字符数(4字节),失败返回0." 折叠 @禁止流程检查 = 真>
    参数 UTF8文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-8字符集文本数据" @输出名 = "input">
    参数 UTF32文本 <类型 = 字节集类 注释 = "转换后的UTF-32文本将保存在此参数中" @输出名 = "output">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假 @输出名 = "null_terminated">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假 @输出名 = "validate">
    {
        @ size_t outlen = simdutf::utf32_length_from_utf8(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()));
        @ if (!outlen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ output.Alloc((outlen + 1) * 4, TRUE);
        @ outlen = validate ? simdutf::convert_utf8_to_utf32(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()),
        @                                                    reinterpret_cast<char32_t *>(output.GetPtr()))
        @                   : simdutf::convert_valid_utf8_to_utf32(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()),
        @                                                          reinterpret_cast<char32_t *>(output.GetPtr()));
        @ output.Realloc(outlen ? ((outlen + (null_terminated ? 1 : 0)) * 4) : 0);
        @ return static_cast<INT>(outlen);
    }

    # UTF-16转换到其他 ---

    方法 文本到UTF32 <公开 静态 类型 = 字节集类 注释 = "将UTF-16LE文本转换到UTF-32字节集后返回." 折叠>
    参数 UTF16文本 <类型 = 文本型 注释 = "提供所欲转换的UTF-16LE文本">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        变量 结果 <类型 = 字节集类>
        文本到UTF32_Ex (UTF16文本, 结果, 是否包括结束零字符, 是否校验文本)
        返回 (结果)
    }

    方法 UTF16LE到UTF8 <公开 静态 类型 = 字节集类 注释 = "将UTF-16LE文本数据转换到UTF-8字节集后返回." 折叠>
    参数 UTF16文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-16LE文本">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        变量 结果 <类型 = 字节集类>
        UTF16LE到UTF8_Ex (UTF16文本, 结果, 是否包括结束零字符, 是否校验文本)
        返回 (结果)
    }

    方法 UTF16LE到UTF32 <公开 静态 类型 = 字节集类 注释 = "将UTF-16LE文本转换到UTF-32字节集后返回." 折叠>
    参数 UTF16文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-16LE文本">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        变量 结果 <类型 = 字节集类>
        UTF16LE到UTF32_Ex (UTF16文本, 结果, 是否包括结束零字符, 是否校验文本)
        返回 (结果)
    }

    方法 UTF16BE到UTF8 <公开 静态 类型 = 字节集类 注释 = "将UTF-16BE文本数据转换到UTF-8字节集后返回." 折叠>
    参数 UTF16文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-16BE文本">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        变量 结果 <类型 = 字节集类>
        UTF16BE到UTF8_Ex (UTF16文本, 结果, 是否包括结束零字符, 是否校验文本)
        返回 (结果)
    }

    方法 UTF16BE到UTF32 <公开 静态 类型 = 字节集类 注释 = "将UTF-16BE文本数据转换到UTF-32字节集后返回." 折叠>
    参数 UTF16文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-16BE文本">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        变量 结果 <类型 = 字节集类>
        UTF16BE到UTF32_Ex (UTF16文本, 结果, 是否包括结束零字符, 是否校验文本)
        返回 (结果)
    }

    方法 文本到UTF32_Ex <公开 静态 类型 = 整数 注释 = "将UTF-16LE文本转换到UTF-32字节集后返回." 注释 = "跟\"文本到UTF32\"的区别是在参数中返回转换后的数据."
            返回值注释 = "返回UTF-32文本的字符数(4字节),失败返回0." 折叠 @禁止流程检查 = 真>
    参数 UTF16文本 <类型 = 文本型 注释 = "提供所欲转换的UTF-16LE文本" @输出名 = "input">
    参数 UTF32文本 <类型 = 字节集类 注释 = "转换后的UTF-32文本将保存在此参数中" @输出名 = "output">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假 @输出名 = "null_terminated">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假 @输出名 = "validate">
    {
        @ size_t outlen = simdutf::utf32_length_from_utf16le(reinterpret_cast<const char16_t *>(input.GetText()), static_cast<size_t>(input.GetLength()));
        @ if (!outlen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ output.Alloc((outlen + 1) * 4, TRUE);
        @ outlen = validate ? simdutf::convert_utf16le_to_utf32(reinterpret_cast<const char16_t *>(input.GetText()), static_cast<size_t>(input.GetLength()),
        @                                                       reinterpret_cast<char32_t *>(output.GetPtr()))
        @                   : simdutf::convert_valid_utf16le_to_utf32(reinterpret_cast<const char16_t *>(input.GetText()), static_cast<size_t>(input.GetLength()),
        @                                                             reinterpret_cast<char32_t *>(output.GetPtr()));
        @ output.Realloc(outlen ? ((outlen + (null_terminated ? 1 : 0)) * 4) : 0);
        @ return static_cast<INT>(outlen);
    }

    方法 UTF16LE到UTF8_Ex <公开 静态 类型 = 整数 注释 = "将UTF-16LE文本数据转换到UTF-8字节集."
            注释 = "跟\"UTF16LE到UTF8\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-8文本的字节数,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 UTF16文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-16LE文本" @输出名 = "input">
    参数 UTF8文本 <类型 = 字节集类 注释 = "转换后的UTF-8文本将保存在此参数中" @输出名 = "output">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假 @输出名 = "null_terminated">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假 @输出名 = "validate">
    {
        @ size_t outlen = simdutf::utf8_length_from_utf16le(reinterpret_cast<const char16_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 2);
        @ if (!outlen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ output.Alloc(outlen + 1, TRUE);
        @ outlen = validate ? simdutf::convert_utf16le_to_utf8(reinterpret_cast<const char16_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 2,
        @                                                      reinterpret_cast<char *>(output.GetPtr()))
        @                   : simdutf::convert_valid_utf16le_to_utf8(reinterpret_cast<const char16_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 2,
        @                                                            reinterpret_cast<char *>(output.GetPtr()));
        @ output.Realloc(outlen ? (outlen + (null_terminated ? 1 : 0)) : 0);
        @ return static_cast<INT>(outlen);
    }

    方法 UTF16LE到UTF32_Ex <公开 静态 类型 = 整数 注释 = "将UTF-16LE文本转换到UTF-32字节集."
            注释 = "跟\"UTF16LE到UTF32\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-32文本的字符数(4字节),失败返回0." 折叠 @禁止流程检查 = 真>
    参数 UTF16文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-16LE文本" @输出名 = "input">
    参数 UTF32文本 <类型 = 字节集类 注释 = "转换后的UTF-32文本将保存在此参数中" @输出名 = "output">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假 @输出名 = "null_terminated">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假 @输出名 = "validate">
    {
        @ size_t outlen = simdutf::utf32_length_from_utf16le(reinterpret_cast<const char16_t *>(input.GetPtr()), static_cast<size_t>(input.GetLength()));
        @ if (!outlen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ output.Alloc((outlen + 1) * 4, TRUE);
        @ outlen = validate ? simdutf::convert_utf16le_to_utf32(reinterpret_cast<const char16_t *>(input.GetText()), static_cast<size_t>(input.GetLength()),
        @                                                       reinterpret_cast<char32_t *>(output.GetPtr()))
        @                   : simdutf::convert_valid_utf16le_to_utf32(reinterpret_cast<const char16_t *>(input.GetText()), static_cast<size_t>(input.GetLength()),
        @                                                             reinterpret_cast<char32_t *>(output.GetPtr()));
        @ output.Realloc(outlen ? ((outlen + (null_terminated ? 1 : 0)) * 4) : 0);
        @ return static_cast<INT>(outlen);
    }

    方法 UTF16BE到UTF8_Ex <公开 静态 类型 = 整数 注释 = "将UTF-16BE文本数据转换到UTF-8字节集."
            注释 = "跟\"UTF16BE到UTF8\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-8文本的字节数,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 UTF16文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-16BE文本" @输出名 = "input">
    参数 UTF8文本 <类型 = 字节集类 注释 = "转换后的UTF-8文本将保存在此参数中" @输出名 = "output">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假 @输出名 = "null_terminated">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假 @输出名 = "validate">
    {
        @ size_t outlen = simdutf::utf8_length_from_utf16be(reinterpret_cast<const char16_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 2);
        @ if (!outlen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ output.Alloc(outlen + 1, TRUE);
        @ outlen = validate ? simdutf::convert_utf16be_to_utf8(reinterpret_cast<const char16_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 2,
        @                                                      reinterpret_cast<char *>(output.GetPtr()))
        @                   : simdutf::convert_valid_utf16be_to_utf8(reinterpret_cast<const char16_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 2,
        @                                                            reinterpret_cast<char *>(output.GetPtr()));
        @ output.Realloc(outlen ? (outlen + (null_terminated ? 1 : 0)) : 0);
        @ return static_cast<INT>(outlen);
    }

    方法 UTF16BE到UTF32_Ex <公开 静态 类型 = 整数 注释 = "将UTF-16BE文本数据转换到UTF-32字节集."
            注释 = "跟\"UTF16BE到UTF32\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-32文本的字符数(4字节),失败返回0." 折叠 @禁止流程检查 = 真>
    参数 UTF16文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-16BE文本" @输出名 = "input">
    参数 UTF32文本 <类型 = 字节集类 注释 = "转换后的UTF-32文本将保存在此参数中" @输出名 = "output">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假 @输出名 = "null_terminated">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假 @输出名 = "validate">
    {
        @ size_t outlen = simdutf::utf32_length_from_utf16be(reinterpret_cast<const char16_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 2);
        @ if (!outlen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ output.Alloc((outlen + 1) * 4, TRUE);
        @ outlen = validate ? simdutf::convert_utf16be_to_utf32(reinterpret_cast<const char16_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 2,
        @                                                       reinterpret_cast<char32_t *>(output.GetPtr()))
        @                   : simdutf::convert_valid_utf16be_to_utf32(reinterpret_cast<const char16_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 2,
        @                                                             reinterpret_cast<char32_t *>(output.GetPtr()));
        @ output.Realloc(outlen ? ((outlen + (null_terminated ? 1 : 0)) * 4) : 0);
        @ return static_cast<INT>(outlen);
    }

    # UTF-32转换到其他 ---

    方法 UTF32到UTF8 <公开 静态 类型 = 字节集类 注释 = "将UTF-32文本数据转换到UTF-8字节集后返回." 折叠>
    参数 UTF32文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-32字符集文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        变量 结果 <类型 = 字节集类>
        UTF32到UTF8_Ex (UTF32文本, 结果, 是否包括结束零字符, 是否校验文本)
        返回 (结果)
    }

    方法 UTF32到文本 <公开 静态 类型 = 文本型 注释 = "将UTF-32文本数据转换到UTF-16LE文本后返回." 折叠>
    参数 UTF32文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-32字符集文本数据">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        变量 结果 <类型 = 文本型>
        UTF32到文本_Ex (UTF32文本, 结果, 是否校验文本)
        返回 (结果)
    }

    方法 UTF32到UTF16LE <公开 静态 类型 = 字节集类 注释 = "将UTF-32文本数据转换到UTF-16LE字节集后返回." 折叠>
    参数 UTF32文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-32字符集文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        变量 结果 <类型 = 字节集类>
        UTF32到UTF16LE_Ex (UTF32文本, 结果, 是否包括结束零字符, 是否校验文本)
        返回 (结果)
    }

    方法 UTF32到UTF16BE <公开 静态 类型 = 字节集类 注释 = "将UTF-32文本数据转换到UTF-16BE字节集后返回." 折叠>
    参数 UTF32文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-32字符集文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假>
    {
        变量 结果 <类型 = 字节集类>
        UTF32到UTF16BE_Ex (UTF32文本, 结果, 是否包括结束零字符, 是否校验文本)
        返回 (结果)
    }

    方法 UTF32到UTF8_Ex <公开 静态 类型 = 整数 注释 = "将UTF-32文本数据转换到UTF-8字节集." 注释 = "跟\"UTF32到UTF8\"的区别是在参数中返回转换后的数据."
            返回值注释 = "返回UTF-8文本的字节数,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 UTF32文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-32LE字符集文本数据" @输出名 = "input">
    参数 UTF8文本 <类型 = 字节集类 注释 = "转换后的UTF-8文本将保存在此参数中" @输出名 = "output">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假 @输出名 = "null_terminated">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假 @输出名 = "validate">
    {
        @ size_t outlen = simdutf::utf8_length_from_utf32(reinterpret_cast<const char32_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 4);
        @ if (!outlen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ output.Alloc(outlen + 1, TRUE);
        @ outlen = validate ? simdutf::convert_utf32_to_utf8(reinterpret_cast<const char32_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 4,
        @                                                       reinterpret_cast<char *>(output.GetPtr()))
        @                   : simdutf::convert_valid_utf32_to_utf8(reinterpret_cast<const char32_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 4,
        @                                                             reinterpret_cast<char *>(output.GetPtr()));
        @ output.Realloc(outlen ? (outlen + (null_terminated ? 1 : 0)) : 0);
        @ return static_cast<INT>(outlen);
    }

    方法 UTF32到文本_Ex <公开 静态 类型 = 整数 注释 = "将UTF-32文本数据转换到UTF-16LE文本." 注释 = "跟\"UTF32到文本\"的区别是在参数中返回转换后的数据."
            返回值注释 = "返回UTF-16LE文本的字符数(2字节),失败返回0." 折叠 @禁止流程检查 = 真>
    参数 UTF32文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-32字符集文本数据" @输出名 = "input">
    参数 UTF16文本 <类型 = 文本型 注释 = "转换后的UTF-16LE文本将保存在此参数中" @输出名 = "output">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假 @输出名 = "validate">
    {
        @ size_t outlen = simdutf::utf16_length_from_utf32(reinterpret_cast<const char32_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 4);
        @ if (!outlen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ output.SetLength(outlen);
        @ outlen = validate ? simdutf::convert_utf32_to_utf16le(reinterpret_cast<const char32_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 4,
        @                                                       reinterpret_cast<char16_t *>(const_cast<WCHAR *>(output.GetText())))
        @                   : simdutf::convert_valid_utf32_to_utf16le(reinterpret_cast<const char32_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 4,
        @                                                             reinterpret_cast<char16_t *>(const_cast<WCHAR *>(output.GetText())));
        @ output.SetLength(outlen);
        @ return static_cast<INT>(outlen);
    }

    方法 UTF32到UTF16LE_Ex <公开 静态 类型 = 整数 注释 = "将UTF-32文本数据转换到UTF-16LE字节集."
            注释 = "跟\"UTF32到UTF16LE\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-16LE文本的字符数(2字节),失败返回0." 折叠 @禁止流程检查 = 真>
    参数 UTF32文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-32字符集文本数据" @输出名 = "input">
    参数 UTF16文本 <类型 = 字节集类 注释 = "转换后的UTF-16LE文本将保存在此参数中" @输出名 = "output">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假 @输出名 = "null_terminated">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假 @输出名 = "validate">
    {
        @ size_t outlen = simdutf::utf16_length_from_utf32(reinterpret_cast<const char32_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 4);
        @ if (!outlen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ output.Alloc((outlen + 1) * 2, TRUE);
        @ outlen = validate ? simdutf::convert_utf32_to_utf16le(reinterpret_cast<const char32_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 4,
        @                                                       reinterpret_cast<char16_t *>(output.GetPtr()))
        @                   : simdutf::convert_valid_utf32_to_utf16le(reinterpret_cast<const char32_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 4,
        @                                                             reinterpret_cast<char16_t *>(output.GetPtr()));
        @ output.Realloc(outlen ? ((outlen + (null_terminated ? 1 : 0)) * 2) : 0);
        @ return static_cast<INT>(outlen);
    }

    方法 UTF32到UTF16BE_Ex <公开 静态 类型 = 整数 注释 = "将UTF-32文本数据转换到UTF-16BE字节集."
            注释 = "跟\"UTF32到UTF16BE\"的区别是在参数中返回转换后的数据." 返回值注释 = "返回UTF-16BE文本的字符数(2字节),失败返回0." 折叠 @禁止流程检查 = 真>
    参数 UTF32文本 <类型 = 字节集类 注释 = "提供所欲转换的UTF-32字符集文本数据" @输出名 = "input">
    参数 UTF16文本 <类型 = 字节集类 注释 = "转换后的UTF-16BE文本将保存在此参数中" @输出名 = "output">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假 @输出名 = "null_terminated">
    参数 是否校验文本 <类型 = 逻辑型 注释 = "  默认将输入的数据假定为有效的文本,不作校验地进行" 注释 = "转换,返回的结果可能会有乱码;"
            注释 = "  为真时,在转换过程中会对数据进行验证,适合处理来源" 注释 = "不可信的文本,若校验失败可能会返回空文本." @默认值 = 假 @输出名 = "validate">
    {
        @ size_t outlen = simdutf::utf16_length_from_utf32(reinterpret_cast<const char32_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 4);
        @ if (!outlen) {
        @     output.Empty();
        @     return 0;
        @ }
        @ output.Alloc((outlen + 1) * 2, TRUE);
        @ outlen = validate ? simdutf::convert_utf32_to_utf16be(reinterpret_cast<const char32_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 4,
        @                                                       reinterpret_cast<char16_t *>(output.GetPtr()))
        @                   : simdutf::convert_valid_utf32_to_utf16be(reinterpret_cast<const char32_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 4,
        @                                                             reinterpret_cast<char16_t *>(output.GetPtr()));
        @ output.Realloc(outlen ? ((outlen + (null_terminated ? 1 : 0)) * 2) : 0);
        @ return static_cast<INT>(outlen);
    }

    # 验证文本 ---

    方法 验证UTF8 <公开 静态 类型 = 逻辑型 注释 = "验证指定的字节集是否为有效的UTF-8文本数据." 折叠 @禁止流程检查 = 真>
    参数 文本数据 <类型 = 字节集类 注释 = "提供所欲验证的UTF8编码文本数据" @输出名 = "input">
    {
        @ return simdutf::validate_utf8(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()));
    }

    方法 验证ASCII <公开 静态 类型 = 逻辑型 注释 = "验证指定的字节集是否为有效的ASCII文本数据." 注释 = "只能验证可打印的ASCII字符,数据中含中文等字符会返回假." 折叠
            @禁止流程检查 = 真>
    参数 文本数据 <类型 = 字节集类 注释 = "提供所欲验证的ASCII编码文本数据" @输出名 = "input">
    {
        @ return simdutf::validate_ascii(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()));
    }

    方法 验证UTF16LE <公开 静态 类型 = 逻辑型 注释 = "验证指定的字节集是否为有效的UTF-16LE文本数据." 折叠 @禁止流程检查 = 真>
    参数 文本数据 <类型 = 字节集类 注释 = "提供所欲验证的UTF-16LE编码文本数据" @输出名 = "input">
    {
        @ return simdutf::validate_utf16le(reinterpret_cast<const char16_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 2);
    }

    方法 验证UTF16BE <公开 静态 类型 = 逻辑型 注释 = "验证指定的字节集是否为有效的UTF-16BE文本数据." 折叠 @禁止流程检查 = 真>
    参数 文本数据 <类型 = 字节集类 注释 = "提供所欲验证的UTF-16BE编码文本数据" @输出名 = "input">
    {
        @ return simdutf::validate_utf16be(reinterpret_cast<const char16_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 2);
    }

    方法 验证UTF32 <公开 静态 类型 = 逻辑型 注释 = "验证指定的字节集是否为有效的UTF-32文本数据." 折叠 @禁止流程检查 = 真>
    参数 文本数据 <类型 = 字节集类 注释 = "提供所欲验证的UTF-32编码文本数据" @输出名 = "input">
    {
        @ return simdutf::validate_utf32(reinterpret_cast<const char32_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 4);
    }

    # 获取文本长度 ---

    方法 取UTF8长度 <公开 静态 类型 = 整数 注释 = "获取UTF-8文本数据的有效字符长度(1个字符可能占1到4字节)." 折叠 @禁止流程检查 = 真>
    参数 UTF8文本数据 <类型 = 字节集类 注释 = "提供所欲取字符数量的UTF-8字符集文本数据" @输出名 = "input">
    {
        @ return (INT)simdutf::count_utf8(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()));
    }

    方法 取UTF16LE长度 <公开 静态 类型 = 整数 注释 = "获取UTF-16LE文本数据的有效字符长度(1个字符占2字节)." 折叠 @禁止流程检查 = 真>
    参数 UTF16文本数据 <类型 = 字节集类 注释 = "提供所欲取字符数量的UTF-16LE字符集文本数据" @输出名 = "input">
    {
        @ return (INT)simdutf::count_utf16le(reinterpret_cast<const char16_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 2);
    }

    方法 取UTF16BE长度 <公开 静态 类型 = 整数 注释 = "获取UTF-16BE文本数据的有效字符长度(1个字符占2字节)." 折叠 @禁止流程检查 = 真>
    参数 UTF16文本数据 <类型 = 字节集类 注释 = "提供所欲取字符数量的UTF-16BE字符集文本数据" @输出名 = "input">
    {
        @ return (INT)simdutf::count_utf16be(reinterpret_cast<const char16_t *>(input.GetPtr()), static_cast<size_t>(input.GetSize()) / 2);
    }

    # BASE64 ---

    方法 字节集到BASE64文本 <公开 静态 类型 = 文本型 注释 = "返回本字节集数据所对应的BASE64编码格式文本内容" 折叠 @禁止流程检查 = 真>
    参数 字节数据 <类型 = 字节集类 注释 = "所欲编码的字节集数据" @输出名 = "input">
    参数 URL专用 <类型 = 逻辑型 注释 = "选择BASE64的编码格式:" 注释 = " 真=URL专用" 注释 = " 假=标准BASE64" @默认值 = 假 @输出名 = "options">
    {
        @ PivBuffer<char, size_t> buf;
        @ buf.Alloc(simdutf::base64_length_from_binary(static_cast<size_t>(input.GetSize()),
        @                                              options ? simdutf::base64_options::base64_url : simdutf::base64_options::base64_default), true);
        @ size_t wb = simdutf::binary_to_base64(reinterpret_cast<const char *>(input.GetPtr()), static_cast<size_t>(input.GetSize()),
        @                                       buf.GetPtr(), options ? simdutf::base64_options::base64_url : simdutf::base64_options::base64_default);
        @ return @an<CVolString>(buf.GetPtr(), wb);
    }

    方法 BASE64文本到字节集 <公开 静态 类型 = 字节集类 注释 = "将所指定的BASE64编码格式文本解码为对应的字节集后返回" 折叠 @禁止流程检查 = 真>
    参数 BASE64编码文本 <类型 = 文本型 注释 = "提供所欲解码的BASE64编码文本" @输出名 = "input">
    参数 URL专用 <类型 = 逻辑型 注释 = "选择BASE64的编码格式:" 注释 = " 真=URL专用" 注释 = " 假=标准BASE64" @默认值 = 假 @输出名 = "options">
    {
        @ simdutf::result ret;
        @ CVolMem buf;
        @ buf.Alloc((INT_P)simdutf::maximal_binary_length_from_base64(reinterpret_cast<const char16_t *>(input.GetText()),
        @                                                             static_cast<size_t>(input.GetLength())), TRUE);
        @ ret = simdutf::base64_to_binary(reinterpret_cast<const char16_t*>(input.GetText()), static_cast<size_t>(input.GetLength()),
        @                                 reinterpret_cast<char*>(buf.GetPtr()), options ? simdutf::base64_options::base64_url : simdutf::base64_options::base64_default);
        @ if (ret.error == simdutf::SUCCESS)
        @     return buf;
        @ return @an<CVolMem>();
    }

    # 其他 ---

    方法 匹配系统 <公开 静态 类型 = 逻辑型 注释 = "检查系统是否匹配指定的内存字节序" 折叠 @嵌入式方法 = "">
    参数 是否大端 <类型 = 逻辑型>
    {
        @ simdutf::match_system(static_cast<simdutf::endianness>(@<是否大端>))
    }

    方法 检测BOM签名 <公开 静态 类型 = 整数 注释 = "检查提供的文本数据是否有BOM签名,如果无签名返回0(SIMD编码类型.未知)." 返回值注释 = "请参考\"SIMD编码类型\"的常量"
            折叠 @禁止流程检查 = 真>
    参数 文本数据 <类型 = 字节集类 @输出名 = "data">
    {
        @ return (INT)simdutf::BOM::check_bom(reinterpret_cast<(const char*>(data.GetPtr()), static_cast<size_t>(data.GetSize()));
    }

    方法 取BOM大小 <公开 静态 类型 = 整数 注释 = "获取指定文本编码的BOM签名大小,以字节为单位." 折叠 @嵌入式方法 = "">
    参数 编码类型 <类型 = 整数 注释 = "请参考\"SIMD编码类型\"的常量" @输出名 = "bom">
    {
        @ simdutf::BOM::bom_byte_size(static_cast<simdutf::encoding_type>(bom))
    }
}

类 SIMD编码类型 <公开 注释 = "\"simdUTF\"检测编码的返回值" 折叠 @文档 = "category = \"编码处理.辅助类\"">
{
    常量 未知 <公开 类型 = 整数 值 = 0>
    常量 UTF8 <公开 类型 = 整数 值 = 1>
    常量 UTF16_LE <公开 类型 = 整数 值 = 2>
    常量 UTF16_BE <公开 类型 = 整数 值 = 4>
    常量 UTF32_LE <公开 类型 = 整数 值 = 8>
    常量 UTF32_BE <公开 类型 = 整数 值 = 16>
    常量 Latin1 <公开 类型 = 整数 值 = 32>

    方法 到文本 <公开 静态 类型 = 标准文本类 折叠 @嵌入式方法 = "">
    参数 编码类型 <类型 = 整数>
    {
        @ simdutf::to_string(static_cast<simdutf::encoding_type>(@<编码类型>))
    }
}

# ===

类 BASE编解码类 <公开 注释 = "Base91、Base85编解码." 注释 = "源码: https://github.com/r-lyeh-archived/base"
        注释 = "针对火山对源码进行了大量修改" 折叠 @文档 = "category = \"编码处理\"" "@视窗.外部头文件.全局-111" = "src\\piv_encoding.hpp"
        @禁止创建对象 = 真 @全局类 = 真>
{
    方法 字节集到BASE91文本 <公开 静态 类型 = 文本型 注释 = "将字节集数据转换为BASE91编码格式文本." 注释 = "保留ASCII字符为{<>\"}." 折叠 @嵌入式方法 = "">
    参数 所欲编码数据 <类型 = 字节集类>
    {
        @ piv::base91<wchar_t>{}.Encode (@<所欲编码数据>)
    }

    方法 BASE91文本到字节集 <公开 静态 类型 = 字节集类 注释 = "将BASE91编码格式文本解码为对应的字节集后返回." 注释 = "保留ASCII字符为{<>\"}." 折叠
            @嵌入式方法 = "">
    参数 BASE91编码文本 <类型 = 文本型>
    {
        @ piv::base91<wchar_t>{}.Decode (@<BASE91编码文本>)
    }

    方法 字节集到BASE85文本 <公开 静态 类型 = 文本型 注释 = "将字节集数据转换为BASE85编码格式文本." 返回值注释 = "编码失败时返回空文本" 折叠 @嵌入式方法 = "">
    参数 所欲编码数据 <类型 = 字节集类>
    参数 自动填充 <类型 = 逻辑型 注释 = "为真时将在内部自动填充编码数据,以满足字节对齐为4的倍数." 注释 = "如果为假,编码数据的长度必须为4的倍数,否则将失败返回空文本." @默认值 = 真>
    {
        @ piv::base85<wchar_t>{}.Encode (@<所欲编码数据>, @<自动填充>)
    }

    方法 BASE85文本到字节集 <公开 静态 类型 = 字节集类 注释 = "将BASE85编码格式文本解码为对应的字节集后返回." 返回值注释 = "解码失败时返回空字节集" 折叠 @嵌入式方法 = "">
    参数 BASE85编码文本 <类型 = 文本型 注释 = "BASE85文本的长度必须为5的倍数,否则将解码失败.">
    {
        @ piv::base85<wchar_t>{}.Decode (@<BASE85编码文本>)
    }
}

# ===

类 MD5校验类 <公开 注释 = "  比\"CNG加解密\"和\"OpenSSL\"的MD5略快,取文件MD5时会自动" 注释 = "分段校验,不需要打开整个文件,适合处理大文件."
        注释 = "  源码: https://github.com/ulwanski/md5" 注释 = "  针对火山对源码进行了大量修改" 折叠 @文档 = "category = \"加解密\""
        @视窗.外部头文件 = "src\\detail\\piv_md5.hpp" @禁止创建对象 = 真>
{
    常量 空数据 <公开 类型 = 文本型 值 = "D41D8CD98F00B204E9800998ECF8427E" 注释 = "这是空数据的MD5,可以通过比较判断是否成功执行了MD5校验.">

    方法 取文件MD5 <公开 静态 类型 = 文本型 注释 = "获取指定文件的MD5数据摘要(32个字符)" 返回值注释 = "打开文件失败会返回空文本" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲计算摘要的文件名">
    参数 是否大写 <类型 = 逻辑型 注释 = "默认返回大写字符,为假时返回小写字符." @默认值 = 真>
    参数 文件偏移 <类型 = 长整数 注释 = "  指定是否跳过文件开头的一部分数据,应提供大于等于0的值,0表示从文件" 注释 = "首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    {
        @ piv::GetFileMd5 (@<文件名>.GetText (), @<是否大写>, @<文件偏移>, (uint64_t)@<数据长度>)
    }

    方法 取数据MD5 <公开 静态 类型 = 文本型 注释 = "获取指定数据的MD5数据摘要(32个字符)" 返回值注释 = "可以与\"MD5校验类.空数据\"判断是否校验了有效的数据" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 是否大写 <类型 = 逻辑型 注释 = "默认返回大写字符,为假时返回小写字符." @默认值 = 真>
    {
        @ piv::GetDataMd5 (@<数据>, @<是否大写>)
    }

    方法 取资源MD5 <公开 静态 类型 = 文本型 注释 = "获取指定视窗文件资源的MD5数据摘要(32个字符)" 返回值注释 = "可以与\"MD5校验类.空数据\"判断是否校验了有效的数据" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 文件资源 <类型 = 视窗文件资源 注释 = "提供所欲计算摘要的视窗文件资源">
    参数 是否大写 <类型 = 逻辑型 注释 = "默认返回大写字符,为假时返回小写字符." @默认值 = 真>
    {
        @ piv::GetDataMd5 (@<文件资源>, @<是否大写>)
    }

    方法 取数据简短MD5 <公开 静态 类型 = 文本型 注释 = "获取指定数据的简短MD5数据摘要(6个字符)" 折叠 @嵌入式方法 = "">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    {
        @ piv::GetDataMd5sum6 (@<数据>)
    }
}

类 xxHash类 <公开 注释 = "  速度最快的摘要算法之一,工作速度接近内存的速度限制," 注释 = "其中XXH128比MD5快几倍以上."
        注释 = "  源码: https://github.com/Cyan4973/xxHash" 注释 = "  内部有4个不同版本和长度的子算法,速度比较:"
        注释 = "  XXH3(64位) > XXH128 > XXH64 > XXH32" 折叠 @文档 = "category = \"加解密\""
        @视窗.外部头文件 = "src\\detail\\piv_xxhash.hpp" @禁止创建对象 = 真>
{
    方法 取版本号 <公开 静态 类型 = 整数 注释 = "返回xxHash的版本号" 折叠 @嵌入式方法 = "">
    {
        @ (INT)XXH_INLINE_XXH_versionNumber()
    }

    方法 生成密码 <公开 静态 类型 = 字节集类 注释 = "从自定义密码种子中生成一个指定长度的密码" 返回值注释 = "返回所生成的高熵密码,失败返回空字节集." 折叠 @嵌入式方法 = "">
    参数 密码长度 <类型 = 整数 注释 = "提供所欲生成的密码长度,必须大于136">
    参数 自定义种子 <类型 = 字节集类 注释 = "提供一个自定义的密码种子,为空时将使用内部的默认密码作为种子." @默认值 = 空对象>
    {
        @ piv::hash::Generate_Secret(@<密码长度>, @<自定义种子>)
    }

    方法 生成密码_192 <公开 静态 类型 = 字节集类 注释 = "从64位整数种子值生成一个192字节长度的密码" 返回值注释 = "返回所生成的高熵密码" 折叠 @嵌入式方法 = "">
    参数 种子 <类型 = 长整数 注释 = "使用相同的种子值会生成一样的密码">
    {
        @ piv::hash::Generate_Secret_fromSeed((uint64_t)@<种子>)
    }

    # XXH3(128位) ---

    方法 取数据XXH128 <公开 静态 类型 = 文本型 注释 = "计算指定数据的XXH3(128位)数据摘要,返回十六进制文本结果(32个字符)." 返回值注释 = "数据为空仍会返回非0的哈希值"
            折叠 @嵌入式方法 = "">
    参数 数据 <注释 = "提供所欲计算摘要的数据,支持以下数据类型:" 注释 = " 字节集类、文本型、变整数(地址)、标准文本类(A/U)、文本视图类(A/U)" @匹配类型 = 通用型>
    参数 数据长度 <类型 = 变整数 注释 = "提供所欲计算摘要的数据长度,可选计算整个数据或前面一部分." 注释 = "默认值-1表示计算整个数据,如果\"数据\"参数提供的是数据地址(变整数),"
            注释 = "则必须提供正确的长度(大于0且小于等于数据尺寸)." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ piv::hash::Get_XXH128(@<数据>, (size_t)@<数据长度>, (uint64_t)@<种子>, @an<CVolString>{})
    }

    方法 取数据XXH128_字节集 <公开 静态 类型 = 字节集类 注释 = "计算指定数据的XXH3(128位)数据摘要,返回字节集结果(16个字节)." 返回值注释 = "数据为空仍会返回非0的哈希值"
            折叠 @嵌入式方法 = "">
    参数 数据 <注释 = "提供所欲计算摘要的数据,支持以下数据类型:" 注释 = " 字节集类、文本型、变整数(地址)、标准文本类(A/U)、文本视图类(A/U)" @匹配类型 = 通用型>
    参数 数据长度 <类型 = 变整数 注释 = "提供所欲计算摘要的数据长度,可选计算整个数据或前面一部分." 注释 = "默认值-1表示计算整个数据,如果\"数据\"参数提供的是数据地址(变整数),"
            注释 = "则必须提供正确的长度(大于0且小于等于数据尺寸)." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ piv::hash::Get_XXH128(@<数据>, (size_t)@<数据长度>, (uint64_t)@<种子>, @an<CVolMem>{})
    }

    方法 取数据HMAC_XXH128 <公开 静态 类型 = 文本型 注释 = "使用密码计算指定数据的XXH3(128位)数据摘要,返回十六进制文本(32个字符)."
            返回值注释 = "数据为空仍会返回非0的哈希值" 折叠 @嵌入式方法 = "">
    参数 数据 <注释 = "提供所欲计算摘要的数据,支持以下数据类型:" 注释 = " 字节集类、文本型、变整数(地址)、标准文本类(A/U)、文本视图类(A/U)" @匹配类型 = 通用型>
    参数 数据长度 <类型 = 变整数 注释 = "提供所欲计算摘要的数据长度,可选计算整个数据或前面一部分." 注释 = "默认值-1表示计算整个数据,如果\"数据\"参数提供的是数据地址(变整数),"
            注释 = "则必须提供正确的长度(大于0且小于等于数据尺寸)." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 如果密码为空或所计算的数据长度小于240字节,将使用内部的默认密码,"
            注释 = "此时的计算结果跟\"取数据XXH128\"一样." @默认值 = 空对象>
    {
        @ piv::hash::Get_XXH128_withSecret(@<数据>, (size_t)@<数据长度>, @<密码>, (uint64_t)@<种子>, @an<CVolString>{})
    }

    方法 取数据HMAC_XXH128_字节集 <公开 静态 类型 = 字节集类 注释 = "使用密码计算指定数据的XXH3(128位)数据摘要,返回字节集(16个字节)."
            返回值注释 = "数据为空仍会返回非0的哈希值" 折叠 @嵌入式方法 = "">
    参数 数据 <注释 = "提供所欲计算摘要的数据,支持以下数据类型:" 注释 = " 字节集类、文本型、变整数(地址)、标准文本类(A/U)、文本视图类(A/U)" @匹配类型 = 通用型>
    参数 数据长度 <类型 = 变整数 注释 = "提供所欲计算摘要的数据长度,可选计算整个数据或前面一部分." 注释 = "默认值-1表示计算整个数据,如果\"数据\"参数提供的是数据地址(变整数),"
            注释 = "则必须提供正确的长度(大于0且小于等于数据尺寸)." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 如果密码为空或所计算的数据长度小于240字节,将使用内部的默认密码,"
            注释 = "此时的计算结果跟\"取数据XXH128\"一样." @默认值 = 空对象>
    {
        @ piv::hash::Get_XXH128_withSecret(@<数据>, (size_t)@<数据长度>, @<密码>, (uint64_t)@<种子>, @an<CVolMem>{})
    }

    方法 取文件XXH128 <公开 静态 类型 = 文本型 注释 = "计算指定文件的XXH3(128位)数据摘要,返回十六进制文本(32个字符)."
            返回值注释 = "文件不存在或无法访问时返回0值,但文件数据为空仍会返回非0的哈希值." 折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲计算摘要的文件名">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 本参数仅在提供的密码长度大于136字节时生效,否则使用内部的默认密码." @默认值 = 空对象>
    {
        @ piv::hash::GetFile_XXH128(@<文件名>, @<文件偏移>, (uint64_t)@<数据长度>, @<密码>, (uint64_t)@<种子>, @an<CVolString>{})
    }

    方法 取文件XXH128_字节集 <公开 静态 类型 = 字节集类 注释 = "计算指定文件的XXH3(128位)数据摘要,返回字节集结果(16个字节)."
            返回值注释 = "文件不存在或无法访问时返回0值,但文件数据为空仍会返回非0的哈希值." 折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲计算摘要的文件名">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 本参数仅在提供的密码长度大于136字节时生效,否则使用内部的默认密码." @默认值 = 空对象>
    {
        @ piv::hash::GetFile_XXH128(@<文件名>, @<文件偏移>, (uint64_t)@<数据长度>, @<密码>, (uint64_t)@<种子>, @an<CVolMem>{})
    }

    方法 取资源XXH128 <公开 静态 类型 = 文本型 注释 = "计算指定文件资源的XXH3(128位)数据摘要,返回十六进制文本(32个字符)."
            返回值注释 = "文件资源无法载入时返回0值,但文件数据为空仍会返回非0的哈希值." 折叠 @嵌入式方法 = "">
    参数 文件资源 <类型 = 视窗文件资源 注释 = "提供所欲计算摘要的视窗文件资源">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 本参数仅在提供的密码长度大于136字节时生效,否则使用内部的默认密码." @默认值 = 空对象>
    {
        @ piv::hash::GetRes_XXH128(@<文件资源>, @<文件偏移>, (uint64_t)@<数据长度>, @<密码>, (uint64_t)@<种子>, @an<CVolString>{})
    }

    方法 取资源XXH128_字节集 <公开 静态 类型 = 字节集类 注释 = "计算指定文件资源的XXH3(128位)数据摘要,返回字节集结果(16个字节)."
            返回值注释 = "文件资源无法载入时返回0值,但文件数据为空仍会返回非0的哈希值." 折叠 @嵌入式方法 = "">
    参数 文件资源 <类型 = 视窗文件资源 注释 = "提供所欲计算摘要的视窗文件资源">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 本参数仅在提供的密码长度大于136字节时生效,否则使用内部的默认密码." @默认值 = 空对象>
    {
        @ piv::hash::GetRes_XXH128(@<文件资源>, @<文件偏移>, (uint64_t)@<数据长度>, @<密码>, (uint64_t)@<种子>, @an<CVolMem>{})
    }

    # XXH3(64位) ---

    方法 取数据XXH3 <公开 静态 类型 = 长整数 注释 = "计算指定数据的XXH3(64位)数据摘要,返回64位长整数哈希值."
            返回值注释 = "数据为空仍会返回非0的哈希值,如需十六进制文本可以调用:" 返回值注释 = "取长整数十六进制文本 (哈希值, 16)" 折叠 @嵌入式方法 = "">
    参数 数据 <注释 = "提供所欲计算摘要的数据,支持以下数据类型:" 注释 = " 字节集类、文本型、变整数(地址)、标准文本类(A/U)、文本视图类(A/U)" @匹配类型 = 通用型>
    参数 数据长度 <类型 = 变整数 注释 = "提供所欲计算摘要的数据长度,可选计算整个数据或前面一部分." 注释 = "默认值-1表示计算整个数据,如果\"数据\"参数提供的是数据地址(变整数),"
            注释 = "则必须提供正确的长度(大于0且小于等于数据尺寸)." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ (INT64)piv::hash::Get_XXH3(@<数据>, (size_t)@<数据长度>, (uint64_t)@<种子>)
    }

    方法 取数据HMAC_XXH3 <公开 静态 类型 = 长整数 注释 = "使用密码计算指定数据的XXH3(64位)数据摘要,返回64位长整数哈希值."
            返回值注释 = "数据为空仍会返回非0的哈希值,如需十六进制文本可以调用:" 返回值注释 = "取长整数十六进制文本 (哈希值, 16)" 折叠 @嵌入式方法 = "">
    参数 数据 <注释 = "提供所欲计算摘要的数据,支持以下数据类型:" 注释 = " 字节集类、文本型、变整数(地址)、标准文本类(A/U)、文本视图类(A/U)" @匹配类型 = 通用型>
    参数 数据长度 <类型 = 变整数 注释 = "提供所欲计算摘要的数据长度,可选计算整个数据或前面一部分." 注释 = "默认值-1表示计算整个数据,如果\"数据\"参数提供的是数据地址(变整数),"
            注释 = "则必须提供正确的长度(大于0且小于等于数据尺寸)." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 如果密码为空或所计算的数据长度小于240字节,将使用内部的默认密码,"
            注释 = "此时的计算结果跟\"取数据XXH128\"一样." @默认值 = 空对象>
    {
        @ (INT64)piv::hash::Get_XXH3_withSecret(@<数据>, (size_t)@<数据长度>, @<密码>, (uint64_t)@<种子>)
    }

    方法 取文件XXH3 <公开 静态 类型 = 长整数 注释 = "计算指定文件的XXH3(64位)数据摘要,返回64位长整数哈希值."
            返回值注释 = "文件不存在或无法访问时返回0值,但文件数据为空仍会返回非0的哈希值." 返回值注释 = "如需十六进制文本可以调用: 取长整数十六进制文本 (哈希值, 16)" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲计算摘要的文件名">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 本参数仅在提供的密码长度大于136字节时生效,否则使用内部的默认密码." @默认值 = 空对象>
    {
        @ (INT64)piv::hash::GetFile_XXH3(@<文件名>, @<文件偏移>, (uint64_t)@<数据长度>, @<密码>, (uint64_t)@<种子>)
    }

    方法 取资源XXH3 <公开 静态 类型 = 长整数 注释 = "计算指定文件资源的XXH3(64位)数据摘要,返回64位长整数哈希值."
            返回值注释 = "文件资源无法载入时返回0值,但文件数据为空仍会返回非0的哈希值." 返回值注释 = "如需十六进制文本可以调用: 取长整数十六进制文本 (哈希值, 16)" 折叠
            @嵌入式方法 = "">
    参数 文件资源 <类型 = 视窗文件资源 注释 = "提供所欲计算摘要的视窗文件资源">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    参数 密码 <类型 = 字节集类 注释 = "提供计算摘要的密码,自定义密码可以增加外部哈希碰撞攻击的难度." 注释 = "密码的品质将影响哈希算法的分散性,应提供一段长度大于136字节的随机字节."
            注释 = "建议使用\"生成密码\"函数生成一个高熵密码." 注释 = "注意: 本参数仅在提供的密码长度大于136字节时生效,否则使用内部的默认密码." @默认值 = 空对象>
    {
        @ (INT64)piv::hash::GetRes_XXH3(@<文件资源>, @<文件偏移>, (uint64_t)@<数据长度>, @<密码>, (uint64_t)@<种子>)
    }

    # XXH64 ---

    方法 取数据XXH64 <公开 静态 类型 = 长整数 注释 = "计算指定数据的XXH64数据摘要,返回64位长整数哈希值." 返回值注释 = "数据为空仍会返回非0的哈希值,如需十六进制文本可以调用:"
            返回值注释 = "取长整数十六进制文本 (哈希值, 16)" 折叠 @嵌入式方法 = "">
    参数 数据 <注释 = "提供所欲计算摘要的数据,支持以下数据类型:" 注释 = " 字节集类、文本型、变整数(地址)、标准文本类(A/U)、文本视图类(A/U)" @匹配类型 = 通用型>
    参数 数据长度 <类型 = 变整数 注释 = "提供所欲计算摘要的数据长度,可选计算整个数据或前面一部分." 注释 = "默认值-1表示计算整个数据,如果\"数据\"参数提供的是数据地址(变整数),"
            注释 = "则必须提供正确的长度(大于0且小于等于数据尺寸)." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ (INT64)piv::hash::Get_XXH64(@<数据>, (size_t)@<数据长度>, (uint64_t)@<种子>)
    }

    方法 取文件XXH64 <公开 静态 类型 = 长整数 注释 = "计算指定文件的XXH64数据摘要,返回64位长整数哈希值."
            返回值注释 = "文件不存在或无法访问时返回0值,但文件数据为空仍会返回非0的哈希值." 返回值注释 = "如需十六进制文本可以调用: 取长整数十六进制文本 (哈希值, 16)" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲计算摘要的文件名">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ (INT64)piv::hash::GetFile_XXH64(@<文件名>, @<文件偏移>, (uint64_t)@<数据长度>, (uint64_t)@<种子>)
    }

    方法 取资源XXH64 <公开 静态 类型 = 长整数 注释 = "计算指定文件资源的XXH64数据摘要,返回64位长整数哈希值."
            返回值注释 = "文件资源无法载入时返回0值,但文件数据为空仍会返回非0的哈希值." 返回值注释 = "如需十六进制文本可以调用: 取长整数十六进制文本 (哈希值, 16)" 折叠
            @嵌入式方法 = "">
    参数 文件资源 <类型 = 视窗文件资源 注释 = "提供所欲计算摘要的视窗文件资源">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 长整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ (INT64)piv::hash::GetRes_XXH64(@<文件资源>, @<文件偏移>, (uint64_t)@<数据长度>, (uint64_t)@<种子>)
    }

    # XXH32 ---

    方法 取数据XXH32 <公开 静态 类型 = 整数 注释 = "计算指定数据的XXH32数据摘要,返回32位整数哈希值." 返回值注释 = "数据为空仍会返回非0的哈希值,如需十六进制文本可以调用:"
            返回值注释 = "取十六进制文本 (哈希值, 8)" 折叠 @嵌入式方法 = "">
    参数 数据 <注释 = "提供所欲计算摘要的数据,支持以下数据类型:" 注释 = " 字节集类、文本型、变整数(地址)、标准文本类(A/U)、文本视图类(A/U)" @匹配类型 = 通用型>
    参数 数据长度 <类型 = 变整数 注释 = "提供所欲计算摘要的数据长度,可选计算整个数据或前面一部分." 注释 = "默认值-1表示计算整个数据,如果\"数据\"参数提供的是数据地址(变整数),"
            注释 = "则必须提供正确的长度(大于0且小于等于数据尺寸)." @默认值 = -1>
    参数 种子 <类型 = 整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ (INT)piv::hash::Get_XXH64(@<数据>, (size_t)@<数据长度>, (uint32_t)@<种子>)
    }

    方法 取文件XXH32 <公开 静态 类型 = 整数 注释 = "计算指定文件的XXH32数据摘要,返回32位整数哈希值."
            返回值注释 = "文件不存在或无法访问时返回0值,但文件数据为空仍会返回非0的哈希值." 返回值注释 = "如需十六进制文本可以调用: 取十六进制文本 (哈希值, 8)" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲计算摘要的文件名">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ (INT)piv::hash::GetFile_XXH64(@<文件名>, @<文件偏移>, (uint64_t)@<数据长度>, (uint32_t)@<种子>)
    }

    方法 取资源XXH32 <公开 静态 类型 = 整数 注释 = "计算指定文件资源的XXH32数据摘要,返回32位整数哈希值."
            返回值注释 = "文件资源无法载入时返回0值,但文件数据为空仍会返回非0的哈希值." 返回值注释 = "如需十六进制文本可以调用: 取十六进制文本 (哈希值, 8)" 折叠 @嵌入式方法 = "">
    参数 文件资源 <类型 = 视窗文件资源 注释 = "提供所欲计算摘要的视窗文件资源">
    参数 文件偏移 <类型 = 长整数 注释 = "指定是否跳过文件开头的一部分数据,应提供大于等于0的值." 注释 = "0表示从文件首部开始计算摘要,如果提供的偏移值大于文件长度,将不计算任何数据."
            @默认值 = 0>
    参数 数据长度 <类型 = 长整数 注释 = "提供所欲计算摘要的数据长度,默认值-1表示计算偏移值后面的所有数据." @默认值 = -1>
    参数 种子 <类型 = 整数 注释 = "修改种子值允许可预测地改变输出的哈希值" @默认值 = 0>
    {
        @ (INT)piv::hash::GetRes_XXH64(@<文件资源>, @<文件偏移>, (uint64_t)@<数据长度>, (uint32_t)@<种子>)
    }
}

# ===

类 简易加解密 <公开 注释 = "纯C++源码实现的简易加解密库." 注释 = "其中RC4的加解密支持不定长度密码,结果跟易语言一致."
        注释 = "源码: https://github.com/lsw29475/iAlgorithm" 折叠 @文档 = "category = \"加解密\"" @禁止创建对象 = 真>
{

    # AES

    方法 加密_AES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(ECB模式)." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32.">
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        返回 (加密_字节集_AES_ECB (数据, 文本到多字节 (密码, 假), 填充方式))
    }

    方法 加密_字节集_AES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(ECB模式)." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠
            @禁止流程检查 = 真 @视窗.外部头文件 = "src\\iAlgorithm\\iAes.h" @视窗.外部源文件 = "src\\iAlgorithm\\iAes.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32.">
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        @ CAES aes; @an<CVolMem> out;
        @ @an<CVolMem> key = @<密码>; int keysize = (int)key.GetSize ();
        @ if (keysize < 8) {
        @     key.AddSpace (8 - keysize, TRUE); keysize = 8;
        @ } else if (keysize < 16) {
        @     key.AddSpace (16 - keysize, TRUE); keysize = 16;
        @ } else if (keysize < 32) {
        @     key.AddSpace (32 - keysize, TRUE); keysize = 32;
        @ } else {
        @     keysize = 32;
        @ }
        @ if ( !aes.AesInit ((unsigned char*)key.GetPtr (), keysize, NULL, 0, 1) )
        @     return out;
        @ @an<CVolMem> input = @<数据>;
        @ input.SetMemAlignSize (@<数据>.GetSize () + 16);
        @ if (input.GetSize () % 16 != 0) {
        @     int nNun = 16 - input.GetSize () % 16;
        @     if (@<填充方式> == 1) {
        @         input.AddSpace (nNun, TRUE);
        @     } else if (@<填充方式> == 2) {
        @         for (int i = 0; i < nNun; i++) input.AddU8Char ( (U8CHAR)nNun);
        @     }
        @ }
        @ out.Alloc (input.GetSize (), TRUE);
        @ return aes.Encrypt_ECB ((unsigned char*)input.GetPtr (), (int)input.GetSize (),
        @                         (unsigned char*)out.GetPtr (), (int)out.GetSize ()) ? out : CVolMem ();
    }

    方法 解密_AES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(ECB模式)." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32.">
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        返回 (解密_字节集_AES_ECB (数据, 文本到多字节 (密码, 假), 填充方式))
    }

    方法 解密_字节集_AES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(ECB模式)." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠
            @禁止流程检查 = 真 @视窗.外部头文件 = "src\\iAlgorithm\\iAes.h" @视窗.外部源文件 = "src\\iAlgorithm\\iAes.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32.">
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        @ CAES aes; @an<CVolMem> out;
        @ int nSize = (int)@<数据>.GetSize ();
        @ if (nSize <= 0) return out;
        @ @an<CVolMem> key = @<密码>; int keysize = (int)key.GetSize ();
        @ if (keysize < 8) {
        @     key.AddSpace (8 - keysize, TRUE); keysize = 8;
        @ } else if (keysize < 16) {
        @     key.AddSpace (16 - keysize, TRUE); keysize = 16;
        @ } else if (keysize < 32) {
        @     key.AddSpace (32 - keysize, TRUE); keysize = 32;
        @ } else {
        @     keysize = 32;
        @ }
        @ if ( !aes.AesInit ((unsigned char*)key.GetPtr (), keysize, NULL, 0, 1) )
        @     return out;
        @ out.Alloc (nSize, TRUE);
        @ if ( !aes.Decrypt_ECB ((unsigned char*)@<数据>.GetPtr (), nSize,
        @                        (unsigned char*)out.GetPtr (), (int)out.GetSize ()) )
        @     return CVolMem ();
        @ if (@<填充方式> == 2) {
        @     S_BYTE padChar = out.Get_S_BYTE (nSize - 1);
        @     if (padChar < 8 && padChar > 0) {
        @         bool bPad = true;
        @         for (int i = nSize - padChar; i < nSize; i++) {
        @             if (out.Get_S_BYTE (i) != padChar) bPad = false;
        @         }
        @         if (bPad) out.Realloc (nSize - padChar);
        @     }
        @ }
        @ return out;
    }

    方法 加密_AES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(CBC模式)." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        返回 (加密_字节集_AES_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 加密_字节集_AES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(CBC模式)." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠
            @禁止流程检查 = 真 @视窗.外部头文件 = "src\\iAlgorithm\\iAes.h" @视窗.外部源文件 = "src\\iAlgorithm\\iAes.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        @ CAES aes; @an<CVolMem> out;
        @ @an<CVolMem> key = @<密码>; int keysize = (int)key.GetSize ();
        @ if (keysize < 8) {
        @     key.AddSpace (8 - keysize, TRUE); keysize = 8;
        @ } else if (keysize < 16) {
        @     key.AddSpace (16 - keysize, TRUE); keysize = 16;
        @ } else if (keysize < 32) {
        @     key.AddSpace (32 - keysize, TRUE); keysize = 32;
        @ } else {
        @     keysize = 32;
        @ }
        @ if ( !aes.AesInit ((unsigned char*)key.GetPtr (), keysize, NULL, 0, 2) )
        @     return out;
        @ @an<CVolMem> iv = @<向量>;
        @ if (iv.GetSize () < 16) iv.AddSpace (16 - iv.GetSize (), TRUE);
        @ aes.AesSetIv ((unsigned char*)iv.GetPtr ());
        @ @an<CVolMem> input = @<数据>;
        @ input.SetMemAlignSize (@<数据>.GetSize () + 16);
        @ if (input.GetSize () % 16 != 0) {
        @     int nNun = 16 - input.GetSize () % 16;
        @     if (@<填充方式> == 1) {
        @         input.AddSpace (nNun, TRUE);
        @     } else if (@<填充方式> == 2) {
        @         for (int i = 0; i < nNun; i++) input.AddU8Char ( (U8CHAR)nNun);
        @     }
        @ }
        @ out.Alloc (input.GetSize (), TRUE);
        @ return aes.Encrypt_CBC ((unsigned char*)input.GetPtr (), (int)input.GetSize (),
        @                         (unsigned char*)out.GetPtr (), (int)out.GetSize ()) ? out : CVolMem ();
    }

    方法 解密_AES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(CBC模式)." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        返回 (解密_字节集_AES_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 解密_字节集_AES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(CBC模式)." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠
            @禁止流程检查 = 真 @视窗.外部头文件 = "src\\iAlgorithm\\iAes.h" @视窗.外部源文件 = "src\\iAlgorithm\\iAes.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        @ CAES aes; @an<CVolMem> out;
        @ int nSize = (int)@<数据>.GetSize ();
        @ if (nSize <= 0) return out;
        @ @an<CVolMem> key = @<密码>; int keysize = (int)key.GetSize ();
        @ if (keysize < 8) {
        @     key.AddSpace (8 - keysize, TRUE); keysize = 8;
        @ } else if (keysize < 16) {
        @     key.AddSpace (16 - keysize, TRUE); keysize = 16;
        @ } else if (keysize < 32) {
        @     key.AddSpace (32 - keysize, TRUE); keysize = 32;
        @ } else {
        @     keysize = 32;
        @ }
        @ if ( !aes.AesInit ((unsigned char*)key.GetPtr (), keysize, NULL, 0, 2) )
        @     return out;
        @ @an<CVolMem> iv = @<向量>;
        @ if (iv.GetSize () < 16) iv.AddSpace (16 - iv.GetSize (), TRUE);
        @ aes.AesSetIv ((unsigned char*)iv.GetPtr ());
        @ out.Alloc (nSize, TRUE);
        @ if ( !aes.Decrypt_CBC ((unsigned char*)@<数据>.GetPtr (), nSize,
        @                        (unsigned char*)out.GetPtr (), (int)out.GetSize ()) )
        @     return CVolMem ();
        @ if (@<填充方式> == 2) {
        @     S_BYTE padChar = out.Get_S_BYTE (nSize - 1);
        @     if (padChar < 8 && padChar > 0) {
        @         bool bPad = true;
        @         for (int i = nSize - padChar; i < nSize; i++) {
        @             if (out.Get_S_BYTE (i) != padChar) bPad = false;
        @         }
        @         if (bPad) out.Realloc (nSize - padChar);
        @     }
        @ }
        @ return out;
    }

    # DEC

    方法 加密_DES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DES加密(ECB模式)." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        返回 (加密_字节集_DES_ECB (数据, 文本到多字节 (密码, 假), 填充方式))
    }

    方法 加密_字节集_DES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DES加密(ECB模式)." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠
            @禁止流程检查 = 真 @视窗.外部头文件 = "src\\iAlgorithm\\iBit.h\nsrc\\iAlgorithm\\iDes.h"
            @视窗.外部源文件 = "src\\iAlgorithm\\iBit.cpp\nsrc\\iAlgorithm\\iDes.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        @ CDES des; @an<CVolMem> out;
        @ @an<CVolMem> key = @<密码>;
        @ if (key.GetSize() < 8) key.AddSpace (8 - key.GetSize (), TRUE);
        @ if ( !des.DesInit ((unsigned char*)key.GetPtr (), 8) )
        @     return out;
        @ @an<CVolMem> input = @<数据>;
        @ input.SetMemAlignSize (@<数据>.GetSize () + 8);
        @ if (input.GetSize () % 8 != 0) {
        @     int nNun = 8 - input.GetSize () % 8;
        @     if (@<填充方式> == 2) {
        @         for (int i = 0; i < nNun; i++) input.AddU8Char ( (U8CHAR)nNun);
        @     } else if (@<填充方式> == 1) {
        @         input.AddSpace (nNun, TRUE);
        @     }
        @ }
        @ out.Alloc (input.GetSize (), TRUE);
        @ return des.Encrypt_ECB ((unsigned char*)input.GetPtr (), (int)input.GetSize (),
        @                         (unsigned char*)out.GetPtr (), (int)out.GetSize ()) ? out : CVolMem ();
    }

    方法 解密_DES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定DES加密的数据进行解密(ECB模式)." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        返回 (解密_字节集_DES_ECB (数据, 文本到多字节 (密码, 假), 填充方式))
    }

    方法 解密_字节集_DES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定DES加密的数据进行解密(ECB模式)." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠
            @禁止流程检查 = 真 @视窗.外部头文件 = "src\\iAlgorithm\\iBit.h\nsrc\\iAlgorithm\\iDes.h"
            @视窗.外部源文件 = "src\\iAlgorithm\\iBit.cpp\nsrc\\iAlgorithm\\iDes.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        @ CDES des; @an<CVolMem> out;
        @ int nSize = (int)@<数据>.GetSize ();
        @ if (nSize <= 0) return out;
        @ @an<CVolMem> key = @<密码>;
        @ if (key.GetSize() < 8) key.AddSpace (8 - key.GetSize (), TRUE);
        @ if ( !des.DesInit ((unsigned char*)key.GetPtr (), 8) )
        @     return out;
        @ out.Alloc (nSize, TRUE);
        @ if ( !des.Decrypt_ECB ((unsigned char*)@<数据>.GetPtr (), nSize,
        @                        (unsigned char*)out.GetPtr (), (int)out.GetSize ()) )
        @     return CVolMem ();
        @ if (@<填充方式> == 2) {
        @     S_BYTE padChar = out.Get_S_BYTE (nSize - 1);
        @     if (padChar < 8 && padChar > 0) {
        @         bool bPad = true;
        @         for (int i = nSize - padChar; i < nSize; i++) {
        @             if (out.Get_S_BYTE (i) != padChar) bPad = false;
        @         }
        @         if (bPad) out.Realloc (nSize - padChar);
        @     }
        @ }
        @ return out;
    }

    方法 加密_DES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DES加密(CBC模式)." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        返回 (加密_字节集_DES_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 加密_字节集_DES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DES加密(CBC模式)." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠
            @禁止流程检查 = 真 @视窗.外部头文件 = "src\\iAlgorithm\\iBit.h\nsrc\\iAlgorithm\\iDes.h"
            @视窗.外部源文件 = "src\\iAlgorithm\\iBit.cpp\nsrc\\iAlgorithm\\iDes.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        @ CDES des; @an<CVolMem> out;
        @ @an<CVolMem> key = @<密码>;
        @ if (key.GetSize() < 8) key.AddSpace (8 - key.GetSize (), TRUE);
        @ if ( !des.DesInit ((unsigned char*)key.GetPtr (), 8) )
        @     return out;
        @ @an<CVolMem> iv = @<向量>;
        @ if (iv.GetSize () < 8) iv.AddSpace (8 - iv.GetSize (), TRUE);
        @ des.DesSetIv ((unsigned char*)iv.GetPtr ());
        @ @an<CVolMem> input = @<数据>;
        @ input.SetMemAlignSize (@<数据>.GetSize () + 8);
        @ if (input.GetSize () % 8 != 0) {
        @     int nNun = 8 - input.GetSize () % 8;
        @     if (@<填充方式> == 2) {
        @         for (int i = 0; i < nNun; i++) input.AddU8Char ((U8CHAR)nNun);
        @     } else if (@<填充方式> == 1) {
        @         input.AddSpace (nNun, TRUE);
        @     }
        @ }
        @ out.Alloc (input.GetSize (), TRUE);
        @ return des.Encrypt_CBC ((unsigned char*)input.GetPtr (), (int)input.GetSize (),
        @                         (unsigned char*)out.GetPtr (), (int)out.GetSize ()) ? out : CVolMem ();
    }

    方法 解密_DES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定DES加密的数据进行解密(CBC模式)." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = PKCS7填充" 注释 = " 2 = 零填充" @默认值 = 1>
    {
        返回 (解密_字节集_DES_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 解密_字节集_DES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定DES加密的数据进行解密(CBC模式)." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠
            @禁止流程检查 = 真 @视窗.外部头文件 = "src\\iAlgorithm\\iBit.h\nsrc\\iAlgorithm\\iDes.h"
            @视窗.外部源文件 = "src\\iAlgorithm\\iBit.cpp\nsrc\\iAlgorithm\\iDes.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = 整数 注释 = " 0 = 不填充" 注释 = " 1 = 零填充" 注释 = " 2 = PKCS7填充" @默认值 = 1>
    {
        @ CDES des; @an<CVolMem> out;
        @ int nSize = (int)@<数据>.GetSize ();
        @ if (nSize <= 0) return out;
        @ @an<CVolMem> key = @<密码>;
        @ if (key.GetSize() < 8) key.AddSpace (8 - key.GetSize (), TRUE);
        @ if ( !des.DesInit ((unsigned char*)key.GetPtr (), 8) )
        @     return out;
        @ @an<CVolMem> iv = @<向量>;
        @ if (iv.GetSize () < 8) iv.AddSpace (8 - iv.GetSize (), TRUE);
        @ des.DesSetIv ((unsigned char*)iv.GetPtr ());
        @ out.Alloc (nSize, TRUE);
        @ if ( !des.Decrypt_CBC ((unsigned char*)@<数据>.GetPtr (), nSize,
        @                        (unsigned char*)out.GetPtr (), (int)out.GetSize ()) )
        @     return CVolMem ();
        @ if (@<填充方式> == 2) {
        @     S_BYTE padChar = out.Get_S_BYTE (nSize - 1);
        @     if (padChar < 8 && padChar > 0) {
        @         bool bPad = true;
        @         for (int i = nSize - padChar; i < nSize; i++) {
        @             if (out.Get_S_BYTE (i) != padChar) bPad = false;
        @         }
        @         if (bPad) out.Realloc (nSize - padChar);
        @     }
        @ }
        @ return out;

    }

    # RC4

    方法 加密_RC4 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC4加密." 返回值注释 = "返回数据加密后的结果,如果加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,长度为1-256个字符.">
    {
        返回 (加密_字节集_RC4 (数据, 文本到多字节 (密码, 假)))
    }

    方法 加密_字节集_RC4 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC4加密." 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠 @禁止流程检查 = 真
            @视窗.外部头文件 = "src\\iAlgorithm\\iRc4.h" @视窗.外部源文件 = "src\\iAlgorithm\\iRc4.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,长度为1-256字节.">
    {
        @ CRC4 RC4; @an<CVolMem> out;
        @ if ( !RC4.InitKey ((unsigned char*)@<密码>.GetPtr (), (int)@<密码>.GetSize ()) )
        @     return out;
        @ out.Alloc (@<数据>.GetSize (), TRUE);
        @ return RC4.EncryptData ((unsigned char*)@<数据>.GetPtr (), (int)@<数据>.GetSize (),
        @                         (unsigned char*)out.GetPtr (), (int)out.GetSize ()) ? out : CVolMem ();
    }

    方法 解密_RC4 <公开 静态 类型 = 字节集类 注释 = "将指定RC4加密的数据进行解密." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,长度为1-256个字符.">
    {
        返回 (解密_字节集_RC4 (数据, 文本到多字节 (密码, 假)))
    }

    方法 解密_字节集_RC4 <公开 静态 类型 = 字节集类 注释 = "将指定RC4加密的数据进行解密." 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠 @禁止流程检查 = 真
            @视窗.外部头文件 = "src\\iAlgorithm\\iRc4.h" @视窗.外部源文件 = "src\\iAlgorithm\\iRc4.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲解密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,长度为1-256字节.">
    {
        @ CRC4 RC4; @an<CVolMem> out;
        @ if ( !RC4.InitKey ((unsigned char*)@<密码>.GetPtr (), (int)@<密码>.GetSize ()) )
        @     return out;
        @ out.Alloc (@<数据>.GetSize (), TRUE);
        @ return RC4.DecryptData ((unsigned char*)@<数据>.GetPtr (), (int)@<数据>.GetSize (),
        @                         (unsigned char*)out.GetPtr (), (int)out.GetSize ()) ? out : CVolMem ();
    }

    # MD5

    方法 取数据MD5 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的MD5数据摘要." 返回值注释 = "返回摘要计算后的结果." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据.">
    {
        返回 (取数据MD5_字节集 (数据).字节集到十六进制文本 ())
    }

    方法 取数据MD5_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的MD5数据摘要." 返回值注释 = "返回摘要计算后的结果." 折叠 @禁止流程检查 = 真
            @视窗.外部头文件 = "src\\iAlgorithm\\iMd5.h" @视窗.外部源文件 = "src\\iAlgorithm\\iMd5.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据.">
    {
        @ CMD5 hash;
        @ if ( !hash.InitHash (0) ) return CVolMem ();
        @ @an<CVolMem> DigestOut; DigestOut.Alloc (16, TRUE);
        @ return hash.CalcHash ((unsigned char*)@<数据>.GetPtr (), (int)@<数据>.GetSize (),
        @                       (unsigned char*)DigestOut.GetPtr ()) ? DigestOut : CVolMem ();
    }

    # SHA1

    方法 取数据SHA1 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的SHA1数据摘要." 返回值注释 = "返回摘要计算后的结果." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据.">
    {
        返回 (取数据SHA1_字节集 (数据).字节集到十六进制文本 ())
    }

    方法 取数据SHA1_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的SHA1数据摘要." 返回值注释 = "返回摘要计算后的结果." 折叠 @禁止流程检查 = 真
            @视窗.外部头文件 = "src\\iAlgorithm\\iSha1.h" @视窗.外部源文件 = "src\\iAlgorithm\\iSha1.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据.">
    {
        @ CSHA1 hash;
        @ if ( !hash.InitHash (0) ) return CVolMem ();
        @ @an<CVolMem> DigestOut; DigestOut.Alloc (20, TRUE);
        @ return hash.CalcHash ((unsigned char*)@<数据>.GetPtr (), (int)@<数据>.GetSize (),
        @                       (unsigned char*)DigestOut.GetPtr ()) ? DigestOut : CVolMem ();
    }

    # SHA256

    方法 取数据SHA256 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的SHA256数据摘要." 返回值注释 = "返回摘要计算后的结果." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据.">
    {
        返回 (取数据SHA256_字节集 (数据).字节集到十六进制文本 ())
    }

    方法 取数据SHA256_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的SHA256数据摘要." 返回值注释 = "返回摘要计算后的结果." 折叠 @禁止流程检查 = 真
            @视窗.外部头文件 = "src\\iAlgorithm\\iSha256.h" @视窗.外部源文件 = "src\\iAlgorithm\\iSha256.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据.">
    {
        @ CSHA256 hash;
        @ if ( !hash.InitHash (0) ) return CVolMem ();
        @ @an<CVolMem> DigestOut; DigestOut.Alloc (32, TRUE);
        @ return hash.CalcHash ((unsigned char*)@<数据>.GetPtr (), (int)@<数据>.GetSize (),
        @                       (unsigned char*)DigestOut.GetPtr ()) ? DigestOut : CVolMem ();
    }

    # SHA512

    方法 取数据SHA512 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的SHA512数据摘要." 返回值注释 = "返回摘要计算后的结果." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据.">
    {
        返回 (取数据SHA512_字节集 (数据).字节集到十六进制文本 ())
    }

    方法 取数据SHA512_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的SHA512数据摘要." 返回值注释 = "返回摘要计算后的结果." 折叠 @禁止流程检查 = 真
            @视窗.外部头文件 = "src\\iAlgorithm\\iSha512.h" @视窗.外部源文件 = "src\\iAlgorithm\\iSha512.cpp">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据.">
    {
        @ CSHA512 hash;
        @ if ( !hash.InitHash (0) ) return CVolMem ();
        @ @an<CVolMem> DigestOut; DigestOut.Alloc (64, TRUE);
        @ return hash.CalcHash ((unsigned char*)@<数据>.GetPtr (), (int)@<数据>.GetSize (),
        @                       (unsigned char*)DigestOut.GetPtr ()) ? DigestOut : CVolMem ();
    }
}

#
