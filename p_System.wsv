<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv" "">

类 系统辅助类 <公开 注释 = "一些未分类的全局辅助方法" 折叠 @文档 = "category = \"系统操作\"" @禁止创建对象 = 真 @全局类 = 真>
{
    方法 跳转到 <公开 静态 注释 = "goto操作符的封装,需要配合\"置跳转标号\"使用." 折叠 @嵌入式方法 = "">
    参数 语句标号 <类型 = 文本型 注释 = "  请提供由\"置跳转标号\"设置过标号." 注释 = "  只能填入用\"\"包围的字符串字面量,不能使用文本变量." @需求类型 = 立即数或常量>
    {
        @ goto @pvpt<语句标号>
    }

    方法 置跳转标号 <公开 静态 注释 = "设置语句标号,用设置\"跳转到\"(goto)的目标位置." 折叠 @嵌入式方法 = "no_end_sem = true">
    参数 语句标号 <类型 = 文本型 注释 = "只能填入用\"\"包围的字符串字面量,不能使用文本变量." @需求类型 = 立即数或常量>
    {
        @ @pvpt<语句标号>:
    }

    方法 取全局单例 <公开 静态 注释 = "  获取指定类型对象类的唯一性全局实例." 注释 = "  如果该类型的全局对象尚不存在,则自动创建一个新对象并记录到系统数组中返回,否则直接"
            注释 = "返回在系统数组中的已有全局类对象." 注释 = "  本方法支持在多线程环境中运行. 当用户程序退出时,系统将自动释放所有已有的全局对象."
            注释 = "  注: 与系统的\"取全局对象\"相比,本方法不需要做类型转换,直接返回你需要的对象类型." 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲获取对象类型 <类型 = 对象类 注释 = "提供所欲获取全局对象的类型" @需求类型 = 数据类型 @返回值类型 = 0>
    {
        @ dynamic_cast<@<所欲获取对象类型>&>(g_objVolApp.GetRefGlobalObject(VOL_RUNTIME_CLASS(@<所欲获取对象类型>)))
    }

    方法 构造对象 <公开 静态 注释 = "创建并返回一个所指定类型的新对象." 返回值注释 = "所返回对象的类型跟提供的数据类型一致,无需转换类型." 折叠 @嵌入式方法 = "">
    参数 所欲创建对象的类型 <注释 = "提供所欲创建对象的数据类型" @需求类型 = 数据类型 @匹配类型 = 通用类 @返回值类型 = 0>
    {
        @ @<所欲创建对象的类型> ()
    }

    方法 带参构造对象 <公开 静态 注释 = "使用提供的参数创建并返回一个所指定类型的新对象." 注释 = "注意: 只能对拥有带参构造函数的类使用,由于火山语法的限制,"
            注释 = "也不支持C++类和指针等参数." 返回值注释 = "所返回对象的类型跟提供的数据类型一致,无需转换类型." 折叠 @嵌入式方法 = "">
    参数 所欲创建对象的类型 <注释 = "提供所欲创建对象的数据类型" @需求类型 = 数据类型 @匹配类型 = 通用类 @返回值类型 = 0>
    参数 参数列表 <注释 = "提供类的构造参数" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @<所欲创建对象的类型> (@<参数列表>)
    }

    方法 取变量类型名称 <公开 静态 类型 = 文本型 注释 = "返回指定变量的C++类型名称" 折叠 @视窗.外部头文件 = "<typeinfo>" @嵌入式方法 = "">
    参数 变量 <注释 = "所欲取类型名称的变量" @匹配类型 = 通用型>
    {
        @ @an<CVolString>(typeid(@<变量>).name())
    }

    #

    方法 取执行文件路径 <公开 静态 类型 = 文本型 注释 = "返回当前被执行程序文件的完整路径(带文件名)." 折叠 @禁止流程检查 = 真>
    {
        @ TCHAR buf [MAX_PATH + 1] { 0 };
        @ if (::GetModuleFileName (NULL, buf, MAX_PATH) > 0)
        @     return @an<CVolString> (buf);
        @ return @an<CVolString>(L"");
    }

    方法 禁止重复运行 <公开 静态 注释 = "禁止当前程序多开运行" 折叠>
    参数 标识文本 <类型 = 文本型 注释 = "请用英文字母标记,尽量输复杂一点的文本">
    {
        @ @an<CVolString> szGlobal(L"Global\\"); // 给标识加上全局前缀
        @ szGlobal.AddText(@<标识文本>.GetText());
        @ if (::OpenEventW(SYNCHRONIZE, FALSE, szGlobal.GetText()) != 0)
        @     ::ExitProcess(0);
        @ else
        @     ::CreateEventW(NULL, FALSE, FALSE, szGlobal.GetText());
    }

    方法 取最后错误信息 <公开 静态 类型 = 文本型 注释 = "获取最后一次错误的代码和描述信息." 返回值注释 = "成功返回错误信息,失败返回空文本." 折叠 @禁止流程检查 = 真>
    参数 错误信息格式 <类型 = 文本型 注释 = "%u为错误代码,%s为错误信息,这两个格式替代符 的前后顺序不能改动." @默认值 = "最后错误(%u): %s">
    {
        @ DWORD dwLastError = ::GetLastError ();
        @ LPVOID lpvMessageBuffer;
        @ @an<CVolString> ErrorMsg;
        @ if (::FormatMessageW ( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        @       NULL, dwLastError, MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), (LPWSTR)&lpvMessageBuffer, 0, NULL)) {
        @     ErrorMsg.Format (@<错误信息格式>.GetText (), dwLastError, (LPWSTR)lpvMessageBuffer);
        @     ::LocalFree (lpvMessageBuffer);
        @ }
        @ return ErrorMsg;
    }

    方法 取指定错误信息 <公开 静态 类型 = 文本型 注释 = "获取指定错误的代码的描述信息." 返回值注释 = "成功返回错误信息,失败返回空文本." 折叠 @禁止流程检查 = 真>
    参数 错误代码 <类型 = 整数>
    参数 错误信息格式 <类型 = 文本型 注释 = "%u为错误代码,%s为错误信息,这两个格式替代符 的前后顺序不能改动." @默认值 = "错误(%u): %s">
    {
        @ DWORD dwLastError = (DWORD)@<错误代码>;
        @ LPVOID lpvMessageBuffer;
        @ @an<CVolString> ErrorMsg;
        @ if (::FormatMessageW (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        @       NULL, dwLastError, MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), (LPWSTR)&lpvMessageBuffer, 0, NULL)) {
        @     ErrorMsg.Format (@<错误信息格式>, dwLastError, (LPWSTR)lpvMessageBuffer);
        @     ::LocalFree (lpvMessageBuffer);
        @ }
        @ return ErrorMsg;
    }

    方法 取机器码_VMP <公开 静态 类型 = 文本型 注释 = "VMProtect的辅助函数,可以将HWID中各硬件的机器码解析出来,返回不包含网卡特征的另一种机器码格式." 折叠>
    参数 HWID <类型 = 文本型>
    {
        变量 机器码 <类型 = 字节集类>
        变量 索引 <类型 = 整数>
        变量 长度 <类型 = 整数>
        机器码 = BASE64文本到字节集 (HWID)
        长度 = 机器码.取字节集长度 ()
        如果 (长度 < 8 || 长度 % 4 != 0)
        {
            返回 ("")

        }
        变量 CPU <类型 = 文本型>
        变量 HOST <类型 = 文本型>
        变量 HDD <类型 = 文本型>
        循环 (0, 长度, 索引, 4)
        {
            变量 t1 <类型 = 整数>
            变量 t2 <类型 = 整数>
            变量 t3 <类型 = 整数>
            变量 t4 <类型 = 整数>
            变量 val <类型 = 整数>
            变量 ids <类型 = 文本型>
            t1 = 无符号字节到整数 (机器码.取字节集数据 (索引, 字节))
            t2 = 无符号字节到整数 (机器码.取字节集数据 (索引 + 1, 字节))
            t3 = 无符号字节到整数 (机器码.取字节集数据 (索引 + 2, 字节))
            t4 = 无符号字节到整数 (机器码.取字节集数据 (索引 + 3, 字节))
            val = t4 * 位左移 (2, 23) + t3 * 位左移 (2, 15) + t2 * 位左移 (2, 7) + 位与 (t1, 0xFC)
            @ wchar_t buffer[20] { 0 };
            @ _itow(@<val>, buffer, 16);
            @ @<ids> = CVolString (buffer).MakeUpper ();
            如果 (取文本长度 (ids) < 8)
            {
                插入文本 (ids, 0, 取重复文本 ("0", 8 - 取文本长度 (ids)))

            }
            分支判断 (位与 (t1, 3))
            {
                分支 (0)
                {
                    CPU = ids
                }
                分支 (1)
                {
                    HOST = ids
                }
                分支 (3)
                {
                    HDD = ids
                }

            }
        }
        返回 (CPU + "-" + HOST + "-" + HDD)
    }

    方法 写文本数组注册项 <公开 静态 类型 = 逻辑型 注释 = "在Windows注册表中保存或建立指定的文本数组(REG_MULTI_SZ)注册表项" 返回值注释 = "返回是否成功" 折叠
            @禁止流程检查 = 真>
    参数 根目录 <类型 = 注册表根目录类型>
    参数 全路径注册项名 <类型 = 文本型>
    参数 欲写入值 <类型 = 文本数组类>
    {
        @ CVolString strPath;
        @ const TCHAR* szItemName = @<全路径注册项名>.GetText ();
        @ const TCHAR* ps = _tcsrchr (szItemName, '\\');
        @ if (ps != NULL) {
        @     strPath.SetText (szItemName, ps - szItemName);
        @     szItemName = ps + 1;
        @ }
        @ return @<写文本数组注册项2> (@<根目录>, strPath, CVolString (szItemName), @<欲写入值>);
    }

    方法 写文本数组注册项2 <公开 静态 类型 = 逻辑型 注释 = "在Windows注册表中保存或建立指定的文本数组(REG_MULTI_SZ)注册表项" 返回值注释 = "返回是否成功" 折叠
            @禁止流程检查 = 真>
    参数 根目录 <类型 = 注册表根目录类型>
    参数 表项路径 <类型 = 文本型 注释 = "提供表项所处的注册表路径文本,路径分隔符为\'\\\\\'字符.">
    参数 表项名称 <类型 = 文本型 注释 = "提供表项的具体名称,如欲读取注册项默认值,请提供空文本.">
    参数 欲写入值 <类型 = 文本数组类>
    {
        @ HKEY hKey;
        @ if (::RegOpenKeyEx ((HKEY)(UINT_P)@<根目录>, @<表项路径>.GetText (), 0, KEY_WRITE, &hKey) == ERROR_SUCCESS ||
        @         ::RegCreateKey ((HKEY)(UINT_P)@<根目录>, @<表项路径>.GetText (), &hKey) == ERROR_SUCCESS) {
        @     @an<CVolMem> szItemValue;
        @     for (INT_P i = 0; i < @<欲写入值>.data ().GetCount (); i++) {
        @         szItemValue.AddTextValue (@<欲写入值>.data ().GetAt (i), TRUE);
        @     }
        @     BOOL bRes = (::RegSetValueEx (hKey, @<表项名称>.GetText (), NULL, REG_MULTI_SZ, (BYTE*)szItemValue.GetPtr (), (DWORD)szItemValue.GetSize ()) == ERROR_SUCCESS);
        @     ::RegCloseKey (hKey);
        @     return bRes;
        @ }
        @ return FALSE;
    }

    方法 取文本数组注册项 <公开 静态 类型 = 文本数组类 注释 = "在Windows注册表中返回指定的文本数组(REG_MULTI_SZ)注册表项值" 折叠 @禁止流程检查 = 真>
    参数 根目录 <类型 = 注册表根目录类型>
    参数 全路径注册项名 <类型 = 文本型>
    {
        @ CVolString strPath;
        @ const TCHAR* szItemName = @<全路径注册项名>.GetText ();
        @ const TCHAR* ps = _tcsrchr (szItemName, '\\');
        @ if (ps != NULL) {
        @     strPath.SetText (szItemName, ps - szItemName);
        @     szItemName = ps + 1;
        @ }
        @ return @<取文本数组注册项2> (@<根目录>, strPath, CVolString (szItemName));
    }

    方法 取文本数组注册项2 <公开 静态 类型 = 文本数组类 注释 = "在Windows注册表中返回指定的文本数组(REG_MULTI_SZ)注册表项值" 折叠>
    参数 根目录 <类型 = 注册表根目录类型>
    参数 表项路径 <类型 = 文本型 注释 = "提供表项所处的注册表路径文本,路径分隔符为\'\\\\\'字符.">
    参数 表项名称 <类型 = 文本型 注释 = "提供表项的具体名称,如欲读取注册项默认值,请提供空文本.">
    {
        变量 结果变量 <类型 = 文本数组类>
        @ HKEY hKey;
        @ if (::RegOpenKeyEx ((HKEY)(UINT_P)@<根目录>, @<表项路径>.GetText (), 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
        @     DWORD dwType, dwDataSize = 0;
        @     if (::RegQueryValueEx (hKey, @<表项名称>.GetText (), NULL, &dwType, NULL, &dwDataSize) == ERROR_SUCCESS && dwType == REG_MULTI_SZ) {
        @         WCHAR *pChValue = new WCHAR[dwDataSize]{0};
        @         if (!pChValue) return @<结果变量>;
        @         if (::RegQueryValueEx (hKey, @<表项名称>.GetText (), NULL, NULL, (LPBYTE)pChValue, &dwDataSize) == ERROR_SUCCESS) {
        @             UINT nIndex = 0, nLen = wcslen (&pChValue[0]);
        @             do {
        @                 @<结果变量>.data ().Add (&pChValue[nIndex]);
        @                 nIndex += nLen + 1;
        @                 nLen = wcslen (&pChValue[nIndex]);
        @             } while (nLen > 0);
        @         }
        @         delete[] pChValue;
        @     }
        @     ::RegCloseKey (hKey);
        @ }
        返回 (结果变量)
    }

    方法 全局处理事件 <公开 静态 注释 = "暂时转让控制权,以便让Windows操作系统有机会处理其它的如用户键盘或鼠标输入等事件."
            注释 = "直到操作系统处理并发送完程序消息队列中的所有事件后,本方法才会返回." 折叠>
    {
        @ MSG msg;
        @ while (::PeekMessage (&msg, NULL, NULL, NULL, PM_NOREMOVE) && msg.message != WM_QUIT)
        @ {
        @     if (::GetMessage (&msg, NULL, 0, 0) <= 0)
        @         break;
        @     ::TranslateMessage (&msg);
        @     ::DispatchMessage (&msg);
        @ }
    }

    # 已过时 ===

    方法 添加拖放消息过滤 <公开 静态 注释 = "*官方的\"允许拖放\"已经支持该功能,已经没用处了." 注释 = "在UIPI\"用户界面特权隔离\"消息过滤器中增加拖放消息."
            注释 = "\"以管理员身份运行\"时必须调用本方法,否则将收不到拖放消息." 注释 = "本方法用来配合官方窗口类的拖放文件." 折叠 @编译条件 = "PIV_ENABLE_OBSOLETE">
    {
        @ typedef BOOL(WINAPI* Typedef_ChangeWindowMessageFilter)(UINT, DWORD);
        @ Typedef_ChangeWindowMessageFilter API_ChangeWindowMessageFilter =
        @         (Typedef_ChangeWindowMessageFilter)::GetProcAddress(::GetModuleHandleW (L"User32.dll"), "ChangeWindowMessageFilter");
        @ if (API_ChangeWindowMessageFilter) {
        @     API_ChangeWindowMessageFilter (WM_DROPFILES, 1); // WM_DROPFILES, MSGFLT_ADD
        @     API_ChangeWindowMessageFilter (0x0049, 1); // 0x0049 == WM_COPYGLOBALDATA, MSGFLT_ADD
        @ }
    }

    方法 移除拖放消息过滤 <公开 静态 注释 = "*官方的\"允许拖放\"已经支持该功能,已经没用处了." 注释 = "从UIPI\"用户界面特权隔离\"消息过滤器中移除拖放消息."
            注释 = "调用本方法后,\"以管理员身份运行\"时将收不到拖放消息." 注释 = "本方法用来配合官方窗口类的拖放文件." 折叠 @编译条件 = "PIV_ENABLE_OBSOLETE">
    {
        @ typedef BOOL(WINAPI* Typedef_ChangeWindowMessageFilter)(UINT, DWORD);
        @ Typedef_ChangeWindowMessageFilter API_ChangeWindowMessageFilter =
        @         (Typedef_ChangeWindowMessageFilter)::GetProcAddress(::GetModuleHandleW (L"User32.dll"), "ChangeWindowMessageFilter");
        @ if (API_ChangeWindowMessageFilter) {
        @     API_ChangeWindowMessageFilter (WM_DROPFILES, 0); // WM_DROPFILES, MSGFLT_RESET
        @     API_ChangeWindowMessageFilter (0x0049, 0); // 0x0049 == WM_COPYGLOBALDATA, MSGFLT_RESET
        @ }
    }

    方法 添加拖放消息过滤2 <公开 静态 注释 = "*官方的\"允许拖放\"已经支持该功能,已经没用处了." 注释 = "跟\"添加拖放消息过滤\"不同是本方法可以只对某个窗口组件起作用." 折叠
            @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 窗口句柄 <类型 = 变整数>
    {
        @ typedef struct tagCHANGEFILTERSTRUCT {
        @   DWORD cbSize;
        @   DWORD ExtStatus;
        @ } CHANGEFILTERSTRUCT, *PCHANGEFILTERSTRUCT;
        @ typedef BOOL(WINAPI* Typedef_ChangeWindowMessageFilterEx)(HWND, UINT, DWORD, PCHANGEFILTERSTRUCT);
        @ Typedef_ChangeWindowMessageFilterEx API_ChangeWindowMessageFilterEx =
        @         (Typedef_ChangeWindowMessageFilterEx)::GetProcAddress(::GetModuleHandleW (L"User32.dll"), "ChangeWindowMessageFilterEx");
        @ if (API_ChangeWindowMessageFilterEx) {
        @     API_ChangeWindowMessageFilterEx ((HWND)@<窗口句柄>, WM_DROPFILES, 1, NULL); // WM_DROPFILES, MSGFLT_ADD
        @     API_ChangeWindowMessageFilterEx ((HWND)@<窗口句柄>, 0x0049, 1, NULL); // 0x0049 == WM_COPYGLOBALDATA, MSGFLT_ADD
        @ }
    }

    方法 移除拖放消息过滤2 <公开 静态 注释 = "*官方的\"允许拖放\"已经支持该功能,已经没用处了." 注释 = "跟\"移除拖放消息过滤\"不同是本方法可以只对某个窗口组件起作用." 折叠
            @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 窗口句柄 <类型 = 变整数>
    {
        @ typedef struct tagCHANGEFILTERSTRUCT {
        @   DWORD cbSize;
        @   DWORD ExtStatus;
        @ } CHANGEFILTERSTRUCT, *PCHANGEFILTERSTRUCT;
        @ typedef BOOL(WINAPI* Typedef_ChangeWindowMessageFilterEx)(HWND, UINT, DWORD, PCHANGEFILTERSTRUCT);
        @ Typedef_ChangeWindowMessageFilterEx API_ChangeWindowMessageFilterEx =
        @         (Typedef_ChangeWindowMessageFilterEx)::GetProcAddress(::GetModuleHandleW (L"User32.dll"), "ChangeWindowMessageFilterEx");
        @ if (API_ChangeWindowMessageFilterEx) {
        @     API_ChangeWindowMessageFilterEx ((HWND)@<窗口句柄>, WM_DROPFILES, 0, NULL); // WM_DROPFILES, MSGFLT_RESET
        @     API_ChangeWindowMessageFilterEx ((HWND)@<窗口句柄>, 0x0049, 0, NULL); // 0x0049 == WM_COPYGLOBALDATA, MSGFLT_RESET
        @ }
    }
}

类 剪贴板类 <公开 注释 = "封装了一些剪贴板的功能" 折叠 @文档 = "category = \"系统操作\"" @禁止创建对象 = 真>
{
    方法 置剪贴板文件 <静态 类型 = 逻辑型 注释 = "内部调用" 返回值注释 = "返回是否成功" 折叠 @禁止流程检查 = 真>
    参数 缓冲区 <类型 = 字节集类 @输出名 = "Buffer">
    参数 是否复制 <类型 = 逻辑型 注释 = "默认复制文件,假为剪切文件." @默认值 = 真 @输出名 = "bCopy">
    {
        @ if (::OpenClipboard (NULL) == FALSE) return FALSE;
        @ if (::EmptyClipboard () == FALSE) return FALSE;
        @ UINT uDropEffect;
        @ DROPFILES dropFiles;
        @ UINT uDropFilesLen;
        @ HGLOBAL hGblFiles, hGblEffect;
        @ char *szData, *szFileList;

        @ DWORD *dwDropEffect;
        @ uDropEffect = ::RegisterClipboardFormatW (CFSTR_PREFERREDDROPEFFECT);
        @ hGblEffect = ::GlobalAlloc (GMEM_ZEROINIT | GMEM_MOVEABLE | GMEM_DDESHARE, sizeof (DWORD));
        @ if (hGblEffect == NULL) return FALSE;
        @ dwDropEffect = (DWORD*)::GlobalLock (hGblEffect);
        @ if (bCopy == TRUE)
        @     *dwDropEffect = DROPEFFECT_COPY;
        @ else
        @     *dwDropEffect = DROPEFFECT_MOVE;
        @ ::GlobalUnlock (hGblEffect);

        @ uDropFilesLen = sizeof (DROPFILES);
        @ dropFiles.pFiles = uDropFilesLen;
        @ dropFiles.pt.x = 0;
        @ dropFiles.pt.y = 0;
        @ dropFiles.fNC = FALSE;
        @ dropFiles.fWide = TRUE;

        @ hGblFiles = ::GlobalAlloc (GMEM_ZEROINIT | GMEM_MOVEABLE | GMEM_DDESHARE, uDropFilesLen + Buffer.GetSize () + 8);
        @ if (hGblFiles == NULL) return FALSE;
        @ szData = (char*)::GlobalLock (hGblFiles);
        @ memcpy (szData, (LPVOID)(&dropFiles), uDropFilesLen);
        @ szFileList = szData + uDropFilesLen;
        @ memcpy (szFileList, Buffer.GetPtr (), Buffer.GetSize ());
        @ ::GlobalUnlock (hGblFiles);

        @ HANDLE hRetD = ::SetClipboardData (CF_HDROP, hGblFiles);
        @ HANDLE hRetE = ::SetClipboardData (uDropEffect, hGblEffect);
        @ ::CloseClipboard ();
        @ ::GlobalFree (hGblFiles);
        @ ::GlobalFree (hGblEffect);
        @ if (hRetD == NULL || hRetE == NULL)
        @     return FALSE;
        @ else
        @     return TRUE;
    }

    方法 复制文件到剪贴板 <公开 静态 类型 = 逻辑型 注释 = "将文件复制到剪贴板,之后可以在文件资源管理器等地方粘贴来复制文件." 返回值注释 = "返回是否成功" 折叠>
    参数 文件路径 <类型 = 文本型>
    {
        变量 文件 <类型 = 字节集类>
        文件 = 文本到字节集 (文件路径)
        文件.添加字节集内容 (0, 0)
        返回 (置剪贴板文件 (文件, 真))
    }

    方法 剪切文件到剪贴板 <公开 静态 类型 = 逻辑型 注释 = "将文件剪切到剪贴板,之后可以在文件资源管理器等地方粘贴来移动文件." 返回值注释 = "返回是否成功" 折叠>
    参数 文件路径 <类型 = 文本型>
    {
        变量 文件 <类型 = 字节集类>
        文件 = 文本到字节集 (文件路径)
        文件.添加字节集内容 (0, 0)
        返回 (置剪贴板文件 (文件, 假))
    }

    方法 复制多个文件到剪贴板 <公开 静态 类型 = 逻辑型 注释 = "将多个文件复制到剪贴板,之后可以在文件资源管理器等地方粘贴来复制文件." 返回值注释 = "返回是否成功" 折叠>
    参数 文件列表 <类型 = 文本数组类>
    {
        变量 文件列表_ <类型 = 字节集类>
        文件列表.枚举循环 ()
        {
            文件列表_.添加文本到字节集 (文件列表.取枚举值 ())
            文件列表_.添加字节集内容 (0, 0)
        }
        返回 (置剪贴板文件 (文件列表_, 真))
    }

    方法 剪切多个文件到剪贴板 <公开 静态 类型 = 逻辑型 注释 = "将多个文件剪切到剪贴板,之后可以在文件资源管理器等地方粘贴来移动文件." 返回值注释 = "返回是否成功" 折叠>
    参数 文件列表 <类型 = 文本数组类>
    {
        变量 文件列表_ <类型 = 字节集类>
        文件列表.枚举循环 ()
        {
            文件列表_.添加文本到字节集 (文件列表.取枚举值 ())
            文件列表_.添加字节集内容 (0, 0)
        }
        返回 (置剪贴板文件 (文件列表_, 假))
    }

    方法 取剪贴板文件 <公开 静态 类型 = 整数 注释 = "获取剪贴板中保存的文件,同时判断是复制文件还是剪切文件." 返回值注释 = "0表示获取失败,1表示复制文件,2表示剪切文件." 折叠
            @禁止流程检查 = 真>
    参数 文件列表 <类型 = 文本数组类 注释 = "从剪贴板获取的文件列表" @输出名 = "aFileList">
    {
        @ aFileList.data ().RemoveAll ();
        @ INT iRet;
        @ if (::IsClipboardFormatAvailable (CF_HDROP) == FALSE) return 0;
        @ if (::OpenClipboard (NULL)) {
        @     HDROP hDrop = HDROP (::GetClipboardData (CF_HDROP));
        @     if (hDrop) {
        @         DWORD dwEffect, *dw;
        @         UINT uDropEffect = ::RegisterClipboardFormatW (CFSTR_PREFERREDDROPEFFECT);
        @         dw = (DWORD*)(::GetClipboardData (uDropEffect));
        @         if (dw == NULL)
        @             dwEffect = DROPEFFECT_COPY;
        @         else
        @             dwEffect = *dw;
        @         UINT nFiles = DragQueryFileW (hDrop, 0xFFFFFFFF, NULL, 0);
        @         WCHAR szFile[MAX_PATH];
        @         for (UINT count = 0; count < nFiles; count++) {
        @             DragQueryFileW (hDrop, count, szFile, sizeof (szFile));
        @             aFileList.data ().Add (szFile);
        @         }
        @         if (dwEffect & DROPEFFECT_MOVE) {
        @             iRet = 2;
        @         } else if (dwEffect & DROPEFFECT_COPY) {
        @             iRet = 1;
        @         }
        @     }
        @     ::CloseClipboard();
        @ }
        @ return iRet;
    }

    方法 粘贴文件自剪贴板 <公开 静态 类型 = 逻辑型 注释 = "将剪贴板中的文件粘贴到指定的位置,自动识别是复制文件还是剪切文件." 返回值注释 = "返回是否成功" 折叠>
    参数 目标位置 <类型 = 文本型 注释 = "粘贴文件的目标位置,请以\\\\结尾">
    参数 是否覆盖 <类型 = 逻辑型 注释 = "默认覆盖目标位置的同名文件: 如果不覆盖,自动将粘贴的文件改名." @默认值 = 真>
    {
        变量 文件列表 <类型 = 文本数组类>
        变量 返回值 <类型 = 整数>
        检查加入路径字符 (目标位置)
        返回值 = 取剪贴板文件 (文件列表)
        如果 (返回值 == 1)  // 复制文件
        {
            如果 (创建目录 (目标位置) == 假)
            {
                返回 (假)

            }
            文件列表.枚举循环 ()
            {
                变量 目标文件名 <类型 = 文本型>
                目标文件名 = 目标位置 + 取文件名无路径部分 (文件列表.取枚举值 ())
                如果 (是否覆盖 == 假)
                {
                    变量 临时文件名 <类型 = 文本型>
                    变量 编号 <类型 = 整数 值 = 1>
                    变量 扩展名 <类型 = 文本型>
                    变量 插入位置 <类型 = 整数>
                    扩展名 = 取文件名后缀 (目标文件名)
                    如果 (文本是否为空 (扩展名) == 假)
                    {
                        插入位置 = 寻找文本 (目标文件名, 扩展名) - 1
                    }
                    否则
                    {
                        插入位置 = 取文本长度 (目标文件名)
                    }
                    临时文件名 = 目标文件名
                    判断循环 (文件是否存在 (临时文件名) == 真)
                    {
                        临时文件名 = 目标文件名
                        插入文本 (临时文件名, 插入位置, " - 副本 (" + 到文本 (编号) + ")")
                        编号 = 编号 + 1
                    }
                    目标文件名 = 临时文件名
                }
                复制文件 (文件列表.取枚举值 (), 目标文件名)

            }
            返回 (真)
        }
        否则 (返回值 == 2)  // 粘贴文件
        {
            如果 (创建目录 (目标位置) == 假)
            {
                返回 (假)
            }
            文件列表.枚举循环 ()
            {
                变量 目标文件名 <类型 = 文本型>
                目标文件名 = 目标位置 + 取文件名无路径部分 (文件列表.取枚举值 ())
                如果 (是否覆盖 == 假)
                {
                    变量 临时文件名 <类型 = 文本型>
                    变量 编号 <类型 = 整数 值 = 1>
                    变量 扩展名 <类型 = 文本型>
                    变量 插入位置 <类型 = 整数>
                    扩展名 = 取文件名后缀 (目标文件名)
                    如果 (文本是否为空 (扩展名) == 假)
                    {
                        插入位置 = 寻找文本 (目标文件名, 扩展名) - 1
                    }
                    否则
                    {
                        插入位置 = 取文本长度 (目标文件名)
                    }
                    临时文件名 = 目标文件名
                    判断循环 (文件是否存在 (临时文件名) == 真)
                    {
                        临时文件名 = 目标文件名
                        插入文本 (临时文件名, 插入位置, " - 副本 (" + 到文本 (编号) + ")")
                        编号 = 编号 + 1
                    }
                    目标文件名 = 临时文件名
                }
                移动文件 (文件列表.取枚举值 (), 目标文件名)

            }
            返回 (真)
        }
        否则
        {
            返回 (假)
        }

    }

    方法 置剪贴板图像 <公开 静态 类型 = 逻辑型 注释 = "将位图对象类置入到剪贴板中,之后可以粘贴到其他支持位图的软件,比如QQ、Photoshop." 返回值注释 = "返回是否成功" 折叠
            @禁止流程检查 = 真>
    参数 位图 <类型 = 位图对象类>
    {
        变量 位图字节集 <类型 = 字节集类 @输出名 = "BitmapBuffer">
        位图.取图片数据 (位图字节集)
        @ if (::OpenClipboard (NULL) == FALSE) return FALSE;
        @ if (::EmptyClipboard () == FALSE) return FALSE;
        @ INT buflen = (INT)BitmapBuffer.GetSize ();
        @ buflen -= sizeof (BITMAPFILEHEADER);
        @ HGLOBAL hResult = ::GlobalAlloc (GMEM_MOVEABLE, buflen);
        @ if (hResult == NULL) return FALSE;
        @ memcpy (::GlobalLock (hResult), BitmapBuffer.GetPtr () + sizeof (BITMAPFILEHEADER), buflen);
        @ ::GlobalUnlock (hResult);
        @ HANDLE hRet = ::SetClipboardData (CF_DIB, hResult);
        @ ::CloseClipboard ();
        @ ::GlobalFree (hResult);
        @ return (hRet != NULL);
    }

    方法 置剪贴板图像文件 <公开 静态 类型 = 逻辑型 注释 = "从图片文件读入位图数,然后置入到剪贴板中,之后可以粘贴到其他支持位图的软件,比如QQ、Photoshop."
            返回值注释 = "返回是否成功" 折叠 "">
    参数 图片文件 <类型 = 文本型>
    {
        变量 位图对象 <类型 = 位图对象类>
        位图对象 = 载入位图文件 (图片文件)
        如果 (位图对象.为空 () == 真)
        {
            返回 (假)
        }
        返回 (置剪贴板图像 (位图对象))
    }

    方法 取剪贴板图像 <公开 静态 类型 = 逻辑型 注释 = "获取剪贴板中的位图数据" 注释 = "之后可以用\"CxImage图像处理支持\"转换图像格式"
            注释 = "图像处理类.创建自位图对象 (位图对象)" 注释 = "图像处理类.保存到文件 (保存路径, 图像格式类型.PNG格式)" 返回值注释 = "返回是否成功" 折叠>
    参数 位图 <类型 = 位图对象类 注释 = "获取的位图对象">
    {
        变量 位图字节集 <类型 = 字节集类 @输出名 = "BitmapBuffer">
        @ if (::IsClipboardFormatAvailable (CF_DIB) == FALSE) return FALSE;
        @ if (::OpenClipboard (NULL) == FALSE) return FALSE;
        @ GLOBALHANDLE hGMem = ::GetClipboardData (CF_DIB);
        @ if (hGMem == NULL) return FALSE;
        @ BITMAPFILEHEADER bmpHeader;
        @ bmpHeader.bfType = 'MB';
        @ bmpHeader.bfSize = (DWORD)sizeof(BITMAPFILEHEADER) + (DWORD)GlobalSize (hGMem);
        @ bmpHeader.bfReserved1 = 0;
        @ bmpHeader.bfReserved2 = 0;
        @ bmpHeader.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof (BITMAPINFOHEADER);
        @ LPBITMAPINFO lpBI;
        @ lpBI = (LPBITMAPINFO)::GlobalLock (hGMem);
        @ BitmapBuffer.Append ((void*)&bmpHeader, sizeof (BITMAPFILEHEADER));
        @ BitmapBuffer.Append (lpBI, GlobalSize (hGMem));
        @ ::GlobalUnlock (hGMem);
        @ ::CloseClipboard ();
        位图 = 载入位图数据 (位图字节集)
        返回 (取反 (位图.为空 ()))
    }

    方法 取剪贴板图像到文件 <公开 静态 类型 = 逻辑型 注释 = "获取剪贴板中的位图数据,并保存为位图文件" 返回值注释 = "返回是否成功" 折叠 @禁止流程检查 = 真>
    参数 位图文件 <类型 = 文本型 注释 = "保存的目标文件名(包含完整路径),文件后缀为 .bmp">
    参数 是否覆盖 <类型 = 逻辑型 注释 = "默认覆盖目标位置的同名文件: 如果不覆盖,自动将粘贴的文件改名" @默认值 = 真>
    {
        变量 位图对象 <类型 = 位图对象类>
        变量 目标文件名 <类型 = 文本型>
        如果 (取剪贴板图像 (位图对象) == 假)
        {
            返回 (假)
        }
        目标文件名 = 位图文件
        如果 (是否覆盖 == 假)
        {
            变量 临时文件名 <类型 = 文本型>
            变量 编号 <类型 = 整数 值 = 1>
            变量 扩展名 <类型 = 文本型>
            变量 插入位置 <类型 = 整数>
            扩展名 = 取文件名后缀 (目标文件名)
            如果 (文本是否为空 (扩展名) == 假)
            {
                插入位置 = 寻找文本 (目标文件名, 扩展名) - 1
            }
            否则
            {
                插入位置 = 取文本长度 (目标文件名)
            }
            临时文件名 = 目标文件名
            判断循环 (文件是否存在 (临时文件名) == 真)
            {
                临时文件名 = 目标文件名
                插入文本 (临时文件名, 插入位置, " - 副本 (" + 到文本 (编号) + ")")
                编号 = 编号 + 1
            }
            目标文件名 = 临时文件名
        }
        返回 (位图对象.写图片文件 (目标文件名))
    }
}

类 通用文件对话框 <公开 注释 = "调用系统的文件对话框选择文件" 折叠 @文档 = "category = \"文件操作\"" @禁止创建对象 = 真>
{
    方法 打开文件 <公开 静态 类型 = 逻辑型 注释 = "调用系统的文件对话框选择打开文件." 返回值注释 = "  返回是否成功,成功时在\"文件名\"参数中返回全路径文件名."
            返回值注释 = "  如失败或取消打开文件,则\"文件名\"参数返回空文本." 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "用作初始化对话框中的文件名编辑框内容,以及返回用户所选择的全路径文件名.">
    参数 过滤器 <类型 = 文本型 注释 = "  要选择的文件后缀,过滤器文本由单个或多个成对的文本串组成." 注释 = "  每对文本串的第一个提供显示文本,如:\"文本文件(*.txt)\","
            注释 = "  第二个指定实际的过滤匹配符,如: \"*.txt\"." 注释 = "  所有各文本串之间用\"|\"号隔开."
            注释 = "  例如 \"MP4文件(*.mp4;*.m4a)|*.mp4;*.m4a|所有文件(*.*)|*.*\"" 注释 = "  留空则不显示过滤器,可以选择所有类型的文件."
            @默认值 = 空对象>
    参数 父窗口句柄 <类型 = 变整数 注释 = "父窗口的句柄,0表示无父窗口" @默认值 = 0>
    参数 标题 <类型 = 文本型 注释 = "文件对话框的标题,默认为\"打开\"" @默认值 = 空对象>
    参数 初始过滤器 <类型 = 整数 注释 = "  指定初始过滤器在\"过滤器\"属性中的索引位置(从1开始)," 注释 = "0为不指定初始过滤器,以第一个过滤器为初始项." @默认值 = 0>
    参数 初始目录 <类型 = 文本型 注释 = "指定打开对话框时自动跳转到的目录" @默认值 = 空对象>
    参数 默认文件后缀 <类型 = 文本型 注释 = "当用户没有输入文件的后缀名称时,自动使用这里的文件后缀名称." @默认值 = 空对象>
    参数 创建时提示 <类型 = 逻辑型 注释 = "如果输入的文件不存在,提示是否创建文件" @默认值 = 假>
    参数 禁止解析快捷方式 <类型 = 逻辑型 注释 = "选择快捷方式时默认解析为它指向的目标文件,设置为真时返回快捷方式文件本身." @默认值 = 假>
    参数 不改变目录 <类型 = 逻辑型 注释 = "是否在对话框关闭后,将\"当前目录\"还原为打开对话框之前的目录." @默认值 = 假>
    {
        @ OPENFILENAMEW ofn { 0 };
        @ ofn.lStructSize = sizeof(OPENFILENAMEW);
        @ ofn.hwndOwner = @<父窗口句柄> ? reinterpret_cast<HWND>(@<父窗口句柄>) : NULL;
        @ @an<CVolMem> szFilter;
        @ if (@<过滤器>.IsEmpty()) {
        @     ofn.lpstrFilter = NULL;
        @ } else {
        @     szFilter.AddTextValue(@<过滤器>, TRUE);
        @     szFilter.ReplaceBin(CVolMem(_CT2(L"|")), CVolMem().AddManyBytes(2, 0, 0), 0, 0);
        @     szFilter.AddWord(0);
        @     ofn.lpstrFilter = reinterpret_cast<const WCHAR*>(szFilter.GetPtr());
        @ }
        @ ofn.lpstrInitialDir = @<初始目录>.IsEmpty() ? NULL : @<初始目录>.GetText();
        @ WCHAR szBuffer[MAX_PATH * 4];
        @ if (@<文件名>.IsEmpty())
        @     szBuffer[0] = '\0';
        @ else
        @     wcscpy_s(szBuffer, MAX_PATH * 4, @<文件名>.GetText());
        @ ofn.lpstrFile = szBuffer;
        @ ofn.lpstrTitle = @<标题>.IsEmpty() ? NULL : @<标题>.GetText();
        @ ofn.nMaxFile = sizeof(szBuffer);
        @ ofn.nFilterIndex = static_cast<DWORD>(@<初始过滤器>);
        @ ofn.lpstrDefExt = @<默认文件后缀>.IsEmpty() ? NULL : @<默认文件后缀>.GetText();
        @ ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
        @ if (@<创建时提示>) ofn.Flags |= OFN_CREATEPROMPT;
        @ if (@<禁止解析快捷方式>) ofn.Flags |= OFN_NODEREFERENCELINKS;
        @ if (@<不改变目录>) ofn.Flags |= OFN_NOCHANGEDIR;
        @ if (::GetOpenFileNameW(&ofn)) {
        @     @<文件名>.SetText(ofn.lpstrFile);
        @     return TRUE;
        @ }
        @ @<文件名>.Empty();
        @ return FALSE;
    }

    方法 打开选择多个文件 <公开 静态 类型 = 整数 注释 = "调用系统的文件对话框选择打开文件,允许多选." 返回值注释 = "成功返回文件名的数量,失败或未选择文件返回0." 折叠
            @禁止流程检查 = 真>
    参数 文件名列表 <类型 = 文本数组类 注释 = "成功在此返回文件名数组.不建议打开超过1000个文件,否则可能会因为缓冲区不足而失败.">
    参数 过滤器 <类型 = 文本型 注释 = "  要选择的文件后缀,过滤器文本由单个或多个成对的文本串组成." 注释 = "  每对文本串的第一个提供显示文本,如:\"文本文件(*.txt)\","
            注释 = "  第二个指定实际的过滤匹配符,如: \"*.txt\"." 注释 = "  所有各文本串之间用\"|\"号隔开."
            注释 = "  例如 \"MP4文件(*.mp4;*.m4a)|*.mp4;*.m4a|所有文件(*.*)|*.*\"" 注释 = "  留空则不显示过滤器,可以选择所有类型的文件."
            @默认值 = 空对象>
    参数 父窗口句柄 <类型 = 变整数 注释 = "父窗口的句柄,0表示无父窗口" @默认值 = 0>
    参数 标题 <类型 = 文本型 注释 = "文件对话框的标题,默认为\"打开\"" @默认值 = 空对象>
    参数 初始过滤器 <类型 = 整数 注释 = "  指定初始过滤器在\"过滤器\"属性中的索引位置(从1开始)," 注释 = "0为不指定初始过滤器,以第一个过滤器为初始项." @默认值 = 0>
    参数 初始目录 <类型 = 文本型 注释 = "指定打开对话框时自动跳转到的目录" @默认值 = 空对象>
    参数 不改变目录 <类型 = 逻辑型 注释 = "是否在对话框关闭后,将\"当前目录\"还原为打开对话框之前的目录." @默认值 = 假>
    {
        @ @<文件名列表>.data().RemoveAll();
        @ OPENFILENAMEW ofn { 0 };
        @ ofn.lStructSize = sizeof(OPENFILENAMEW);
        @ ofn.hwndOwner = @<父窗口句柄> ? reinterpret_cast<HWND>(@<父窗口句柄>) : NULL;
        @ @an<CVolMem> szFilter;
        @ if (@<过滤器>.IsEmpty()) {
        @     ofn.lpstrFilter = NULL;
        @ } else {
        @     szFilter.AddTextValue(@<过滤器>, TRUE);
        @     szFilter.ReplaceBin(CVolMem(_CT2(L"|")), CVolMem().AddManyBytes(2, 0, 0), 0, 0);
        @     szFilter.AddWord(0);
        @     ofn.lpstrFilter = reinterpret_cast<const WCHAR*>(szFilter.GetPtr());
        @ }
        @ ofn.lpstrInitialDir = @<初始目录>.IsEmpty() ? NULL : @<初始目录>.GetText();
        // 这个缓冲区大小保守可以打开1000-2000个文件
        @ ofn.lpstrFile = reinterpret_cast<WCHAR *>(calloc(MAX_PATH * 512, sizeof(WCHAR)));
        @ ofn.lpstrTitle = @<标题>.IsEmpty() ? NULL : @<标题>.GetText();
        @ ofn.nMaxFile = MAX_PATH * 512;
        @ ofn.nFilterIndex = static_cast<DWORD>(@<初始过滤器>);
        @ ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_ALLOWMULTISELECT | OFN_NODEREFERENCELINKS;
        @ if (@<不改变目录>) ofn.Flags |= OFN_NOCHANGEDIR;
        @ if (::GetOpenFileNameW(&ofn)) {
        @     @an<CVolString> szPath {ofn.lpstrFile, ofn.nFileOffset};
        @     szPath.CheckAddPathChar();
        @     WCHAR* p = ofn.lpstrFile + ofn.nFileOffset; // 把指针移到第一个文件
        @     while (*p) {
        @         @an<CVolString> szFileName;
        @         szFileName.AddText(szPath);
        @         szFileName.AddText(p);
        @         @<文件名列表>.data().Add(szFileName);
        @         p += wcslen(p) + 1; // 移至下一个文件
        @     }
        @ }
        @ free(ofn.lpstrFile);
        @ return static_cast<INT>(@<文件名列表>.data().GetCount());
    }

    方法 保存文件 <公开 静态 类型 = 逻辑型 注释 = "调用系统的文件对话框选择保存文件." 返回值注释 = "  返回是否成功,成功时在\"文件名\"参数中返回全路径文件名."
            返回值注释 = "  如失败或取消打开文件,则\"文件名\"参数返回空文本." 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "用作初始化对话框中的文件名编辑框内容,以及返回用户所选择的全路径文件名.">
    参数 过滤器 <类型 = 文本型 注释 = "  要选择的文件后缀,过滤器文本由单个或多个成对的文本串组成." 注释 = "  每对文本串的第一个提供显示文本,如:\"文本文件(*.txt)\","
            注释 = "  第二个指定实际的过滤匹配符,如: \"*.txt\"." 注释 = "  所有各文本串之间用\"|\"号隔开."
            注释 = "  例如 \"MP4文件(*.mp4;*.m4a)|*.mp4;*.m4a|所有文件(*.*)|*.*\"" 注释 = "  留空则不显示过滤器,可以选择所有类型的文件."
            @默认值 = 空对象>
    参数 父窗口句柄 <类型 = 变整数 注释 = "父窗口的句柄,0=表示无父窗口" @默认值 = 0>
    参数 标题 <类型 = 文本型 注释 = "文件对话框的标题,默认为\"保存\"" @默认值 = 空对象>
    参数 初始过滤器 <类型 = 整数 注释 = "  指定初始过滤器在\"过滤器\"属性中的索引位置(从1开始)," 注释 = "0为不指定初始过滤器,以第一个过滤器为初始项." @默认值 = 0>
    参数 初始目录 <类型 = 文本型 注释 = "指定打开对话框时自动跳转到的目录" @默认值 = 空对象>
    参数 默认文件后缀 <类型 = 文本型 注释 = "当用户没有输入文件的后缀名称时,自动使用这里的文件后缀名称." @默认值 = 空对象>
    参数 文件覆盖提示 <类型 = 逻辑型 注释 = "如果选择的文件已经存在,提示是否覆盖" @默认值 = 真>
    参数 不改变目录 <类型 = 逻辑型 注释 = "是否在对话框关闭后,将\"当前目录\"还原为打开对话框之前的目录." @默认值 = 假>
    {
        @ OPENFILENAMEW ofn { 0 };
        @ ofn.lStructSize = sizeof(OPENFILENAMEW);
        @ ofn.hwndOwner = @<父窗口句柄> ? reinterpret_cast<HWND>(@<父窗口句柄>) : NULL;
        @ @an<CVolMem> szFilter;
        @ if (@<过滤器>.IsEmpty()) {
        @     ofn.lpstrFilter = NULL;
        @ } else {
        @     szFilter.AddTextValue(@<过滤器>, TRUE);
        @     szFilter.ReplaceBin(CVolMem(_CT2(L"|")), CVolMem().AddManyBytes(2, 0, 0), 0, 0);
        @     szFilter.AddWord(0);
        @     ofn.lpstrFilter = reinterpret_cast<const WCHAR*>(szFilter.GetPtr());
        @ }
        @ ofn.lpstrInitialDir = @<初始目录>.IsEmpty() ? NULL : @<初始目录>.GetText();
        @ WCHAR szBuffer[MAX_PATH * 4];
        @ if (@<文件名>.IsEmpty())
        @     szBuffer[0] = '\0';
        @ else
        @     wcscpy_s(szBuffer, MAX_PATH * 4, @<文件名>.GetText());
        @ ofn.lpstrFile = szBuffer;
        @ ofn.lpstrTitle = @<标题>.IsEmpty() ? NULL : @<标题>.GetText();
        @ ofn.nMaxFile = sizeof(szBuffer);
        @ ofn.nFilterIndex = static_cast<DWORD>(@<初始过滤器>);
        @ ofn.lpstrDefExt = @<默认文件后缀>.IsEmpty() ? NULL : @<默认文件后缀>.GetText();
        @ ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
        @ if (@<文件覆盖提示>) ofn.Flags |= OFN_OVERWRITEPROMPT;
        @ if (@<不改变目录>) ofn.Flags |= OFN_NOCHANGEDIR;
        @ if (::GetSaveFileNameW(&ofn)) {
        @     @<文件名>.SetText(ofn.lpstrFile);
        @     return TRUE;
        @ }
        @ @<文件名>.Empty();
        @ return FALSE;
    }
}

类 文件拖放类 <公开 注释 = "给窗口组件启用文件拖放功能" 折叠 @文档 = "category = \"文件操作\"">
{

    # ---
    # @begin
    # <> <include>
    # HWND m_hWnd = NULL;
    # LONG_PTR m_OldWndProc = 0;
    # typedef BOOL(WINAPI* pChangeWindowMessageFilterEx)(HWND, UINT, DWORD, PVOID);
    # pChangeWindowMessageFilterEx API_ChangeWindowMessageFilterEx =
    #     (pChangeWindowMessageFilterEx)::GetProcAddress(::GetModuleHandle(L"User32.dll"), "ChangeWindowMessageFilterEx");
    # static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    # <> </include>
    # LRESULT CALLBACK @sn<current_class>::WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    #     @sn<current_class>* pThis = reinterpret_cast<@sn<current_class>*>(::GetPropW(hwnd, L"_piv_DragUserData"));
    #     if (pThis != NULL) {
    #         if (uMsg == WM_DROPFILES) {
    #             @dt<文本数组类> saryFileNames;
    #             WCHAR szFileName[MAX_PATH] = {'\0'};
    #             UINT uFileNum = ::DragQueryFileW((HDROP)wParam, 0xFFFFFFFF, NULL, 0);
    #             for (UINT i = 0; i < uFileNum; ++i) {
    #                 ::DragQueryFileW((HDROP)wParam, i, szFileName, MAX_PATH);
    #                 saryFileNames.data().Add(szFileName);
    #             }
    #             ::DragFinish((HDROP)wParam);
    #             pThis->@<文件被拖放>(saryFileNames);
    #             return 0;
    #         }
    #         return ::CallWindowProcW((WNDPROC)pThis->m_OldWndProc, hwnd, uMsg, wParam, lParam);
    #     }
    #     return ::DefWindowProcW(hwnd, uMsg, wParam, lParam);
    # }
    # @end

    方法 类_清理 <折叠>
    {
        禁用拖放 ()
    }

    方法 文件被拖放 <公开 定义事件 类型 = 整数 注释 = "拖放操作的回调事件" 折叠>
    参数 所拖放文件 <类型 = 文本数组类 注释 = "拖放操作接收到的文件">

    方法 是否启用 <公开 属性读 类型 = 逻辑型 注释 = "返回当前是否启用了文件拖放" 折叠 @禁止流程检查 = 真>
    {
        @ return (m_hWnd != NULL && m_OldWndProc != 0);
    }

    方法 启用拖放 <公开 注释 = "启用文件拖放,并选择需要绑定的窗口组件" 折叠>
    参数 绑定组件 <类型 = 变整数 注释 = "所欲绑定到拖放的窗口组件句柄(可使用\"取窗口句柄\"获取)">
    {
        @ if (!m_hWnd) { @<禁用拖放>(); } // 如果之前有绑定过其他组件,先将它禁用
        @ m_hWnd = (HWND)@<绑定组件>;
        @ if (!m_OldWndProc) {
        @     ::SetPropW(m_hWnd, L"_piv_DragUserData", (HANDLE)this);
        @     ::SetWindowLongPtrW(m_hWnd, GWLP_USERDATA, (LONG_PTR)this);
        @     m_OldWndProc = ::SetWindowLongPtrW(m_hWnd, GWLP_WNDPROC, (LONG_PTR)WindowProc);
        @ }
        @ ::DragAcceptFiles(m_hWnd, TRUE);
        @ if (API_ChangeWindowMessageFilterEx) {
        @     API_ChangeWindowMessageFilterEx(m_hWnd, WM_DROPFILES, 1, NULL); // WM_DROPFILES, MSGFLT_ADD
        @     API_ChangeWindowMessageFilterEx(m_hWnd, 0x0049, 1, NULL); // 0x0049 == WM_COPYGLOBALDATA, MSGFLT_ADD
        @ }
    }

    方法 禁用拖放 <公开 注释 = "停止拖放功能" 折叠>
    {
        @ if (m_hWnd && m_OldWndProc) {
        @     ::DragAcceptFiles(m_hWnd, FALSE);
        @     ::SetWindowLongPtrW(m_hWnd, GWLP_WNDPROC, m_OldWndProc);
        @     if (API_ChangeWindowMessageFilterEx) {
        @         API_ChangeWindowMessageFilterEx(m_hWnd, WM_DROPFILES, 0, NULL); // WM_DROPFILES, MSGFLT_RESET
        @         API_ChangeWindowMessageFilterEx(m_hWnd, 0x0049, 0, NULL); // 0x0049 == WM_COPYGLOBALDATA, MSGFLT_RESET
        @     }
        @     ::RemovePropW(m_hWnd, L"_piv_DragUserData");
        @     m_hWnd = NULL; m_OldWndProc = 0;
        @ }
    }
}

类 字体枚举类 <公开 注释 = "枚举系统字体" 折叠 @文档 = "category = \"系统操作\"">
{

    # @begin
    # <> <include>
    # static BOOL CALLBACK nEnumFontFamExProc(LPLOGFONTW lplf, LPTEXTMETRIC lptm, DWORD iType, LPARAM lpData);
    # static BOOL CALLBACK eEnumFontFamExProc(LPLOGFONTW lplf, LPTEXTMETRIC lptm, DWORD iType, LPARAM lpData) {
    #     if (((@sn<current_class>*)lpData)->@<字体回调>(@an<CVolString>(lplf->lfFaceName), (INT)iType) == 0)
    #         return TRUE;
    #     return FALSE;
    # }
    # <> </include>
    # BOOL CALLBACK @sn<current_class>::nEnumFontFamExProc(LPLOGFONTW lplf, LPTEXTMETRIC lptm, DWORD iType, LPARAM lpData) {
    #     (*(@dt<文本数组类>*)lpData).data().Add(lplf->lfFaceName);
    #     return TRUE;
    # }
    # @end

    方法 取系统字体列表 <公开 类型 = 整数 注释 = "枚举系统中的字体到文本数组类中" 返回值注释 = "成功返回字体数量" 折叠 @禁止流程检查 = 真>
    参数 字体列表 <类型 = 文本数组类 注释 = "返回的字体列表" @默认值 = 空对象>
    参数 字符集 <类型 = 字体字符集类 注释 = "指定返回哪个字符集的字体,默认为系统当前的区域设置." @默认值 = 字体字符集类.默认>
    参数 检索字体 <类型 = 文本型 注释 = "为空返回所有字体, 否则只返回指定名称的字体(文本超长将被忽略),可用于判断指定的字体是否存在." @默认值 = 空对象>
    参数 窗口句柄 <类型 = 变整数 注释 = "可空" @默认值 = 0>
    {
        @ @<字体列表>.data().RemoveAll();
        @ HWND hwnd = (@<窗口句柄> == 0) ? NULL : (HWND)@<窗口句柄>;
        @ HDC hdc = ::GetDC(hwnd);
        @ LOGFONTW lf;
        @ memset(&lf, 0, sizeof(LOGFONTW));
        @ lf.lfCharSet = (BYTE)@<字符集>;
        @ wcscpy_s(lf.lfFaceName, 32, @<检索字体>.GetText());
        @ ::EnumFontFamiliesExW(hdc, &lf, (FONTENUMPROCW)&@sn<current_class>::nEnumFontFamExProc, (LPARAM)&@<字体列表>, 0);
        @ ::ReleaseDC(hwnd, hdc);
        @ return (INT)@<字体列表>.data().GetCount();
    }

    方法 枚举系统字体 <公开 注释 = "枚举系统中的字体,然后在\"字体回调\"事件中处理找到的字体." 折叠 "">
    参数 字符集 <类型 = 字体字符集类 注释 = "指定返回哪个字符集的字体,默认为系统当前的区域设置." @默认值 = 字体字符集类.默认>
    参数 检索字体 <类型 = 文本型 注释 = "为空返回所有字体, 否则只返回指定名称的字体(文本超长将被忽略)." @默认值 = 空对象>
    参数 窗口句柄 <类型 = 变整数 注释 = "可空" @默认值 = 0>
    {
        @ HWND hwnd = (@<窗口句柄> == 0) ? NULL : (HWND)@<窗口句柄>;
        @ HDC hdc = ::GetDC((@<窗口句柄> == 0) ? NULL : (HWND)@<窗口句柄>);
        @ LOGFONTW lf;
        @ memset(&lf, 0, sizeof(LOGFONTW));
        @ lf.lfCharSet = (BYTE)@<字符集>;
        @ wcscpy_s(lf.lfFaceName, 32, @<检索字体>.GetText());
        @ ::EnumFontFamiliesExW(hdc, (LPLOGFONTW)&lf, (FONTENUMPROCW)&@sn<current_class>::eEnumFontFamExProc, (LPARAM)this, 0);
        @ ::ReleaseDC(hwnd, hdc);
    }

    方法 字体回调 <公开 定义事件 类型 = 整数 注释 = "执行\"枚举系统字体\"后,本事件会收到枚举的字体,每次事件返回一个字体"
            返回值注释 = "返回0继续枚举下一个字体,返回任意的非0整数将停止枚举." 折叠>
    参数 字体名称 <类型 = 文本型 注释 = "找到的字体名称">
    参数 字体类型 <类型 = 整数 注释 = " 找到的字体类型,这是一个组合值." 注释 = " 可以通过\"是否设备字体\"、\"是否栅格字体\"、\"是否TrueType字体\"等方法判断.">

    方法 是否设备字体 <公开 类型 = 逻辑型 注释 = "检查字体的类型是否为设备字体(DEVICE_FONTTYPE)" 返回值注释 = "返回是否为设备字体" 折叠 @嵌入式方法 = "">
    参数 字体类型 <类型 = 整数 注释 = "为\"字体回调\"事件中的\"字体类型\"参数.">
    {
        @ ((DWORD)@<字体类型> & DEVICE_FONTTYPE) == DEVICE_FONTTYPE
    }

    方法 是否栅格字体 <公开 类型 = 逻辑型 注释 = "检查字体的类型是否为栅格字体(RASTER_FONTTYPE)" 返回值注释 = "返回是否为栅格字体" 折叠 @嵌入式方法 = "">
    参数 字体类型 <类型 = 整数 注释 = "为\"字体回调\"事件中的\"字体类型\"参数.">
    {
        @ ((DWORD)@<字体类型> & RASTER_FONTTYPE) == RASTER_FONTTYPE
    }

    方法 是否TrueType字体 <公开 类型 = 逻辑型 注释 = "检查字体的类型是否为TrueType字体(TRUETYPE_FONTTYPE)" 返回值注释 = "返回是否为TrueType字体"
            折叠 @嵌入式方法 = "">
    参数 字体类型 <类型 = 整数 注释 = "为\"字体回调\"事件中的\"字体类型\"参数.">
    {
        @ ((DWORD)@<字体类型> & TRUETYPE_FONTTYPE) == TRUETYPE_FONTTYPE
    }
}

类 字体字符集类 <公开 注释 = "\"字体枚举类\"的辅助类" 折叠 @文档 = "category = \"系统操作.辅助类\"" @常量类 = 短整数>
{
    常量 ANSI <公开 值 = @ANSI_CHARSET>
    常量 波罗的语族 <公开 值 = @BALTIC_CHARSET>
    常量 繁体中文BIG5码 <公开 值 = @CHINESEBIG5_CHARSET>
    常量 默认 <公开 值 = @DEFAULT_CHARSET 注释 = "默认字符集基于当前系统的区域设置. 例如系统区域设置为\"简体中文(中国)\"时,它被设置为GB2312字符集.">
    常量 东欧 <公开 值 = @EASTEUROPE_CHARSET>
    常量 简体中文GB2312 <公开 值 = @GB2312_CHARSET>
    常量 希腊文 <公开 值 = @GREEK_CHARSET>
    常量 韩文 <公开 值 = @HANGUL_CHARSET>
    常量 MAC <公开 值 = @MAC_CHARSET>
    常量 OEM <公开 值 = @OEM_CHARSET 注释 = "指定与操作系统相关的字符集.">
    常量 俄语 <公开 值 = @RUSSIAN_CHARSET>
    常量 日文SHIFTJIS <公开 值 = @SHIFTJIS_CHARSET>
    常量 符号 <公开 值 = @SYMBOL_CHARSET>
    常量 土耳其语 <公开 值 = @TURKISH_CHARSET>
    常量 越南语 <公开 值 = @VIETNAMESE_CHARSET>
    常量 JOHAB <公开 值 = @JOHAB_CHARSET 注释 = "韩国版Windows系统">
    常量 阿拉伯文 <公开 值 = @ARABIC_CHARSET 注释 = "中东版Windows系统">
    常量 希伯来文 <公开 值 = @HEBREW_CHARSET 注释 = "中东版Windows系统">
    常量 泰文 <公开 值 = @THAI_CHARSET 注释 = "泰国版Windows系统">
}

类 管道命令行类 <公开 注释 = "启动一个命令行提示符进程,通过匿名管道让当前进程和命令行之间交互传递输出输入信息." 折叠 @文档 = "category = \"系统操作\"">
{
    方法 类_初始化 <折叠>
    {
        启动命令行 (200)
    }

    方法 类_清理 <折叠>
    {
        关闭命令行 ()
    }

    方法 是否已启动 <公开 属性读 类型 = 逻辑型 注释 = "返回当前是否已启动命令行控制台" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.m_hProcess != NULL
    }

    方法 是否空闲 <公开 属性读 类型 = 逻辑型 注释 = "返回当前是否处于空闲状态,返回假表示正在执行命令."
            注释 = "  注意: 本方法通过检查最后输出的字符是否为\'>\'来判断命令是否执行完毕," 注释 = "如果命令在执行的过程中输出了\'>\'字符,将可能无法获取正确的结果." 折叠
            @嵌入式方法 = "">
    {
        @ !@sn<this>.m_bRunning
    }

    方法 收到输出信息 <公开 定义事件 类型 = 整数 注释 = "启动命令行提示符或执行命令后,在此返回命令的输出信息." 返回值注释 = "此返回值无意义" 折叠>
    参数 输出信息 <类型 = 字节集类 注释 = "  命令行提示符打印在屏幕上的文本,请根据命令行的编码" 注释 = "使用\"多字节到文本\"或\"UTF8到文本\"等命令转换到文本型.">

    方法 启动命令行 <公开 类型 = 逻辑型 注释 = "启动命令行提示符进程,并建立匿名管道." 注释 = "类初始化时会自动启动,除非你执行过\"关闭命令行\",否则不需要手动调用本方法." 折叠
            @禁止流程检查 = 真 "">
    参数 刷新时间 <类型 = 整数 注释 = "读取屏幕信息的间隔" @默认值 = 200>
    {
        @ if (m_hProcess) { return FALSE; } // 避免重复启动CMD
        @ // 设定管道的安全属性
        @ m_bRunning = FALSE;
        @ SECURITY_ATTRIBUTES sa { 0 };
        @ sa.bInheritHandle = TRUE;
        @ sa.nLength = sizeof(sa);
        @ sa.lpSecurityDescriptor = NULL;
        @ STARTUPINFOW si = { sizeof(STARTUPINFO) };
        @ PROCESS_INFORMATION pi = { 0 };
        @ // 创建第一条匿名管道
        @ if (!::CreatePipe(&m_hReadPipeHandle, &m_hWritePipeShell, &sa, 6))
        @     goto Fail;
        @ // 创建第二条匿名管道
        @ if (!::CreatePipe(&m_hReadPipeShell, &m_hWritePipeHandle, &sa, 6))
        @     goto Fail;
        @ // 设置进程的信息
        @ GetStartupInfoW(&si);
        @ si.hStdError = m_hWritePipeShell; // 设置命令行错误输出管道
        @ si.hStdOutput = m_hWritePipeShell; // 设置命令行信息输出管道
        @ si.hStdInput = m_hReadPipeShell; // 设置命令行输入管道
        @ si.wShowWindow = SW_HIDE; // 隐藏命令行窗口
        @ si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
        @ // 设置命令行提示符的文件路径
        @ WCHAR strShellPath[MAX_PATH] { 0 };
        @ GetSystemDirectoryW(strShellPath, MAX_PATH);
        @ wcscat(strShellPath, L"\\cmd.exe");
        @ // 创建命令行提示符进程
        @ if (!::CreateProcessW(strShellPath, NULL, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
        @     goto Fail;
        @ m_hProcess = pi.hProcess; // 保存进程句柄
        @ if (pi.hThread) { ::CloseHandle(pi.hThread); } // 因为后续不需要使用,先关闭命令行的线程句柄
        @ m_dwTime = (DWORD)@<刷新时间>; // 读取屏显文本的时间间隔
        @ m_hEvent = ::CreateEventW(0, FALSE, FALSE, NULL); // 该事件用来通知回调函数退出
        @ ::ResetEvent(m_hEvent);
        @ // 创建回调线程
        @ m_hThread = ::CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&@<读屏显>, this, 0, NULL);
        @ if (m_hThread == NULL) { goto Fail; }
        @ m_ProcessId = pi.dwProcessId;
        @ ::SetConsoleCtrlHandler(NULL, TRUE);
        @ return TRUE;
        @ Fail:
        @     if (m_hProcess) { ::CloseHandle(m_hProcess); m_hProcess = NULL; }
        @     if (m_hReadPipeHandle) { ::CloseHandle(m_hReadPipeHandle); m_hReadPipeHandle = NULL; }
        @     if (m_hWritePipeShell) { ::CloseHandle(m_hWritePipeShell); m_hWritePipeShell = NULL; }
        @     if (m_hReadPipeShell) { ::CloseHandle(m_hReadPipeShell); m_hReadPipeShell = NULL; }
        @     if (m_hWritePipeHandle) { ::CloseHandle(m_hWritePipeHandle); m_hWritePipeHandle = NULL; }
        @ return FALSE;
    }

    方法 读屏显 <静态 类型 = 整数 注释 = "内部函数,线程获取命令行提示符的屏幕显示内容" 折叠 @禁止流程检查 = 真>
    参数 对象指针 <类型 = 变整数>
    {
        @ @sn<current_class>* pThis = (@sn<current_class>*)@<对象指针>;
        @ DWORD BytesRead = 0;
        @ DWORD TotalBytesAvail;
        @ // 用等待事件来无限循环尝试读取屏显文本,读取间隔为等待事件的第二个参数
        @ // 如果等待的事件发出信息,即结束循环,退出本线程
        @ while (::WaitForSingleObject(pThis->m_hEvent, pThis->m_dwTime) != WAIT_OBJECT_0)
        @ {
        @     // 尝试读取匿名管道中的数据,读取的数据不会从管道中删除
        @     // 这里只用来返回管道中是否有可供读取的数据
        @     ::PeekNamedPipe(pThis->m_hReadPipeHandle, NULL, NULL, NULL, &TotalBytesAvail, NULL);
        @     if (TotalBytesAvail) // 如果管道中有数据
        @     {
        @         @an<CVolMem> ReadData;
        @         // 从管道中读取数据,数据读取后会在管道中删除
        @         if (::ReadFile(pThis->m_hReadPipeHandle, ReadData.Alloc(TotalBytesAvail, TRUE), TotalBytesAvail, &BytesRead, NULL))
        @         {
        @             if (ReadData.Get_S_BYTE(BytesRead - 1) == '>')
        @             {
        @                 pThis->m_bRunning = FALSE;
        @             }
        @             pThis->@<收到输出信息> (ReadData);
        @         }
        @     }
        @ }
        @ return 0; // 结束线程
    }

    方法 执行命令 <公开 类型 = 逻辑型 注释 = "在命令行提示符中执行一条命令,如果当前有正在运行的命令,执行会失败." 折叠 @禁止流程检查 = 真>
    参数 执行命令 <类型 = 文本型 注释 = "提供你要执行的命令,后面不需要添加回车符.">
    参数 是否为UTF8 <类型 = 逻辑型 注释 = "是否以UTF-8编码要执行的命令,否则为ANSI本地多字节编码" @默认值 = 假>
    {
        @ if (m_bRunning) return FALSE;
        变量 命令行 <类型 = 字节集类>
        // 命令行需要转换编码,并在命令后增加换行符,命令的最后不能有结尾0字符
        如果 (是否为UTF8)
        {
            命令行 = 文本到UTF8 (执行命令 + "\r\n", 假)
        }
        否则
        {
            命令行 = 文本到多字节 (执行命令 + "\r\n", 假)
        }
        @ DWORD BytesWrite = 0;
        @ // 将命令输入给管道
        @ ::WriteFile (m_hWritePipeHandle, @<命令行>.GetPtr(), (DWORD)@<命令行>.GetSize(), &BytesWrite, NULL);
        @ if (BytesWrite)
        @ {
        @     m_bRunning = TRUE;
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 终止命令 <公开 注释 = "在命令行提示符中发出CTRL+C信号,终止正在执行的命令." 折叠>
    {
        @ if (!m_ProcessId) return;
        @ ::AttachConsole(m_ProcessId);
        @ ::GenerateConsoleCtrlEvent(CTRL_C_EVENT, 0);
        @ ::FreeConsole();
    }

    方法 关闭命令行 <公开 注释 = "关闭命令行提示符" 折叠 @禁止流程检查 = 真>
    {
        终止命令 ()
        @ if (m_hEvent) { ::SetEvent(m_hEvent); } // 发信号让回调函数退出线程
        @ if (m_hThread)
        @ {   // 等待回调线程结束,然后关闭句柄
        @     ::WaitForSingleObject(m_hThread, INFINITE);
        @     ::CloseHandle(m_hThread); m_hThread = NULL;
        @ }
        执行命令 ("exit")  // 尝试执行命令退出命令行提示符,如果当前还有命令未执行完毕,则不起作用
        @ if (m_hProcess)
        @ {   // 等待1秒,如果命令行还没结束,就强制结束进程
        @     if (::WaitForSingleObject(m_hThread, 1000) == WAIT_TIMEOUT)
        @     {
        @         ::TerminateProcess(m_hProcess, 0);
        @     }
        @     ::CloseHandle(m_hProcess); m_hProcess = NULL;
        @ }
        @ m_bRunning = FALSE;
        @ ::SetConsoleCtrlHandler(NULL, FALSE);
        @ // 关闭匿名管道的读写句柄
        @ if (m_hReadPipeHandle) { ::CloseHandle(m_hReadPipeHandle); m_hReadPipeHandle = NULL; }
        @ if (m_hWritePipeShell) { ::CloseHandle(m_hWritePipeShell); m_hWritePipeShell = NULL; }
        @ if (m_hReadPipeShell) { ::CloseHandle(m_hReadPipeShell); m_hReadPipeShell = NULL; }
        @ if (m_hWritePipeHandle) { ::CloseHandle(m_hWritePipeHandle); m_hWritePipeHandle = NULL; }
    }

    # ---
    # @begin
    # <> <include>
    # HANDLE m_hReadPipeHandle = NULL;
    # HANDLE m_hWritePipeShell = NULL;
    # HANDLE m_hReadPipeShell = NULL;
    # HANDLE m_hWritePipeHandle = NULL;
    # HANDLE m_hProcess = NULL;
    # HANDLE m_hThread = NULL;
    # HANDLE m_hEvent = NULL;
    # DWORD m_dwTime;
    # DWORD m_ProcessId;
    # BOOL m_bRunning = FALSE;
    # <> </include>
    # @end
}

类 磁盘管理类 <公开 注释 = "需要管理员权限" 折叠 @文档 = "category = \"文件操作\"" @禁止创建对象 = 真>
{
    方法 删除卷装载点 <公开 静态 类型 = 逻辑型 注释 = "删除驱动器号或装载的文件夹." 返回值注释 = "返回是否成功." 折叠 @嵌入式方法 = "">
    参数 卷装载路径 <类型 = 文本型 注释 = " 所欲删除的驱动器号或装载的文件夹." 注释 = " 需要以反斜杠结尾,例如\"X:\\\"或\"Y:\\\\MountX\\\".">
    {
        @ ::DeleteVolumeMountPointW(@<卷装载路径>.GetText())
    }

    方法 置卷装载点 <公开 静态 类型 = 逻辑型 注释 = "将卷与另一卷上的驱动器号或目录相关联." 返回值注释 = "返回是否成功." 折叠 @嵌入式方法 = "">
    参数 卷装载路径 <类型 = 文本型 注释 = " 所欲与卷关联的用户模式路径." 注释 = " 这可以是驱动器号(例如\"X:\")或另一卷上的目录(例如\"Y:\\MountX\")."
            注释 = " 文本必须以反斜杠\"\\\"结尾.">
    参数 卷GUID <类型 = 文本型 注释 = " 卷的GUID路径(可用\"取卷装载点路径\"获取)."
            注释 = " 字符串格式必须为\"\\\\?\\Volume{GUID}\\\",其中GUID是卷的标识GUID," 注释 = " \"\\\\?\\\"用于关闭路径解析,在路径中会被忽略.">
    {
        @ ::SetVolumeMountPointW(@<卷装载路径>.GetText(), @<卷GUID>.GetText())
    }

    方法 取卷装载点路径 <公开 静态 类型 = 逻辑型 注释 = "获取与指定卷装载点(驱动器号、卷GUID路径或装载的文件夹)关联的卷GUID路径."
            返回值注释 = "返回是否成功,成功将在\"卷GUID\"中返回结果." 折叠 @禁止流程检查 = 真>
    参数 卷装载路径 <类型 = 文本型 注释 = " 所欲取卷GUID路径的已装载文件夹的路径(例如\"Y:\\MountX\\\")或驱动器号(例如\"X:\\\")."
            注释 = " 文本必须以反斜杠\"\\\"结尾.">
    参数 卷GUID <类型 = 文本型 注释 = " 返回获取的卷GUID路径." 注释 = " 此路径的格式为\"\\\\?\\Volume{GUID}\\\",其中GUID是卷的标识GUID."
            注释 = " 如果该卷有多个卷GUID路径,则只返回装载管理器缓存中的第一个路径.">
    {
        @ TCHAR szVolumeName[50];
        @ if (::GetVolumeNameForVolumeMountPointW(@<卷装载路径>.GetText(), szVolumeName, 50)) {
        @     @<卷GUID>.SetText(szVolumeName);
        @     return TRUE;
        @ }
        @ @<卷GUID>.Empty();
        @ return FALSE;
    }
}

类 全局内存管理类 <公开 注释 = "  各种内存管理都是在堆中分配内存,但因为分配器的机制不同,不能交叉使用," 注释 = "比如\"分配内存\"的地址不能用\"释放全局内存\"来释放."
        注释 = "  由于部分系统API需要使用\"释放全局内存\"释放,所以本类的封装还是有意义的." 注释 = "  本类只封装了固定地址一种应用方法,未封装另一种可移动内存对象."
        注释 = "  本类的开销比\"分配内存\"大,如非必要不建议使用." 注释 = "  全局内存和本地内存只在Win16系统中有区别,在Win32以上系统中这两者无区别." 折叠
        @文档 = "category = \"内存操作\"" @禁止创建对象 = 真 @编译条件 = "PIV_ENABLE_OBSOLETE">
{
    方法 分配全局内存 <公开 静态 类型 = 变整数 注释 = "  在堆中分配一段所指定尺寸的全局内存,返回所分配内存的地址."
            注释 = "  注意: 所返回的内存地址在不再使用后必须使用\"释放全局内存\"" 注释 = "方法将其释放(除非调用了\"重分配全局内存\"方法将其重新分配)."
            返回值注释 = "成功返回所分配内存的地址指针,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲分配内存的尺寸 <类型 = 整数 注释 = "  提供所欲分配内存的尺寸,必须大于0." 注释 = "  实际分配的内存可能会大于该值,可以用\"取全局内存尺寸\"获取实际尺寸.">
    参数 是否清零 <类型 = 逻辑型 注释 = "是否将所分配的内容空间清除为字节值零." @默认值 = 真>
    {
        @ (INT_P)GlobalAlloc (@<是否清零> ? GPTR : GMEM_FIXED , (SIZE_T)@<所欲分配内存的尺寸>)
    }

    方法 重分配全局内存 <公开 静态 类型 = 变整数 注释 = "重新分配先前所已分配内存的尺寸或属性,返回重分配后的内存地址指针."
            注释 = "注意: 先前内存中的数据内容将被保留,即使本方法返回了不同的地址指针." 返回值注释 = "成功返回所重分配内存的地址指针,失败返回0." 折叠 @嵌入式方法 = "">
    参数 先前所分配内存地址 <类型 = 变整数 注释 = "  提供先前调用\"分配内存\"或\"重分配内存\"方法所返回的内存地址指针,注"
            注释 = "意所提供的先前内存地址指针在重分配后将不再有效(注意本方法也可能返" 注释 = "回相同的地址指针值).">
    参数 所欲重分配内存的尺寸 <类型 = 整数 注释 = "提供所欲重新分配内存的尺寸,必须大于0.">
    参数 是否清零 <类型 = 逻辑型 注释 = "如果新尺寸大于原尺寸,是否在新增的内存区域清零." @默认值 = 真>
    {
        @ (INT_P)GlobalReAlloc ((HGLOBAL)@<先前所分配内存地址>, (SIZE_T)@<所欲重分配内存的尺寸>, @<是否清零> ? GMEM_ZEROINIT : 0)
    }

    方法 取全局内存尺寸 <公开 静态 类型 = 整数 注释 = "获取指定全局内存地址的实际尺寸,实际分配的尺寸可能会大于分配时指定要分配的尺寸."
            返回值注释 = "成功返回字节单位的尺寸,失败或地址已被释放返回0." 折叠 @嵌入式方法 = "">
    参数 全局内存地址 <类型 = 变整数 注释 = "提供\"分配全局内存\"或\"重分配全局内存\"返回的全局内存地址.">
    {
        @ (INT)GlobalSize ((HGLOBAL)@<全局内存地址>)
    }

    方法 释放全局内存 <公开 静态 类型 = 变整数 注释 = "释放先前调用\"分配全局内存\"或\"重分配全局内存\"方法所分配的全局内存." 返回值注释 = "成功返回0,失败返回原来的内存地址."
            折叠 @嵌入式方法 = "">
    参数 先前所分配内存地址 <类型 = 变整数 注释 = "  提供先前调用\"分配全局内存\"或\"重分配全局内存\"方法所返回的内存地址指针," 注释 = "注意所提供的内存地址指针在释放后将不再有效.">
    {
        @ (INT_P)GlobalFree ((HGLOBAL)@<先前所分配内存地址>)
    }
}

类 本地内存管理类 <公开 注释 = "  各种内存管理都是在堆中分配内存,但因为分配器的机制不同,不能交叉使用," 注释 = "比如\"分配内存\"的地址不能用\"释放本地内存\"来释放."
        注释 = "  由于部分系统API需要使用\"释放本地内存\"释放,所以本类的封装还是有意义的." 注释 = "  本类只封装了固定地址一种应用方法,未封装另一种可移动内存对象."
        注释 = "  本类的开销比\"分配内存\"大,如非必要不建议使用." 注释 = "  全局内存和本地内存只在Win16系统中有区别,在Win32以上系统中这两者无区别." 折叠
        @文档 = "category = \"内存操作\"" @禁止创建对象 = 真 @编译条件 = "PIV_ENABLE_OBSOLETE" "">
{
    方法 分配本地内存 <公开 静态 类型 = 变整数 注释 = "  在堆中分配一段所指定尺寸的本地内存,返回所分配内存的地址."
            注释 = "  注意: 所返回的内存地址在不再使用后必须使用\"释放本地内存\"" 注释 = "方法将其释放(除非调用了\"重分配本地内存\"方法将其重新分配)."
            返回值注释 = "成功返回所分配内存的地址指针,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲分配内存的尺寸 <类型 = 整数 注释 = "  提供所欲分配内存的尺寸,必须大于0." 注释 = "  实际分配的内存可能会大于该值,可以用\"取全局内存尺寸\"获取实际尺寸.">
    参数 是否清零 <类型 = 逻辑型 注释 = "是否将所分配的内容空间清除为字节值零." @默认值 = 真>
    {
        @ (INT_P)LocalAlloc (@<是否清零> ? LPTR : LMEM_FIXED , (SIZE_T)@<所欲分配内存的尺寸>)
    }

    方法 重分配本地内存 <公开 静态 类型 = 变整数 注释 = "重新分配先前所已分配内存的尺寸或属性,返回重分配后的内存地址指针."
            注释 = "注意: 先前内存中的数据内容将被保留,即使本方法返回了不同的地址指针." 返回值注释 = "成功返回所重分配内存的地址指针,失败返回0." 折叠 @嵌入式方法 = "">
    参数 先前所分配内存地址 <类型 = 变整数 注释 = "  提供先前调用\"分配内存\"或\"重分配内存\"方法所返回的内存地址指针,注"
            注释 = "意所提供的先前内存地址指针在重分配后将不再有效(注意本方法也可能返" 注释 = "回相同的地址指针值).">
    参数 所欲重分配内存的尺寸 <类型 = 整数 注释 = "提供所欲重新分配内存的尺寸,必须大于0.">
    参数 是否清零 <类型 = 逻辑型 注释 = "如果新尺寸大于原尺寸,是否在新增的内存区域清零." @默认值 = 真>
    {
        @ (INT_P)LocalReAlloc ((HLOCAL)@<先前所分配内存地址>, (SIZE_T)@<所欲重分配内存的尺寸>, @<是否清零> ? LMEM_ZEROINIT : 0)
    }

    方法 取本地内存尺寸 <公开 静态 类型 = 整数 注释 = "获取指定全局内存地址的实际尺寸,实际分配的尺寸可能会大于分配时指定要分配的尺寸."
            返回值注释 = "成功返回字节单位的尺寸,失败或地址已被释放返回0." 折叠 @嵌入式方法 = "">
    参数 全局内存地址 <类型 = 变整数 注释 = "提供\"分配全局内存\"或\"重分配全局内存\"返回的全局内存地址.">
    {
        @ (INT)GlobalSize ((HGLOBAL)@<全局内存地址>)
    }

    方法 释放本地内存 <公开 静态 类型 = 变整数 注释 = "释放先前调用\"分配本地内存\"或\"重分配本地内存\"方法所分配的本地内存." 返回值注释 = "成功返回0,失败返回原来的内存地址."
            折叠 @嵌入式方法 = "">
    参数 先前所分配内存地址 <类型 = 变整数 注释 = "  提供先前调用\"分配本地内存\"或\"重分配本地内存\"方法所返回的内存地址指针," 注释 = "注意所提供的内存地址指针在释放后将不再有效.">
    {
        @ (INT_P)LocalFree ((HLOCAL)@<先前所分配内存地址>)
    }
}

# ===

类 程序信息类 <公开 注释 = "用于获取程序文件的版本信息" 折叠 @文档 = "category = \"系统操作\"" @全局类 = 真 @禁止创建对象 = 真
        @视窗.外部库 = "Version.lib">
{
    方法 取程序版本 <公开 静态 类型 = 逻辑型 注释 = "获取程序文件的完整版本信息,取自版本信息资源的StringFileInfo结构."
            注释 = "注意: 由于火山程序的版本信息比较别扭,本方法只能获取火山程序的\"版本名称\"属性," 注释 = "如果要获取\"版本号\",请使用\"取文件版本\"或\"取产品版本\"."
            返回值注释 = "返回是否成功" 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "包含完整路径的文件名">
    参数 版本信息 <类型 = 程序版本信息类>
    {
        @ @<版本信息>.ResetToNullObject ();
        @ DWORD bufSize = ::GetFileVersionInfoSizeW (@<文件名>.GetText (), 0);
        @ if (!bufSize) return FALSE;
        @ @an<CVolMem> buffer;
        @ buffer.Alloc (bufSize, TRUE);
        @ if (::GetFileVersionInfoW (@<文件名>.GetText (), 0, bufSize, buffer.GetPtr ()) == 0)
        @     return FALSE;
        @ struct LANGANDCODEPAGE {
        @     WORD wLanguage;
        @     WORD wCodePage;
        @ } *lpTranslate;
        @ UINT cbTranslate, data_len;
        @ if (::VerQueryValueW (buffer.GetPtr (), L"\\VarFileInfo\\Translation", (LPVOID*)&lpTranslate, &cbTranslate))
        @ {
        @     for (UINT i = 0; i < (cbTranslate / sizeof (struct LANGANDCODEPAGE)); i++)
        @     {
        @         WCHAR SubBlock[MAX_PATH] { '\0' };
        @         const WCHAR* szText = nullptr;
        @         if (::VerLanguageNameW (lpTranslate[i].wLanguage, SubBlock, MAX_PATH)) @<版本信息.语言>.SetText (SubBlock);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\Comments", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.注释>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\CompanyName", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.公司名称>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\FileDescription", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.文件说明>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\FileVersion", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.文件版本>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\InternalName", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.内部名称>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\LegalCopyright", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.版权>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\LegalTrademarks", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.法律商标>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\OriginalFilename", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.原始文件名>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\ProductName", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.产品名称>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\ProductVersion", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.产品版本>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\PrivateBuild", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.私有版本>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\SpecialBuild", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.特殊版本>.SetText (szText);
        @         break; // 跳出循环,只取第一个语言
        @     }
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 取程序文件版本 <公开 静态 类型 = 文本型 注释 = "返回程序文件的文件版本字符串,取自版本信息资源的StringFileInfo结构."
            返回值注释 = "成功返回文件版本(等同火山程序的\"版本名称\"属性)" 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "包含完整路径的文件名">
    {
        @ DWORD bufSize = ::GetFileVersionInfoSizeW (@<文件名>.GetText (), 0);
        @ @an<CVolString> szFileVersion;
        @ if (!bufSize) return szFileVersion;
        @ @an<CVolMem> buffer;
        @ buffer.Alloc (bufSize, TRUE);
        @ if (::GetFileVersionInfoW (@<文件名>.GetText(), 0, bufSize, buffer.GetPtr ()) == 0)
        @     return szFileVersion;
        @ struct LANGANDCODEPAGE {
        @     WORD wLanguage;
        @     WORD wCodePage;
        @ } *lpTranslate;
        @ UINT cbTranslate, data_len;
        @ if (::VerQueryValueW (buffer.GetPtr (), L"\\VarFileInfo\\Translation", (LPVOID*)&lpTranslate, &cbTranslate))
        @ {
        @     for (UINT i = 0; i < (cbTranslate / sizeof (struct LANGANDCODEPAGE)); i++)
        @     {
        @         WCHAR SubBlock[MAX_PATH] { 0 };
        @         const WCHAR* szText = nullptr;
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\FileVersion", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len))
        @             szFileVersion.SetText (szText);
        @         break; // 跳出循环,只取第一个语言
        @     }
        @ }
        @ return szFileVersion;
    }

    方法 取文件版本 <公开 静态 类型 = 长整数 注释 = "返回程序文件的文件版本,取自版本信息资源的VS_FIXEDFILEINFO结构."
            注释 = "调用失败返回-1,长整数的版本号更适合比较,但不直观." 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "包含完整路径的文件名">
    参数 返回版本格式文本 <类型 = 文本型 注释 = "在本参数中返回类似\"1.1.0.0\"格式的文本版本号,更适合于展示." @默认值 = 空对象>
    {
        @ DWORD bufSize = ::GetFileVersionInfoSizeW (@<文件名>.GetText (), 0);
        @ if (!bufSize) return -1;
        @ @an<CVolMem> buffer;
        @ buffer.Alloc (bufSize, TRUE);
        @ if (::GetFileVersionInfoW (@<文件名>.GetText(), 0, bufSize, buffer.GetPtr ()) == 0)
        @     return -1;
        @ VS_FIXEDFILEINFO* pFileInfo = nullptr;
        @ UINT cbFileInfo;
        @ if (::VerQueryValueW (buffer.GetPtr (), L"\\", (LPVOID*)&pFileInfo, &cbFileInfo))
        @ {
        @     if (!@<返回版本格式文本>.IsNullObject())
        @         @<返回版本格式文本>.Format (L"%d.%d.%d.%d", HIWORD(pFileInfo->dwFileVersionMS), LOWORD((DWORD)pFileInfo->dwFileVersionMS), HIWORD(pFileInfo->dwFileVersionLS), LOWORD((DWORD)pFileInfo->dwFileVersionLS));
        @     return (INT64)(pFileInfo->dwFileVersionMS | ((UINT64)pFileInfo->dwFileVersionLS << 32));
        @ }
        @ return -1;
    }

    方法 取产品版本 <公开 静态 类型 = 长整数 注释 = "返回程序文件的产品版本,取自版本信息资源的VS_FIXEDFILEINFO结构."
            注释 = "调用失败返回-1,长整数的版本号更适合比较,但不直观." 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "包含完整路径的文件名">
    参数 返回版本格式文本 <类型 = 文本型 注释 = "在本参数中返回类似\"1.1.0.0\"格式的文本版本号,更适合于展示." @默认值 = 空对象>
    {
        @ DWORD bufSize = ::GetFileVersionInfoSizeW (@<文件名>.GetText (), 0);
        @ if (!bufSize) return -1;
        @ @an<CVolMem> buffer;
        @ buffer.Alloc (bufSize, TRUE);
        @ if (::GetFileVersionInfoW (@<文件名>.GetText(), 0, bufSize, buffer.GetPtr ()) == 0)
        @     return -1;
        @ VS_FIXEDFILEINFO* pFileInfo = nullptr;
        @ UINT cbFileInfo;
        @ if (::VerQueryValueW (buffer.GetPtr (), L"\\", (LPVOID*)&pFileInfo, &cbFileInfo))
        @ {
        @     if (!@<返回版本格式文本>.IsNullObject())
        @         @<返回版本格式文本>.Format (L"%d.%d.%d.%d", HIWORD(pFileInfo->dwProductVersionMS), LOWORD((DWORD)pFileInfo->dwProductVersionMS), HIWORD(pFileInfo->dwProductVersionLS), LOWORD((DWORD)pFileInfo->dwProductVersionLS));
        @     return (INT64)(pFileInfo->dwProductVersionMS | ((UINT64)pFileInfo->dwProductVersionLS << 32));
        @ }
        @ return -1;
    }
}

类 程序版本信息类 <公开 基础类 = 扩展对象类 注释 = "程序文件版本信息的辅助类" 折叠 @文档 = "category = \"系统操作.辅助类\"">
{
    变量 注释 <公开 类型 = 文本型 注释 = "(可能为空)Comments,与文件关联的注释.">
    变量 公司名称 <公开 类型 = 文本型 注释 = "CompanyName,生成文件的公司的名称.">
    变量 文件说明 <公开 类型 = 文本型 注释 = "FileDescription,文件说明.">
    变量 文件版本 <公开 类型 = 文本型 注释 = "FileVersion,文件的版本号.">
    变量 内部名称 <公开 类型 = 文本型 注释 = "InternalName,文件的内部名称. 如果不存在内部名称,则该属性将包含文件的原始名称(不带扩展名).">
    变量 版权 <公开 类型 = 文本型 注释 = "LegalCopyright,包括所有声明的完整文本、合法符号、版权日期等.">
    变量 法律商标 <公开 类型 = 文本型 注释 = "(可能为空)LegalTrademarks,应用到文件的商标和注册商标.">
    变量 原始文件名 <公开 类型 = 文本型 注释 = "OriginalFilename,创建文件时使用的名称.">
    变量 产品名称 <公开 类型 = 文本型 注释 = "ProductName,与此文件一起发行的产品的名称.">
    变量 产品版本 <公开 类型 = 文本型 注释 = "ProductVersion,与此文件一起发行的产品的版本.">
    变量 私有版本 <公开 类型 = 文本型 注释 = "(可能为空)PrivateBuild,文件私有版本的信息.">
    变量 特殊版本 <公开 类型 = 文本型 注释 = "(可能为空)SpecialBuild,文件的特殊内部版本信息.">
    变量 语言 <公开 类型 = 文本型 注释 = "程序的语言">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<程序版本信息类> 总共 13 个成员:\r\n"
        加入文本 (展示内容, "1. 注释: " + 取调试文本2 (最大展示数据尺寸, 注释) + "\r\n")
        加入文本 (展示内容, "2. 公司名称: " + 取调试文本2 (最大展示数据尺寸, 公司名称) + "\r\n")
        加入文本 (展示内容, "3. 文件说明: " + 取调试文本2 (最大展示数据尺寸, 文件说明) + "\r\n")
        加入文本 (展示内容, "4. 文件版本: " + 取调试文本2 (最大展示数据尺寸, 文件版本) + "\r\n")
        加入文本 (展示内容, "5. 内部名称: " + 取调试文本2 (最大展示数据尺寸, 内部名称) + "\r\n")
        加入文本 (展示内容, "6. 版权: " + 取调试文本2 (最大展示数据尺寸, 版权) + "\r\n")
        加入文本 (展示内容, "7. 法律商标: " + 取调试文本2 (最大展示数据尺寸, 法律商标) + "\r\n")
        加入文本 (展示内容, "8. 原始文件名: " + 取调试文本2 (最大展示数据尺寸, 原始文件名) + "\r\n")
        加入文本 (展示内容, "9. 产品名称: " + 取调试文本2 (最大展示数据尺寸, 产品名称) + "\r\n")
        加入文本 (展示内容, "10. 产品版本: " + 取调试文本2 (最大展示数据尺寸, 产品版本) + "\r\n")
        加入文本 (展示内容, "11. 私有版本: " + 取调试文本2 (最大展示数据尺寸, 私有版本) + "\r\n")
        加入文本 (展示内容, "12. 特殊版本: " + 取调试文本2 (最大展示数据尺寸, 特殊版本) + "\r\n")
        加入文本 (展示内容, "13. 语言: " + 取调试文本2 (最大展示数据尺寸, 语言))
    }
}

类 程序版本信息数组类 <公开 基础类 = 对象数组模板类 @文档 = "category = \"系统操作.辅助类\"" @模板实现类 = "程序版本信息类">

类 "//文件对话框选项" <公开 注释 = "暂未使用,直接写在内嵌代码里了,仅供参考." 折叠 @常量类 = 整数 @文档 = "category = \"文件操作.辅助类\"">
{
    常量 允许多选 <公开 值 = @OFN_ALLOWMULTISELECT 注释 = "允许多选文件,如果不同时设置Explorer风格,将显示旧版风格的文件对话框.">
    常量 创建时提示 <公开 值 = @OFN_CREATEPROMPT 注释 = "如果用户指定了一个不存在的文件,这个标记使用对话框能提示用户是否新建这个文件.">
    常量 不添加到最近使用 <公开 值 = @OFN_DONTADDTORECENT 注释 = "禁止系统将选择的文件增加快捷链接到最近使用文档中.">
    常量 启用钩子 <公开 值 = @OFN_ENABLEHOOK 注释 = "有这个风格,才可以响应对话框的事件,如\"创建完毕\".">
    常量 启用通知 <公开 值 = @OFN_ENABLEINCLUDENOTIFY 注释 = "当用户打开一个文件夹时,引起对话框发送CDN_INCLUDEITEM通知消息到你的OFNHookProc程序.">
    常量 可调节尺寸 <公开 值 = @OFN_ENABLESIZING 注释 = "使Explorer风格的对话框可以使用鼠标或键盘调整大小.">
    常量 启用模板 <公开 值 = @OFN_ENABLETEMPLATE 注释 = "指出lpTemplateName成员是指向对话框模板资源的名字,这个模板资源在能被hInstance成员识别的模块中 .">
    常量 启用模板句柄 <公开 值 = @OFN_ENABLETEMPLATEHANDLE
            注释 = "指出hInstance成员能识别的包含预载对话框模板的数据块. 如果这个标记被指定的,系统忽略lpTemplateName.">
    常量 Explorer风格 <公开 值 = @OFN_EXPLORER 注释 = "使用新的Explorer风格对话框,该选项为默认值."
            注释 = "这个标记仅在你提供了一个钩子程序或定制模板或设置了 OFN_ALLOWMULTISELECT 标记时是必需的.">
    常量 不同扩展名 <公开 值 = @OFN_EXTENSIONDIFFERENT 注释 = "指定用户输入的一个文件的扩展名与lpstrDefExt指定的扩展名不同.">
    常量 文件必须存在 <公开 值 = @OFN_FILEMUSTEXIST 注释 = "指定用户仅可以在文件名登录字段中输入已存在的文件的名字.">
    常量 显示隐藏文件 <公开 值 = @OFN_FORCESHOWHIDDEN 注释 = "强制显示系统和隐藏属性的文件.">
    常量 隐藏只读复选框 <公开 值 = @OFN_HIDEREADONLY 注释 = "隐藏只读复选框.">
    常量 长文件名 <公开 值 = @OFN_LONGNAMES 注释 = "对于旧风格对话框,这个标记引起对话框使用长文件名. EXPLORER风格默认显示长文件名.">
    常量 不改变初始目录 <公开 值 = @OFN_NOCHANGEDIR 注释 = "如果当搜索文件时用户改变了目录的时候,恢复当前目录到它的初始值.">
    常量 不解引用快捷方式 <公开 值 = @OFN_NODEREFERENCELINKS
            注释 = "返回所选快捷方式(.LNK)文件的路径和文件名,如果不启用该选项,会返回快捷方式所引用的文件路径和文件名.">
    常量 短文件名 <公开 值 = @OFN_NOLONGNAMES 注释 = "对于旧风格对话框,这个标识引起对话框去使用短文件名(8.3格式).">
    常量 隐藏网络按钮 <公开 值 = @OFN_NONETWORKBUTTON 注释 = "隐藏网络按钮.">
    常量 返回非只读文件 <公开 值 = @OFN_NOREADONLYRETURN 注释 = "指定返回的文件不具有只读属性,且不在写保护的文件夹中.">
    常量 不检测文件创建 <公开 值 = @OFN_NOTESTFILECREATE 注释 = "指定文件不是在对话框关闭前建立的.">
    常量 不验证数据 <公开 值 = @OFN_NOVALIDATE 注释 = "允许在返回的文件名中有无效的字符.">
    常量 文件覆盖提示 <公开 值 = @OFN_OVERWRITEPROMPT 注释 = "如果选择的文件已经存在,使用另存为对话框产生一个消息框. 用户必须确认是否复盖这个文件.">
    常量 路径必须存在 <公开 值 = @OFN_PATHMUSTEXIST 注释 = "指定用户仅能输入的路径和文件名.">
    常量 显示只读复选框 <公开 值 = @OFN_READONLY 注释 = "当对话框建立时,显示被选择的只读复选框.">
    常量 获取共享文件 <公开 值 = @OFN_SHAREAWARE 注释 = "如果调用OpenFile函数因为网络共享冲突而失败,将忽略错误并返回对话框选择的文件名.">
    常量 显示帮助按钮 <公开 值 = @OFN_SHOWHELP 注释 = "文件对话框显示帮助按钮.">
}

类 磁盘监视类 <公开 基础类 = PIV对象类 注释 = "通过NTFS的USN日志来监视文件和目录的更改,实现原理跟文件搜索软件Everything相同."
        注释 = " 1. 监视USN日志的效率相当高,但只能在NTFS文件系统上使用;" 注释 = " 2. USN日志会监视整个本地磁盘,但可以只输出特定目录下的更改记录;"
        注释 = " 3. 本类的接收事件在子线程中触发,每个盘符一条线程;" 注释 = " 4. 程序需要以管理员权限运行;" 折叠 @文档 = "category = \"文件操作\""
        @视窗.外部头文件 = "src\\piv_UsnMonitor.hpp">
{
    方法 枚举所有盘符 <公开 静态 类型 = 整数 注释 = "获取所有的盘符,返回盘符数量." 返回值注释 = "成功返回盘符数量,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 盘符数组 <类型 = 字符数组类 注释 = "成功返回包含所有盘符的数组">
    参数 仅枚举本地磁盘 <类型 = 逻辑型 注释 = "默认剔除光驱及网络驱动器,如需枚举所有盘符请设置为假." @默认值 = 真>
    {
        @ @<盘符数组>.data().RemoveAll();
        @ WCHAR szBuffer[MAX_PATH + 1] {0};
        @ DWORD dwBufLen = ::GetLogicalDriveStringsW(MAX_PATH, szBuffer);
        @ if (dwBufLen == 0) return 0;
        @ for (DWORD i = 0; i < dwBufLen; i += 4) {
        @     if (@<仅枚举本地磁盘> == TRUE && ::GetDriveTypeW(szBuffer + i) != DRIVE_FIXED)
        @         continue;
        @     @<盘符数组>.data().Add(szBuffer[i]);
        @ }
        @ return (INT)@<盘符数组>.data().GetCount();
    }

    # ---

    方法 开始监视 <公开 类型 = 逻辑型 注释 = "开始监视某个本地磁盘中所有文件和目录的更改:" 注释 = " 1. 指定的盘符必须为NTFS文件格式,且不能为网络驱动器;"
            注释 = " 2. 程序必须以管理员身份运行;" 注释 = " 3. 可以重复调用本方法监视不同的盘符;" 折叠 @禁止流程检查 = 真>
    参数 盘符 <类型 = 字符 注释 = "提供本地磁盘的盘符(不区分大小写),请以单引号输入,如: \'C\'">
    参数 监视目录组 <类型 = 文本数组类 注释 = "可以将监视范围限定在所提供的一或多个目录中,请确保提供的目录已经存在." 注释 = "默认的空数组表示监视整个本地磁盘;"
            注释 = "注意: 本参数有效时,内部会维护一个包含文件夹主从关系的键值表,会占用较大内存." @默认值 = 空对象>
    参数 延迟时间 <类型 = 整数 注释 = "如果上次读取USN日志没有发现新的更改,将延迟指定的时间(单位为毫秒)." @默认值 = 1000>
    参数 路径获取方式 <类型 = 整数 注释 = "选择文件更改事件中\"当前路径\"的获取方式:" 注释 = " 0 不获取路径(速度最快);"
            注释 = " 1 使用系统API获取,需要确保文件夹存在,文件夹被删除后会获取不了;" 注释 = " 2 由本类维护一个数据表,即使文件夹被删除后仍能获取路径,"
            注释 = "但占用内存较大(Win11的系统盘需要500MB以上内存)." @默认值 = 1>
    {
        @ auto it = m_map.find(@<盘符>);
        @ if (it == m_map.end())
        @     it = m_map.emplace(@<盘符>, new PivUsnMonitor{}).first;
        @ if (!it->second->Start(@<盘符>, @<监视目录组>.data(), @<延迟时间>, @<路径获取方式>)) {
        @     m_map.erase(@<盘符>);
        @     return FALSE;
        @ }
        @ it->second->BindInited(&@sn<current_class>::@<初始化完毕>, this, @<盘符>);
        @ it->second->BindCreated(&@sn<current_class>::@<文件被创建>, this, @<盘符>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4);
        @ it->second->BindDeleted(&@sn<current_class>::@<文件被删除>, this, @<盘符>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4);
        @ it->second->BindDataChanged(&@sn<current_class>::@<文件内容改变>, this, @<盘符>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5);
        @ it->second->BindRenamed(&@sn<current_class>::@<文件被重命名>, this, @<盘符>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5);
        @ it->second->BindMoved(&@sn<current_class>::@<文件被移动>, this, @<盘符>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5, std::placeholders::_6);
        @ it->second->BindRecycle(&@sn<current_class>::@<被删到回收站>, this, @<盘符>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5);
        @ it->second->BindAttributeChange(&@sn<current_class>::@<文件属性改变>, this, @<盘符>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5);
        @ it->second->BindOtherChange(&@sn<current_class>::@<其他状态改变>, this, @<盘符>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5);
        @ return TRUE;
    }

    方法 停止监视 <公开 类型 = 逻辑型 注释 = "停止监视某个本地磁盘,返回是否实际停止了监视." 注释 = "注: 类析构时会自动停止监视所有盘符." 折叠 @禁止流程检查 = 真>
    参数 盘符 <类型 = 字符 注释 = "提供本地磁盘的盘符(不区分大小写),请以单引号输入,如: \'C\'">
    参数 删除USN日志 <类型 = 逻辑型 注释 = "是否删除(禁用)USN日志,删除操作是全局的,会影响其他使用了USN日志的软件." @默认值 = 假>
    {
        @ auto it = m_map.find(@<盘符>);
        @ if (it != m_map.end()) {
        @     it->second->Stop(@<删除USN日志>);
        @     return m_map.erase(it) > 0;
        @ }
        @ return FALSE;
    }

    方法 全部停止 <公开 注释 = "停止所有正在运行的监视." 注释 = "注: 类析构时会自动停止监视所有盘符." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.m_map.clear()
    }

    方法 取监视盘符 <公开 类型 = 整数 注释 = "获取当前正在监视的所有盘符,返回监视的盘符数量." 折叠 @禁止流程检查 = 真>
    参数 盘符数组 <类型 = 字符数组类 注释 = "返回所有正在监视的盘符">
    {
        @ @<盘符数组>.data().RemoveAll();
        @ for (auto& it = m_map.begin(); it != m_map.end(); it++) {
        @     @<盘符数组>.data().Add(it->first);
        @ }
        @ return (INT)@<盘符数组>.data().GetCount();
    }

    # ---

    方法 初始化完毕 <公开 定义事件 类型 = 整数 注释 = "USN日志初始化完毕后将发送一次本事件,表示将开始监视文件的更改." 折叠>
    参数 盘符 <类型 = 字符 注释 = "当前监视的盘符">

    方法 文件被创建 <公开 定义事件 类型 = 整数 注释 = "监视到创建了新文件或目录" 折叠>
    参数 盘符 <类型 = 字符 注释 = "当前监视的盘符">
    参数 文件名称 <类型 = 文本型 注释 = "触发更改的文件或目录名称">
    参数 当前路径 <类型 = 文本型 注释 = "本次更改的所在路径,以路径符结尾.">
    参数 时间戳 <类型 = 文件时间结构 注释 = "本次更改的文件时间戳(非Unix时间戳)">
    参数 属性值 <类型 = 整数 注释 = "文件或目录的属性值,为\"文件属性\"常量的组合值;" 注释 = "可用\"位与\"计算来判断是否具有某个属性;"
            注释 = "如: 为子目录 = 位与 (属性值, 文件属性.子目录) != 0">

    方法 文件被删除 <公开 定义事件 类型 = 整数 注释 = "监视到某个文件或目录被删除" 折叠>
    参数 盘符 <类型 = 字符 注释 = "当前监视的盘符">
    参数 文件名称 <类型 = 文本型 注释 = "触发更改的文件或目录名称">
    参数 当前路径 <类型 = 文本型 注释 = "本次更改的所在路径,以路径符结尾.">
    参数 时间戳 <类型 = 文件时间结构 注释 = "本次更改的文件时间戳(非Unix时间戳)">
    参数 属性值 <类型 = 整数 注释 = "文件或目录的属性值,为\"文件属性\"常量的组合值;" 注释 = "可用\"位与\"计算来判断是否具有某个属性;"
            注释 = "如: 为子目录 = 位与 (属性值, 文件属性.子目录) != 0">

    方法 文件内容改变 <公开 定义事件 类型 = 整数 注释 = "监视到某个文件的内容数据被修改" 折叠>
    参数 盘符 <类型 = 字符 注释 = "当前监视的盘符">
    参数 文件名称 <类型 = 文本型 注释 = "触发更改的文件或目录名称">
    参数 当前路径 <类型 = 文本型 注释 = "本次更改的所在路径,以路径符结尾.">
    参数 更改原因 <类型 = 整数 注释 = "文件或目录被更改的原因,请与\"USN更改原因\"的常量进行位与判断.">
    参数 时间戳 <类型 = 文件时间结构 注释 = "本次更改的文件时间戳(非Unix时间戳)">
    参数 属性值 <类型 = 整数 注释 = "文件或目录的属性值,为\"文件属性\"常量的组合值;" 注释 = "可用\"位与\"计算来判断是否具有某个属性;"
            注释 = "如: 为子目录 = 位与 (属性值, 文件属性.子目录) != 0">

    方法 文件被重命名 <公开 定义事件 类型 = 整数 注释 = "监视到某个文件或目录被重命名" 折叠>
    参数 盘符 <类型 = 字符 注释 = "当前监视的盘符">
    参数 旧名称 <类型 = 文本型 注释 = "重命名前的旧名称">
    参数 新名称 <类型 = 文本型 注释 = "重命名后的新名称">
    参数 当前路径 <类型 = 文本型 注释 = "本次更改的所在路径,以路径符结尾.">
    参数 时间戳 <类型 = 文件时间结构 注释 = "本次更改的文件时间戳(非Unix时间戳)">
    参数 属性值 <类型 = 整数 注释 = "文件或目录的属性值,为\"文件属性\"常量的组合值;" 注释 = "可用\"位与\"计算来判断是否具有某个属性;"
            注释 = "如: 为子目录 = 位与 (属性值, 文件属性.子目录) != 0">

    方法 被删到回收站 <公开 定义事件 类型 = 整数 注释 = "监视到某个文件或目录被删除到回收站" 折叠>
    参数 盘符 <类型 = 字符 注释 = "当前监视的盘符">
    参数 文件名称 <类型 = 文本型 注释 = "被删除到回收站之前的原名称">
    参数 原路径 <类型 = 文本型 注释 = "被删除文件的原始路径,以路径符结尾.">
    参数 回收站路径 <类型 = 文本型 注释 = "删除到回收站后的完整路径(文件被重命名为回收站内部使用的名称)">
    参数 时间戳 <类型 = 文件时间结构 注释 = "本次更改的文件时间戳(非Unix时间戳)">
    参数 属性值 <类型 = 整数 注释 = "文件或目录的属性值,为\"文件属性\"常量的组合值;" 注释 = "可用\"位与\"计算来判断是否具有某个属性;"
            注释 = "如: 为子目录 = 位与 (属性值, 文件属性.子目录) != 0">

    方法 文件被移动 <公开 定义事件 类型 = 整数 注释 = "监视到某个文件或目录被移动到同盘的另一个位置" 注释 = "注: 移动到其他盘是触发\"文件被删除\"事件.">
    参数 盘符 <类型 = 字符 注释 = "当前监视的盘符">
    参数 旧名称 <类型 = 文本型 注释 = "文件移动前的旧名称">
    参数 新名称 <类型 = 文本型 注释 = "文件移动后的新名称">
    参数 原路径 <类型 = 文本型 注释 = "文件移动前的原路径,以路径符结尾.">
    参数 新路径 <类型 = 文本型 注释 = "文件移动后的新路径,以路径符结尾.">
    参数 时间戳 <类型 = 文件时间结构 注释 = "本次更改的文件时间戳(非Unix时间戳)">
    参数 属性值 <类型 = 整数 注释 = "文件或目录的属性值,为\"文件属性\"常量的组合值;" 注释 = "可用\"位与\"计算来判断是否具有某个属性;"
            注释 = "如: 为子目录 = 位与 (属性值, 文件属性.子目录) != 0">

    方法 文件属性改变 <公开 定义事件 类型 = 整数 注释 = "监视到某个文件或目录的属性被改变" 折叠>
    参数 盘符 <类型 = 字符 注释 = "当前监视的盘符">
    参数 文件名称 <类型 = 文本型 注释 = "触发更改的文件或目录名称">
    参数 当前路径 <类型 = 文本型 注释 = "本次更改的所在路径,以路径符结尾.">
    参数 更改原因 <类型 = 整数 注释 = "文件或目录被更改的原因,请与\"USN更改原因\"的常量进行位与判断.">
    参数 时间戳 <类型 = 文件时间结构 注释 = "本次更改的文件时间戳(非Unix时间戳)">
    参数 属性值 <类型 = 整数 注释 = "文件或目录的属性值,为\"文件属性\"常量的组合值;" 注释 = "可用\"位与\"计算来判断是否具有某个属性;"
            注释 = "如: 为子目录 = 位与 (属性值, 文件属性.子目录) != 0">

    方法 其他状态改变 <公开 定义事件 类型 = 整数 注释 = "监视到其他不常用的文件或目录的状态或属性被改变" 折叠>
    参数 盘符 <类型 = 字符 注释 = "当前监视的盘符">
    参数 文件名称 <类型 = 文本型 注释 = "触发更改的文件或目录名称">
    参数 当前路径 <类型 = 文本型 注释 = "本次更改的所在路径,以路径符结尾.">
    参数 更改原因 <类型 = 整数 注释 = "文件或目录被更改的原因,请与\"USN更改原因\"的常量进行位与判断.">
    参数 时间戳 <类型 = 文件时间结构 注释 = "本次更改的文件时间戳(非Unix时间戳)">
    参数 属性值 <类型 = 整数 注释 = "文件或目录的属性值,为\"文件属性\"常量的组合值;" 注释 = "可用\"位与\"计算来判断是否具有某个属性;"
            注释 = "如: 为子目录 = 位与 (属性值, 文件属性.子目录) != 0">

    # ---
    # @begin
    # <> <include>
    # std::map<wchar_t, std::unique_ptr<PivUsnMonitor>> m_map;
    # inline void @an<_OnCleanupExtra>() { m_map.clear(); }
    # <> </include>
    # @end
    # ---
}

类 USN更改原因 <公开 注释 = "USN日志的文件更改理由常量" 折叠 @文档 = "category = \"文件操作.辅助类\"">
{
    常量 覆盖数据 <公开 类型 = 整数 值 = @USN_REASON_DATA_OVERWRITE 注释 = "文件或目录中的流数据被覆盖">
    常量 扩展数据 <公开 类型 = 整数 值 = @USN_REASON_DATA_EXTEND 注释 = "文件的流被附加了数据">
    常量 截断数据 <公开 类型 = 整数 值 = @USN_REASON_DATA_TRUNCATION 注释 = "文件的流数据被截断">
    常量 覆盖命名数据 <公开 类型 = 整数 值 = @USN_REASON_NAMED_DATA_OVERWRITE 注释 = "文件或目录中的命名流数据被覆盖">
    常量 扩展命名数据 <公开 类型 = 整数 值 = @USN_REASON_NAMED_DATA_EXTEND 注释 = "文件或目录中的命名流被附加了数据">
    常量 截断命名数据 <公开 类型 = 整数 值 = @USN_REASON_NAMED_DATA_TRUNCATION 注释 = "文件或目录中的命名流被截断">
    常量 创建文件 <公开 类型 = 整数 值 = @USN_REASON_FILE_CREATE 注释 = "创建文件或目录">
    常量 删除文件 <公开 类型 = 整数 值 = @USN_REASON_FILE_DELETE 注释 = "文件或目录被删除">
    常量 扩展属性改变 <公开 类型 = 整数 值 = @USN_REASON_EA_CHANGE 注释 = "用户对文件或目录的扩展属性进行了更改."
            注释 = "基于Windows的应用程序无法访问这些NTFS文件系统属性.">
    常量 安全权限改变 <公开 类型 = 整数 值 = @USN_REASON_SECURITY_CHANGE 注释 = "文件或目录的访问权限被改变">
    常量 重命名前旧名称 <公开 类型 = 整数 值 = @USN_REASON_RENAME_OLD_NAME 注释 = "文件或目录被重命名,当前USN_RECORD结构体中的文件名为旧名称.">
    常量 重命名后新名称 <公开 类型 = 整数 值 = @USN_REASON_RENAME_NEW_NAME 注释 = "文件或目录被重命名,当前USN_RECORD结构体中的文件名为新名称.">
    常量 索引属性改变 <公开 类型 = 整数 值 = @USN_REASON_INDEXABLE_CHANGE
            注释 = "用户更改了FILE_ATTRIBUTE_NOT_CONTENT_INDEXED属性.">
    常量 基本信息被改变 <公开 类型 = 整数 值 = @USN_REASON_BASIC_INFO_CHANGE
            注释 = "用户更改了一个或多个文件或目录的属性(例如:只读、隐藏、系统、存档或稀疏属性),或者更改了一个或多个时间戳.">
    常量 硬链接改变 <公开 类型 = 整数 值 = @USN_REASON_HARD_LINK_CHANGE 注释 = "此文件被添加或移除了一个NTFS硬链接">
    常量 压缩状态改变 <公开 类型 = 整数 值 = @USN_REASON_COMPRESSION_CHANGE 注释 = "文件或目录的压缩状态改变">
    常量 加密状态改变 <公开 类型 = 整数 值 = @USN_REASON_ENCRYPTION_CHANGE 注释 = "文件或目录被加密或解密">
    常量 标识符改变 <公开 类型 = 整数 值 = @USN_REASON_OBJECT_ID_CHANGE 注释 = "文件或目录的对象标识符被改变">
    常量 重解析点改变 <公开 类型 = 整数 值 = @USN_REASON_REPARSE_POINT_CHANGE 注释 = "文件或目录的NTFS重解析点属性被添加、更改或删除.">
    常量 命名流改变 <公开 类型 = 整数 值 = @USN_REASON_STREAM_CHANGE 注释 = "文件或目录被被添加、重命名或移除了一个命名流.">
    常量 事务改变 <公开 类型 = 整数 值 = @USN_REASON_TRANSACTED_CHANGE 注释 = "通过TxF事务修改给定的流">
    常量 完整性改变 <公开 类型 = 整数 值 = 0x00800000
            注释 = "用户更改了给定流的FILE_ATTRIBUTE_INTEGRITY_STREAM属性的状态 USN_REASON_INTEGRITY_CHANGE">
    常量 "" <公开 类型 = 整数 值 = 0x01000000 注释 = "USN_REASON_DESIRED_STORAGE_CLASS_CHANGE">
    常量 关闭文件 <公开 类型 = 整数 值 = @USN_REASON_CLOSE 注释 = "关闭文件或目录(大部分更改以关闭文件结束)">
}

# 文件操作 ---

类 文件读写类EX <公开 注释 = "用作支持读写所指定名称的文件" 折叠 @文档 = "category = \"文件操作\"" @视窗.外部头文件 = "src\\piv_file.hpp"
        @视窗.后缀文本 = "public PivFile">
{
    方法 打开文件 <公开 类型 = 逻辑型 注释 = "打开所指定的文件,以对文件进行读写操作,返回是否打开成功." 注释 = "先前被打开的文件将被自动关闭." 折叠 @嵌入式方法 = "">
    参数 欲打开的文件名称 <类型 = 文本型>
    参数 访问权限 <类型 = 文件访问权限 注释 = "提供\"映射文件访问权限\"常量,设置文件的访问权限" @默认值 = 文件访问权限.读写>
    参数 共享模式 <类型 = 文件共享模式 注释 = "指定限制其它进程操作此文件的方式" @默认值 = 文件共享模式.禁止写>
    参数 创建方式 <类型 = 文件创建方式 注释 = "提供\"映射文件创建方式\"常量,设置是打开一个已经存在的文件还是创建一个新文件." @默认值 = 文件创建方式.打开或创建>
    {
        @ @sn<this>.Open(@<欲打开的文件名称>.GetText(), (DWORD)@<访问权限>, (DWORD)@<共享模式>, (DWORD)@<创建方式>)
    }

    方法 关闭文件 <公开 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.Close()
    }

    方法 是否已打开 <公开 类型 = 逻辑型 注释 = "返回是否已经打开了文件" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.IsOpen()
    }

    方法 交换 <公开 注释 = "将本对象的内容跟另一个对象交换,即交换当前打开的文件." 折叠 @嵌入式方法 = "">
    参数 所欲交换的对象 <类型 = 文件读写类EX>
    {
        @ @sn<this>.Swap(@<所欲交换的对象>)
    }

    方法 取文件句柄 <公开 类型 = 变整数 注释 = "如果当前已经打开了文件,返回其句柄值,否则返回-1." 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.GetFileHandle()
    }

    方法 取文件长度 <公开 类型 = 长整数 注释 = "返回当前被打开文件的长度,单位为字节." 注释 = "如果当前尚未打开文件或失败,将返回-1." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetSize()
    }

    方法 置文件长度 <公开 类型 = 逻辑型 注释 = "设置当前被打开文件的长度,返回是否成功." 注释 = "注: 设置成功后会移动到文件末尾." 折叠 @嵌入式方法 = "">
    参数 欲设置的长度 <类型 = 长整数 注释 = "新长度大于现有长度的区域将以0字节填充;" 注释 = "新长度小于现有长度则截断文件.">
    {
        @ @sn<this>.SetFileSize(@<欲设置的长度>)
    }

    方法 刷新文件 <公开 类型 = 逻辑型 注释 = "刷新当前被打开文件的缓冲区并将所有缓冲数据写入文件." 注释 = "注: 文件的写出操作,会先将数据写入磁盘的缓冲区,缓冲区满后才实际写入到磁盘文件."
            注释 = "执行本方法可以立即将修改保存到磁盘,以降低在程序崩溃或电源故障时丢失数据的风险." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.Flush()
    }

    方法 锁住文件 <公开 类型 = 逻辑型 注释 = "在有若干个进程访问同一个文件的环境中,使用本方法可以拒绝其它进程" 注释 = "对被打开文件中的某个区域进行读写访问." 折叠 @嵌入式方法 = "">
    参数 欲加锁数据的偏移位置 <类型 = 长整数 注释 = "指定欲加锁区域在文件中的偏移位置">
    参数 欲加锁数据的尺寸 <类型 = 长整数 注释 = "指定欲加锁区域的尺寸,单位字节.">
    参数 加锁重试时间 <类型 = 整数 注释 = "本参数指定加锁失败后反复进行重试的毫秒数.为0表示一旦失败立即返回;" 注释 = "为-1则反复进行重试直到加锁成功为止(将阻塞当前线程)."
            @默认值 = 0>
    {
        @ @sn<this>.Lock(@<欲加锁数据的偏移位置>, @<欲加锁数据的尺寸>, @<加锁重试时间>)
    }

    方法 解锁文件 <公开 类型 = 逻辑型 注释 = "解除由\"锁住文件\"命令对文件所进行的锁定,返回是否成功."
            注释 = "注意: 本方法调用时所提供的参数值必须与调用\"锁住文件\"方法时所提供的参数值完全一致." 折叠 @嵌入式方法 = "">
    参数 欲解锁数据的偏移位置 <类型 = 长整数 注释 = "指定欲解锁区域在文件中的偏移位置">
    参数 欲解锁数据的尺寸 <类型 = 长整数 注释 = "指定欲解锁区域的尺寸,单位字节.">
    {
        @ @sn<this>.Unlock(@<欲解锁数据的偏移位置>, @<欲解锁数据的尺寸>)
    }

    方法 取读写位置 <公开 类型 = 长整数 注释 = "返回当前被打开文件的当前读/写位置,位置值从0开始." 注释 = "如果当前尚未打开文件或失败,将返回-1." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetCurrentPos()
    }

    方法 移动读写位置 <公开 类型 = 逻辑型 注释 = "设置下一次读或写操作的位置,返回是否成功." 注释 = "注: 读写位置可以大于物理文件尺寸,使用\"置文件尾\"可以截断或扩展文件大小." 折叠
            @嵌入式方法 = "">
    参数 基准移动位置 <类型 = 文件基准位置 注释 = "指定从文件中开始移动的基准位置" @默认值 = 文件基准位置.文件首>
    参数 移动距离 <类型 = 长整数 注释 = "指定相对于起始移动位置的移动尺寸,单位字节.">
    {
        @ @sn<this>.SetCurrentPos(@<移动距离>, (DWORD)@<基准移动位置>)
    }

    方法 移到文件首 <公开 类型 = 逻辑型 注释 = "设置下一次读或写操作的位置到文件首部,返回是否成功." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.SetCurrentPos(0, FILE_BEGIN)
    }

    方法 移到文件尾 <公开 类型 = 逻辑型 注释 = "设置下一次读或写操作的位置到文件尾部,返回是否成功." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.SetCurrentPos(0, FILE_END)
    }

    方法 置文件尾 <公开 类型 = 逻辑型 注释 = "将文件的当前读写位置设置为文件末尾(即物理文件大小),可用于截断或扩展文件大小." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.SetEof()
    }

    方法 是否在文件尾 <公开 类型 = 逻辑型 注释 = "返回当前读写位置是否已经处于文件数据的尾部" 折叠 @嵌入式方法 = "">
    参数 是否为判断文本已读完 <类型 = 逻辑型 注释 = "如果本参数值为真,且下一即将读入的字符值为\'\\0\'或26(文本结束标志),"
            注释 = "或者当前读写位置已处于文件数据的尾部,方法将返回真" @默认值 = 假>
    参数 是否为Unicode文本 <类型 = 逻辑型 注释 = "指定文本文件的编码类型是否为UTF-16;" 注释 = "如果是UTF-8或多字节编码,请设置为假." @默认值 = 真>
    {
        @ @sn<this>.IsEof(@<是否为判断文本已读完>, @<是否为Unicode文本>)
    }

    # 读写操作 --

    方法 读 <公开 注释 = "从文件的当前读写位置读入指定的基本类型数据并返回." 注释 = "如果读入失败,将自动将当前文件读写位置移到文件尾部." 折叠 @嵌入式方法 = "">
    参数 欲获取的数据类型 <注释 = "提供所欲读入的基本数据类型" @需求类型 = 数据类型 @匹配类型 = 通用非文本基本型 @返回值类型 = 0>
    参数 缺省值 <注释 = "如果读入失败,则返回此处的值" @匹配类型 = 等于前参数值类型>
    {
        @ @sn<this>.Get<@<欲获取的数据类型>>(@<缺省值>)
    }

    方法 读字符 <公开 类型 = 整数 注释 = "获取文件当前读写位置的字符值(char),如果读到文本尾部则返回-1." 注释 = "注意: 请确保当前的数据是UTF-8或本地多字节编码文本."
            注释 = "如果读入失败,将自动将当前文件读写位置移到文件尾部." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetChar()
    }

    方法 读宽字符 <公开 类型 = 整数 注释 = "获取文件当前读写位置的宽字符值(wchar_t),如果读到文本尾部则返回-1." 注释 = "注意: 请确保当前的数据是UTF-16LE编码文本."
            注释 = "如果读入失败,会将当前的读写位置移到尾部." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetWchar()
    }

    方法 读入数据 <公开 类型 = 整数 注释 = "从文件的当前读写位置读入基本类型数值,返回实际读入的字节数." 注释 = "如果读入失败,将自动将当前文件读写位置移到文件尾部."
            返回值注释 = "返回实际读入的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所读入数据的变量 <注释 = "提供所欲返回的基本类型值变量(不能提供立即数)" @需求类型 = 可写入变量 @匹配类型 = 通用非文本基本型>
    {
        @ @sn<this>.Read<@pdt<所读入数据的变量>>(@<所读入数据的变量>)
    }

    方法 写出数据 <公开 类型 = 整数 注释 = "将所指定数据写出到文件中当前读写位置,返回实际写出的字节数." 返回值注释 = "返回实际写出的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲写出的数据 <注释 = "提供所欲写入的基本数值." 注释 = "如欲明确指定其数据类型,可以使用强制类型转换操作符." @匹配类型 = 通用非文本基本型>
    {
        @ @sn<this>.Write<@pdt<所欲写出的数据>>(@<所欲写出的数据>)
    }

    方法 读入文本 <公开 类型 = 长整数 注释 = "从文件的当前读写位置读取一段文本数据,返回实际读入的字节长度."
            注释 = "如果该数据中存在字符值0或26(文本结束标志),将仅返回该字符之前的数据(后续读写将跳过该字符)." 注释 = "如果读入失败,将自动将当前文件读写位置移到文件尾部."
            返回值注释 = "返回实际读入的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 存放读入文本的变量 <类型 = 文本型 注释 = "读入的文本数据将存放在此参数中">
    参数 欲读入的最多字符数 <类型 = 长整数 注释 = "指定欲读入文本数据的最多字符数目." 注释 = "如果为-1,则读入当前读写位置后的所有文本." @默认值 = -1>
    参数 文本编码 <类型 = 文本编码类型 注释 = "指定文本的编码类型" @默认值 = 文本编码类型.UTF16>
    {
        @ @sn<this>.ReadTextWithEncode(@<存放读入文本的变量>, @<欲读入的最多字符数>, @<文本编码>)
    }

    方法 读入一行 <公开 类型 = 长整数 注释 = "从文件的当前读写位置读取一行文本数据,行末的换行符将被抛弃." 注释 = "如果读入失败,将自动将当前文件读写位置移到文件尾部."
            注释 = "注意: 未自动跳过空行,如果返回值<=2且文本为空,则可能是读到空行了." 返回值注释 = "返回实际读入的字节数(包括被抛弃的换行符),失败返回0." 折叠 @嵌入式方法 = "">
    参数 存放读入文本的变量 <类型 = 文本型 注释 = "读入的文本数据将存放在此参数中">
    参数 文本编码 <类型 = 文本编码类型 注释 = "指定文本的编码类型" @默认值 = 文本编码类型.UTF16>
    {
        @ @sn<this>.ReadLineWithEncode(@<存放读入文本的变量>, @<文本编码>)
    }

    方法 写出文本 <公开 类型 = 长整数 注释 = "写出一段指定编码的文本数据到文件中当前读写位置处,返回实际写出的字节数." 返回值注释 = "返回实际写出的字节数,失败返回0." 折叠
            @嵌入式方法 = "">
    参数 所欲写出的文本 <类型 = 文本型 注释 = "所欲写出的文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定是否在所写出文本后添加写出一个\'\\0\'字符" 注释 = "注意: 请勿在纯文本文件中写出结束零字符!" @默认值 = 假>
    参数 文本编码 <类型 = 文本编码类型 注释 = "指定文本的编码类型" @默认值 = 文本编码类型.UTF16>
    {
        @ @sn<this>.WriteText(@<所欲写出的文本>.GetText(), @<是否包括结束零字符>, @<文本编码>)
    }

    方法 写文本行 <公开 类型 = 长整数 注释 = "写出一段指定编码的文本数据并附加\"\\r\\n\"换行符到文件中当前读写位置处," 注释 = "返回实际写出的字节数."
            返回值注释 = "返回实际写出的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲写出的文本 <类型 = 文本型 注释 = "所欲写出的文本数据">
    参数 文本编码 <类型 = 文本编码类型 注释 = "指定文本的编码类型" @默认值 = 文本编码类型.UTF16>
    {
        @ @sn<this>.WriteLine(@<所欲写出的文本>.GetText(), @<文本编码>)
    }

    方法 读入字节集 <公开 类型 = 长整数 注释 = "从文件中当前读写位置读取一段字节集数据,返回实际读入的字节数." 注释 = "如果读入失败,将自动将当前文件读写位置移到文件尾部."
            返回值注释 = "返回实际读入的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 存放数据的字节集 <类型 = 字节集类>
    参数 欲读入数据的尺寸 <类型 = 变整数 注释 = "所欲从文件中读入的数据长度,单位为字节." 注释 = "如果读取中途到达了文件尾部,将只读取部分长度.">
    {
        @ @sn<this>.ReadVolMem(@<存放数据的字节集>, @<欲读入数据的尺寸>)
    }

    方法 写出字节集 <公开 类型 = 长整数 注释 = "写出一个字节集数据到文件中当前读写位置处,返回实际写出的字节长度." 注释 = "如果写入后的尺寸超过了文件尾部,将自动扩展文件的尺寸."
            返回值注释 = "返回实际写出的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 欲写出的字节集数据 <类型 = 字节集类>
    {
        @ @sn<this>.WriteVolMem(@<欲写出的字节集数据>)
    }

    方法 读指针数据 <公开 类型 = 长整数 注释 = "从文件中当前读写位置读出一段数据到指定的指针中,并返回实际读入的字节数." 注释 = "如果读入失败,将自动将当前文件读写位置移到文件尾部."
            返回值注释 = "返回实际读入的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 数据指针 <类型 = 变整数 注释 = "提供一个内存地址,用于存放从文件中读入的数据." 注释 = "该指针必须分配了足够的内存空间(大于等于\"数据尺寸\"的长度).">
    参数 数据尺寸 <类型 = 长整数 注释 = "所欲从文件中读入的数据长度,单位为字节." 注释 = "如果到达了文件尾部,将只读取部分长度.">
    {
        @ @sn<this>.ReadData((void *)@<数据指针>, @<数据尺寸>)
    }

    方法 写指针数据 <公开 类型 = 长整数 注释 = "写出一段指针数据到文件中当前读写位置处,返回实际写出的字节数." 返回值注释 = "返回实际写出的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 数据指针 <类型 = 变整数 注释 = "欲写出数据的指针">
    参数 数据尺寸 <类型 = 长整数 注释 = "欲写出的数据尺寸,如果写出后的尺寸超过了文件尾部,将自动扩展文件的尺寸.">
    {
        @ @sn<this>.WriteData((const void*)@<数据指针>, @<数据尺寸>)
    }

    方法 读入数组数据 <公开 类型 = 长整数 注释 = "从文件中当前读写位置读取并返回指定类型的数组数据,返回实际读入的字节数." 注释 = "如果读入失败,将自动将当前文件读写位置移到文件尾部."
            返回值注释 = "返回实际读入的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所读入数据的存储变量 <注释 = "所读入数据将存放到此数组变量中;" 注释 = "所读入数据的尺寸将由此变量的存储空间尺寸决定." @需求类型 = 可写入变量 @匹配类型 = 通用非文本基本型数组>
    {
        @ @sn<this>.ReadData(_VOL_GET_ARY_VAR_ADR_AND_SIZE(@<所读入数据的存储变量>))
    }

    方法 写出数组数据 <公开 类型 = 长整数 注释 = "将所指定数组数据写出到文件中当前读写位置,返回实际写出的字节数." 返回值注释 = "返回实际写出的字节数,失败返回0." 折叠
            @嵌入式方法 = "">
    参数 所欲写出的数组 <注释 = "所写出数据的尺寸将由此数组变量的存储空间尺寸决定" @匹配类型 = 通用非文本基本型数组>
    {
        @ @sn<this>.WriteData(_VOL_GET_ARY_VAR_ADR_AND_SIZE(@<所欲写出的数组>))
    }

    方法 删除数据 <公开 类型 = 逻辑型 注释 = "删除已打开文件中的部分数据,返回是否成功." 注释 = "注意: 本方法效率不高,成功删除部分数据后会改变文件的实际大小." 折叠
            @嵌入式方法 = "">
    参数 起始位置 <类型 = 长整数 注释 = "提供所欲删除数据的起始位置偏移,从0开始." 注释 = "-1表示从当前的读写位置开始删除." @默认值 = -1>
    参数 删除长度 <类型 = 长整数 注释 = "所欲删除的长度,必须大于0.">
    {
        @ @sn<this>.RemoveData(@<起始位置>, @<删除长度>)
    }
}

类 内存映射文件类EX <公开 注释 = "本类提供内存映射文件创建/读/写操作的支持,相比核心库的增强了功能." 注释 = "注意: 本类的\"尾部\"等同于文件的EOF,即最后一个可读写地址的后面."
        注释 = "由于映射内存不能像磁盘文件那样扩展长度,所以到达尾部后将无法继续写入数据." 折叠 @文档 = "category = \"文件操作\""
        @视窗.外部头文件 = "src\\piv_file.hpp" @视窗.后缀文本 = "public PivFileMapping">
{

    # 创建/关闭 ---

    方法 创建映射文件 <公开 类型 = 逻辑型 注释 = "从提供的文件路径创建内存映射文件" 返回值注释 = "执行成功返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 文件名称 <类型 = 文本型 注释 = "欲创建内存映射文件的文件全路径名称." 注释 = "如果不创建真实的磁盘文件,只映射在内存中,则可以留空." @默认值 = 空对象>
    参数 访问权限 <类型 = 文件访问权限 注释 = "提供\"映射文件访问权限\"常量,设置文件的访问权限" @默认值 = 文件访问权限.读写>
    参数 共享模式 <类型 = 文件共享模式 注释 = "指定限制其它进程操作此文件的方式" @默认值 = 文件共享模式.禁止写>
    参数 创建方式 <类型 = 映射文件创建方式 注释 = "提供\"映射文件创建方式\"常量,设置是打开一个已经存在的文件还是创建一个新文件." @默认值 = 映射文件创建方式.打开或创建>
    参数 映射尺寸 <类型 = 长整数 注释 = "欲创建内存映射文件的文件大小." 注释 = "如果是打开一个已经存在的文件,可以指定该值为0,表示创建的内存映射文件大小和文件本身大小是一致的."
            @默认值 = 0>
    参数 内存页保护 <类型 = 整数 注释 = "提供内存映射文件的页面保护属性,指定文件映射到内存后是否允许读和写." @默认值 = 内存页面保护属性.读写>
    参数 内存映射名称 <类型 = 文本型 注释 = "创建内存映射文件的名称,其它进程可以通过该名称打开内存映射文件.该参数可以为空,表示创建一个没有名称的内存映射文件." @默认值 = 空对象>
    {
        @ @sn<this>.Create(@<文件名称>.GetText(), (DWORD)@<访问权限>, (DWORD)@<共享模式>, (DWORD)@<创建方式>, @<映射尺寸>, (DWORD)@<内存页保护>, @<内存映射名称>.GetTextMaybeNull())
    }

    方法 创建自文件句柄 <公开 类型 = 逻辑型 注释 = "从文件句柄创建内存映射文件" 返回值注释 = "执行成功返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 文件句柄 <类型 = 变整数 注释 = "提供一个外部打开的文件句柄,本对象不会关闭该句柄." "">
    参数 映射尺寸 <类型 = 长整数 注释 = "欲创建内存映射文件的文件大小." 注释 = "如果是打开一个已经存在的文件,可以指定该值为0,表示创建的内存映射文件大小和文件本身大小是一致的."
            @默认值 = 0>
    参数 内存页保护 <类型 = 整数 注释 = "提供内存映射文件的页面保护属性,指定文件映射到内存后是否允许读和写." @默认值 = 内存页面保护属性.读写>
    参数 内存映射名称 <类型 = 文本型 注释 = "创建内存映射文件的名称,其它进程可以通过该名称打开内存映射文件.该参数可以为空,表示创建一个没有名称的内存映射文件." @默认值 = 空对象>
    {
        @ @sn<this>.Create((HANDLE)@<文件句柄>, @<映射尺寸>, (DWORD)@<内存页保护>, @<内存映射名称>.GetTextMaybeNull())
    }

    方法 创建映射内存 <公开 类型 = 逻辑型 注释 = "创建一个不关联实际磁盘文件,只映射到内存的内存映射文件." 返回值注释 = "执行成功返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 映射尺寸 <类型 = 长整数 注释 = "欲创建内存映射文件的文件大小,默认4096字节(4K).如果是打开一个已经存在的文件,可以指定该值为0,表示创建的内存映射文件大小和文件本身大小是一致的."
            @默认值 = 4096>
    参数 内存页保护 <类型 = 整数 注释 = "提供内存映射文件的页面保护属性,指定文件映射到内存后是否允许读和写." @默认值 = 内存页面保护属性.读写>
    参数 内存映射名称 <类型 = 文本型 注释 = "创建内存映射文件的名称,其它进程可以通过该名称打开内存映射文件.该参数可以为空,表示创建一个没有名称的内存映射文件." @默认值 = 空对象>
    {
        @ @sn<this>.Create(@<映射尺寸>, (DWORD)@<内存页保护>, @<内存映射名称>.GetTextMaybeNull())
    }

    方法 打开映射文件 <公开 类型 = 逻辑型 注释 = "打开一个其他进程创建的内存映射文件" 返回值注释 = "执行成功返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 内存映射名称 <类型 = 文本型 注释 = "其他进程创建的内存映射文件名称."
            注释 = "名称可以具有\"Global\\\"或\"Local\\\"前缀,以显式打开全局命名空间或会话命名空间中的对象.">
    参数 访问权限 <类型 = 整数 注释 = "提供内存映射文件的访问权限,能使用哪些权限由创建内存映射文件时的参数决定." @默认值 = 映射文件访问权限.读写>
    {
        @ @sn<this>.Open(@<内存映射名称>.GetText(), (DWORD)@<访问权限>)
    }

    方法 关闭映射文件 <公开 注释 = "关闭并释放已经创建或打开的内存映射文件,关闭后先前所取得的已映射内存指针不可再使用." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.Close()
    }

    方法 是否已打开 <公开 类型 = 逻辑型 注释 = "返回是否已经创建或打开了内存映射文件" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.IsOpen()
    }

    方法 交换 <公开 注释 = "将本对象的内容跟另一个对象交换,即交换当前创建的内存映射文件." 折叠 @嵌入式方法 = "">
    参数 所欲交换的对象 <类型 = 内存映射文件类EX>
    {
        @ @sn<this>.Swap(@<所欲交换的对象>)
    }

    方法 取文件句柄 <公开 类型 = 变整数 注释 = "返回所映射磁盘文件的文件句柄,句柄无效时返回-1." 注释 = "注意: \"创建映射内存\"不会产生有效的文件句柄." 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.GetFileHandle()
    }

    # 映射内存 ---

    方法 映射到内存 <公开 类型 = 逻辑型 注释 = "将一个创建完毕或已打开的内存映射文件的全部或一部分映射到进程的内存空间中." 注释 = "注意: 必须成功执行本方法后,才能进行后续的读写操作!"
            返回值注释 = "执行成功返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 起始位置 <类型 = 长整数 注释 = "映射到内存的文件起始位置.注意该值一定要是系统分配内存的分配粒度." 注释 = "如Windows的分配粒度是64k(即0x10000),"
            注释 = "所以该值一定要是64k的倍数,否则会执行出错,起始位置的值从0开始." @默认值 = 0>
    参数 映射尺寸 <类型 = 长整数 注释 = "映射到内存的字节数量,该值等于0代表从起始位置开始文件其余部分全部映射到内存." @默认值 = 0>
    参数 访问权限 <类型 = 整数 注释 = "提供内存映射文件的访问权限,能使用哪些权限由创建内存映射文件时的参数决定." @默认值 = 映射文件访问权限.读写>
    {
        @ @sn<this>.MapToMemory(@<起始位置>, @<映射尺寸>, (DWORD)@<访问权限>)
    }

    方法 解除映射 <公开 类型 = 逻辑型 注释 = "\"映射到内存\"方法的反操作,将已经映射到内存的文件解除映射."
            注释 = "注意: 解除映射后先前所获取的数据指针不能再使用,也不能再进行读写操作." 返回值注释 = "执行成功返回真,否则返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.UnMapToMemory()
    }

    方法 刷新映射文件 <公开 类型 = 逻辑型 注释 = "将已映射内存中的数据真实写入到对应磁盘文件(调用\"创建映射文件\"方法时指定)中."
            注释 = "注: 映射视图的内存页修改,可能会先在内存中缓存,待共享计数归零才延后写入到磁盘中." 注释 = "执行本方法可以立即将修改保存到磁盘,以降低在程序崩溃或电源故障时丢失数据的风险."
            返回值注释 = "执行成功返回真,否则返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.FlushView(0)
    }

    # 读写操作 ---

    方法 读 <公开 注释 = "从已映射内存中读入指定的基本类型数据并返回." 注释 = "如果读入失败,会将当前的读写位置移到尾部." 折叠 @嵌入式方法 = "">
    参数 欲获取的数据类型 <注释 = "提供所欲读入的基本数据类型" @需求类型 = 数据类型 @匹配类型 = 通用非文本基本型 @返回值类型 = 0>
    参数 缺省值 <注释 = "如果读入失败,则返回此处的值" @匹配类型 = 等于前参数值类型>
    {
        @ @sn<this>.Get<@<欲获取的数据类型>>(@<缺省值>)
    }

    方法 读字符 <公开 类型 = 整数 注释 = "返回当前读写位置的字符值(char),如果读到文本尾部则返回-1." 注释 = "注意: 请确保当前的数据是UTF-8或本地多字节编码文本."
            注释 = "如果读入失败,会将当前的读写位置移到尾部." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetChar()
    }

    方法 读宽字符 <公开 类型 = 整数 注释 = "返回当前读写位置的宽字符值(wchar_t),如果读到文本尾部则返回-1." 注释 = "注意: 请确保当前的数据是UTF-16LE编码文本."
            注释 = "如果读入失败,会将当前的读写位置移到尾部." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetWchar()
    }

    方法 读入字节集 <公开 类型 = 变整数 注释 = "从已映射内存中读入数据,返回实际读入的字节数." 返回值注释 = "返回实际读入的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 存放数据的字节集 <类型 = 字节集类 注释 = "提供字节集变量,存放从内存映射文件中读出的数据,作为方法的返回值.">
    参数 读取长度 <类型 = 变整数 注释 = "从已映射内存中读入数据的长度,单位为字节." 注释 = "如果已映射内存的剩余空间不足,将只读取部分长度.">
    {
        @ @sn<this>.ReadVolMem(@<存放数据的字节集>, @<读取长度>)
    }

    方法 写出字节集 <公开 类型 = 变整数 注释 = "向已映射内存中写出数据,返回实际写出的字节数." 返回值注释 = "返回实际写出的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 欲写出的字节集 <类型 = 字节集类 注释 = "欲写出的数据,如果数据长度超过已映射内存的边界,将只能写出部分数据.">
    {
        @ @sn<this>.WriteVolMem(@<欲写出的字节集>)
    }

    方法 读入数据 <公开 类型 = 整数 注释 = "从已映射内存中读出基本类型数值,返回实际读入的字节数." 注释 = "如果读入失败,会将当前的读写位置移到尾部."
            返回值注释 = "返回实际读入的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所读入数据的变量 <注释 = "提供所欲返回的基本类型值变量(不能提供立即数)" @需求类型 = 可写入变量 @匹配类型 = 通用非文本基本型>
    {
        @ @sn<this>.Read<@pdt<所读入数据的变量>>(@<所读入数据的变量>)
    }

    方法 写出数据 <公开 类型 = 整数 注释 = "向已映射内存中写出基本类型数值,返回实际写出的字节数." 注释 = "写出失败不会移动读写位置." 返回值注释 = "返回实际写出的字节数,失败返回0."
            折叠 @嵌入式方法 = "">
    参数 所欲写出的数据 <注释 = "提供所欲写出的基本数值." 注释 = "如欲明确指定其数据类型,可以使用强制类型转换操作符." @匹配类型 = 通用非文本基本型>
    {
        @ @sn<this>.Write<@pdt<所欲写出的数据>>(@<所欲写出的数据>)
    }

    方法 读入文本 <公开 类型 = 长整数 注释 = "从当前读写位置读取一段文本数据,返回实际读入的字节长度."
            注释 = "如果该数据中存在字符值0或26(文本结束标志),将仅返回该字符之前的数据(后续读写将跳过该字符)." 注释 = "如果读入失败,将返回并0且自动将当前读写位置移到尾部(EOF)."
            返回值注释 = "返回实际读入的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 存放读入文本的变量 <类型 = 文本型 注释 = "读入的文本数据将存放在此参数中">
    参数 欲读入的最多字符数 <类型 = 长整数 注释 = "指定欲读入文本数据的最多字符数目." 注释 = "如果为-1,则读入当前读写位置后的所有文本." @默认值 = -1>
    参数 文本编码 <类型 = 文本编码类型 注释 = "指定文本的编码类型" @默认值 = 文本编码类型.UTF16>
    {
        @ @sn<this>.ReadTextWithEncode(@<存放读入文本的变量>, @<欲读入的最多字符数>, @<文本编码>)
    }

    方法 读入一行 <公开 类型 = 长整数 注释 = "从当前读写位置读取一行文本数据,行末的换行符将被抛弃." 注释 = "如果读入失败,将返回并0且自动将当前读写位置移到尾部(EOF)."
            返回值注释 = "返回实际读入的字节数(包括被抛弃的换行符),失败返回0." 折叠 @嵌入式方法 = "">
    参数 存放读入文本的变量 <类型 = 文本型 注释 = "读入的文本数据将存放在此参数中">
    参数 文本编码 <类型 = 文本编码类型 注释 = "指定文本的编码类型" @默认值 = 文本编码类型.UTF16>
    {
        @ @sn<this>.ReadLineWithEncode(@<存放读入文本的变量>, @<文本编码>)
    }

    方法 写出文本 <公开 类型 = 长整数 注释 = "写出一段指定编码的文本数据到已映射内存的当前读写位置处,返回实际写出的字节数." 注释 = "如果已映射内存的剩余空间不足,将只写出部分文本."
            返回值注释 = "返回实际写出的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲写出的文本 <类型 = 文本型 注释 = "所欲写出的文本数据">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定是否在所写出文本后添加写出一个\'\\0\'字符" 注释 = "注意: 请勿在纯文本文件中写出结束零字符!" @默认值 = 假>
    参数 文本编码 <类型 = 文本编码类型 注释 = "指定文本的编码类型" @默认值 = 文本编码类型.UTF16>
    {
        @ (INT_P)@sn<this>.WriteText(@<所欲写出的文本>.GetText(), @<是否包括结束零字符>, @<文本编码>)
    }

    方法 写文本行 <公开 类型 = 长整数 注释 = "写出指定编码的文本数据并附加\"\\r\\n\"换行符到已映射内存的当前读写位置处,返回实际写出的字节数."
            注释 = "如果已映射内存的剩余空间不足,将只写出部分文本." 返回值注释 = "返回实际写出的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲写出的文本 <类型 = 文本型 注释 = "所欲写出的文本数据">
    参数 文本编码 <类型 = 文本编码类型 注释 = "指定文本的编码类型" @默认值 = 文本编码类型.UTF16>
    {
        @ @sn<this>.WriteLine(@<所欲写出的文本>.GetText(), @<文本编码>)
    }

    方法 读指针数据 <公开 类型 = 长整数 注释 = "从已映射内存中读入一段数据到指定的指针中,返回实际读入的字节数." 返回值注释 = "返回实际读入的字节数,失败返回0." 折叠
            @嵌入式方法 = "">
    参数 数据指针 <类型 = 变整数 注释 = "提供一个内存地址,用于存放从内存映射文件中读入的数据." 注释 = "该指针必须分配了足够的内存空间(大于等于\"数据尺寸\"的长度).">
    参数 数据尺寸 <类型 = 长整数 注释 = "从已映射内存中读入数据的长度,单位为字节." 注释 = "如果已映射内存的剩余空间不足,将只读取部分长度.">
    {
        @ @sn<this>.ReadData((void *)@<数据指针>, @<数据尺寸>)
    }

    方法 写指针数据 <公开 类型 = 长整数 注释 = "向已映射内存中写出一段数据,返回实际写出的字节数." 返回值注释 = "返回实际写出的字节数,失败返回0." 折叠 @嵌入式方法 = "">
    参数 数据指针 <类型 = 变整数 注释 = "欲写出数据的指针">
    参数 数据尺寸 <类型 = 长整数 注释 = "欲写出的数据的尺寸." 注释 = "如果长度超过已映射内存的剩余空间,将只写出部分数据.">
    {
        @ @sn<this>.WriteData((void*)@<数据指针>, @<数据尺寸>)
    }

    方法 删除数据 <公开 类型 = 逻辑型 注释 = "删除已映射内存中的部分数据,删除成功后,会按删除长度将已映射内存的尾部数据清零." 返回值注释 = "返回是否成功" 折叠 @嵌入式方法 = "">
    参数 起始位置 <类型 = 长整数 注释 = "从已映射内存中删除的数据的起始位置偏移,从0开始." 注释 = "-1表示从当前的读写位置开始删除." @默认值 = -1>
    参数 删除长度 <类型 = 长整数 注释 = "所欲删除的长度,必须大于0." 注释 = "如果删除的范围超过了已映射内存的边界,将删除失败.">
    {
        @ @sn<this>.RemoveData(@<起始位置>, @<删除长度>)
    }

    # 读写位置/尺寸 ---

    方法 取读写位置 <公开 类型 = 长整数 注释 = "返回已映射内存的当前读/写位置,有效范围为0到映射内存长度," 注释 = "执行读写操作将移动读写位置."
            注释 = "如果当前尚未映射到内存或失败,将返回-1." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetCurrentPos()
    }

    方法 移动读写位置 <公开 类型 = 逻辑型 注释 = "设置下一次读或写操作的位置,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 基准移动位置 <类型 = 文件基准位置 注释 = "指定从文件中开始移动的基准位置" @默认值 = 文件基准位置.文件首>
    参数 移动距离 <类型 = 长整数 注释 = "指定相对于起始移动位置的移动尺寸,单位字节.">
    {
        @ @sn<this>.SetCurrentPos(@<移动距离>, (DWORD)@<基准移动位置>)
    }

    方法 移到首部 <公开 类型 = 逻辑型 注释 = "设置下一次读或写操作的位置到映射内存首部,返回是否成功." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.SetCurrentPos(0, FILE_BEGIN)
    }

    方法 移到尾部 <公开 类型 = 逻辑型 注释 = "设置下一次读或写操作的位置到映射内存尾部,返回是否成功." 注释 = "注: 这里的尾部等同于EOF,即读写位置等于映射长度." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.SetCurrentPos(0, FILE_END)
    }

    方法 是否在尾部 <公开 类型 = 逻辑型 注释 = "返回当前读写位置是否已经处于映射内存尾部(EOF)." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.IsEof()
    }

    方法 取数据指针 <公开 类型 = 变整数 注释 = "取得已映射内存的地址,用于后续对其进行内存修改和复制操作." 注释 = "注: 本方法不会移动读写位置."
            返回值注释 = "执行成功返回数据地址指针,否则返回0." 折叠 @嵌入式方法 = "">
    参数 读写位置 <类型 = 长整数 注释 = "从已映射内存中读出的数据的起始位置偏移,从0开始." 注释 = "默认为首地址,-1表示当前的读写位置." @默认值 = 0>
    {
        @ (INT_P)@sn<this>.GetPtr(@<读写位置>)
    }

    方法 取文件长度 <公开 类型 = 长整数 注释 = "返回当前被打开磁盘文件的长度,单位为字节." 注释 = "如果当前尚未打开磁盘文件或失败,将返回-1." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetSize()
    }

    方法 取映射长度 <公开 类型 = 长整数 注释 = "返回内存映射文件被映射到内存空间的尺寸,单位为字节." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetViewSize()
    }

    方法 取内存页长度 <公开 类型 = 长整数 注释 = "返回内存映射文件被映射到内存空间的页面尺寸,单位为字节." 注释 = "该值必定是4096的倍数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetMapSize()
    }
}

# 文件操作(辅助类) ---

类 文件访问权限 <公开 注释 = "提供文件的访问权限" 折叠 @文档 = "category = \"文件操作.辅助类\"" @常量类 = 整数>
{
    常量 读入 <公开 值 = @GENERIC_READ 注释 = "允许从指定文件读入数据">
    常量 写出 <公开 值 = @GENERIC_WRITE 注释 = "允许写出数据到文件">
    常量 读写 <公开 值 = @"@(GENERIC_READ | GENERIC_WRITE)" 注释 = "允许从文件中读入数据或者写出数据到文件">
    常量 执行 <公开 值 = @GENERIC_EXECUTE 注释 = "允许执行文件">
    常量 全部 <公开 值 = @GENERIC_ALL 注释 = "允许文件的所有访问权限(读写和执行)">
}

类 文件共享模式 <公开 注释 = "提供文件在进程之间的各种共享模式" 折叠 @文档 = "category = \"文件操作.辅助类\"" @常量类 = 整数>
{
    常量 无限制 <公开 值 = @"@(FILE_SHARE_WRITE | FILE_SHARE_READ)" 注释 = "允许其它程序任意读写此文件">
    常量 禁止读 <公开 值 = @FILE_SHARE_WRITE 注释 = "禁止其它进程读此文件">
    常量 禁止写 <公开 值 = @FILE_SHARE_READ 注释 = "禁止其它进程写此文件">
    常量 禁止读写 <公开 值 = 0 注释 = "禁止其它进程读写此文件">
}

类 文件创建方式 <公开 注释 = "提供文件创建方式常量" 折叠 @文档 = "category = \"文件操作.辅助类\"" @常量类 = 整数>
{
    常量 创建新文件 <公开 值 = @CREATE_NEW 注释 = "创建新文件,如果文件已经存在则创建失败.">
    常量 创建并覆盖 <公开 值 = @CREATE_ALWAYS 注释 = "创建新的文件并覆盖现有文件">
    常量 打开已存在 <公开 值 = @OPEN_EXISTING 注释 = "打开已存在的现有文件">
    常量 打开或创建 <公开 值 = @OPEN_ALWAYS 注释 = "打开文件如果文件不存在就创建一个新的文件">
    常量 覆盖已存在 <公开 值 = @TRUNCATE_EXISTING 注释 = "打开已存在的现有文件并将它覆盖,文件不存在即创建失败.">
}

类 映射文件访问权限 <公开 注释 = "提供内存映射文件的访问权限" 折叠 @文档 = "category = \"文件操作.辅助类\"">
{
    常量 全部 <公开 类型 = 整数 值 = @FILE_MAP_ALL_ACCESS 注释 = "允许读/写映射文件的视图(不包括执行),在\"映射到内存\"方法中等效于\"读写\"."
            注释 = "需要在创建映射文件对象时使用\"读写\"或\"可执行_读写\"的内存页保护.">
    常量 读入 <公开 类型 = 整数 值 = @FILE_MAP_READ 注释 = "允许读取映射文件的视图,写操作将导致访问冲突."
            注释 = "需要在创建映射文件对象时使用包含\"读\"属性的内存页保护.">
    常量 写出 <公开 类型 = 整数 值 = @FILE_MAP_WRITE 注释 = "允许写出数据到映射文件的视图,使用\"映射到内存\"时等效于\"读写\"."
            注释 = "需要在创建映射文件对象时使用\"读写\"或\"可执行_读写\"的内存页保护.">
    常量 读写 <公开 类型 = 整数 值 = @"@(FILE_MAP_READ | FILE_MAP_WRITE)" 注释 = "允许读写映射文件的视图">
    常量 执行 <公开 类型 = 整数 值 = @FILE_MAP_EXECUTE 注释 = "允许执行映射文件的视图." 注释 = "需要在创建映射文件对象时使用包含\"执行\"属性的内存页保护.">
}

#
