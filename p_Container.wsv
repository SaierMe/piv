<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv" 注释 = "封装了std::vector动态数组容器."
        注释 = "注意: std::vector非线程安全,多线程同时读写记得加锁.">

# std::vector 模板基础类 ===

类 动态数组容器基础 <公开 基础类 = 扩展对象类 注释 = "封装了动态数组容器(std::vector)的基本操作." 注释 = "注意: 请勿直接继承本类来设置模板实现类." 折叠
        @文档 = "category = \"数组操作.模板类\"" @视窗.外部头文件 = "<vector>\r\n<algorithm>\r\n<type_traits>" @模板基础类 = 真>
{

    # 分配器

    方法 预分配尺寸 <公开 属性读 类型 = 变整数 注释 = "返回本数组已分配了空间的成员数量,此容量值会大于或等于数组成员数." 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT_P>(@sn<this>.data().capacity())
    }

    方法 预分配尺寸 <公开 属性写 注释 = "提前为本数组分配指定数目成员的空间,用作支持在后面快速进行成员添加." 折叠>
    参数 所欲设置的容量 <类型 = 变整数 注释 = "单位为容器的成员数量">
    {
        @ data().reserve(static_cast<size_t>(@<所欲设置的容量>));
    }

    方法 取最大可用数 <公开 类型 = 变整数 注释 = "返回容器能够容纳的最大成员数,此值通常反映容器的理论限制,一般限制为小于可用的内存." 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT_P>(@sn<this>.data().max_size())
    }

    方法 释放空闲容量 <公开 注释 = "释放数组中未使用的内存空间,可能会重新分配内存." 注释 = "执行后会将数组容量(\"预分配尺寸\")缩减到跟\"取成员数\"一样." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().shrink_to_fit()
    }

    # 方法

    方法 枚举循环 <公开 注释 = "  启动一个循环来枚举本数组中的每一个成员,在循环中可以调用" 注释 = "\"取枚举值\"方法来获取当前所枚举到的成员值,调用\"取枚举索引\""
            注释 = "方法来获取当前所枚举到成员的索引位置." 折叠 隐藏值属性 = "0" @嵌入式方法 = "name = vector_for\r\nhas_loop_body = true">
    {
        @ for (size_t __piv_vector_for = 0; __piv_vector_for < @sn<this>.data().size(); __piv_vector_for++)
    }

    方法 逆向枚举循环 <公开 注释 = "  启动一个循环来逆向枚举本数组中的每一个成员,在循环中可以调用" 注释 = "\"取枚举索引\"/\"取枚举值\"方法来获取当前所枚举索引和对应值."
            注释 = "注意: 不能嵌套使用本循环,否则编译将报错." 折叠 隐藏值属性 = "0" @嵌入式方法 = "name = vector_rfor\r\nhas_loop_body = true">
    {
        @ for (size_t __piv_vector_for = @sn<this>.data().size() - 1; __piv_vector_for >= 0; __piv_vector_for--)
    }

    方法 取枚举索引 <公开 类型 = 整数 注释 = "  只能在本类的\"枚举循环\"/\"逆向枚举循环\"语句的子语句体中使用,用作取回当前枚举到成员的索引位置,如果有"
            注释 = "多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回所处最近层\"枚举循环\"枚举到成员的索" 注释 = "引位置." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "parent = \"vector_for, vector_rfor\"">
    {
        @ static_cast<INT>(__piv_vector_for)
    }

    方法 取容器指针 <公开 类型 = 变整数 注释 = "获取数组类自身的指针(std::vector<模板类型1> *)." 折叠 @嵌入式方法 = "">
    {
        @ reinterpret_cast<INT_P>(@sn<this>.pdata())
    }

    方法 取数组指针 <公开 类型 = 变整数 注释 = "返回当前数组内容的第一个元素的指针" 折叠 @嵌入式方法 = "">
    {
        @ reinterpret_cast<INT_P>(@sn<this>.data().data())
    }

    方法 索引是否有效 <公开 类型 = 逻辑型 注释 = "返回所指定的索引值是否大于等于0且小于本数组的成员数" 折叠 @禁止流程检查 = 真>
    参数 所欲检查的索引值 <类型 = 变整数>
    {
        @ return static_cast<size_t>(@<所欲检查的索引值>) >= 0 && static_cast<size_t>(@<所欲检查的索引值>) < data().size();
    }

    方法 取成员数 <公开 类型 = 整数 注释 = "返回数组中的当前已有成员数目" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(@sn<this>.data().size())
    }

    方法 取最大索引 <公开 类型 = 整数 注释 = "返回数组中尾成员的索引位置,如果当前数组为空,则返回-1." 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(@sn<this>.data().size()) - 1
    }

    方法 是否为空 <公开 类型 = 逻辑型 注释 = "返回本数组是否为空" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().empty()
    }

    方法 删除所有成员 <公开 注释 = "删除当前数组中的所有成员" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().clear()
    }

    方法 重置成员数 <公开 注释 = "重置当前数组的成员数量,如果新的成员数小于当前成员数,则多余的成员值会被删除." 折叠 @嵌入式方法 = "">
    参数 新成员数 <类型 = 整数>
    {
        @ @sn<this>.data().resize(@<新成员数>)
    }

    方法 取成员指针 <公开 类型 = 变整数 注释 = "返回所指定索引位置处的成员值指针" 折叠 @嵌入式方法 = "">
    参数 索引 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于动态数组容器成员数目.">
    {
        @ reinterpret_cast<INT_P>(&@sn<this>.data()[static_cast<size_t>(@<索引>)])
    }

    方法 添加数组 <公开 注释 = "将另一个同类型数组的内容添加到本数组尾部" 折叠>
    参数 所欲添加的数组 <类型 = 动态数组容器基础>
    {
        @ data().insert(data().end(), @<所欲添加的数组>.data().begin(), @<所欲添加的数组>.data().end());
    }

    方法 添加部分数组 <公开 注释 = "将另一个同类型数组内容中的一部分添加到本数组尾部" 折叠>
    参数 所欲添加的数组 <类型 = 动态数组容器基础>
    参数 起始索引位置 <类型 = 整数 注释 = "必须大于等于0且加上\"所欲添加的成员数\"后小于等于\"所欲添加的数组\"的成员数目">
    参数 所欲添加的成员数 <类型 = 整数 注释 = "必须大于等于0且加上\"起始索引位置\"后小于等于\"所欲添加的数组\"的成员数目">
    {
        @ data().insert(data().end(), @<所欲添加的数组>.data().begin() + @<起始索引位置>, @<所欲添加的数组>.data().begin() + @<起始索引位置> + @<所欲添加的成员数>);
    }

    方法 从数组复制 <公开 注释 = "将另一个同类型数组的内容复制到本数组中" 折叠>
    参数 欲复制的数组 <类型 = 动态数组容器基础>
    {
        @ data().resize(@<欲复制的数组>.data().size());
        @ std::move(@<欲复制的数组>.data().begin(), @<欲复制的数组>.data().end(), data().begin());
    }

    方法 加入新成员 <公开 注释 = "原位默认构造一个成员值,并将其加入到本数组的尾部." 注释 = "注意: \"模板类型1\"必须满足可移动插入和可原位构造." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().emplace_back()
    }

    方法 批量加入新成员 <公开 注释 = "原位默认构造一个或多个成员值,并将其加入到本数组的尾部." 注释 = "注意: \"模板类型1\"必须满足可移动插入和可原位构造." 折叠 @嵌入式方法 = "">
    参数 所欲加入的成员数目 <类型 = 变整数 注释 = "提供所欲加入的成员数目" @默认值 = 1>
    {
        @ for (INT_P i = 0; i < @<所欲加入的成员数目>; i++) {
        @     @sn<this>.data().emplace_back();
        @ }
    }

    方法 插入新成员 <公开 类型 = 模板类型1 注释 = "原位构造一个成员值并将其插入到本数组中的指定索引位置,返回所插入成员的参考."
            注释 = "注意: \"模板类型1\"必须满足可移动插入和可原位构造." 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于数组成员数目.">
    {
        @ return *data().emplace(data().begin() + @<插入索引位置>);
    }

    方法 删除尾成员 <公开 注释 = "删除数组尾部的单个成员,数组不能为空." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().pop_back()
    }

    方法 删除成员 <公开 注释 = "删除数组中所指定索引范围的单个或多个成员" 折叠>
    参数 删除索引位置 <类型 = 变整数 注释 = "提供所欲删除的索引位置,必须大于等于0且小于等于动态数组容器成员数目.">
    参数 所欲删除成员数目 <类型 = 变整数 注释 = "提供所欲删除成员的数目,必须大于等于0且加上\"删除索引位置\"参数值后小于等于数组成员数目." @默认值 = 1>
    {
        @ data().erase(data().begin() + @<删除索引位置>, data().begin() + @<删除索引位置> + @<所欲删除成员数目>);
    }

    方法 删除到尾部 <公开 注释 = "删除数组中所指定索引位置后(包括该位置)的所有成员" 折叠>
    参数 起始索引位置 <类型 = 变整数 注释 = "提供所欲删除起始成员的索引位置,必须大于等于0且小于等于数组成员数目.">
    {
        @ data().erase(data().begin() + @<起始索引位置>, data().end());
    }

    方法 查找删除成员 <公开 类型 = 逻辑型 注释 = "查找第一个等于所指定值的成员,如果找到则将其删除并返回真,否则返回假." 折叠>
    参数 所欲查找成员值 <类型 = 模板类型1 注释 = "提供所欲查找并删除的成员值">
    {
        变量 索引值 <类型 = 整数>
        索引值 = 本对象.查找首成员 (所欲查找成员值)
        如果 (索引值 == -1)
        {
            返回 (假)
        }
        本对象.删除成员 (索引值)
        返回 (真)
    }

    方法 交换成员 <公开 注释 = "将两个索引位置处的成员值相互交换" 折叠>
    参数 索引位置1 <类型 = 整数 注释 = "提供成员1的索引位置,必须大于等于0且小于数组成员数目.">
    参数 索引位置2 <类型 = 整数 注释 = "提供成员2的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ std::swap(data()[@<索引位置1>], data()[@<索引位置2>]);
    }

    方法 交换所有成员 <公开 注释 = "将当前数组的成员和另外一个数组的成员进行交换" 折叠 @嵌入式方法 = "">
    参数 欲交换的数组 <类型 = 动态数组容器基础>
    {
        @ std::swap(@sn<this>.data(), @<欲交换的数组>.data())
    }

    方法 交换数组 <公开 注释 = "交换两个动态数组容器的数据内容." 折叠 @嵌入式方法 = "">
    参数 欲交换的数组 <类型 = 动态数组容器基础>
    {
        @ @sn<this>.data().swap(@<欲交换的数组>.data())
    }

    方法 成员是否存在 <公开 类型 = 逻辑型 注释 = "返回数组中是否存在为所指定值的成员" 折叠>
    参数 所欲查找的成员值 <类型 = 模板类型1>
    {
        返回 (本对象.查找首成员 (所欲查找的成员值) != -1)
    }

    方法 替换成员值 <公开 注释 = "将所有等于指定值的成员替换为另一个值" 折叠>
    参数 所欲替换的成员值 <类型 = 模板类型1>
    参数 所替换到的成员值 <类型 = 模板类型1>
    {
        @ std::replace(data().begin(), data().end(), @<所欲替换的成员值>, @<所替换到的成员值>);
    }

    方法 取指定成员数量 <公开 类型 = 整数 注释 = "获取指定成员值在数组内的数量" 折叠 @禁止流程检查 = 真>
    参数 欲检查的成员值 <类型 = 模板类型1>
    {
        @ return std::count(data().begin(), data().end(), @<欲检查的成员值>);
    }

    方法 是否相等 <公开 类型 = 逻辑型 注释 = "返回所指定动态数组容器的内容是否与本动态数组容器相同" 折叠 @嵌入式方法 = "">
    参数 所欲比较的容器 <类型 = 动态数组容器基础>
    {
        @ @sn<this>.data() == @<所欲比较的容器>.data()
    }

    方法 自定义排序 <公开 注释 = "对数组中的所有成员进行自定义排序." 注释 = "注意: 适用于<模板类型1>不支持小于和大于比较的情况,可以通过自定义的排序函数进行排序." 折叠
            @嵌入式方法 = "">
    参数 排序函数 <注释 = "请提供自定义的排序函数,函数类型如下:" 注释 = "  逻辑型 (<模板类型1> 参数A, <模板类型1> 参数B)"
            注释 = "请将<模板类型1>替换为实际成员类型,该函数返回真,即表示参数A的成员排在前面." @匹配方法 = "排序函数模板">
    {
        @ std::vector<@dt<模板类型1>>& @sn<rand_name0> = @sn<this>.data();
        @ std::sort(@sn<rand_name0>.begin(), @sn<rand_name0>.end(), &@<排序函数>)
    }

    方法 排序函数模板 <公开 静态 类型 = 逻辑型 注释 = "\"自定义排序\"的排序函数模板" 返回值注释 = "返回真表示参数A排在前面" 折叠>
    参数 参数A <类型 = 模板类型1>
    参数 参数B <类型 = 模板类型1>
    {
        返回 (真)
    }

    方法 反转顺序 <公开 注释 = "反转数组顺序,例如: 1,2,3 变 3,2,1" 折叠>
    {
        @ std::reverse(data().begin(), data().end());
    }

    方法 打乱顺序 <公开 注释 = "随机地打乱数组中所有成员的顺序." 注释 = "注: 随机算法为std::mt19937,成员的每个排列都拥有相同的出现概率." 折叠
            @视窗.外部头文件 = "<random>">
    {
        @ std::shuffle(data().begin(), data().end(), std::mt19937{std::random_device{}()});
    }

    方法 取随机成员 <公开 类型 = 模板类型1 注释 = "随机返回数组中的任意一个成员." 注释 = "注意: 数组应当至少存在一个成员!" 折叠 @视窗.返回参考 = 真 @禁止流程检查 = 真
            @强制依赖 = "PIV随机数">
    {
        @ return data()[PivRandom::instance().GenInt<size_t>(0, data().size() - 1)];
    }
}

类 动态数组容器基础2 <公开 基础类 = 动态数组容器基础 注释 = "封装了动态数组容器(std::vector)的基本操作." 注释 = "注意: 请勿直接继承本类来设置模板实现类." 折叠
        @文档 = "category = \"数组操作.模板类\"" @模板基础类 = 真>
{

    # 方法

    方法 取枚举值 <公开 类型 = 模板类型1 注释 = "  只能在本类的\"枚举循环\"/\"逆向枚举循环\"语句的子语句体中使用,用作取回当前枚举到的成员值,如果有多层"
            注释 = "本类或本类继承类的\"枚举循环\"嵌套,本方法将返回所处最近层\"枚举循环\"的枚举成员值." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "parent = \"vector_for, vector_rfor\"">
    {
        @ @sn<this>.data()[__piv_vector_for]
    }

    方法 取成员 <公开 类型 = 模板类型1 注释 = "返回所指定索引位置处的成员值" 折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于动态数组容器成员数目.">
    {
        @ @sn<this>.data()[static_cast<size_t>(@<索引位置>)]
    }

    方法 重置数组 <公开 注释 = "重置数组中的成员数为所指定的数目,数组原有的数据将被覆盖." 折叠 @嵌入式方法 = "">
    参数 欲重置的成员数目 <类型 = 变整数 注释 = "重置后的数组成员数">
    参数 初始值 <类型 = 模板类型1 注释 = "用于提供每个成员的初始值">
    {
        @ @sn<this>.data().assign(static_cast<INT_P>(@<欲重置的成员数目>), @<初始值>)
    }

    方法 置成员值 <公开 注释 = "设置数组中所指定索引位置处的成员值" 折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于动态数组容器成员数目.">
    参数 所欲设置的值 <类型 = 模板类型1 注释 = "提供所欲设置的成员值,先前的值将被覆盖.">
    {
        @ @sn<this>.data()[static_cast<size_t>(@<索引位置>)] = @<所欲设置的值>
    }

    方法 初始化 <公开 注释 = "从一系列所提供成员值初始化当前对象" 折叠 @嵌入式方法 = "">
    参数 欲添加成员 <类型 = 模板类型1 @可扩展 = "">
    {
        @ @sn<this>.data() = {@<欲添加成员>}
    }

    方法 加入成员 <公开 注释 = "将一个或多个所指定类型的成员值加入到本数组的尾部" 折叠 @嵌入式方法 = "">
    参数 所欲添加成员值 <类型 = 模板类型1 @可扩展 = "">
    {
        @ piv::push_back(@sn<this>.data(), @<所欲添加成员值>)
    }

    方法 加入并返回成员 <公开 类型 = 模板类型1 注释 = "将一个所指定类型的成员值加入到本数组的尾部,并返回所加入的成员." 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 所欲添加成员值 <类型 = 模板类型1 注释 = "提供所欲加入的成员值">
    {
        @ data().push_back(@<所欲添加成员值>);
        @ return data().back();
    }

    方法 加入并返回新成员 <公开 静态 类型 = 模板类型1 注释 = "原位默认构造一个成员值并将其加入到本数组的尾部,返回所加入成员的参考."
            注释 = "注意: \"模板类型1\"必须满足可移动插入和可原位构造." 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    {
        @ data().emplace_back();
        @ return data().back();
    }

    方法 插入成员 <公开 静态 注释 = "将所指定的成员值插入到所指定的索引位置" 折叠>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于动态数组容器成员数目.">
    参数 所欲插入的成员值 <类型 = 模板类型1>
    {
        @ data().insert(data().begin() + static_cast<size_t>(@<插入索引位置>), @<所欲插入的成员值>);
    }

    方法 插入相同成员 <公开 注释 = "将所指定的成员值插入到所指定的索引位置" 折叠>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于数组成员数目.">
    参数 插入数量 <类型 = 整数>
    参数 所欲插入的成员值 <类型 = 模板类型1>
    {
        @ data().insert(data().begin() + @<插入索引位置>, @<插入数量>, @<所欲插入的成员值>);
    }

    方法 弹出成员 <公开 类型 = 模板类型1 注释 = "返回并删除数组尾部的单个成员." 注释 = "注意: 执行本方法前必须确保数组不为空" 折叠 @禁止流程检查 = 真>
    {
        @ @dt<模板类型1> last_element = data().back();
        @ data().pop_back();
        @ return last_element;
    }

    方法 取首成员 <公开 类型 = 模板类型1 注释 = "取第一个成员." 注释 = "注意: 执行本方法前必须确保容器不为空" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().front()
    }

    方法 取尾成员 <公开 类型 = 模板类型1 注释 = "返回数组尾部的成员值." 注释 = "注意: 执行本方法前必须确保容器不为空" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().back()
    }

    方法 查找首成员 <公开 类型 = 整数 注释 = "正向查找等于所指定值的第一个成员,找到返回其索引位置,未找到返回-1." 折叠 @禁止流程检查 = 真>
    参数 所欲查找的成员值 <类型 = 模板类型1>
    {
        @ auto it = std::find(data().begin(), data().end(), @<所欲查找的成员值>);
        @ return (it != data().end () ? std::distance(data().begin(), it) : -1);
    }

    方法 查找尾成员 <公开 类型 = 整数 注释 = "逆向查找等于所指定值的最后一个成员,找到返回其索引位置,未找到返回-1." 折叠 @禁止流程检查 = 真>
    参数 所欲查找的成员值 <类型 = 模板类型1>
    {
        @ auto it = std::find(data().rbegin(), data().rend(), @<所欲查找的成员值>);
        @ return (it != data().rend() ? data().size() - std::distance(data().rbegin(), it) - 1 : -1);
    }
}

类 基本动态数组模板 <公开 基础类 = 动态数组容器基础2 注释 = "本模板可封装基板数值类型的动态数组容器(std::vector)." 注释 = "模板类型1: 成员的数据类型"
        注释 = "注意: 有些过时,建议改用\"PIV数组模板\"." 折叠 @文档 = "category = \"数组操作.模板类\"" @模板基础类 = 真>
{
    方法 升序排序 <公开 注释 = "将动态数组容器的所有成员按升序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end());
    }

    方法 降序排序 <公开 注释 = "将动态数组容器的所有成员按降序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end(), [](@dt<模板类型1>& lhs, @dt<模板类型1>& rhs) { return lhs > rhs; });
    }

    方法 下一个排序 <公开 类型 = 逻辑型 注释 = "生成数组的下一个排列组合(从小到大)." 注释 = "即每一次执行都生成一个不同的排列顺序,直到穷尽所有组合方式."
            注释 = "注意: 若要用于生成数组成员的所有排列组合,请先按从小到大排序." 返回值注释 = "成功返回真,返回假表示已经穷尽了所有排列组合."
            返回值注释 = "返回假时,会将数组修改为从小到大的排列." 折叠 @禁止流程检查 = 真>
    {
        @ return std::next_permutation(data().begin(), data().end());
    }

    方法 上一个排序 <公开 类型 = 逻辑型 注释 = "生成数组的上一个排列组合(从大到小)." 注释 = "即每一次执行都生成一个不同的排列顺序,直到穷尽所有组合方式."
            注释 = "注意: 若要用于生成数组成员的所有排列组合,请先按从大到小排序." 返回值注释 = "成功返回真,返回假表示已经穷尽了所有排列组合."
            返回值注释 = "返回假时,会将数组修改为从大到小的排列." 折叠 @禁止流程检查 = 真>
    {
        @ return std::prev_permutation(data().begin(), data().end());
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<动态数组容器> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }

    # --
    # @begin
    # <> <include>
    # std::vector<@dt<模板类型1>> m_vecData;
    # inline void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom) { m_vecData = objCopyFrom.m_vecData; }
    # inline @sn<current_class>& operator=(@sn<current_class>&& rhs) { m_vecData = std::move(rhs.m_vecData); return *this; }
    # inline BOOL @an<_IsSelfEqualExtra> (const @sn<current_class>& objCompare) const { return (m_vecData == objCompare.m_vecData); }
    # inline std::vector<@dt<模板类型1>> &data() { return m_vecData; }
    # inline std::vector<@dt<模板类型1>> *pdata() { return &m_vecData; }
    # <> </include>
    # @end
}

类 对象动态数组模板 <公开 基础类 = 动态数组容器基础2 注释 = "本模板可封装火山对象类型的动态数组容器(std::vector)." 注释 = "模板类型1: 成员的对象类型"
        注释 = "注意: 有些过时,建议改用\"PIV数组模板\"." 折叠 @文档 = "category = \"数组操作.模板类\"" @模板基础类 = 真>
{

    # 方法

    方法 取指定类型枚举值 <公开 注释 = "  只能在本类的\"枚举循环\"/\"逆向枚举循环\"语句的子语句体中使用,用作取回当前枚举到的指定数据类型的成员值,"
            注释 = "如果有多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回所处最近层\"枚举循环\"的枚举成员值." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "parent = \"vector_for, vector_rfor\"" @视窗.返回参考 = 真>
    参数 所欲获取对象的类型 <类型 = 模板类型1 注释 = "提供所欲获取对象的数据类型,必须提供正确的类型,否则会报错." @需求类型 = 数据类型 @返回值类型 = 0>
    {
        @ (@<所欲获取对象的类型>&)@sn<this>.data()[__piv_vector_for]
    }

    方法 取指定类型成员 <公开 注释 = "返回所指定索引位置处的成员值." 注释 = "高效率,不检查边界,不抛出异常,索引无效直接崩溃." 折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于动态数组容器成员数目.">
    参数 所欲获取对象的类型 <类型 = 模板类型1 注释 = "提供所欲获取对象的数据类型,必须提供正确的类型,否则会报错." @需求类型 = 数据类型 @返回值类型 = 0>
    {
        @ (@<所欲获取对象的类型>&)@sn<this>.data()[static_cast<size_t>(@<索引位置>)]
    }

    方法 升序排序 <公开 注释 = "将动态数组容器的所有成员按升序排序." 注释 = "注意: 必须在接收事件\"小于比较\"中实现比较函数,才能正确排序." 折叠>
    {
        @ std::sort(data().begin(), data().end(), [this](@dt<模板类型1>& lhs, @dt<模板类型1>& rhs) { return (bool)this->@<小于比较>(lhs, rhs); });
    }

    方法 降序排序 <公开 注释 = "将动态数组容器的所有成员按降序排序." 注释 = "注意: 必须在接收事件\"大于比较\"中实现比较函数,才能正确排序." 折叠>
    {
        @ std::sort(data().begin(), data().end(), [this](@dt<模板类型1>& lhs, @dt<模板类型1>& rhs) { return (bool)this->@<大于比较>(lhs, rhs); });
    }

    方法 小于比较 <公开 定义事件 类型 = 整数 注释 = "请在本事件中实现小于比较函数,即\"对象1\"<\"对象2\"时返回1."
            注释 = "注: 如未在本事件实现正确的比较,将不能正确进行\"升序排序\"." 返回值注释 = "返回1表示\"对象1\"<\"对象2\",其他情况请返回0." 折叠>
    参数 对象1 <类型 = 模板类型1>
    参数 对象2 <类型 = 模板类型1>

    方法 大于比较 <公开 定义事件 类型 = 整数 注释 = "请在本事件中实现小于比较函数,即\"对象1\">\"对象2\"时返回1."
            注释 = "注: 如未在本事件实现正确的比较,将不能正确进行\"降序排序\"." 返回值注释 = "返回1表示\"对象1\">\"对象2\",其他情况请返回0." 折叠>
    参数 对象1 <类型 = 模板类型1>
    参数 对象2 <类型 = 模板类型1>

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<动态数组容器> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }

    # @begin
    # <> <include>
    # std::vector<std::remove_pointer<@dt<模板类型1> *>::type> m_vecData;
    # inline void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom) { m_vecData = objCopyFrom.m_vecData; }
    # inline @sn<current_class>& operator=(@sn<current_class>&& rhs) { m_vecData = std::move(rhs.m_vecData); return *this; }
    # inline BOOL @an<_IsSelfEqualExtra> (const @sn<current_class>& objCompare) const { return (m_vecData == objCompare.m_vecData); }
    # inline std::vector<std::remove_pointer<@dt<模板类型1> *>::type> &data() { return m_vecData; }
    # inline std::vector<std::remove_pointer<@dt<模板类型1> *>::type> *pdata() { return &m_vecData; }
    # <> </include>
    # @end
}

#
