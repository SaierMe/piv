<火山程序 类型 = "通常" 版本 = 1 />

包 火山.VMProtect <注释 = "VMProtect 3.7.2" 注释 = "https://vmpsoft.com" 注释 = "封装: Xelloss">

类 VMProtect <公开 注释 = "封装了VMProtect SDK的函数" 折叠 @文档 = "category = \"VMProtect加密\"" @禁止创建对象 = 真
        @视窗.外部头文件 = "VMProtect\\include\\VMProtectSDK.h" @视窗.外部库.x64 = "VMProtect\\lib\\VMProtectSDK64.lib"
        @视窗.外部库.win32 = "VMProtect\\lib\\VMProtectSDK32.lib"
        @视窗.附属文件.x64 = "VMProtect\\lib\\VMProtectSDK64.dll"
        @视窗.附属文件.win32 = "VMProtect\\lib\\VMProtectSDK32.dll">
{

    # 加密/Protection

    方法 保护 <公开 静态 注释 = "  标记保护的范围(VMProtectBegin),流程线内的子语句体都将被保护," 注释 = "无需调用VMProtectEnd结束保护."
            注释 = "  具体的保护模式需要在VMProtect程序中设置." 折叠
            @嵌入式方法 = "has_body = true\r\nbody_header = \"@none\"\r\nbody_tail = \"VMProtectEnd ();\"">
    参数 标记名称 <类型 = 文本型 注释 = "只能使用字面文本或常量,不能为变量.">
    {
        @ VMProtectBegin (@sn<quot>@pvpt<标记名称>@sn<quot>);
    }

    方法 虚拟化保护 <公开 静态 注释 = "  标记虚拟化保护的范围(VMProtectBeginVirtualization),"
            注释 = "流程线内的子语句体都将被保护,无需调用VMProtectEnd结束保护." 折叠
            @嵌入式方法 = "has_body = true\r\nbody_header = \"@none\"\r\nbody_tail = \"VMProtectEnd ();\"">
    参数 标记名称 <类型 = 文本型 注释 = "只能使用字面文本或常量,不能为变量.">
    {
        @ VMProtectBeginVirtualization (@sn<quot>@pvpt<标记名称>@sn<quot>);
    }

    方法 虚拟化保护_锁定序列号 <公开 静态 注释 = "  标记虚拟化保护的范围并锁定到序列号(VMProtectBeginVirtualizationLockByKey),"
            注释 = "流程线内的子语句体都将被保护,无需调用VMProtectEnd结束保护." 折叠
            @嵌入式方法 = "has_body = true\r\nbody_header = \"@none\"\r\nbody_tail = \"VMProtectEnd ();\"">
    参数 标记名称 <类型 = 文本型 注释 = "只能使用字面文本或常量,不能为变量.">
    {
        @ VMProtectBeginVirtualizationLockByKey (@sn<quot>@pvpt<标记名称>@sn<quot>);
    }

    方法 变异保护 <公开 静态 注释 = "  标记变异保护的范围(VMProtectBeginMutation),流程线内的子语句体" 注释 = "都将被保护,无需调用VMProtectEnd结束保护."
            折叠 @嵌入式方法 = "has_body = true\r\nbody_header = \"@none\"\r\nbody_tail = \"VMProtectEnd ();\"">
    参数 标记名称 <类型 = 文本型 注释 = "只能使用字面文本或常量,不能为变量.">
    {
        @ VMProtectBeginMutation (@sn<quot>@pvpt<标记名称>@sn<quot>);
    }

    方法 超级保护 <公开 静态 注释 = "  标记超级保护的范围(VMProtectBeginUltra),流程线内的子语句体" 注释 = "都将被保护,无需调用VMProtectEnd结束保护." 折叠
            @嵌入式方法 = "has_body = true\r\nbody_header = \"@none\"\r\nbody_tail = \"VMProtectEnd ();\"">
    参数 标记名称 <类型 = 文本型 注释 = "只能使用字面文本或常量,不能为变量.">
    {
        @ VMProtectBeginUltra (@sn<quot>@pvpt<标记名称>@sn<quot>);
    }

    方法 超级保护_锁定序列号 <公开 静态 注释 = "  标记超级保护的范围并锁定到序列号(VMProtectBeginUltraLockByKey),"
            注释 = "流程线内的子语句体都将被保护,无需调用VMProtectEnd结束保护." 折叠
            @嵌入式方法 = "has_body = true\r\nbody_header = \"@none\"\r\nbody_tail = \"VMProtectEnd ();\"">
    参数 标记名称 <类型 = 文本型 注释 = "只能使用字面文本或常量,不能为变量.">
    {
        @ VMProtectBeginUltraLockByKey (@sn<quot>@pvpt<标记名称>@sn<quot>);
    }

    # ---

    方法 开始保护 <公开 静态 注释 = "  标记保护的开始位置(VMProtectBegin),具体的保护模式需要在VMProtect"
            注释 = "程序中设置,必须在受保护代码的尾部调用\"结束保护\"." 注释 = "  默认标记为\"类名::方法名, 行号\",如需自定义请使用\"保护\"." 折叠 @嵌入式方法 = "">
    {
        @ VMProtectBegin (@sn<current_source_class>"::"@sn<current_source_method>", "@sn<current_source_line>)
    }

    方法 开始虚拟化保护 <公开 静态 注释 = "  标记虚拟化保护的开始位置(VMProtectBeginVirtualization),必须在" 注释 = "受保护代码的尾部调用\"结束保护\"."
            注释 = "  默认标记为\"类名::方法名, 行号\",如需自定义请使用\"虚拟化保护\"." 折叠 @嵌入式方法 = "">
    参数 锁定到序列号 <类型 = 逻辑型 注释 = "  默认为假,为真时改为调用VMProtectBeginVirtualizationLockByKey,"
            注释 = "受保护的代码需要验证序列号才能使用." @默认值 = 假>
    {
        @ @<锁定到序列号> ? VMProtectBeginVirtualizationLockByKey (@sn<current_source_class>"::"@sn<current_source_method>", "@sn<current_source_line>) : VMProtectBeginVirtualization (@sn<current_source_class>"::"@sn<current_source_method>", "@sn<current_source_line>)
    }

    方法 开始变异保护 <公开 静态 注释 = "  标记变异保护的开始位置(VMProtectBeginMutation),必须在受保护代码" 注释 = "的尾部调用\"结束保护\"."
            注释 = "  默认标记为\"类名::方法名, 行号\",如需自定义请使用\"变异保护\"." 折叠 @嵌入式方法 = "">
    {
        @ VMProtectBeginMutation (@sn<current_source_class>"::"@sn<current_source_method>", "@sn<current_source_line>)
    }

    方法 开始超级保护 <公开 静态 注释 = "  标记超级保护的开始位置(VMProtectBeginUltra),必须在受保护代码的" 注释 = "尾部调用\"结束保护\"."
            注释 = "  默认标记为\"类名::方法名, 行号\",如需自定义请使用\"超级保护\"." 折叠 @嵌入式方法 = "">
    参数 锁定到序列号 <类型 = 逻辑型 注释 = "  默认为假,为真时改为调用VMProtectBeginUltraLockByKey," 注释 = "受保护的代码需要验证序列号才能使用."
            @默认值 = 假>
    {
        @ @<锁定到序列号> ? VMProtectBeginUltraLockByKey (@sn<current_source_class>"::"@sn<current_source_method>", "@sn<current_source_line>) : VMProtectBeginUltra (@sn<current_source_class>"::"@sn<current_source_method>", "@sn<current_source_line>)
    }

    方法 结束保护 <公开 静态 注释 = "  标记代码保护区的结尾位置(VMProtectEnd),必须放在受保护代码块的" 注释 = "最后一个命令(过程或函数调用)之后." 折叠 @嵌入式方法 = "">
    {
        @ VMProtectEnd ()
    }

    # 实用工具/Utils

    方法 是否被保护 <公开 静态 类型 = 逻辑型 注释 = "VMProtectIsProtected函数检测应用程序是否已经被VMProtect加壳."
            返回值注释 = "返回真表示文件已经被VMProtect加壳." 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)VMProtectIsProtected ()
    }

    方法 检测调试器 <公开 静态 类型 = 逻辑型 注释 = "   VMProtectIsDebuggerPresent函数检测应用程序是否在调试器下启动,"
            注释 = "其结果可用于应用程序内部的保护机制." 返回值注释 = "返回真表示应用程序正在被调试." 折叠 @嵌入式方法 = "">
    参数 检测核心模式 <类型 = 逻辑型 注释 = "   若\"检测核心模式\"为假,该函数将只检测用户模式的调试器(如OllyDBG、WinDBG等),"
            注释 = "为真时则用户模式和内核模式的调试器(SoftICE、Syser等)都将被检测." 注释 = "   保护驱动程序时,\"检测核心模式\"的值不起作用,因为驱动程序总是在内核模式下工作,"
            注释 = "所以检查结果总是真." @默认值 = 假>
    {
        @ (BOOL)VMProtectIsDebuggerPresent (@<检测核心模式>)
    }

    方法 检测虚拟机 <公开 静态 类型 = 逻辑型 注释 = "   VMProtectIsVirtualMachinePresent函数可检测应用程序是否在虚拟机"
            注释 = "软件(VMware、Virtual PC、VirtualBox、Sandboxie)中启动,其结果可用于" 注释 = "应用程序内部的保护机制."
            返回值注释 = "返回真表示应用程序运行在虚拟机中." 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)VMProtectIsVirtualMachinePresent ()
    }

    方法 检测校验码 <公开 静态 类型 = 逻辑型 注释 = "  VMProtectIsValidImageCRC函数检测进程内存中的可执行模块是否已被"
            注释 = "更改,仅检查不可更改的代码段和数据段." 注释 = "  其结果可用于应用程序内部的保护机制." 返回值注释 = "返回假表示程序已经被非法修改." 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)VMProtectIsValidImageCRC ()
    }

    方法 解密文本A <公开 静态 类型 = 字节集类 注释 = "  VMProtectDecryptStringA函数用于解密ANSI文本常量值,实际上这更像"
            注释 = "是加密文本,加密后无法反编译出明文,但运行时仍可以在内存中搜索到." 注释 = "  使用后,必须将其添加到VMProtect的\"需保护的进程\"中." 折叠 @禁止流程检查 = 真>
    参数 字符串 <类型 = 字节集类>
    {
        @ const char * ret = VMProtectDecryptStringA ((const char *)@<字符串>.GetPtr ());
        @ return @an<CVolMem> (ret, strlen (ret) + 1);
    }

    方法 解密文本W <公开 静态 类型 = 文本型 注释 = "  VMProtectDecryptStringW函数用于解密Unicode文本常量值,实际上这更像"
            注释 = "是加密文本,加密后无法反编译出明文,但运行时仍可以在内存中搜索到." 注释 = "  使用后,必须将其添加到VMProtect的\"需保护的进程\"中." 折叠 @嵌入式方法 = "">
    参数 字符串 <类型 = 文本型>
    {
        @ @an<CVolString> (VMProtectDecryptStringW ((const VMP_WCHAR *)@<字符串>.GetText ()))
    }

    方法 释放文本A <公开 静态 类型 = 逻辑型 注释 = "  VMProtectFreeString函数释放为\"解密文本A\"分配的动态内存,一般没必要"
            注释 = "释放内存,但如果要释放,必须使用此函数." 注释 = "  如果不释放之前解密的文本,并使用相同的参数重复调用\"解密文本A\",并不" 注释 = "会分配额外的内存." 折叠
            @嵌入式方法 = "">
    参数 字符串 <类型 = 字节集类>
    {
        @ (BOOL)VMProtectFreeString ((const void *)@<字符串>.GetPtr ())
    }

    方法 释放文本W <公开 静态 类型 = 逻辑型 注释 = "  VMProtectFreeString函数释放为\"解密文本W\"分配的动态内存,一般没必要"
            注释 = "释放内存,但如果要释放,必须使用此函数." 注释 = "  如果不释放之前解密的文本,并使用相同的参数重复调用\"解密文本W\",并不" 注释 = "会分配额外的内存." 折叠
            @嵌入式方法 = "">
    参数 字符串 <类型 = 文本型>
    {
        @ (BOOL)VMProtectFreeString ((const void *)@<字符串>.GetText ())
    }

    # 许可证/licensing

    方法 设置序列号 <公开 静态 类型 = 整数 注释 = "使用序列号进行激活(VMProtectSetSerialNumber)."
            返回值注释 = "激活成功返回0,失败返回其他数值,具体请参考\"VMProtect序列号状态\"." 折叠 @嵌入式方法 = "">
    参数 序列号 <类型 = 文本型>
    {
        @ (INT)VMProtectSetSerialNumber ((const char *)GetMbsText (@<序列号>.GetText (), CVolMem (), NULL))
    }

    方法 取序列号状态 <公开 静态 类型 = 整数 注释 = "获取当前序列号的状态(VMProtectGetSerialNumberState)."
            返回值注释 = "激活成功返回0,失败返回其他数值,具体请参考\"VMProtect序列号状态\"." 折叠 @嵌入式方法 = "">
    {
        @ (INT)VMProtectGetSerialNumberState ()
    }

    方法 取序列号数据 <公开 静态 类型 = 逻辑型 注释 = "获取序列号的详细信息数据(VMProtectGetSerialNumberData)." 返回值注释 = "返回是否获取成功" 折叠
            @嵌入式方法 = "">
    参数 序列号数据 <类型 = VMProtect序列号数据 注释 = "成功在此返回获取的序列号数据">
    {
        @ VMProtectGetSerialNumberData(&@<序列号数据>, sizeof(VMProtectSerialNumberData))
    }

    方法 取序列号数据2 <公开 静态 类型 = 逻辑型 注释 = "  跟\"取序列号数据\"不一样的是获取到的数据是火山类,而不是结构体,"
            注释 = "数据内容直接使用了文本型和字节集类,调用起来更方便." 返回值注释 = "返回是否获取成功." @嵌入式方法 = "">
    参数 序列号数据 <类型 = VMProtect序列号数据类 注释 = "成功在此返回获取的序列号数据">
    {
        @ VMProtectGetSerialNumberData(&@<序列号数据>, sizeof(VMProtectSerialNumberData))
    }

    方法 取当前机器码 <公开 静态 类型 = 文本型 注释 = "  获取当前设备的机器码(VMProtectGetCurrentHWID),必须加壳后才能" 注释 = "获取到正确的HWID." 折叠
            @禁止流程检查 = 真>
    {
        @ @an<CVolMem> memBuf;
        @ int nSize = VMProtectGetCurrentHWID (NULL, 0);
        @ memBuf.Alloc (nSize, TRUE);
        @ VMProtectGetCurrentHWID ((char*)memBuf.GetPtr (), nSize);
        @ return @an<CVolString> (GetWideText ((const CHAR*)memBuf.GetPtr (), CVolMem (), NULL));
    }

    # 在线激活/Activation
    # https://vmpsoft.com/products/web-license-manager/

    方法 在线激活许可证 <公开 静态 类型 = 整数 注释 = "  使用激活码在线激活许可证(VMProtectActivateLicense),"
            注释 = "需要在服务器上部署Web License Manager(另行购买)." 注释 = "  本功能实际上是通过激活码从服务器上获取真实的序列号,"
            注释 = "拿到序列号之后,你仍需要使用\"设置序列号\"来完成激活." 注释 = "  返回的序列号无法在当前的VMP编译版本中冻结,建议对用户" 注释 = "隐藏."
            返回值注释 = "成功返回0,失败返回其他数值,具体请参考\"VMProtect激活结果\"." 折叠 @禁止流程检查 = 真>
    参数 激活码 <类型 = 文本型 注释 = "你的激活码">
    参数 序列号 <类型 = 文本型 注释 = "成功在此返回序列号">
    {
        @ INT nSize = 800;
        @ char *serial = new char[nSize];
        @ INT nRes = VMProtectActivateLicense ((const char *)GetMbsText (@<激活码>.GetText (), CVolMem (), NULL), serial, nSize);
        @ if (nRes == 0)
        @ {
        @     @<序列号>.SetText (GetWideText ((const CHAR*)serial, CVolMem (), NULL));
        @ }
        @ delete [] serial;
        @ return nRes;
    }

    方法 在线解绑许可证 <公开 静态 类型 = 整数 注释 = "  使用序列号在线解绑许可证(VMProtectDeactivateLicense),"
            注释 = "需要在服务器上部署Web License Manager(另行购买)." 注释 = "  本功能用于释放服务器端上的激活次数,让用户的激活码可以"
            注释 = "激活另一台设备.请注意解绑的序列号并未生效,在到期之前仍可" 注释 = "使用." 返回值注释 = "成功返回0,失败返回其他数值,具体请参考\"VMProtect激活结果\"." 折叠
            @嵌入式方法 = "">
    参数 序列号 <类型 = 文本型 注释 = "此序列号由服务器在激活成功后返回">
    {
        @ (INT)VMProtectDeactivateLicense ((const char *)GetMbsText (@<序列号>.GetText (), CVolMem (), NULL))
    }

    方法 取离线激活代码 <公开 静态 类型 = 整数 注释 = "  使用激活码离线激活许可证(VMProtectGetOfflineActivationString),"
            注释 = "需要在服务器上部署Web License Manager(另行购买)." 注释 = "  成功执行本功能后,需要用户将返回的激活代码提交到离线激活网页中,"
            注释 = "服务器端将返回序列号,之后需要引导用户使用此序列号进行下一步的" 注释 = "\"设置序列号\"来完成激活."
            返回值注释 = "成功返回0,失败返回其他数值,具体请参考\"VMProtect激活结果\"." 折叠 @禁止流程检查 = 真>
    参数 激活码 <类型 = 文本型 注释 = "你的激活码">
    参数 离线激活代码 <类型 = 文本型 注释 = "成功在此返回激活代码,之后在激活网页上提交">
    {
        @ char* szBuf = new char[1000];
        @ INT nRes = VMProtectGetOfflineActivationString ((const char *)GetMbsText (@<激活码>.GetText (), CVolMem (), NULL), szBuf, 1000);
        @ if (nRes == 0)
        @ {
        @     @<离线激活代码>.SetText (GetWideText ((const CHAR*)szBuf, CVolMem (), NULL));
        @ }
        @ delete [] szBuf;
        @ return nRes;
    }

    方法 取离线解绑代码 <公开 静态 类型 = 整数 注释 = "  使用序列号离线解绑许可证(VMProtectGetOfflineDeactivationString),"
            注释 = "需要在服务器上部署Web License Manager(另行购买)." 注释 = "  成功执行本功能后,需要用户将返回的解绑代码提交到离线激活网页中,"
            注释 = "服务器端接收后会释放激活次数." 返回值注释 = "成功返回0,失败返回其他数值,具体请参考\"VMProtect激活结果\"." 折叠 @禁止流程检查 = 真>
    参数 序列号 <类型 = 文本型 注释 = "此序列号由服务器在激活成功后返回">
    参数 离线解绑代码 <类型 = 文本型 注释 = "成功在此返回解绑代码,之后在激活网页上提交">
    {
        @ char* szBuf = new char[1000];
        @ INT nRes = VMProtectGetOfflineDeactivationString ((const char *)GetMbsText (@<序列号>.GetText (), CVolMem (), NULL), szBuf, 1000);
        @ if (nRes == 0)
        @ {
        @     @<离线解绑代码>.SetText (GetWideText ((const CHAR*)szBuf, CVolMem (), NULL));
        @ }
        @ delete [] szBuf;
        @ return nRes;
    }
}

类 VMProtect全局辅助类 <公开 注释 = "一些常用的VMProtect全局方法" 折叠 @文档 = "category = \"VMProtect加密\"" @全局类 = 真
        @强制依赖 = "VMProtect">
{
    方法 VMP保护 <公开 静态 注释 = "  标记VMP保护的范围,具体的保护模式在VMProtect程序中设置(VMProtectBegin),"
            注释 = "流程线内的子语句体都将被保护,尾部无需调用VMProtectEnd." 注释 = "  默认标记为\"类名::方法名, 行号\",不可修改." 折叠
            @嵌入式方法 = "has_body = true\r\nbody_header = \"@none\"\r\nbody_tail = \"VMProtectEnd ();\"">
    {
        @ VMProtectBegin (@sn<current_source_class>"::"@sn<current_source_method>", "@sn<current_source_line>);
    }

    方法 VMP虚拟化保护 <公开 静态 注释 = "  标记虚拟化保护的范围(VMProtectBeginVirtualization),流程线内的子语句体"
            注释 = "都将被保护,尾部无需调用VMProtectEnd." 注释 = "  默认标记为\"类名::方法名, 行号\",不可修改." 折叠
            @嵌入式方法 = "has_body = true\r\nbody_header = \"@none\"\r\nbody_tail = \"VMProtectEnd ();\"">
    参数 锁定到序列号 <类型 = 逻辑型 注释 = "  默认为假,为真时改为调用VMProtectBeginUltraLockByKey," 注释 = "受保护的代码需要验证序列号才能使用."
            @默认值 = 假>
    {
        @ @<锁定到序列号> ? VMProtectBeginVirtualizationLockByKey (@sn<current_source_class>"::"@sn<current_source_method>", "@sn<current_source_line>) : VMProtectBeginVirtualization (@sn<current_source_class>"::"@sn<current_source_method>", "@sn<current_source_line>);
    }

    方法 VMP变异保护 <公开 静态 注释 = "  标记变异保护的范围(VMProtectBeginMutation),流程线内的子语句体都将被" 注释 = "保护,尾部无需调用VMProtectEnd."
            注释 = "  默认标记为\"类名::方法名, 行号\",不可修改." 折叠
            @嵌入式方法 = "has_body = true\r\nbody_header = \"@none\"\r\nbody_tail = \"VMProtectEnd ();\"">
    {
        @ VMProtectBeginMutation (@sn<current_source_class>"::"@sn<current_source_method>", "@sn<current_source_line>);
    }

    方法 VMP超级保护 <公开 静态 注释 = "  标记超级保护的范围(VMProtectBeginUltra),流程线内的子语句体都将被保护," 注释 = "尾部无需调用VMProtectEnd."
            注释 = "  默认标记为\"类名::方法名, 行号\",不可修改." 折叠
            @嵌入式方法 = "has_body = true\r\nbody_header = \"@none\"\r\nbody_tail = \"VMProtectEnd ();\"">
    参数 锁定到序列号 <类型 = 逻辑型 注释 = "    默认为假,为真时改为调用VMProtectBeginUltraLockByKey," 注释 = "受保护的代码需要验证序列号才能使用."
            @默认值 = 假>
    {
        @ @<锁定到序列号> ? VMProtectBeginUltraLockByKey (@sn<current_source_class>"::"@sn<current_source_method>", "@sn<current_source_line>) : VMProtectBeginUltra (@sn<current_source_class>"::"@sn<current_source_method>", "@sn<current_source_line>);
    }

    方法 VMP取机器码信息 <公开 静态 类型 = 逻辑型 注释 = "  非SDK函数,可解析出HWID中各项软硬件信息(CPU、网卡、硬盘和主机名)的"
            注释 = "识别码,算法来源 https://helloacm.com/decode-hardware-id" 返回值注释 = "返回是否成功,失败一般是因为提供的HWID无效." 折叠>
    参数 HWID <类型 = 文本型 注释 = "欲解析的HWID">
    参数 HWID信息 <类型 = HWID信息类 注释 = "成功在此返回HWID信息">
    {
        变量 机器码 <类型 = 字节集类>
        变量 长度 <类型 = 整数>
        机器码 = BASE64文本到字节集 (HWID)
        长度 = 机器码.取字节集长度 ()
        如果 (长度 < 8 || 长度 % 4 != 0)
        {
            返回 (假)

        }
        HWID信息.重置为空对象 ()
        变量 索引 <类型 = 整数>
        循环 (0, 长度, 索引, 4)
        {
            变量 t1 <类型 = 整数>
            变量 t2 <类型 = 整数>
            变量 t3 <类型 = 整数>
            变量 t4 <类型 = 整数>
            变量 val <类型 = 整数>
            变量 ids <类型 = 文本型>
            t1 = 无符号字节到整数 (机器码.取字节集数据 (索引, 字节))
            t2 = 无符号字节到整数 (机器码.取字节集数据 (索引 + 1, 字节))
            t3 = 无符号字节到整数 (机器码.取字节集数据 (索引 + 2, 字节))
            t4 = 无符号字节到整数 (机器码.取字节集数据 (索引 + 3, 字节))
            val = t4 * 位左移 (2, 23) + t3 * 位左移 (2, 15) + t2 * 位左移 (2, 7) + 位与 (t1, 0xFC)
            @ wchar_t buffer[20] { 0 };
            @ _itow(@<val>, buffer, 16);
            @ @<ids> = CVolString (buffer).MakeUpper ();
            如果 (取文本长度 (ids) < 8)
            {
                插入文本 (ids, 0, 取重复文本 ("0", 8 - 取文本长度 (ids)))

            }
            分支判断 (位与 (t1, 3))
            {
                分支 (0)
                {
                    HWID信息.CPU = ids
                }
                分支 (1)
                {
                    HWID信息.HOST = ids
                }
                分支 (2)
                {
                    HWID信息.ETHERNET.加入成员 (ids)
                }
                分支 (3)
                {
                    HWID信息.HDD = ids
                }

            }
        }
        返回 (真)
    }
}

# ------

类 VMProtect序列号状态 <公开 注释 = "VMProtectSerialStateFlags为\"设置序列号\"和\"取序列号状态\"的返回值." 折叠
        @文档 = "category = \"VMProtect加密.辅助类\"">
{
    常量 成功 <公开 类型 = 整数 值 = 0 注释 = "序列号激活成功">
    常量 已损坏 <公开 类型 = 整数 值 = 1 注释 = "许可证系统已被损坏,可能的原因是项目的加密设置不正确,或被试图破解.">
    常量 无效 <公开 类型 = 整数 值 = 2 注释 = "此序列号无效,许可证系统无法解密序列号时返回此状态.">
    常量 黑名单 <公开 类型 = 整数 值 = 4 注释 = "此序列号已经被VMProtect列入黑名单.">
    常量 已过期 <公开 类型 = 整数 值 = 8 注释 = "此序列号已经过期.可以调用\"取序列号数据\"获取此序列号的有效日期.">
    常量 运行超时 <公开 类型 = 整数 值 = 16 注释 = "程序的运行(试用)时间已耗尽,可以调用\"取序列号数据\"获取此序列号的运行时效;"
            注释 = "注意: VMProtect本身未实现到时限提示或退出程序的功能,需要你自己编程实现.">
    常量 机器码错误 <公开 类型 = 整数 值 = 32 注释 = "当前设备的机器码与密钥中的硬件机器码不匹配.">
    常量 版本号太新 <公开 类型 = 整数 值 = 64 注释 = "此序列号不支持当前的软件版本,可以调用\"取序列号数据\"获取此序列号能使用的最大程序生成日期.">
}

类 VMProtect日期 <公开 基础类 = PIV结构模板 注释 = "VMProtectDate为序列号数据中的日期数据" 折叠
        @文档 = "category = \"VMProtect加密.辅助类\"" @别名 = "VMProtectDate" @模板实现类 = "VMProtect日期"
        @强制依赖 = "VMProtect">
{
    变量 年 <公开 类型 = 短整数 注释 = "4位数年份" @输出名 = "wYear">
    变量 月 <公开 类型 = 字节 注释 = "月份,从1开始" @输出名 = "bMonth">
    变量 日 <公开 类型 = 字节 注释 = "天数,从1开始" @输出名 = "bDay">

    方法 到日期文本 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = VMProtect日期>
    {
        返回 (取格式文本 ("%04u-%02u-%02u", 欲操作本对象.年, 欲操作本对象.月, 欲操作本对象.日))
    }
}

类 VMProtect序列号数据 <公开 基础类 = PIV结构模板 注释 = "VMProtectSerialNumberData为\"取序列号数据\"返回的结构类" 折叠
        @文档 = "category = \"VMProtect加密.辅助类\"" @别名 = "VMProtectSerialNumberData" @模板实现类 = "VMProtect序列号数据"
        @强制依赖 = "VMProtect">
{
    变量 状态 <公开 类型 = 整数 注释 = "序列号的激活状态,0表示激活成功,其他含义请参考\"VMProtect序列号状态\"." @输出名 = "nState">
    变量 用户名 <公开 类型 = "字符 [256]" 注释 = "用户名称" @输出名 = "wUserName">
    变量 邮箱 <公开 类型 = "字符 [256]" 注释 = "用户的邮箱" @输出名 = "wEMail">
    变量 到期日期 <公开 类型 = VMProtect日期 注释 = "序列号的有效日期" @输出名 = "dtExpire">
    变量 更新期限 <公开 类型 = VMProtect日期 注释 = "免费更新的期限,程序在此日期前编译的,可以免费使用." @输出名 = "dtMaxBuild">
    变量 运行时限 <公开 类型 = 整数 注释 = "从程序运行时开始计算,超过此参数(以分钟为单位)的时间后,将不再允许使用程序;"
            注释 = "注意: VMProtect本身未实现到时限提示或退出程序的功能,需要你自己编程实现," 注释 = "这里只是在序列号里提供了这个状态." @输出名 = "bRunningTime">
    变量 "// 用户数据长度" <公开 类型 = 无符号字节 注释 = "用户数据已使用的字节数,最大255字节." @输出名 = "nUserDataLength">
    变量 用户数据 <公开 类型 = "字节 [255]" 注释 = "序列号中包含的用户数据,实际占用尺寸以\"用户数据长度\"为准." @输出名 = "bUserData">

    方法 用户数据长度 <公开 静态 属性读 类型 = 整数 注释 = "用户数据已使用的字节数,最大255字节." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = VMProtect序列号数据>
    {
        @ (INT)@<欲操作本对象>.nUserDataLength
    }

    方法 用户数据长度 <公开 静态 属性写 注释 = "用户数据已使用的字节数,最大255字节." 折叠>
    参数 欲操作本对象 <类型 = VMProtect序列号数据>
    参数 值 <类型 = 整数 注释 = "最大不能超过255">
    {
        @ @<欲操作本对象>.nUserDataLength = (unsigned char)@<值>;
    }

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = VMProtect序列号数据>
    {
        变量 展示内容 <类型 = 文本型>
        展示内容 = "<VMProtectSerialNumberData> 总共 8 个成员:\r\n"
        加入格式文本 (展示内容, "1. 状态(nState): %d\r\n", 欲操作本对象.状态)
        加入格式文本 (展示内容, "2. 用户名(wUserName): %s\r\n", 字符数组到文本 (欲操作本对象.用户名, 256))
        加入格式文本 (展示内容, "3. 邮箱(wEMail): %s\r\n", 字符数组到文本 (欲操作本对象.邮箱, 256))
        加入格式文本 (展示内容, "4. 到期日期(dtExpire): %s\r\n", 欲操作本对象.到期日期.到日期文本 ())
        加入格式文本 (展示内容, "5. 更新期限(dtMaxBuild): %s\r\n", 欲操作本对象.更新期限.到日期文本 ())
        加入格式文本 (展示内容, "6. 运行时限(bRunningTime): %d\r\n", 欲操作本对象.运行时限)
        加入格式文本 (展示内容, "7. 用户数据长度(nUserDataLength): %d\r\n", 欲操作本对象.用户数据长度)
        加入格式文本 (展示内容, "8. 用户数据(bUserData): %s", 编码辅助类.展示字节数据 (取数组变量地址 (欲操作本对象.用户数据), 欲操作本对象.用户数据长度))
        返回 (展示内容)
    }
}

类 VMProtect序列号数据类 <公开 基础类 = PIV结构模板 注释 = "\"取序列号数据2\"返回的火山对象类" 折叠
        @文档 = "category = \"VMProtect加密.辅助类\"" @别名 = "VMProtectSerialNumberData" @模板实现类 = "VMProtect序列号数据类"
        @强制依赖 = "VMProtect">
{
    变量 状态 <公开 类型 = 整数 注释 = "序列号的激活状态,0表示激活成功,其他含义请参考\"VMProtect序列号状态\"." @输出名 = "nState">
    变量 到期日期 <公开 类型 = VMProtect日期 注释 = "序列号的有效日期" @输出名 = "dtExpire">
    变量 更新期限 <公开 类型 = VMProtect日期 注释 = "免费更新的期限,程序在此日期前编译的,可以免费使用." @输出名 = "dtMaxBuild">
    变量 运行时限 <公开 类型 = 整数 注释 = "从程序运行时开始计算,超过此参数(以分钟为单位)的时间后,将不再允许使用程序;"
            注释 = "注意: VMProtect本身未实现到时限提示或退出程序的功能,需要你自己编程实现," 注释 = "这里只是在序列号里提供了这个状态." @输出名 = "bRunningTime">

    方法 用户名 <公开 静态 属性读 类型 = 文本型 注释 = "返回用户名称" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = VMProtect序列号数据类>
    {
        @ @an<CVolString>(@<欲操作本对象>.wUserName)
    }

    方法 用户名 <公开 静态 属性写 注释 = "设置用户名称(不得超过256个字符)" 折叠>
    参数 欲操作本对象 <类型 = VMProtect序列号数据类>
    参数 欲设置用户名 <类型 = 文本型 注释 = "不得超过256个字符">
    {
        @ wcscpy_s(@<欲操作本对象>.wUserName, 256, @<欲设置用户名>.GetText());
    }

    方法 邮箱 <公开 静态 属性读 类型 = 文本型 注释 = "返回用户邮箱" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = VMProtect序列号数据类>
    {
        @ @an<CVolString>(@<欲操作本对象>.wEMail)
    }

    方法 邮箱 <公开 静态 属性写 注释 = "设置用户邮箱(不得超过256个字符)" 折叠>
    参数 欲操作本对象 <类型 = VMProtect序列号数据类>
    参数 欲设置邮箱 <类型 = 文本型 注释 = "不得超过256个字符">
    {
        @ wcscpy_s(@<欲操作本对象>.wEMail, 256, @<欲设置邮箱>.GetText());
    }

    方法 用户数据长度 <公开 静态 属性读 类型 = 整数 注释 = "用户数据已使用的字节数,最大255字节." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = VMProtect序列号数据类>
    {
        @ (INT)@<欲操作本对象>.nUserDataLength
    }

    方法 用户数据长度 <公开 静态 属性写 注释 = "用户数据已使用的字节数,最大255字节." 折叠>
    参数 欲操作本对象 <类型 = VMProtect序列号数据类>
    参数 值 <类型 = 整数 注释 = "最大不能超过255">
    {
        @ @<欲操作本对象>.nUserDataLength = (unsigned char)@<值>;
    }

    方法 用户数据 <公开 静态 属性读 类型 = 字节集类 注释 = "返回序列号中包含的用户数据,实际占用尺寸以\"用户数据长度\"为准." 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = VMProtect序列号数据类>
    {
        @ return @an<CVolMem>(@<欲操作本对象>.bUserData, @<欲操作本对象>.nUserDataLength);
    }

    方法 用户数据 <公开 静态 属性写 注释 = "设置序列号中包含的用户数据,最大不能超过255字节." 折叠>
    参数 欲操作本对象 <类型 = VMProtect序列号数据类>
    参数 欲设置数据 <类型 = 字节集类 注释 = "不得超过255个字节">
    {
        @ memcpy(@<欲操作本对象>.bUserData, @<欲设置数据>.GetPtr(), @<欲设置数据>.GetSize() > 255 ? 255 : @<欲设置数据>.GetSize());
    }

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = VMProtect序列号数据类>
    {
        变量 展示内容 <类型 = 文本型>
        展示内容 = "<VMProtectSerialNumberData> 总共 8 个成员:\r\n"
        加入格式文本 (展示内容, "1. 状态(nState): %d\r\n", 欲操作本对象.状态)
        加入格式文本 (展示内容, "2. 用户名(wUserName): %s\r\n", 欲操作本对象.用户名)
        加入格式文本 (展示内容, "3. 邮箱(wEMail): %s\r\n", 欲操作本对象.邮箱)
        加入格式文本 (展示内容, "4. 到期日期(dtExpire): %s\r\n", 欲操作本对象.到期日期.到日期文本 ())
        加入格式文本 (展示内容, "5. 更新期限(dtMaxBuild): %s\r\n", 欲操作本对象.更新期限.到日期文本 ())
        加入格式文本 (展示内容, "6. 运行时限(bRunningTime): %d\r\n", 欲操作本对象.运行时限)
        加入格式文本 (展示内容, "7. 用户数据长度(nUserDataLength): %d\r\n", 欲操作本对象.用户数据长度)
        加入格式文本 (展示内容, "8. 用户数据(bUserData): %s", 编码辅助类.展示字节集 (欲操作本对象.用户数据))
        返回 (展示内容)
    }
}

类 VMProtect激活结果 <公开 注释 = "VMProtectActivationFlags为服务器激活/解绑的返回值" 折叠
        @文档 = "category = \"VMProtect加密.辅助类\"">
{
    常量 激活成功 <公开 类型 = 整数 值 = 0 注释 = "激活成功.当前的序列号将加入到序列号变量中.">
    常量 缓冲区过小 <公开 类型 = 整数 值 = 1 注释 = "缓冲区太小,无法存储序列号;"
            注释 = "最小缓冲区大小的计算公式为: bits/8*3/2+N,其中bits是以位为单位的RSA密钥的长度,"
            注释 = "N是一个\"安全常数\",可能的换行符和其他特殊符号的额外字节,建议至少为10.">
    常量 无法连接 <公开 类型 = 整数 值 = 2 注释 = "激活模块无法连接到网络许可证管理器.">
    常量 返回错误 <公开 类型 = 整数 值 = 3 注释 = "激活服务器返回了异常结果.可能是服务器配置问题、URL地址错误或被尝试攻击.">
    常量 已禁止 <公开 类型 = 整数 值 = 4 注释 = "软件供应商通过WebLM界面在服务器上禁止了该激活码;" 注释 = "原因可能是密钥泄漏或盗版,不要跟\"已被使用\"混淆.">
    常量 已损坏 <公开 类型 = 整数 值 = 5 注释 = "该错误由激活模块的自检系统产生,通常意味着被破解攻击;" 注释 = "如果出现此错误,所有后续的序列号和激活操作都不再安全.">
    常量 激活码错误 <公开 类型 = 整数 值 = 6 注释 = "在激活服务器的数据库中找不到指定的激活码;" 注释 = "也可能是用户输入错误,所以可以让他检查和重试.">
    常量 已被使用 <公开 类型 = 整数 值 = 7 注释 = "此激活码的可用次数已经耗尽,无法继续激活;" 注释 = "这不代表激活码错误或被禁止,激活码是正确的,只是不能再激活了;"
            注释 = "用户应联系软件供应商,购买更多的许可证或在其他计算机上卸载软件,以增加服务器上的激活次数.">
    常量 未知序列号 <公开 类型 = 整数 值 = 8 注释 = "激活错误,服务器的数据库中找不到指定的序列号.因此无法解绑许可证.">
    常量 已过期 <公开 类型 = 整数 值 = 9 注释 = "激活错误,此激活码的激活期限已过.">
    常量 不可用 <公开 类型 = 整数 值 = 10 注释 = "此错误意味着激活和解绑功能不可用.">
}

类 HWID信息类 <公开 基础类 = 扩展对象类 注释 = "\"VMP取机器码信息\"的解析结果" 折叠 @文档 = "category = \"VMProtect加密.辅助类\"">
{
    变量 CPU <公开 类型 = 文本型 注释 = "处理器识别码">
    变量 HOST <公开 类型 = 文本型 注释 = "主机名识别码">
    变量 ETHERNET <公开 类型 = 文本数组类 注释 = "网卡识别码">
    变量 HDD <公开 类型 = 文本型 注释 = "硬盘识别码">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<HWID信息> 总共 4 个成员:\r\n"
        加入文本 (展示内容, "1. CPU: " + 取调试文本2 (最大展示数据尺寸, CPU) + "\r\n")
        加入文本 (展示内容, "2. HOST: " + 取调试文本2 (最大展示数据尺寸, HOST) + "\r\n")
        加入文本 (展示内容, "3. ETHERNET: " + 取调试文本2 (最大展示数据尺寸, ETHERNET) + "\r\n")
        加入文本 (展示内容, "4. HDD: " + 取调试文本2 (最大展示数据尺寸, HDD))
    }
}

# ======

类 VMP注册机类 <公开 注释 = "使用步骤:" 注释 = " 1. 导入密钥对/导入产品信息" 注释 = " 2. 生成序列号" @文档 = "category = \"VMProtect注册机\""
        @视窗.外部头文件 = "VMProtect\\include\\KeyGenAPI.h" @视窗.外部库.x64 = "VMProtect\\lib\\KeyGen64.lib"
        @视窗.外部库.win32 = "VMProtect\\lib\\KeyGen32.lib" @视窗.附属文件.x64 = "VMProtect\\lib\\KeyGen64.dll"
        @视窗.附属文件.win32 = "VMProtect\\lib\\KeyGen32.dll">
{
    变量 产品信息 <类型 = VMProtect产品信息>
    变量 ProductInfo <类型 = VMProtectProductInfo @输出名 = "ProductInfo">

    方法 导入密钥对 <公开 类型 = 逻辑型 注释 = "导入VMProtect生成的密钥对,返回是否成功." 返回值注释 = "返回是否成功" 折叠>
    参数 密钥对 <类型 = 文本型 注释 = "请输入从VMProtect导出的密钥对">
    参数 密钥对格式 <类型 = 整数 注释 = "VMProtect的密钥对导出格式,建议使用后两种格式:" 注释 = " 0 = KeyGen.dll(MSVC)"
            注释 = " 1 = KeyGen.dll(Delphi)" 注释 = " 2 = KeyGen.Net/PayPro Global" 注释 = " 3 = Keygen.php" @默认值 = 2>
    {
        产品信息.重置为空对象 ()
        如果 (密钥对格式 == 0)
        {
            变量 搜寻位置 <类型 = 整数>
            变量 私钥文本 <类型 = 文本型>
            变量 模数文本 <类型 = 文本型>
            变量 产品代码文本 <类型 = 文本型>
            产品信息.算法 = 0
            产品信息.位数 = 文本到整数 (VMP_取文本中间 (密钥对, "g_nBits = ", ";", , 真))
            搜寻位置 = 寻找文本 (密钥对, "g_vPrivate", , 真)
            私钥文本 = VMP_取文本中间 (密钥对, "{", "};", 搜寻位置)
            搜寻位置 = 寻找文本 (密钥对, "g_vModulus", , 真)
            模数文本 = VMP_取文本中间 (密钥对, "{", "};", 搜寻位置)
            搜寻位置 = 寻找文本 (密钥对, "g_vProductCode", , 真)
            产品代码文本 = VMP_取文本中间 (密钥对, "{", "};", 搜寻位置)
            变量 文本数组 <类型 = 文本数组类>
            变量 字节数组 <类型 = 字节数组类>
            分割文本 (私钥文本, ",", 文本数组)
            文本数组.枚举循环 ()
            {
                字节数组.加入成员 ((字节)文本到整数 (文本数组.取枚举值 ()))
            }
            产品信息.私钥 = 字节数组.取字节集 ()

            文本数组.删除所有成员 ()
            字节数组.删除所有成员 ()
            分割文本 (模数文本, ",", 文本数组)
            文本数组.枚举循环 ()
            {
                字节数组.加入成员 ((字节)文本到整数 (文本数组.取枚举值 ()))
            }
            产品信息.模数 = 字节数组.取字节集 ()

            文本数组.删除所有成员 ()
            字节数组.删除所有成员 ()
            分割文本 (产品代码文本, ",", 文本数组)
            文本数组.枚举循环 ()
            {
                字节数组.加入成员 ((字节)文本到整数 (文本数组.取枚举值 ()))
            }
            产品信息.产品代码 = 字节数组.取字节集 ()

        }
        否则 (密钥对格式 == 1)
        {
            变量 搜寻位置 <类型 = 整数>
            变量 私钥文本 <类型 = 文本型>
            变量 模数文本 <类型 = 文本型>
            变量 产品代码文本 <类型 = 文本型>
            产品信息.算法 = 0
            产品信息.位数 = 文本到整数 (VMP_取文本中间 (密钥对, "g_nBits: Longword = ", ";", , 真))
            搜寻位置 = 寻找文本 (密钥对, "g_vPrivate", , 真)
            私钥文本 = VMP_取文本中间 (密钥对, "(", ");", 搜寻位置, 真)
            搜寻位置 = 寻找文本 (密钥对, "g_vModulus", , 真)
            模数文本 = VMP_取文本中间 (密钥对, "(", ");", 搜寻位置)
            搜寻位置 = 寻找文本 (密钥对, "g_vProductCode")
            产品代码文本 = VMP_取文本中间 (密钥对, "(", ");", 搜寻位置)
            变量 文本数组 <类型 = 文本数组类>
            变量 字节数组 <类型 = 字节数组类>
            分割文本 (私钥文本, ",", 文本数组)
            文本数组.枚举循环 ()
            {
                字节数组.加入成员 ((字节)文本到整数 (文本数组.取枚举值 ()))
            }
            产品信息.私钥 = 字节数组.取字节集 ()

            文本数组.删除所有成员 ()
            字节数组.删除所有成员 ()
            分割文本 (模数文本, ",", 文本数组)
            文本数组.枚举循环 ()
            {
                字节数组.加入成员 ((字节)文本到整数 (文本数组.取枚举值 ()))
            }
            产品信息.模数 = 字节数组.取字节集 ()

            文本数组.删除所有成员 ()
            字节数组.删除所有成员 ()
            分割文本 (产品代码文本, ",", 文本数组)
            文本数组.枚举循环 ()
            {
                字节数组.加入成员 ((字节)文本到整数 (文本数组.取枚举值 ()))
            }
            产品信息.产品代码 = 字节数组.取字节集 ()

        }
        否则 (密钥对格式 == 2)
        {
            变量 密钥对明文 <类型 = 文本型>
            密钥对明文 = 多字节到文本 (BASE64文本到字节集 (密钥对))
            产品信息.算法 = 0
            产品信息.位数 = 文本到整数 (VMP_取文本中间 (密钥对明文, "bits=\"", "\"", , 真))
            产品信息.私钥 = BASE64文本到字节集 (VMP_取文本中间 (密钥对明文, "exp=\"", "\"", , 真))
            产品信息.模数 = BASE64文本到字节集 (VMP_取文本中间 (密钥对明文, "mod=\"", "\"", , 真))
            产品信息.产品代码 = BASE64文本到字节集 (VMP_取文本中间 (密钥对明文, "product=\"", "\"", , 真))

        }
        否则 (密钥对格式 == 3)
        {
            产品信息.算法 = 0
            产品信息.位数 = 文本到整数 (VMP_取文本中间 (密钥对, "$exported_bits = ", ";", , 真))
            产品信息.私钥 = BASE64文本到字节集 (VMP_取文本中间 (密钥对, "$exported_private = \"", "\";", , 真))
            产品信息.模数 = BASE64文本到字节集 (VMP_取文本中间 (密钥对, "$exported_modulus = \"", "\";", , 真))
            产品信息.产品代码 = BASE64文本到字节集 (VMP_取文本中间 (密钥对, "$exported_product_code = \"", "\";", , 真))

        }
        否则
        {
            ProductInfo.清零 ()
            返回 (假)

        }
        如果 (产品信息.位数 == 0 || 产品信息.私钥.字节集是否为空 () || 产品信息.模数.字节集是否为空 () || 产品信息.产品代码.字节集是否为空 ())
        {
            产品信息.重置为空对象 ()
            ProductInfo.清零 ()
            返回 (假)
        }
        产品信息.置结构数据 (ProductInfo)
        返回 (真)
    }

    方法 导入密钥对文件 <公开 类型 = 逻辑型 注释 = "从VMProtect工程文件导入密钥对,返回是否成功." 折叠>
    参数 工程文件 <类型 = 文本型 注释 = "提供.vmp格式的VMProtect工程文件">
    {
        变量 文件内容 <类型 = 文本型>
        如果 (读入文本文件2 (文件内容, 工程文件, -1, 文本编码类型.UTF8) == 假)
        {
            返回 (假)
        }
        产品信息.重置为空对象 ()
        变量 搜寻位置 <类型 = 整数>
        搜寻位置 = 寻找文本 (文件内容, "<LicenseManager", 0, 真)
        如果 (搜寻位置 == -1)
        {
            返回 (假)
        }
        产品信息.产品代码 = BASE64文本到字节集 (VMP_取文本中间 (文件内容, "ProductCode=\"", "\"", 搜寻位置, 真))
        产品信息.位数 = 文本到整数 (VMP_取文本中间 (文件内容, "Bits=\"", "\"", 搜寻位置, 真))
        产品信息.私钥 = BASE64文本到字节集 (VMP_取文本中间 (文件内容, "PrivateExp=\"", "\"", 搜寻位置, 真))
        产品信息.模数 = BASE64文本到字节集 (VMP_取文本中间 (文件内容, "Modulus=\"", "\"", 搜寻位置, 真))
        如果 (产品信息.位数 == 0 || 产品信息.私钥.字节集是否为空 () || 产品信息.模数.字节集是否为空 () || 产品信息.产品代码.字节集是否为空 ())
        {
            产品信息.重置为空对象 ()
            ProductInfo.清零 ()
            返回 (假)
        }
        产品信息.置结构数据 (ProductInfo)
        返回 (真)
    }

    方法 生成序列号 <公开 类型 = 整数 注释 = "填入用户信息并生成序列号." 注释 = " 1. 生成的序列号可直接激活软件,无需在VMProtect里添加授权并重新编译;"
            注释 = " 2. 只有当你想禁止某个序列号,才有必要在VMProtect里把某个序列号添加到授权并设置禁止;"
            返回值注释 = "返回0表示成功,其他值为错误,具体的错误代码请参考\"VMProtect错误代码\"." 折叠 @禁止流程检查 = 真>
    参数 序列号 <类型 = 文本型 注释 = "生成的序列号返回到本参数中">
    参数 用户名 <类型 = 文本型 注释 = "【可空】用户姓名,最长255字" @默认值 = 空对象>
    参数 邮箱 <类型 = 文本型 注释 = "【可空】用户的邮箱地址,最长255字" @默认值 = 空对象>
    参数 到期日期 <类型 = 整数 注释 = "【可空】序列号的到期日期(用\"取VMP日期\"生成),到期后序列号不再可用." @默认值 = 0>
    参数 更新期限 <类型 = 整数 注释 = "【可空】序列号只能在此日期(用\"取VMP日期\"生成)之前编译的软件中使用," 注释 = "用于限制序列号的软件版本升级期限." @默认值 = 0>
    参数 运行时限 <类型 = 整数 注释 = "【可空】软件每次启动后,运行超过此时间(单位为分钟,最大值为255)后就不能再使用;" 注释 = "可用于制作试用版的序列号(需要自行编程实现)."
            @默认值 = 0>
    参数 机器码 <类型 = 文本型 注释 = "【可空】绑定机器码(HWID),序列号只能在机器码对应的设备上使用." @默认值 = 空对象>
    参数 用户数据 <类型 = 字节集类 注释 = "【可空】由你自定义的用户数据(最大255字节)" @默认值 = 空对象>
    {
        变量 序列号信息 <类型 = VMProtectSerialNumberInfo>
        变量 硬件ID <类型 = 字节集类>
        如果 (文本是否为空 (用户名) == 假)
        {
            序列号信息.标志 = 位或 (序列号信息.标志, VMProtectSerialNumberFlags.有用户名)
            序列号信息.用户名 = 文本指针.获取 (用户名)
        }
        如果 (文本是否为空 (邮箱) == 假)
        {
            序列号信息.标志 = 位或 (序列号信息.标志, VMProtectSerialNumberFlags.有邮箱)
            序列号信息.邮箱 = 文本指针.获取 (用户名)
        }
        如果 (到期日期 != 0)
        {
            序列号信息.标志 = 位或 (序列号信息.标志, VMProtectSerialNumberFlags.有期限)
            序列号信息.到期日期 = 无符号整数.来自 (到期日期)
        }
        如果 (更新期限 != 0)
        {
            序列号信息.标志 = 位或 (序列号信息.标志, VMProtectSerialNumberFlags.有更新期限)
            序列号信息.更新期限 = 无符号整数.来自 (更新期限)
        }
        如果 (运行时限 != 0)
        {
            序列号信息.标志 = 位或 (序列号信息.标志, VMProtectSerialNumberFlags.有运行时限)
            序列号信息.运行时限 = 无符号字节.来自 (运行时限)
        }
        如果 (文本是否为空 (机器码) == 假)
        {
            序列号信息.标志 = 位或 (序列号信息.标志, VMProtectSerialNumberFlags.有机器码)
            硬件ID = 文本到多字节 (机器码, 真)
            序列号信息.HWID = 硬件ID.取字节集指针 ()
        }
        如果 (用户数据.字节集是否为空 () == 假 && 用户数据.取字节集长度 () <= 255)
        {
            序列号信息.标志 = 位或 (序列号信息.标志, VMProtectSerialNumberFlags.有用户数据)
            序列号信息.用户数据长度 = 用户数据.取字节集长度 ()
            序列号信息.用户数据 = 用户数据.取字节集指针 ()
        }
        返回 (生成序列号2 (序列号, 序列号信息))
    }

    方法 生成序列号2 <公开 类型 = 整数 注释 = "使用指定的序列号信息生成序列号" 返回值注释 = "返回0表示成功,其他值为错误,具体的错误代码请参考\"VMProtect错误代码\"." 折叠
            @禁止流程检查 = 真>
    参数 序列号 <类型 = 文本型 注释 = "生成的序列号返回到本参数中">
    参数 序列号信息 <类型 = VMProtectSerialNumberInfo>
    {
        @ char* pBuf = nullptr;
        @ VMProtectErrors Res = VMProtectGenerateSerialNumber(&ProductInfo, &@<序列号信息>, &pBuf);
        @ if (Res == 0)
        @     @<序列号>.SetText(GetWideText(pBuf, CVolMem(), NULL));
        @ VMProtectFreeSerialNumberMemory(pBuf);
        @ return (INT)Res;
    }

    方法 导入产品信息 <公开 类型 = 逻辑型 注释 = "本方法可以替代\"导入密钥对\",用于导入本地已经处理好的密钥对信息" 折叠>
    参数 数据 <类型 = 字节集类>
    {
        如果 (数据.字节集是否为空 ())
        {
            产品信息.重置为空对象 ()
            ProductInfo.清零 ()
            返回 (假)
        }
        产品信息.置对象数据 (数据)
        产品信息.置结构数据 (ProductInfo)
        返回 (真)
    }

    方法 导出产品信息 <公开 类型 = 字节集类 注释 = "将本地已导入的密钥对转换到字节集,之后你可以保存到文件中" 折叠>
    {
        返回 (产品信息.取对象数据 ())
    }

    方法 密钥对是否有效 <公开 类型 = 逻辑型 注释 = "检查是否已经导入了密钥对" 返回值注释 = "密钥对有效返回真" 折叠>
    {
        返回 (产品信息.是否为空对象 () == 假 || ProductInfo.nBits != 0 || ProductInfo.pPrivate.到变整数 () == 产品信息.私钥.取字节集指针 () || ProductInfo.pModulus.到变整数 () == 产品信息.模数.取字节集指针 () || ProductInfo.pProductCode.到变整数 () == 产品信息.产品代码.取字节集指针 ())
    }

    方法 取VMP日期 <公开 类型 = 整数 注释 = "返回VMProtect序列号信息的整数型日期" 折叠 @嵌入式方法 = "">
    参数 年 <类型 = 整数>
    参数 月 <类型 = 整数>
    参数 日 <类型 = 整数>
    {
        @ MAKEDATE (@<年>, @<月>, @<日>)
    }

    方法 VMP_取文本中间 <类型 = 文本型 注释 = "取出两段文本中间的内容" 折叠 "">
    参数 文本内容 <类型 = 文本型>
    参数 开始文本 <类型 = 文本型>
    参数 结束文本 <类型 = 文本型>
    参数 起始搜寻位置 <类型 = 整数 @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" @默认值 = 假>
    参数 如果找不到就返回原文本 <类型 = 逻辑型 注释 = "默认找不到就返回空文本" @默认值 = 假>
    {
        变量 开始位置 <类型 = 整数>
        变量 结束位置 <类型 = 整数>
        变量 中间文本 <类型 = 文本型>
        开始位置 = 寻找文本 (文本内容, 开始文本, 起始搜寻位置, 是否不区分大小写)
        如果 (开始位置 == -1)
        {
            如果 (如果找不到就返回原文本 == 真)
            {
                返回 (文本内容)
            }
            否则
            {
                返回 (中间文本)
            }
        }
        起始搜寻位置 = 开始位置 + 取文本长度 (开始文本)
        结束位置 = 寻找文本 (文本内容, 结束文本, 起始搜寻位置, 是否不区分大小写)
        如果 (开始位置 == -1)
        {
            如果 (如果找不到就返回原文本 == 真)
            {
                返回 (文本内容)
            }
            否则
            {
                返回 (中间文本)
            }
        }
        如果 (是否包含开始文本 == 假)
        {
            开始位置 = 起始搜寻位置
        }
        中间文本 = 取文本中间 (文本内容, 开始位置, 结束位置 - 开始位置)
        返回 (中间文本)
    }
}

# ------

类 VMProtect错误代码 <公开 注释 = "VMProtectErrors为生成注册码时返回的错误代码" 折叠 @文档 = "category = \"VMProtect注册机.辅助类\"">
{
    常量 无错误 <公开 类型 = 整数 值 = 0 注释 = "无任何错误,序列号生成成功">
    常量 不支持的算法 <公开 类型 = 整数 值 = 1 注释 = "函数的第一个参数传递了错误的密钥加密算法">
    常量 不支持的位数 <公开 类型 = 整数 值 = 2 注释 = "函数的第一个参数传递的位数不正确">
    常量 用户名太长 <公开 类型 = 整数 值 = 3 注释 = "UTF-8编码的用户名长度超过了255字节">
    常量 邮件太长 <公开 类型 = 整数 值 = 4 注释 = "UTF-8编码的邮箱长度超过了255字节">
    常量 用户数据太长 <公开 类型 = 整数 值 = 5 注释 = "用户数据的长度超过了255字节">
    常量 HWID长度错误 <公开 类型 = 整数 值 = 6 注释 = "机器码的长度不正确">
    常量 产品代码长度错误 <公开 类型 = 整数 值 = 7 注释 = "传递到函数的第一个参数的产品识别码大小不正确">
    常量 序列号太长 <公开 类型 = 整数 值 = 8 注释 = "序列号太长,无法匹配算法中指定的位数">
    常量 产品信息错误 <公开 类型 = 整数 值 = 9 注释 = "函数的第一个参数不正确或为空">
    常量 序列号信息错误 <公开 类型 = 整数 值 = 10 注释 = "函数的第二个参数不正确或为空">
    常量 序列号容器错误 <公开 类型 = 整数 值 = 11 注释 = "函数的第三个参数不指向要写入序列号的内存地址">
    常量 非空序列号容器 <公开 类型 = 整数 值 = 12 注释 = "函数的第三个参数不指向空内存单元,该单元必须为NULL">
    常量 个人信息错误 <公开 类型 = 整数 值 = 13 注释 = "函数的第一个参数包含不正确的个人信息">
    常量 模数错误 <公开 类型 = 整数 值 = 14 注释 = "函数的第一个参数包含不正确的模数数值">
}

类 VMProtect产品信息 <公开 基础类 = 扩展对象类 折叠 @文档 = "category = \"VMProtect注册机.辅助类\"">
{
    变量 算法 <公开 类型 = 整数 注释 = "ALGORITHM_RSA = 0," 注释 = "ALGORITHM_PADDING = 0xFFFFFFFF">
    变量 位数 <公开 类型 = 变整数 注释 = "RSA密钥对的位数">
    变量 私钥 <公开 类型 = 字节集类>
    变量 模数 <公开 类型 = 字节集类>
    变量 产品代码 <公开 类型 = 字节集类>

    方法 置结构数据 <公开 类型 = 变整数 折叠 @嵌入式方法 = "">
    参数 结构体 <类型 = VMProtectProductInfo @需求类型 = 可写入变量>
    {
        @ (INT_P)@sn<this>.SetInfo(&@<结构体>)
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<VMProtect产品信息> 总共 5 个成员:\r\n"
        加入文本 (展示内容, "1. 算法: " + 取调试文本2 (最大展示数据尺寸, 算法) + "\r\n")
        加入文本 (展示内容, "2. 位数: " + 取调试文本2 (最大展示数据尺寸, 位数) + "\r\n")
        加入文本 (展示内容, "3. 私钥: " + 取调试文本2 (最大展示数据尺寸, 私钥) + "\r\n")
        加入文本 (展示内容, "4. 模数: " + 取调试文本2 (最大展示数据尺寸, 模数) + "\r\n")
        加入文本 (展示内容, "5. 产品代码: " + 取调试文本2 (最大展示数据尺寸, 产品代码))
    }

    # @begin
    # <> <include>
    # VMProtectProductInfo* SetInfo(VMProtectProductInfo* stInfo)
    # {
    #     stInfo->algorithm = ALGORITHM_RSA;
    #     stInfo->nBits = static_cast<size_t>(@<位数>);
    #     stInfo->nPrivateSize = static_cast<size_t>(@<私钥>.GetSize());
    #     stInfo->pPrivate = @<私钥>.GetPtr();
    #     stInfo->nModulusSize = static_cast<size_t>(@<模数>.GetSize());
    #     stInfo->pModulus = @<模数>.GetPtr();
    #     stInfo->nProductCodeSize = static_cast<size_t>(@<产品代码>.GetSize());
    #     stInfo->pProductCode = @<产品代码>.GetPtr();
    #     return stInfo;
    # }
    # <> </include>
    # @end
}

类 VMProtectSerialNumberFlags <公开 折叠 @文档 = "category = \"VMProtect注册机.辅助类\"" @强制依赖 = "VMP注册机类">
{
    常量 有用户名 <公开 类型 = 整数 值 = @HAS_USER_NAME 注释 = "将pUserName变量中的用户名置入到序列号" 编辑时信息 = "33FFC, 0, 0, 0">
    常量 有邮箱 <公开 类型 = 整数 值 = @HAS_EMAIL 注释 = "将pEMail变量中的电子邮箱置入到序列号" 编辑时信息 = "33FFC, 0, 0, 0">
    常量 有期限 <公开 类型 = 整数 值 = @HAS_EXP_DATE 注释 = "序列号将在dwExpDate变量的日期后过期" 编辑时信息 = "33FFC, 0, 0, 0">
    常量 有更新期限 <公开 类型 = 整数 值 = @HAS_MAX_BUILD_DATE 注释 = "序列号只能在软件编译日期在dwMaxBuildDate变量之前的版本中可用"
            编辑时信息 = "33FFC, 0, 0, 0">
    常量 有运行时限 <公开 类型 = 整数 值 = @HAS_TIME_LIMIT 注释 = "程序在达到nRunningTimeLimit变量中指定的时间后停止工作(以分钟为单位,不应超过255);"
            注释 = "注意: VMProtect本身未实现到时限提示或退出程序的功能,需要你自己编程实现,这里只是在序列号里提供了这个状态." 编辑时信息 = "33FFC, 0, 0, 0">
    常量 有机器码 <公开 类型 = 整数 值 = @HAS_HARDWARE_ID 注释 = "该程序只能在pHardwareID变量中指定的机器码上运行" 编辑时信息 = "33FFC, 0, 0, 0">
    常量 有用户数据 <公开 类型 = 整数 值 = @HAS_USER_DATA 注释 = "将pUserData地址的自定义用户数据置入到序列号" 编辑时信息 = "33FFC, 0, 0, 0">
}

类 VMProtectProductInfo <公开 基础类 = PIV结构模板 折叠 @文档 = "category = \"VMProtect注册机.辅助类\"" @强制依赖 = "VMP注册机类"
        @别名 = "VMProtectProductInfo" @模板实现类 = "VMProtectProductInfo">
{
    变量 algorithm <公开 类型 = 整数 注释 = "ALGORITHM_RSA = 0," 注释 = "ALGORITHM_PADDING = 0xFFFFFFFF"
            @输出名 = "algorithm">
    变量 nBits <公开 类型 = 变整数 @输出名 = "nBits">
    变量 nPrivateSize <公开 类型 = 变整数 @输出名 = "nPrivateSize">
    变量 pPrivate <公开 类型 = 通用指针 @输出名 = "pPrivate">
    变量 nModulusSize <公开 类型 = 变整数 @输出名 = "nModulusSize">
    变量 pModulus <公开 类型 = 通用指针 @输出名 = "pModulus">
    变量 nProductCodeSize <公开 类型 = 变整数 @输出名 = "nProductCodeSize">
    变量 pProductCode <公开 类型 = 通用指针 @输出名 = "pProductCode">
}

类 VMProtectSerialNumberInfo <公开 基础类 = PIV结构模板 折叠 @文档 = "category = \"VMProtect注册机.辅助类\""
        @强制依赖 = "VMP注册机类" @别名 = "VMProtectSerialNumberInfo" @模板实现类 = "VMProtectSerialNumberInfo">
{
    变量 标志 <公开 类型 = 整数 注释 = "\"VMProtect序列号标志\"中常量的位或值" @输出名 = "flags">
    变量 用户名 <公开 类型 = 文本指针 注释 = "用户名称的Unicode文本指针" @输出名 = "pUserName">
    变量 邮箱 <公开 类型 = 文本指针 注释 = "用户的邮箱的Unicode文本指针" @输出名 = "pEMail">
    变量 到期日期 <公开 类型 = 无符号整数 注释 = "序列号的有效日期" @输出名 = "dwExpDate">
    变量 更新期限 <公开 类型 = 无符号整数 注释 = "免费更新的期限,程序在此日期前编译的,可以免费使用." @输出名 = "dwMaxBuildDate">
    变量 运行时限 <公开 类型 = 无符号字节 注释 = "从程序运行时开始计算,超过此参数(以分钟为单位)的时间后,将不再允许使用程序;"
            注释 = "注意: VMProtect本身未实现到时限提示或退出程序的功能,需要你自己编程实现," 注释 = "这里只是在序列号里提供了这个状态." @输出名 = "nRunningTimeLimit">
    变量 "//HWID" <公开 类型 = PIV.类型.多字节指针 注释 = "硬件ID的ANSI文本指针" @输出名 = "pHardwareID">
    变量 用户数据长度 <公开 类型 = 变整数 注释 = "用户数据已使用的字节数,最大255字节." @输出名 = "nUserDataLength">
    变量 "//用户数据" <公开 类型 = PIV.类型.无符号字节指针 注释 = "用户数据的字节集指针,实际占用尺寸以\"用户数据长度\"为准." @输出名 = "pUserData">

    方法 HWID <公开 静态 属性读 类型 = 变整数 注释 = "硬件ID的ANSI文本指针" 折叠 @嵌入式方法 = "">
    参数 本结构 <类型 = VMProtectSerialNumberInfo>
    {
        @ (INT_P)@<本结构>.pHardwareID
    }

    方法 HWID <公开 静态 属性写 注释 = "硬件ID的ANSI文本指针" 折叠>
    参数 本结构 <类型 = VMProtectSerialNumberInfo>
    参数 文本指针 <类型 = 变整数>
    {
        @ @<本结构>.pHardwareID = (const char *)@<文本指针>;
    }

    方法 用户数据 <公开 静态 属性读 类型 = 变整数 注释 = "用户数据的字节集指针,实际占用尺寸以\"用户数据长度\"为准." @嵌入式方法 = "">
    参数 本结构 <类型 = VMProtectSerialNumberInfo>
    {
        @ (INT_P)@<本结构>.pUserData
    }

    方法 用户数据 <公开 静态 属性写 注释 = "用户数据的字节集指针,实际占用尺寸以\"用户数据长度\"为准.">
    参数 本结构 <类型 = VMProtectSerialNumberInfo>
    参数 数据指针 <类型 = 变整数>
    {
        @ @<本结构>.pUserData = (const char *)@<数据指针>;
    }

    #
}
