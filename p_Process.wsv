<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv">

类 进程操作类 <公开 注释 = "面向对象操作进程、模块和虚拟内存." 折叠 折叠2 @文档 = "category = \"进程操作\""
        @视窗.外部头文件 = "src\\piv_process.hpp" @视窗.附加编译参数 = "cpp: -DPSAPI_VERSION=1"
        @视窗.后缀文本 = "public PivProcess">
{
    方法 打开进程 <公开 类型 = 逻辑型 注释 = "打开一个进程句柄,使用本类时必须先使用本方法." 注释 = "注: 调用本方法前将关闭之前打开的句柄." 返回值注释 = "返回是否成功" 折叠
            @嵌入式方法 = "">
    参数 进程ID <注释 = "所欲打开的进程ID,0为当前进程ID." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 进程访问权限 <类型 = 整数 注释 = "进程的访问权限,默认为全部权限;" 注释 = "使用进程方法需要对应的权限." @默认值 = 进程访问权限.全部权限>
    {
        @ @sn<this>.open_process(static_cast<DWORD>(@<进程ID>), static_cast<DWORD>(@<进程访问权限>))
    }

    方法 打开句柄 <公开 类型 = 逻辑型 注释 = "将一个外部的进程句柄置入到本类中进行操作." 注释 = "注: 调用本方法前将关闭之前打开的句柄." 返回值注释 = "返回是否成功" 折叠
            @嵌入式方法 = "">
    参数 外部句柄 <注释 = "外部的进程句柄" @匹配类型 = 通用整数型>
    参数 自动关闭句柄 <类型 = 逻辑型 注释 = "是否在类析构时自动关闭外部句柄" @默认值 = 假>
    {
        @ @sn<this>.open_handle(reinterpret_cast<HANDLE>(@<外部句柄>), @<自动关闭句柄>)
    }

    方法 关闭进程 <公开 注释 = "关闭进程的句柄." 注释 = "对象实例离开作用域时会自动关闭,除非有必要提前释放进程句柄,一般不需要手动调用." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.close_process()
    }

    方法 进程句柄 <公开 属性读 类型 = 变整数 注释 = "获取所打开进程的句柄" 返回值注释 = "未打开进程时返回0" 折叠 @嵌入式方法 = "">
    {
        @ reinterpret_cast<ptrdiff_t>(@sn<this>.get_process_handle())
    }

    方法 进程ID <公开 属性读 类型 = 整数 注释 = "获取所打开进程的ID" 返回值注释 = "失败或未打开进程时返回0" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<int32_t>(@sn<this>.get_process_id())
    }

    方法 句柄数量 <公开 属性读 类型 = 整数 注释 = "获取进程已打开的句柄数量" 返回值注释 = "失败或未打开进程时返回0" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(@sn<this>.get_handle_count())
    }

    方法 取创建时间 <公开 类型 = 小数 注释 = "获取进程的创建时间" 返回值注释 = "失败或未打开进程时返回0.0" 折叠 @嵌入式方法 = "">
    参数 时区 <类型 = 整数 注释 = "默认返回北京时间,为0时返回UTC时间." @默认值 = 8>
    {
        @ @sn<this>.get_creation_time(@<时区>)
    }

    方法 取内存使用情况 <公开 类型 = 逻辑型 注释 = "查看进程ID的内存使用情况" 返回值注释 = "返回是否获取成功" 折叠 @禁止流程检查 = 真>
    参数 内存使用情况 <类型 = 进程内存使用情况类 注释 = "成功返回进程详细的内存使用状况">
    {
        @ @<内存使用情况>.ResetToNullObject();
        @ PROCESS_MEMORY_COUNTERS MemCounters {sizeof(PROCESS_MEMORY_COUNTERS)};
        @ if (get_memory_info(&MemCounters))
        @ {
        @     @<内存使用情况>.SetStruct(reinterpret_cast<@dt<进程内存使用情况类>::S*>(&MemCounters));
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 取优先级 <公开 类型 = 进程优先级 注释 = "获取所打开进程的优先级,打开进程时需要提供\"进程访问权限.查询进程信息\"." 返回值注释 = "失败或未打开进程会返回\"进程优先级.异常\""
            折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(@sn<this>.get_priority_class())
    }

    方法 置优先级 <公开 类型 = 逻辑型 注释 = "设置进程的优先级,打开进程时需要提供\"进程访问权限.设置进程信息\"." 返回值注释 = "返回是否成功" 折叠 @嵌入式方法 = "">
    参数 优先级 <类型 = 进程优先级 @默认值 = 进程优先级.正常>
    {
        @ @sn<this>.set_priority_class(static_cast<DWORD>(@<优先级>))
    }

    方法 取进程DEP策略 <公开 类型 = 逻辑型 注释 = "获取32位进程的数据执行保护(DEP)策略,本方法不适用于64位进程(64位进程始终开启DEP且无法禁用)."
            返回值注释 = "返回是否获取成功,64位进程将始终返回假." 折叠 @嵌入式方法 = "">
    参数 DEP设置 <类型 = 整数类 注释 = "获取成功将返回DEP设置(获取失败时始终为0):" 注释 = "  0 当前进程禁用DEP;" 注释 = "  1 当前进程启用DEP;"
            注释 = "  3 当前进程启用DEP,并禁用DEP-ATL thunk emulation">
    参数 是否固定 <类型 = 逻辑型类 注释 = "为真表示当前的DEP设置在进程的整个生命周期是固定的,不可修改;"
            注释 = "为假时可以调用\"置进程DEP策略\"修改DEP策略(只能修改当前32位进程).">
    {
        @ @sn<this>.get_dep_policy(static_cast<DWORD>(@<DEP设置.值>), @<是否固定.值>)
    }

    方法 是否为WOW64模式 <公开 类型 = 逻辑型 注释 = "判断已打开的进程是否运行在WOW64模式."
            注释 = "WOW64(Windows-On-Windows 64bit)是X64 Windows的一个子系统,为32位应用程序提供运行环境." 注释 = "注: 本方法不能用来判断进程和系统位数."
            返回值注释 = "为真表示32位进程运行在64位的系统上,其他情况为假." 折叠 @嵌入式方法 = "">
    参数 查询当前进程 <类型 = 逻辑型 注释 = "为真时表示查询当前程序是否为WOW64模式,为假则表示查询所打开的进程." @默认值 = 假>
    {
        @ @sn<this>.is_wow64(@<查询当前进程>)
    }

    方法 取命令行 <公开 类型 = 文本型 注释 = "获取已打开进程的完整命令行" 返回值注释 = "成功返回命令行(部分进程的命令行是空的),失败始终返回空文本." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.get_commandline()
    }

    方法 取模块句柄 <公开 类型 = 变整数 注释 = "通过模块名称获取模块的句柄" 返回值注释 = "成功返回模块句柄,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块名称 <类型 = 文本型 注释 = "所欲取句柄的模块文件名称(不区分大小写);" 注释 = "如省略扩展名则默认为\".dll\". 结尾为\".\"则表示模块名称没有扩展名;"
            注释 = "该名称可以不包含路径,如果指定路径,必须用反斜杠\"\\\\\";" 注释 = "留空为打开进程的exe文件." @默认值 = 空对象>
    {
        @ reinterpret_cast<INT_P>(@sn<this>.get_module_handle(@<模块名称>.GetText()))
    }

    方法 取模块基址 <公开 类型 = 变整数 注释 = "获取已打开进程中模块文件(.exe或.dll)的基址" 返回值注释 = "成功返回模块基址,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲获取信息的模块句柄" @匹配类型 = 通用整数型>
    {
        @ reinterpret_cast<ptrdiff_t>(@sn<this>.get_module_base (reinterpret_cast<HMODULE>(@<模块句柄>)))
    }

    方法 枚举模块句柄 <公开 类型 = 整数 注释 = "枚举进程中的所有模块句柄" 返回值注释 = "成功返回模块句柄的数量,未打开进程始终返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄数组 <类型 = 变整数数组类 注释 = "成功返回模块句柄数组">
    {
        @ @sn<this>.enum_modules(@<模块句柄数组>.data (), 3)
    }

    方法 枚举模块名称 <公开 类型 = 整数 注释 = "枚举进程中的所有模块句柄和模块文件名" 返回值注释 = "成功返回模块句柄的数量,未打开进程始终返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄数组 <类型 = 变整数数组类 注释 = "成功返回模块句柄数组" @默认值 = 空对象>
    参数 模块名称数组 <类型 = 文本数组类 注释 = "成功返回模块名称数组" @默认值 = 空对象>
    参数 是否完整路径 <类型 = 逻辑型 注释 = "枚举的模块名称是否带完整路径" @默认值 = 真>
    {
        @ @sn<this>.enum_modules(@<模块句柄数组>.data(), @<模块名称数组>.data(), @<是否完整路径>, 3)
    }

    方法 取模块信息 <公开 类型 = 逻辑型 注释 = "获取已打开进程中的模块文件(.exe或.dll)信息" 返回值注释 = "返回是否获取成功,未打开进程始终返回假." @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲获取信息的模块句柄" @匹配类型 = 通用整数型>
    参数 模块信息 <类型 = 模块信息类 注释 = "成功返回模块信息" "">
    {
        @ @sn<this>.get_module_info(reinterpret_cast<HMODULE>(@<模块句柄>), &@<模块信息>)
    }

    方法 取模块名称 <公开 类型 = 文本型 注释 = "获取进程中指定模块句柄的名称(不含路径)" 返回值注释 = "成功返回模块的文件名(不含路径),失败返回空文本." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲获取名称的模块句柄,0为进程的主程序.exe文件." @默认值 = 0 @匹配类型 = 通用整数型>
    {
        @ @sn<this>.get_module_name(reinterpret_cast<HMODULE>(@<模块句柄>))
    }

    方法 取模块文件名 <公开 类型 = 文本型 注释 = "获取进程中指定模块句柄的文件全名(含路径)" 返回值注释 = "成功返回模块的完整文件名(含路径),失败返回空文本." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲获取文件全名的模块句柄,0为进程可执行文件的路径." @默认值 = 0 @匹配类型 = 通用整数型>
    {
        @ @sn<this>.get_module_filename(reinterpret_cast<HMODULE>(@<模块句柄>))
    }

    方法 取模块路径 <公开 类型 = 文本型 注释 = "获取进程中指定模块句柄的无文件名路径" 返回值注释 = "成功返回模块的路径,失败返回空文本." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲获取路径的模块句柄,0为进程可执行文件的路径." @默认值 = 0 @匹配类型 = 通用整数型>
    {
        @ @sn<this>.get_module_path(reinterpret_cast<HMODULE>(@<模块句柄>))
    }

    方法 取内存映射文件 <公开 类型 = 文本型 注释 = "检查指定的地址是否在指定进程的内存映射文件中,如果是则返回内存映射文件的名称."
            注释 = "返回路径中的驱动器为MS-DOS驱动器名称,而非盘符." 注释 = "如果需要转换为盘符路径,请用\"DOS名称路径转盘符路径\"."
            返回值注释 = "成功返回内存映射文件的文件名(含路径),失败返回空文本." 折叠 @嵌入式方法 = "">
    参数 所欲验证地址 <注释 = "所欲验证的虚拟内存地址" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.get_mapped_filename (reinterpret_cast<void*>(@<所欲验证地址>))
    }

    方法 取进程映像文件名 <公开 类型 = 文本型 注释 = "获取进程的映像(可执行文件)文件名." 注释 = "返回路径中的驱动器为MS-DOS驱动器名称,而非盘符."
            注释 = "如果需要转换为盘符路径,请用\"DOS名称路径转盘符路径\"." 返回值注释 = "成功返回映像文件的文件名(含路径),失败返回空文本." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.get_image_filename ()
    }

    方法 创建远程线程 <公开 类型 = 逻辑型 注释 = "远程在进程中创建线程.首先尝试使用NtCreateThreadEx," 注释 = "不成功则使用CreateRemoteThread."
            返回值注释 = "返回是否创建线程成功" 折叠 @嵌入式方法 = "">
    参数 函数指针 <@匹配类型 = 通用整数型>
    参数 参数指针 <@匹配类型 = 通用整数型>
    参数 是否等待 <类型 = 逻辑型 注释 = "指定本方法是否一直等待线程执行完毕后才会返回" @默认值 = 假>
    {
        @ @sn<this>.create_remote_thread (reinterpret_cast<void*>(@<函数指针>), reinterpret_cast<void*>(@<参数指针>), @<是否等待>)
    }

    # 进程内存操作

    方法 分配虚拟内存 <公开 类型 = 变整数 注释 = "在进程的虚拟空间保留或提交内存区域,除非指定MEM_RESET参数," 注释 = "否则将该内存区域置0."
            返回值注释 = "成功返回虚拟内存的地址,失败返回0." 折叠 @嵌入式方法 = "">
    参数 内存地址 <注释 = "指定分配的目标地址,该地址必须是未初始化的;" 注释 = "一般请置为0,由系统自带分配地址." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 分配大小 <注释 = "所欲分配的内存区域大小(字节单位)." @匹配类型 = 通用整数型>
    参数 分配类型 <类型 = 整数 注释 = "请提供\"内存操作类型\"的一个常量或多个常量的位或值;" 注释 = "默认值为(MEM_COMMIT | MEM_RESERVE)."
            @默认值 = 12288>
    参数 保护类型 <类型 = 整数 注释 = "请提供\"内存页面保护属性\"的一个常量或多个常量的位或值." @默认值 = 内存页面保护属性.可执行_读写>
    {
        @ reinterpret_cast<ptrdiff_t>(@sn<this>.virtual_alloc(reinterpret_cast<void*>(@<内存地址>), static_cast<size_t>(@<分配大小>), static_cast<DWORD>(@<分配类型>), static_cast<DWORD>(@<保护类型>)))
    }

    方法 释放虚拟内存 <公开 类型 = 逻辑型 注释 = "释放、取消提交虚拟地址空间内的内存区域." 返回值注释 = "返回是否成功" 折叠 @嵌入式方法 = "">
    参数 内存地址 <注释 = "所欲释放内存区域的起始地址;" 注释 = "如果\"释放类型\"为\"释放内存/MEM_RELEASE\",则本参数必须是保留区域时"
            注释 = "由\"分配虚拟内存/VirtualAllocEx\"返回的基址." @匹配类型 = 通用整数型>
    参数 内存大小 <注释 = "所欲释放的内存区域大小(字节单位);" 注释 = "  如果\"释放类型\"为\"释放内存/MEM_RELEASE\",则本参数必须为0,本函数将"
            注释 = "释放由调用\"分配虚拟内存/VirtualAllocEx\"保留的整个区域;" 注释 = "  如果\"释放类型\"为\"取消提交/MEM_DECOMMIT\",则本函数将取消提交从\"区"
            注释 = "域地址\"到本区域大小的所有内存页.若\"区域地址\"为\"分配虚拟内存\"返回的" 注释 = "基址且本参数为0,则取消提交之前分配的整个区域;" @默认值 = 0
            @匹配类型 = 通用整数型>
    参数 释放类型 <类型 = 整数 注释 = "请提供\"内存操作类型\"的一个常量或多个常量的位或值" @默认值 = 内存操作类型.释放内存>
    {
        @ @sn<this>.virtual_free(reinterpret_cast<void*>(@<内存地址>), static_cast<size_t>(@<内存大小>), static_cast<DWORD>(@<释放类型>))
    }

    方法 修改内存保护 <公开 类型 = 整数 注释 = "修改进程虚拟地址空间中已提交页区域的保护属性" 返回值注释 = "成功返回修改前的保护属性,失败返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲修改的地址 <注释 = "所欲修改内存保护属性的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲修改的长度 <注释 = "所欲修改内存保护属性的长度" @匹配类型 = 通用整数型>
    参数 新的内存保护属性 <类型 = 整数 注释 = "默认值为可执行和可读写权限,其余属性请参考\"内存页面保护属性\"的常量." @默认值 = 内存页面保护属性.可执行_读写>
    {
        @ @sn<this>.modify_memory_protect(reinterpret_cast<void*>(@<所欲修改的地址>), static_cast<size_t>(@<所欲修改的长度>), static_cast<DWORD>(@<新的内存保护属性>))
    }

    方法 寻找内存特征码 <公开 类型 = 变整数 注释 = "Sunday算法实现内存快速搜索特征码(支持通配符模糊搜索)." 注释 = "本方法只返回找到的一个地址."
            返回值注释 = "返回找到的虚拟内存地址,未找到则返回0." 折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 特征码 <类型 = 文本型 注释 = "十六进制文本,中间的空格可以省略,支持通配符?" 注释 = "例如\"BA ?? 00 B4 09 ?? 21\"">
    参数 起始地址 <注释 = "搜索的起始位置" @默认值 = 0 @匹配类型 = 通用整数型>
    参数 结束地址 <注释 = "搜索的结束位置,默认搜索整个虚拟内存;" 注释 = "0则为进程所有模块的地址尾部,可能会找不到部分数据." @默认值 = -1 @匹配类型 = 通用整数型>
    参数 指定保护属性 <类型 = 整数 注释 = "是否仅寻找指定保护属性的内存地址,0为寻找全部保护属性;" 注释 = "请参考\"内存页面保护属性\"的常量." @默认值 = 0>
    参数 指定页面类型 <类型 = 整数 注释 = "是否仅寻找指定页面类型的内存地址,0为寻找全部类型;" 注释 = "请参考\"内存页面类型\"的常量." @默认值 = 0>
    {
        @ @sn<this>.find_signatures(@<特征码>, reinterpret_cast<const void*>(@<起始地址>), reinterpret_cast<const void*>(@<结束地址>), static_cast<DWORD>(@<指定保护属性>), static_cast<DWORD>(@<指定页面类型>))
    }

    方法 寻找内存字节集 <公开 类型 = 变整数 注释 = "在进程的虚拟内存中寻找指定的字节集数据,本方法只返回找到的一个地址." 返回值注释 = "返回找到的虚拟内存地址,未找到则返回0." 折叠
            @嵌入式方法 = "">
    参数 所欲寻找的字节集 <类型 = 字节集类 注释 = "所欲寻找的字节集">
    参数 起始地址 <注释 = "搜索的起始位置" @默认值 = 0 @匹配类型 = 通用整数型>
    参数 结束地址 <注释 = "搜索的结束位置,默认搜索整个虚拟内存;" 注释 = "0则为进程所有模块的地址尾部,可能会找不到部分数据." @默认值 = -1 @匹配类型 = 通用整数型>
    参数 指定保护属性 <类型 = 整数 注释 = "是否仅寻找指定保护属性的内存地址,0为寻找全部保护属性;" 注释 = "请参考\"内存页面保护属性\"的常量." @默认值 = 0>
    参数 指定页面类型 <类型 = 整数 注释 = "是否仅寻找指定页面类型的内存地址,0为寻找全部类型;" 注释 = "请参考\"内存页面类型\"的常量." @默认值 = 0>
    {
        @ @sn<this>.find_memory(@<所欲寻找的字节集>, reinterpret_cast<const void*>(@<起始地址>), reinterpret_cast<const void*>(@<结束地址>), static_cast<DWORD>(@<指定保护属性>), static_cast<DWORD>(@<指定页面类型>))
    }

    方法 寻找所有内存特征码 <公开 类型 = 整数 注释 = "Sunday算法实现内存快速搜索特征码(支持通配符模糊搜索)." 返回值注释 = "返回找到的虚拟内存地址数量,未找到则返回0." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 特征码 <类型 = 文本型 注释 = "十六进制文本,中间的空格可以省略,支持通配符?" 注释 = "例如\"BA ?? 00 B4 09 ?? 21\"">
    参数 结果地址数组 <类型 = 变整数数组类 注释 = "在此返回所有找到的虚拟内存地址">
    参数 起始地址 <注释 = "搜索的起始位置" @默认值 = 0 @匹配类型 = 通用整数型>
    参数 结束地址 <注释 = "搜索的结束位置,搜索的结束位置,默认搜索整个虚拟内存;" 注释 = "0则为进程所有模块的地址尾部,可能会找不到部分数据." @默认值 = -1 @匹配类型 = 通用整数型>
    参数 指定保护属性 <类型 = 整数 注释 = "是否仅寻找指定保护属性的内存地址,0为寻找全部保护属性;" 注释 = "请参考\"内存页面保护属性\"的常量." @默认值 = 0>
    参数 指定页面类型 <类型 = 整数 注释 = "是否仅寻找指定页面类型的内存地址,0为寻找全部类型;" 注释 = "请参考\"内存页面类型\"的常量." @默认值 = 0>
    {
        @ @sn<this>.find_signatures(@<特征码>, @<结果地址数组>.data(), reinterpret_cast<const void*>(@<起始地址>), reinterpret_cast<const void*>(@<结束地址>), static_cast<DWORD>(@<指定保护属性>), static_cast<DWORD>(@<指定页面类型>))
    }

    方法 寻找所有内存字节集 <公开 类型 = 整数 注释 = "在进程的虚拟内存中寻找指定的字节集数据" 返回值注释 = "返回找到的虚拟内存地址数量,未找到则返回0." 折叠 @嵌入式方法 = "">
    参数 所欲寻找的字节集 <类型 = 字节集类 注释 = "所欲寻找的字节集">
    参数 结果地址数组 <类型 = 变整数数组类 注释 = "在此返回所有找到的虚拟内存地址">
    参数 起始地址 <注释 = "搜索的起始位置" @默认值 = 0 @匹配类型 = 通用整数型>
    参数 结束地址 <注释 = "搜索的结束位置,默认搜索整个虚拟内存;" 注释 = "0则为进程所有模块的地址尾部,可能会找不到部分数据." @默认值 = -1 @匹配类型 = 通用整数型>
    参数 指定保护属性 <类型 = 整数 注释 = "是否仅寻找指定保护属性的内存地址,0为寻找全部保护属性;" 注释 = "请参考\"内存页面保护属性\"的常量." @默认值 = 0>
    参数 指定页面类型 <类型 = 整数 注释 = "是否仅寻找指定页面类型的内存地址,0为寻找全部类型;" 注释 = "请参考\"内存页面类型\"的常量." @默认值 = 0>
    {
        @ @sn<this>.find_memory(@<所欲寻找的字节集>, @<结果地址数组>.data(), reinterpret_cast<const void*>(@<起始地址>), reinterpret_cast<const void*>(@<结束地址>), static_cast<DWORD>(@<指定保护属性>), static_cast<DWORD>(@<指定页面类型>))
    }

    方法 读内存数值 <公开 类型 = 逻辑型 注释 = "读取进程中指定虚拟地址的数值型数据,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 存放读取的值 <注释 = "成功后在此参数中保存所读取的数值,支持所有的数值类型." @匹配类型 = 通用数值型 @需求类型 = 可写入变量>
    {
        @ @sn<this>.read_memory_num(reinterpret_cast<const void*>(@<所欲读取的地址>), @<存放读取的值>)
    }

    方法 读内存数据 <公开 类型 = 逻辑型 注释 = "读取进程中指定虚拟地址的内存数据,并保存到指定的地址中." 返回值注释 = "返回是否读取成功" 折叠 @嵌入式方法 = "">
    参数 保存数据的地址 <注释 = "读取的数据保存在此地址中,请确保该地址分配了足够的空间." @匹配类型 = 通用整数型>
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲读取的长度 <注释 = "所欲读取的内存数据长度" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory(reinterpret_cast<void*>(@<保存数据的地址>), reinterpret_cast<const void*>(@<所欲读取的地址>), static_cast<size_t>(@<所欲读取的长度>))
    }

    方法 写内存数据 <公开 类型 = 逻辑型 注释 = "进程中指定的虚拟地址中写入数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <注释 = "所欲写入的内存数据" @匹配类型 = 通用整数型>
    参数 所欲写入的长度 <注释 = "所欲写入的内存数据长度" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.write_memory(reinterpret_cast<void*>(@<所欲写入的地址>), reinterpret_cast<const void*>(@<所欲写入的数据>), static_cast<size_t>(@<所欲写入的长度>))
    }

    方法 读内存字节集 <公开 类型 = 字节集类 注释 = "读取进程中指定虚拟地址的内存数据,并保存到字节集中." 返回值注释 = "成功返回读取的字节集,失败返回空字节集." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲读取的长度 <注释 = "所欲读取的内存数据长度" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory(reinterpret_cast<const void*>(@<所欲读取的地址>), static_cast<size_t>(@<所欲读取的长度>))
    }

    方法 写内存字节集 <公开 类型 = 逻辑型 注释 = "用字节集改写进程中指定虚拟地址的内存数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 字节集类 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_memory(reinterpret_cast<void*>(@<所欲写入的地址>), @<所欲写入的数据>)
    }

    方法 读内存字节 <公开 类型 = 字节 注释 = "读取进程中指定虚拟地址的字节数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory_value<S_BYTE>(reinterpret_cast<const void*>(@<所欲读取的地址>))
    }

    方法 写内存字节 <公开 类型 = 逻辑型 注释 = "改写进程中指定虚拟地址的字节数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 字节 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_memory_value<S_BYTE>(reinterpret_cast<void*>(@<所欲写入的地址>), @<所欲写入的数据>)
    }

    方法 读内存短整数 <公开 类型 = 短整数 注释 = "读取进程中指定虚拟地址的短整数数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory_value<SHORT>(reinterpret_cast<const void*>(@<所欲读取的地址>))
    }

    方法 写内存短整数 <公开 类型 = 逻辑型 注释 = "改写进程中指定虚拟地址的短整数数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 短整数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_memory_value<SHORT>(reinterpret_cast<void*>(@<所欲写入的地址>), @<所欲写入的数据>)
    }

    方法 读内存整数 <公开 类型 = 整数 注释 = "读取进程中指定虚拟地址的整数数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory_value<INT>(reinterpret_cast<const void*>(@<所欲读取的地址>))
    }

    方法 写内存整数 <公开 类型 = 逻辑型 注释 = "改写进程中指定虚拟地址的整数数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 整数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_memory_value<INT>(reinterpret_cast<void*>(@<所欲写入的地址>), @<所欲写入的数据>)
    }

    方法 读内存长整数 <公开 类型 = 长整数 注释 = "读取进程中指定虚拟地址的长整数数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory_value<INT64>(reinterpret_cast<const void*>(@<所欲读取的地址>))
    }

    方法 写内存长整数 <公开 类型 = 逻辑型 注释 = "改写进程中指定虚拟地址的长整数数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 长整数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_memory_value<INT64>(reinterpret_cast<void*>(@<所欲写入的地址>), @<所欲写入的数据>)
    }

    方法 读内存变整数 <公开 类型 = 变整数 注释 = "读取进程中指定虚拟地址的变整数数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory_value<INT_P>(reinterpret_cast<const void*>(@<所欲读取的地址>))
    }

    方法 写内存变整数 <公开 类型 = 逻辑型 注释 = "改写进程中指定虚拟地址的变整数数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 变整数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_memory_value<INT_P>(reinterpret_cast<void*>(@<所欲写入的地址>), @<所欲写入的数据>)
    }

    方法 读内存小数 <公开 类型 = 小数 注释 = "读取进程中指定虚拟地址的双精度小数" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory_value<double>(reinterpret_cast<const void*>(@<所欲读取的地址>))
    }

    方法 写内存小数 <公开 类型 = 逻辑型 注释 = "改写进程中指定虚拟地址的双精度小数" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 小数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_memory_value<double>(reinterpret_cast<void*>(@<所欲写入的地址>), @<所欲写入的数据>)
    }

    方法 读内存单精度小数 <公开 类型 = 单精度小数 注释 = "读取进程中指定虚拟地址的单精度小数" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory_value<float>(reinterpret_cast<const void*>(@<所欲读取的地址>))
    }

    方法 写内存单精度小数 <公开 类型 = 逻辑型 注释 = "改写进程中指定虚拟地址的单精度小数" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 单精度小数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_memory_value<float>(reinterpret_cast<void*>(@<所欲写入的地址>), @<所欲写入的数据>)
    }

    # 模块文件的内存操作

    方法 寻找模块特征码 <公开 类型 = 变整数 注释 = "Sunday算法实现内存快速搜索特征码(支持通配符模糊搜索)." 返回值注释 = "返回找到的虚拟内存地址,未找到则返回0." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 特征码 <类型 = 文本型 注释 = "十六进制文本,中间的空格可以省略,支持通配符?" 注释 = "例如\"BA ?? 00 B4 09 ?? 21\"">
    参数 起始偏移地址 <注释 = "搜索的起始偏移位置,0为模块的基地址,实际地址为模块的虚拟内存基址+偏移地址;" 注释 = "如果提供的偏移地址大于模块尺寸,将返回失败." @默认值 = 0
            @匹配类型 = 通用整数型>
    参数 结束偏移地址 <注释 = "搜索的结束偏移位置,默认值0表示搜索到模块文件的结尾,实际地址为模块的虚拟" 注释 = "内存基址+偏移地址;" 注释 = "如果提供的偏移地址大于模块尺寸,将返回失败."
            @默认值 = 0 @匹配类型 = 通用整数型>
    参数 指定保护属性 <类型 = 整数 注释 = "是否仅寻找指定保护属性的内存地址,0为寻找全部保护属性;" 注释 = "请参考\"内存页面保护属性\"的常量." @默认值 = 0>
    参数 指定页面类型 <类型 = 整数 注释 = "是否仅寻找指定页面类型的内存地址,0为寻找全部类型;" 注释 = "请参考\"内存页面类型\"的常量." @默认值 = 0>
    {
        @ @sn<this>.find_module_signatures(reinterpret_cast<HMODULE>(@<模块句柄>), @<特征码>, static_cast<size_t>(@<起始偏移地址>), static_cast<size_t>(@<结束偏移地址>), static_cast<DWORD>(@<指定保护属性>), static_cast<DWORD>(@<指定页面类型>))
    }

    方法 寻找模块字节集 <公开 类型 = 变整数 注释 = "在模块的虚拟内存中寻找指定的字节集数据" 返回值注释 = "返回找到的虚拟内存地址,未找到则返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲寻找的字节集 <类型 = 字节集类 注释 = "所欲寻找的字节集.">
    参数 起始偏移地址 <注释 = "搜索的起始偏移位置,0为模块的基地址,实际地址为模块的虚拟内存基址+偏移地址;" 注释 = "如果提供的偏移地址大于模块尺寸,将返回失败." @默认值 = 0
            @匹配类型 = 通用整数型>
    参数 结束偏移地址 <注释 = "搜索的结束偏移位置,默认值0表示搜索到模块文件的结尾,实际地址为模块的虚拟" 注释 = "内存基址+偏移地址;" 注释 = "如果提供的偏移地址大于模块尺寸,将返回失败."
            @默认值 = 0 @匹配类型 = 通用整数型>
    参数 指定保护属性 <类型 = 整数 注释 = "是否仅寻找指定保护属性的内存地址,0为寻找全部保护属性;" 注释 = "请参考\"内存页面保护属性\"的常量." @默认值 = 0>
    参数 指定页面类型 <类型 = 整数 注释 = "是否仅寻找指定页面类型的内存地址,0为寻找全部类型;" 注释 = "请参考\"内存页面类型\"的常量." @默认值 = 0>
    {
        @ @sn<this>.find_module_memory(reinterpret_cast<HMODULE>(@<模块句柄>), @<所欲寻找的字节集>, static_cast<size_t>(@<起始偏移地址>), static_cast<size_t>(@<结束偏移地址>), static_cast<DWORD>(@<指定保护属性>), static_cast<DWORD>(@<指定页面类型>))
    }

    方法 寻找所有模块特征码 <公开 类型 = 整数 注释 = "Sunday算法实现内存快速搜索特征码(支持通配符模糊搜索)." 返回值注释 = "返回找到的虚拟内存地址数量,未找到则返回0." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 特征码 <类型 = 文本型 注释 = "十六进制文本,中间的空格可以省略,支持通配符?" 注释 = "例如\"BA ?? 00 B4 09 ?? 21\"">
    参数 结果地址数组 <类型 = 变整数数组类 注释 = "在此返回所有找到的虚拟内存地址.">
    参数 起始偏移地址 <注释 = "搜索的起始偏移位置,0为模块的基地址,实际地址为模块的虚拟内存基址+偏移地址;" 注释 = "如果提供的偏移地址大于模块尺寸,将返回失败." @默认值 = 0
            @匹配类型 = 通用整数型>
    参数 结束偏移地址 <注释 = "搜索的结束偏移位置,默认值0表示搜索到模块文件的结尾,实际地址为模块的虚拟" 注释 = "内存基址+偏移地址;" 注释 = "如果提供的偏移地址大于模块尺寸,将返回失败."
            @默认值 = 0 @匹配类型 = 通用整数型>
    参数 指定保护属性 <类型 = 整数 注释 = "是否仅寻找指定保护属性的内存地址,0为寻找全部保护属性;" 注释 = "请参考\"内存页面保护属性\"的常量." @默认值 = 0>
    参数 指定页面类型 <类型 = 整数 注释 = "是否仅寻找指定页面类型的内存地址,0为寻找全部类型;" 注释 = "请参考\"内存页面类型\"的常量." @默认值 = 0>
    {
        @ @sn<this>.find_module_signatures(reinterpret_cast<HMODULE>(@<模块句柄>), @<特征码>, @<结果地址数组>.data (), static_cast<size_t>(@<起始偏移地址>),
        @     static_cast<size_t>(@<结束偏移地址>), static_cast<DWORD>(@<指定保护属性>), static_cast<DWORD>(@<指定页面类型>))
    }

    方法 寻找所有模块字节集 <公开 类型 = 整数 注释 = "在模块的虚拟内存中寻找指定的字节集数据" 返回值注释 = "返回找到的虚拟内存地址数量,未找到则返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲寻找的字节集 <类型 = 字节集类 注释 = "所欲寻找的字节集">
    参数 结果地址数组 <类型 = 变整数数组类 注释 = "在此返回所有找到的虚拟内存地址">
    参数 起始偏移地址 <注释 = "搜索的起始偏移位置,0为模块的基地址,实际地址为模块的虚拟内存基址+偏移地址;" 注释 = "如果提供的偏移地址大于模块尺寸,将返回失败." @默认值 = 0
            @匹配类型 = 通用整数型>
    参数 结束偏移地址 <注释 = "搜索的结束偏移位置,默认值0表示搜索到模块文件的结尾,实际地址为模块的虚拟" 注释 = "内存基址+偏移地址;" 注释 = "如果提供的偏移地址大于模块尺寸,将返回失败."
            @默认值 = 0 @匹配类型 = 通用整数型>
    参数 指定保护属性 <类型 = 整数 注释 = "是否仅寻找指定保护属性的内存地址,0为寻找全部保护属性;" 注释 = "请参考\"内存页面保护属性\"的常量." @默认值 = 0>
    参数 指定页面类型 <类型 = 整数 注释 = "是否仅寻找指定页面类型的内存地址,0为寻找全部类型;" 注释 = "请参考\"内存页面类型\"的常量." @默认值 = 0>
    {
        @ @sn<this>.find_module_memory(reinterpret_cast<HMODULE>(@<模块句柄>), @<所欲寻找的字节集>, @<结果地址数组>.data (), static_cast<size_t>(@<起始偏移地址>),
        @     static_cast<size_t>(@<结束偏移地址>), static_cast<DWORD>(@<指定保护属性>), static_cast<DWORD>(@<指定页面类型>))
    }

    方法 读模块数值 <公开 类型 = 逻辑型 注释 = "读取模块中指定虚拟地址的数值型数据,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 存放读取的值 <注释 = "成功后在此参数中保存所读取的数值,支持所有的数值类型." @匹配类型 = 通用数值型 @需求类型 = 可写入变量>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_num(reinterpret_cast<HMODULE>(@<模块句柄>), @<存放读取的值>, static_cast<size_t>(@<所欲读取的偏移地址>))
    }

    方法 读模块数据 <公开 类型 = 逻辑型 注释 = "读取模块中指定虚拟地址的内存数据,并保存到指定的地址中." 返回值注释 = "返回是否读取成功." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 保存数据的地址 <注释 = "读取的数据保存在此地址中,请确保该地址分配了足够的空间." @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲读取的长度 <注释 = "所欲读取的内存数据长度" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_memory(reinterpret_cast<HMODULE>(@<模块句柄>), reinterpret_cast<void*>(@<保存数据的地址>), static_cast<size_t>(@<所欲读取的偏移地址>), static_cast<size_t>(@<所欲读取的长度>))
    }

    方法 写模块数据 <公开 类型 = 逻辑型 注释 = "用字节集改写模块中指定虚拟地址的内存数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <注释 = "所欲写入的内存数据" @匹配类型 = 通用整数型>
    参数 所欲写入的长度 <注释 = "所欲写入的内存数据长度" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.write_module_memory(reinterpret_cast<HMODULE>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), reinterpret_cast<const void*>(@<所欲写入的数据>), static_cast<size_t>(@<所欲写入的长度>))
    }

    方法 读模块字节集 <公开 类型 = 字节集类 注释 = "读取模块中指定虚拟地址的内存数据,并保存到字节集中." 返回值注释 = "成功返回读取的字节集,失败返回空字节集." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲读取的长度 <注释 = "所欲读取的内存数据长度" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_memory(reinterpret_cast<HMODULE>(@<模块句柄>), static_cast<size_t>(@<所欲读取的偏移地址>), @<所欲读取的长度>)
    }

    方法 写模块字节集 <公开 类型 = 逻辑型 注释 = "用字节集改写模块中指定虚拟地址的内存数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 字节集类 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_module_memory(reinterpret_cast<HMODULE>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), @<所欲写入的数据>)
    }

    方法 读模块字节 <公开 类型 = 字节 注释 = "读取模块中指定虚拟地址的字节数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_value<S_BYTE>(reinterpret_cast<HMODULE>(@<模块句柄>), static_cast<size_t>(@<所欲读取的偏移地址>))
    }

    方法 写模块字节 <公开 类型 = 逻辑型 注释 = "改写模块中指定虚拟地址的字节数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 字节 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_module_value<S_BYTE>(reinterpret_cast<HMODULE>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), @<所欲写入的数据>)
    }

    方法 读模块短整数 <公开 类型 = 短整数 注释 = "读取模块中指定虚拟地址的短整数数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_value<SHORT>(reinterpret_cast<HMODULE>(@<模块句柄>), static_cast<size_t>(@<所欲读取的偏移地址>))
    }

    方法 写模块短整数 <公开 类型 = 逻辑型 注释 = "改写模块中指定虚拟地址的短整数数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 短整数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_module_value<SHORT>(reinterpret_cast<HMODULE>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), @<所欲写入的数据>)
    }

    方法 读模块整数 <公开 类型 = 整数 注释 = "读取模块中指定虚拟地址的整数数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_value<INT>(reinterpret_cast<HMODULE>(@<模块句柄>), static_cast<size_t>(@<所欲读取的偏移地址>))
    }

    方法 写模块整数 <公开 类型 = 逻辑型 注释 = "改写模块中指定虚拟地址的整数数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 整数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_module_value<INT>(reinterpret_cast<HMODULE>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), @<所欲写入的数据>)
    }

    方法 读模块长整数 <公开 类型 = 长整数 注释 = "读取模块中指定虚拟地址的长整数数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_value<INT64>(reinterpret_cast<HMODULE>(@<模块句柄>), static_cast<size_t>(@<所欲读取的偏移地址>))
    }

    方法 写模块长整数 <公开 类型 = 逻辑型 注释 = "改写模块中指定虚拟地址的长整数数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 长整数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_module_value<INT64>(reinterpret_cast<HMODULE>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), @<所欲写入的数据>)
    }

    方法 读模块变整数 <公开 类型 = 变整数 注释 = "读取模块中指定虚拟地址的变整数数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_value<INT_P>(reinterpret_cast<HMODULE>(@<模块句柄>), static_cast<size_t>(@<所欲读取的偏移地址>))
    }

    方法 写模块变整数 <公开 类型 = 逻辑型 注释 = "改写模块中指定虚拟地址的变整数数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 变整数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_module_value<INT_P>(reinterpret_cast<HMODULE>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), @<所欲写入的数据>)
    }

    方法 读模块小数 <公开 类型 = 小数 注释 = "读取模块中指定虚拟地址的双精度小数值" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_value<double>(reinterpret_cast<HMODULE>(@<模块句柄>), static_cast<size_t>(@<所欲读取的偏移地址>))
    }

    方法 写模块小数 <公开 类型 = 逻辑型 注释 = "改写模块中指定虚拟地址的双精度小数值" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 小数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_module_value<double>(reinterpret_cast<HMODULE>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), @<所欲写入的数据>)
    }

    方法 读模块单精度小数 <公开 类型 = 单精度小数 注释 = "读取模块中指定虚拟地址的单精度小数值" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_value<float>(reinterpret_cast<HMODULE>(@<模块句柄>), static_cast<size_t>(@<所欲读取的偏移地址>))
    }

    方法 写模块单精度小数 <公开 类型 = 逻辑型 注释 = "改写模块中指定虚拟地址的单精度小数值" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 单精度小数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_module_value<float>(reinterpret_cast<HMODULE>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), @<所欲写入的数据>)
    }
}

类 NT进程操作类 <公开 注释 = "使用NT API,面向对象操作进程、模块和虚拟内存.本类可以在32位程序操作64位进程." 折叠 折叠2 @文档 = "category = \"进程操作\""
        @视窗.外部头文件 = "src\\piv_NtProcess.hpp" @视窗.后缀文本 = "public PivProcessNT">
{
    方法 打开进程 <公开 类型 = 逻辑型 注释 = "打开一个进程句柄,使用本类时必须先使用本方法." 注释 = "注: 调用本方法前将关闭之前打开的句柄." 返回值注释 = "返回是否成功" 折叠
            @嵌入式方法 = "">
    参数 进程ID <注释 = "所欲打开的进程ID,0为当前进程ID." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 进程访问权限 <类型 = 整数 注释 = "进程的访问权限,默认为全部权限;" 注释 = "使用进程方法需要对应的权限." @默认值 = 进程访问权限.全部权限>
    参数 是否提权 <类型 = 逻辑型 注释 = "将当前程序的权限提升至调试级别;" 注释 = "如果打开进程失败,可以将本参数设置为真后重试." @默认值 = 假>
    {
        @ @sn<this>.open_process(static_cast<DWORD>(@<进程ID>), static_cast<DWORD>(@<进程访问权限>), @<是否提权>)
    }

    方法 关闭进程 <公开 注释 = "关闭进程的句柄." 注释 = "对象实例离开作用域时会自动关闭,除非有必要提前释放进程句柄,一般不需要手动调用." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.close_process()
    }

    方法 进程句柄 <公开 属性读 类型 = 变整数 注释 = "获取所打开进程的句柄" 返回值注释 = "未打开进程时返回0" 折叠 @嵌入式方法 = "">
    {
        @ reinterpret_cast<ptrdiff_t>(@sn<this>.get_process_handle())
    }

    方法 进程ID <公开 属性读 类型 = 整数 注释 = "获取所打开进程的ID" 返回值注释 = "失败或未打开进程时返回0" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<int32_t>(@sn<this>.get_process_id())
    }

    方法 句柄数量 <公开 属性读 类型 = 整数 注释 = "获取进程已打开的句柄数量" 返回值注释 = "失败或未打开进程时返回0" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(@sn<this>.get_handle_count())
    }

    方法 进程基址 <公开 属性读 类型 = 长整数 注释 = "获取进程加载的基地址" 返回值注释 = "失败或未打开进程时返回0" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT64>(@sn<this>.get_base_address())
    }

    方法 取创建时间 <公开 类型 = 小数 注释 = "获取进程的创建时间,失败或未打开进程时返回0.0" 折叠 @嵌入式方法 = "">
    参数 时区偏差 <类型 = 整数 注释 = "提供UTC和本地时间之间的偏差(以分钟计),0为UTC时间;" 注释 = "默认返回系统本地时区的时区." @默认值 = 数值范围.最大整数值>
    {
        @ @sn<this>.get_creation_time(@<时区偏差>)
    }

    方法 取内存使用情况 <公开 类型 = 逻辑型 注释 = "查看进程ID的内存使用情况" 返回值注释 = "返回是否获取成功" 折叠 @禁止流程检查 = 真>
    参数 内存使用情况 <类型 = 进程内存使用情况类 注释 = "成功返回进程详细的内存使用状况">
    {
        @ @<内存使用情况>.ResetToNullObject();
        @ @dt<进程内存使用情况类>::S MemCounters{sizeof(@dt<进程内存使用情况类>::S)};
        @ if (get_memory_info((void*)&MemCounters, sizeof(MemCounters)))
        @ {
        @     @<内存使用情况>.SetStruct(&MemCounters);
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 取优先级 <公开 类型 = 进程优先级 注释 = "获取所打开进程的优先级,打开进程时需要提供\"进程访问权限.查询进程信息\"." 返回值注释 = "失败或未打开进程会返回\"进程优先级.异常\""
            折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(@sn<this>.get_priority_class())
    }

    方法 置优先级 <公开 类型 = 逻辑型 注释 = "设置进程的优先级,打开进程时需要提供\"进程访问权限.设置进程信息\"." 返回值注释 = "返回是否成功" 折叠 @嵌入式方法 = "">
    参数 优先级 <类型 = 进程优先级 @默认值 = 进程优先级.正常>
    {
        @ @sn<this>.set_priority_class(static_cast<DWORD>(@<优先级>))
    }

    方法 取进程DEP策略 <公开 类型 = 逻辑型 注释 = "获取32位进程的数据执行保护(DEP)策略,本方法不适用于64位进程(64位进程始终开启DEP且无法禁用)."
            返回值注释 = "返回是否获取成功,64位进程将始终返回假." 折叠 @嵌入式方法 = "">
    参数 DEP设置 <类型 = 整数类 注释 = "获取成功将返回DEP设置(获取失败时始终为0):" 注释 = "  0 当前进程禁用DEP;" 注释 = "  1 当前进程启用DEP;"
            注释 = "  3 当前进程启用DEP,并禁用DEP-ATL thunk emulation">
    参数 是否固定 <类型 = 逻辑型类 注释 = "为真表示当前的DEP设置在进程的整个生命周期是固定的,不可修改;"
            注释 = "为假时可以调用\"置进程DEP策略\"修改DEP策略(只能修改当前32位进程).">
    {
        @ @sn<this>.get_dep_policy(static_cast<DWORD>(@<DEP设置.值>), @<是否固定.值>)
    }

    方法 是否为WOW64模式 <公开 类型 = 逻辑型 注释 = "判断已打开的进程是否运行在WOW64模式."
            注释 = "WOW64(Windows-On-Windows 64bit)是X64 Windows的一个子系统,为32位应用程序提供运行环境." 注释 = "注: 本方法不能用来判断系统位数."
            返回值注释 = "为真表示32位进程运行在64位的系统上,其他情况为假." 折叠 @嵌入式方法 = "">
    参数 查询当前进程 <类型 = 逻辑型 注释 = "为真时表示查询当前程序是否为WOW64模式,为假则表示查询所打开的进程." @默认值 = 假>
    {
        @ @sn<this>.is_wow64(@<查询当前进程>)
    }

    方法 取命令行 <公开 类型 = 文本型 注释 = "获取已打开进程的完整命令行" 返回值注释 = "成功返回命令行(部分进程的命令行是空的),失败始终返回空文本." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.get_commandline()
    }

    方法 取环境变量 <公开 类型 = 整数 注释 = "获取已打开进程的所有环境变量" 返回值注释 = "返回环境变量数量" 折叠 @嵌入式方法 = "">
    参数 环境变量数组 <类型 = 文本数组类 注释 = "所获取的全部环境变量将保存在此数组中,每个成员为一个环境变量;"
            注释 = "环境变量由变量和值组成,它们之间用\'=\'分隔,还可以用\';\'分隔出多个值." 注释 = "比如: \"ALLUSERSPROFILE=C:\\\\ProgramData\"">
    {
        @ @sn<this>.get_environment(@<环境变量数组>.data())
    }

    方法 取模块句柄 <公开 类型 = 长整数 注释 = "通过模块名称获取模块的句柄" 返回值注释 = "成功返回模块句柄,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块名称 <类型 = 文本型 注释 = "所欲取句柄的模块文件名称(不区分大小写);" 注释 = "该名称可以不包含路径,如果指定路径,必须用反斜杠\"\\\\\";"
            注释 = "留空为打开进程的exe文件." @默认值 = 空对象>
    参数 强制刷新 <类型 = 逻辑型 注释 = "是否重新枚举所有模块;" 注释 = "本类在打开进程时枚举和缓存了所有模块信息,本方法从这些信息中获取结果;"
            注释 = "只有在进程加载或卸载了模块后,才有必要将本参数设置为真." @默认值 = 假>
    {
        @ static_cast<INT64>(@sn<this>.get_module_handle(@<模块名称>, @<强制刷新>))
    }

    方法 取模块基址 <公开 类型 = 长整数 注释 = "获取已打开进程中模块文件(.exe或.dll)的基址." 注释 = "注: 模块句柄==模块基址,所以本方法实在多余,"
            注释 = "但如果返回0,说明提供的模块句柄是有问题的." 返回值注释 = "成功返回模块基址,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲获取信息的模块句柄" @匹配类型 = 通用整数型>
    {
        @ static_cast<INT64>(@sn<this>.get_module_base(static_cast<ULONG64>(@<模块句柄>)))
    }

    方法 枚举模块信息 <公开 类型 = 整数 注释 = "枚举进程中的所有模块的详细信息" 返回值注释 = "成功返回模块句柄的数量,未打开进程始终返回0." 折叠 @禁止流程检查 = 真>
    参数 模块信息数组 <类型 = NT模块信息数组类 注释 = "成功返回模块信息数组">
    {
        @ @<模块信息数组>.clear();
        @ if (enum_modules() == 0) { return 0; }
        @ for (auto& it = modules_map().begin(); it != modules_map().end(); it++) {
        @     @<模块信息数组>.emplace_back(it->second);
        @ }
        @ return static_cast<INT>(@<模块信息数组>.size());
    }

    方法 枚举模块句柄 <公开 类型 = 整数 注释 = "枚举进程中的所有模块句柄." 注释 = "注意: 建议改用\"枚举模块信息\"!" 返回值注释 = "成功返回模块句柄的数量,未打开进程始终返回0."
            折叠 @嵌入式方法 = "">
    参数 模块句柄数组 <类型 = 长整数数组类 注释 = "成功返回模块句柄数组">
    {
        @ @sn<this>.enum_modules(@<模块句柄数组>.data())
    }

    方法 枚举模块名称 <公开 类型 = 整数 注释 = "枚举进程中的所有模块句柄和模块文件名." 注释 = "注意: 建议改用\"枚举模块信息\"!"
            返回值注释 = "成功返回模块句柄的数量,未打开进程始终返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄数组 <类型 = 长整数数组类 注释 = "成功返回模块句柄数组" @默认值 = 空对象>
    参数 模块名称数组 <类型 = 文本数组类 注释 = "成功返回模块名称数组" @默认值 = 空对象>
    参数 是否完整路径 <类型 = 逻辑型 注释 = "枚举的模块名称是否带完整路径" @默认值 = 真>
    {
        @ @sn<this>.enum_modules(@<模块句柄数组>.data(), @<模块名称数组>.data(), @<是否完整路径>)
    }

    方法 取模块信息 <公开 类型 = 逻辑型 注释 = "获取已打开进程中的模块文件(.exe或.dll)信息" 返回值注释 = "返回是否获取成功,未打开进程始终返回假." 折叠 @禁止流程检查 = 真>
    参数 模块句柄 <类型 = 长整数 注释 = "所欲获取信息的模块句柄">
    参数 模块信息 <类型 = NT模块信息类 注释 = "成功返回模块信息">
    {
        @ PivProcessNT::ModuleInfo ModuleInfo;
        @ if (get_module_info(static_cast<ULONG64>(@<模块句柄>), ModuleInfo))
        @ {
        @     @<模块信息>.SetInfo(ModuleInfo);
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 取模块名称 <公开 类型 = 文本型 注释 = "获取进程中指定模块句柄的名称(不含路径)" 返回值注释 = "成功返回模块的文件名(不含路径),失败返回空文本." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲获取名称的模块句柄,0为进程的主程序.exe文件." @默认值 = 0 @匹配类型 = 通用整数型>
    {
        @ @sn<this>.get_module_name(static_cast<ULONG64>(@<模块句柄>))
    }

    方法 取模块文件名 <公开 类型 = 文本型 注释 = "获取进程中指定模块句柄的文件全名(含路径)" 返回值注释 = "成功返回模块的完整文件名(含路径),失败返回空文本." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲获取文件全名的模块句柄,0为进程可执行文件的路径." @默认值 = 0 @匹配类型 = 通用整数型>
    {
        @ @sn<this>.get_module_filename(static_cast<ULONG64>(@<模块句柄>))
    }

    方法 取模块路径 <公开 类型 = 文本型 注释 = "获取进程中指定模块句柄的无文件名路径" 返回值注释 = "成功返回模块的路径,失败返回空文本." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲获取路径的模块句柄,0为进程可执行文件的路径." @默认值 = 0 @匹配类型 = 通用整数型>
    {
        @ @sn<this>.get_module_path(static_cast<ULONG64>(@<模块句柄>))
    }

    方法 取内存映射文件 <公开 类型 = 文本型 注释 = "检查指定的地址是否在指定进程的内存映射文件中,如果是则返回内存映射文件的名称."
            注释 = "返回路径中的驱动器为MS-DOS驱动器名称,而非盘符." 注释 = "如果需要转换为盘符路径,请用\"DOS名称路径转盘符路径\"."
            注释 = "注: 本方法不支持从32位程序获取64位进程的信息." 返回值注释 = "成功返回内存映射文件的文件名(含路径),失败返回空文本." 折叠 @嵌入式方法 = "">
    参数 所欲验证地址 <注释 = "所欲验证的虚拟内存地址" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.get_mapped_filename(reinterpret_cast<PVOID64>(@<所欲验证地址>))
    }

    方法 取进程映像文件名 <公开 类型 = 文本型 注释 = "获取进程的映像(可执行文件)文件名." 注释 = "返回路径中的驱动器为MS-DOS驱动器名称,而非盘符."
            注释 = "如果需要转换为盘符路径,请用\"DOS名称路径转盘符路径\"." 返回值注释 = "成功返回映像文件的文件名(含路径),失败返回空文本." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.get_image_filename()
    }

    方法 创建远程线程 <公开 类型 = 逻辑型 注释 = "远程在进程中创建线程." 注释 = "注: 本方法不支持从32位程序操作64位进程." 返回值注释 = "返回是否创建线程成功" 折叠
            @嵌入式方法 = "">
    参数 函数指针 <@匹配类型 = 通用整数型>
    参数 参数指针 <@匹配类型 = 通用整数型>
    参数 是否等待 <类型 = 逻辑型 注释 = "指定本方法是否一直等待线程执行完毕后才会返回" @默认值 = 假>
    {
        @ @sn<this>.create_remote_thread(reinterpret_cast<void*>(@<函数指针>), reinterpret_cast<void*>(@<参数指针>), @<是否等待>)
    }

    # 进程内存操作

    方法 分配虚拟内存 <公开 类型 = 长整数 注释 = "在进程的虚拟空间保留或提交内存区域,除非指定MEM_RESET参数,否则将该内存区域置0."
            返回值注释 = "成功返回虚拟内存的地址,失败返回0." 折叠 @嵌入式方法 = "">
    参数 内存地址 <注释 = "指定分配的目标地址,该地址必须是未初始化的;" 注释 = "一般请置为0,由系统自动分配地址." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 分配大小 <注释 = "所欲分配的内存区域大小(字节单位)." @匹配类型 = 通用整数型>
    参数 分配类型 <类型 = 整数 注释 = "请提供\"内存操作类型\"的一个常量或多个常量的位或值;" 注释 = "默认值为(MEM_COMMIT | MEM_RESERVE)."
            @默认值 = 12288>
    参数 保护类型 <类型 = 整数 注释 = "请提供\"内存页面保护属性\"的一个常量或多个常量的位或值." @默认值 = 内存页面保护属性.可执行_读写>
    {
        @ reinterpret_cast<int64_t>(@sn<this>.virtual_alloc(reinterpret_cast<PVOID64>(@<内存地址>), static_cast<uint64_t>(@<分配大小>), static_cast<DWORD>(@<分配类型>), static_cast<DWORD>(@<保护类型>)))
    }

    方法 释放虚拟内存 <公开 类型 = 逻辑型 注释 = "释放、取消提交虚拟地址空间内的内存区域." 注释 = "注: 不支持从32位程序释放64位进程的虚拟内存!" 返回值注释 = "返回是否成功" 折叠
            @嵌入式方法 = "">
    参数 内存地址 <注释 = "所欲释放内存区域的起始地址;" 注释 = "如果\"释放类型\"为\"释放内存/MEM_RELEASE\",则本参数必须是保留区域时"
            注释 = "由\"分配虚拟内存\"返回的基址." @匹配类型 = 通用整数型>
    参数 内存大小 <注释 = "所欲释放的内存区域大小(字节单位);" 注释 = "  如果\"释放类型\"为\"释放内存/MEM_RELEASE\",则本参数必须为0,本函数将"
            注释 = "释放由调用\"分配虚拟内存\"保留的整个区域;" 注释 = "  如果\"释放类型\"为\"取消提交/MEM_DECOMMIT\",则本函数将取消提交从\"区"
            注释 = "域地址\"到本区域大小的所有内存页.若\"区域地址\"为\"分配虚拟内存\"返回的" 注释 = "基址且本参数为0,则取消提交之前分配的整个区域;" @默认值 = 0
            @匹配类型 = 通用整数型>
    参数 释放类型 <类型 = 整数 注释 = "请提供\"内存操作类型\"的一个常量或多个常量的位或值" @默认值 = 内存操作类型.释放内存>
    {
        @ @sn<this>.virtual_free(reinterpret_cast<void*>(@<内存地址>), static_cast<size_t>(@<内存大小>), static_cast<DWORD>(@<释放类型>))
    }

    方法 修改内存保护 <公开 类型 = 整数 注释 = "修改进程虚拟地址空间中已提交页区域的保护属性." 注释 = "注: 不支持从32位程序修改64位进程的内存保护!"
            返回值注释 = "成功返回修改前的保护属性,失败返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲修改的地址 <注释 = "所欲修改内存保护属性的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲修改的长度 <注释 = "所欲修改内存保护属性的长度" @匹配类型 = 通用整数型>
    参数 新的内存保护属性 <类型 = 整数 注释 = "默认值为可执行和可读写权限,其余属性请参考\"内存页面保护属性\"的常量." @默认值 = 内存页面保护属性.可执行_读写>
    {
        @ @sn<this>.modify_memory_protect(reinterpret_cast<void*>(@<所欲修改的地址>), static_cast<size_t>(@<所欲修改的长度>), static_cast<DWORD>(@<新的内存保护属性>))
    }

    方法 寻找内存特征码 <公开 类型 = 长整数 注释 = "Sunday算法实现内存快速搜索特征码(支持通配符模糊搜索)." 注释 = "本方法只返回找到的一个地址."
            返回值注释 = "返回找到的虚拟内存地址,未找到则返回0." 折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 特征码 <类型 = 文本型 注释 = "十六进制文本,中间的空格可以省略,支持通配符?" 注释 = "例如\"BA ?? 00 B4 09 ?? 21\"">
    参数 起始地址 <注释 = "搜索的起始位置" @默认值 = 0 @匹配类型 = 通用整数型>
    参数 结束地址 <注释 = "搜索的结束位置,默认搜索整个虚拟内存;" 注释 = "0则为进程所有模块的地址尾部,可能会找不到部分数据." @默认值 = -1 @匹配类型 = 通用整数型>
    参数 指定保护属性 <类型 = 整数 注释 = "是否仅寻找指定保护属性的内存地址,0为寻找全部保护属性;" 注释 = "请参考\"内存页面保护属性\"的常量." @默认值 = 0>
    参数 指定页面类型 <类型 = 整数 注释 = "是否仅寻找指定页面类型的内存地址,0为寻找全部类型;" 注释 = "请参考\"内存页面类型\"的常量." @默认值 = 0>
    {
        @ @sn<this>.find_signatures(@<特征码>, reinterpret_cast<PVOID64>(@<起始地址>), reinterpret_cast<PVOID64>(@<结束地址>), static_cast<DWORD>(@<指定保护属性>), static_cast<DWORD>(@<指定页面类型>))
    }

    方法 寻找内存字节集 <公开 类型 = 长整数 注释 = "在进程的虚拟内存中寻找指定的字节集数据,本方法只返回找到的一个地址." 返回值注释 = "返回找到的虚拟内存地址,未找到则返回0." 折叠
            @嵌入式方法 = "">
    参数 所欲寻找的字节集 <类型 = 字节集类 注释 = "所欲寻找的字节集">
    参数 起始地址 <注释 = "搜索的起始位置" @默认值 = 0 @匹配类型 = 通用整数型>
    参数 结束地址 <注释 = "搜索的结束位置,默认搜索整个虚拟内存;" 注释 = "0则为进程所有模块的地址尾部,可能会找不到部分数据." @默认值 = -1 @匹配类型 = 通用整数型>
    参数 指定保护属性 <类型 = 整数 注释 = "是否仅寻找指定保护属性的内存地址,0为寻找全部保护属性;" 注释 = "请参考\"内存页面保护属性\"的常量." @默认值 = 0>
    参数 指定页面类型 <类型 = 整数 注释 = "是否仅寻找指定页面类型的内存地址,0为寻找全部类型;" 注释 = "请参考\"内存页面类型\"的常量." @默认值 = 0>
    {
        @ @sn<this>.find_memory(@<所欲寻找的字节集>, reinterpret_cast<PVOID64>(@<起始地址>), reinterpret_cast<PVOID64>(@<结束地址>), static_cast<DWORD>(@<指定保护属性>), static_cast<DWORD>(@<指定页面类型>))
    }

    方法 寻找所有内存特征码 <公开 类型 = 整数 注释 = "Sunday算法实现内存快速搜索特征码(支持通配符模糊搜索)." 返回值注释 = "返回找到的虚拟内存地址数量,未找到则返回0." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 特征码 <类型 = 文本型 注释 = "十六进制文本,中间的空格可以省略,支持通配符?" 注释 = "例如\"BA ?? 00 B4 09 ?? 21\"">
    参数 结果地址数组 <类型 = 长整数数组类 注释 = "在此返回所有找到的虚拟内存地址">
    参数 起始地址 <注释 = "搜索的起始位置" @默认值 = 0 @匹配类型 = 通用整数型>
    参数 结束地址 <注释 = "搜索的结束位置,搜索的结束位置,默认搜索整个虚拟内存;" 注释 = "0则为进程所有模块的地址尾部,可能会找不到部分数据." @默认值 = -1 @匹配类型 = 通用整数型>
    参数 指定保护属性 <类型 = 整数 注释 = "是否仅寻找指定保护属性的内存地址,0为寻找全部保护属性;" 注释 = "请参考\"内存页面保护属性\"的常量." @默认值 = 0>
    参数 指定页面类型 <类型 = 整数 注释 = "是否仅寻找指定页面类型的内存地址,0为寻找全部类型;" 注释 = "请参考\"内存页面类型\"的常量." @默认值 = 0>
    {
        @ @sn<this>.find_signatures(@<特征码>, @<结果地址数组>.data(), reinterpret_cast<PVOID64>(@<起始地址>), reinterpret_cast<PVOID64>(@<结束地址>), static_cast<DWORD>(@<指定保护属性>), static_cast<DWORD>(@<指定页面类型>))
    }

    方法 寻找所有内存字节集 <公开 类型 = 整数 注释 = "在进程的虚拟内存中寻找指定的字节集数据" 返回值注释 = "返回找到的虚拟内存地址数量,未找到则返回0." 折叠 @嵌入式方法 = "">
    参数 所欲寻找的字节集 <类型 = 字节集类 注释 = "所欲寻找的字节集">
    参数 结果地址数组 <类型 = 长整数数组类 注释 = "在此返回所有找到的虚拟内存地址">
    参数 起始地址 <注释 = "搜索的起始位置" @默认值 = 0 @匹配类型 = 通用整数型>
    参数 结束地址 <注释 = "搜索的结束位置,默认搜索整个虚拟内存;" 注释 = "0则为进程所有模块的地址尾部,可能会找不到部分数据." @默认值 = -1 @匹配类型 = 通用整数型>
    参数 指定保护属性 <类型 = 整数 注释 = "是否仅寻找指定保护属性的内存地址,0为寻找全部保护属性;" 注释 = "请参考\"内存页面保护属性\"的常量." @默认值 = 0>
    参数 指定页面类型 <类型 = 整数 注释 = "是否仅寻找指定页面类型的内存地址,0为寻找全部类型;" 注释 = "请参考\"内存页面类型\"的常量." @默认值 = 0>
    {
        @ @sn<this>.find_memory(@<所欲寻找的字节集>, @<结果地址数组>.data(), reinterpret_cast<PVOID64>(@<起始地址>), reinterpret_cast<PVOID64>(@<结束地址>), static_cast<DWORD>(@<指定保护属性>), static_cast<DWORD>(@<指定页面类型>))
    }

    方法 读内存数值 <公开 类型 = 逻辑型 注释 = "读取进程中指定虚拟地址的数值型数据,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 存放读取的值 <注释 = "成功后在此参数中保存所读取的数值,支持所有的数值类型." @匹配类型 = 通用数值型 @需求类型 = 可写入变量>
    {
        @ @sn<this>.read_memory_num(reinterpret_cast<PVOID64>(@<所欲读取的地址>), @<存放读取的值>)
    }

    方法 读内存数据 <公开 类型 = 逻辑型 注释 = "读取进程中指定虚拟地址的内存数据,并保存到指定的地址中." 返回值注释 = "返回是否读取成功" 折叠 @嵌入式方法 = "">
    参数 保存数据的地址 <注释 = "读取的数据保存在此地址中,请确保该地址分配了足够的空间." @匹配类型 = 通用整数型>
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲读取的长度 <注释 = "所欲读取的内存数据长度" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory(reinterpret_cast<void*>(@<保存数据的地址>), reinterpret_cast<PVOID64>(@<所欲读取的地址>), static_cast<uint64_t>(@<所欲读取的长度>))
    }

    方法 写内存数据 <公开 类型 = 逻辑型 注释 = "进程中指定的虚拟地址中写入数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <注释 = "所欲写入的内存数据" @匹配类型 = 通用整数型>
    参数 所欲写入的长度 <注释 = "所欲写入的内存数据长度" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.write_memory(reinterpret_cast<PVOID64>(@<所欲写入的地址>), reinterpret_cast<const void*>(@<所欲写入的数据>), static_cast<size_t>(@<所欲写入的长度>))
    }

    方法 读内存字节集 <公开 类型 = 字节集类 注释 = "读取进程中指定虚拟地址的内存数据,并保存到字节集中." 返回值注释 = "成功返回读取的字节集,失败返回空字节集." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲读取的长度 <注释 = "所欲读取的内存数据长度" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory(reinterpret_cast<PVOID64>(@<所欲读取的地址>), static_cast<size_t>(@<所欲读取的长度>))
    }

    方法 写内存字节集 <公开 类型 = 逻辑型 注释 = "用字节集改写进程中指定虚拟地址的内存数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 字节集类 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_memory(reinterpret_cast<PVOID64>(@<所欲写入的地址>), @<所欲写入的数据>)
    }

    方法 读内存字节 <公开 类型 = 字节 注释 = "读取进程中指定虚拟地址的字节数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory_value<int8_t>(reinterpret_cast<PVOID64>(@<所欲读取的地址>))
    }

    方法 写内存字节 <公开 类型 = 逻辑型 注释 = "改写进程中指定虚拟地址的字节数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 字节 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_memory_value<int8_t>(reinterpret_cast<PVOID64>(@<所欲写入的地址>), @<所欲写入的数据>)
    }

    方法 读内存短整数 <公开 类型 = 短整数 注释 = "读取进程中指定虚拟地址的短整数数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory_value<int16_t>(reinterpret_cast<PVOID64>(@<所欲读取的地址>))
    }

    方法 写内存短整数 <公开 类型 = 逻辑型 注释 = "改写进程中指定虚拟地址的短整数数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 短整数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_memory_value<int16_t>(reinterpret_cast<PVOID64>(@<所欲写入的地址>), @<所欲写入的数据>)
    }

    方法 读内存整数 <公开 类型 = 整数 注释 = "读取进程中指定虚拟地址的整数数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory_value<int32_t>(reinterpret_cast<PVOID64>(@<所欲读取的地址>))
    }

    方法 写内存整数 <公开 类型 = 逻辑型 注释 = "改写进程中指定虚拟地址的整数数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 整数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_memory_value<int32_t>(reinterpret_cast<PVOID64>(@<所欲写入的地址>), @<所欲写入的数据>)
    }

    方法 读内存长整数 <公开 类型 = 长整数 注释 = "读取进程中指定虚拟地址的长整数数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory_value<int64_t>(reinterpret_cast<PVOID64>(@<所欲读取的地址>))
    }

    方法 写内存长整数 <公开 类型 = 逻辑型 注释 = "改写进程中指定虚拟地址的长整数数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 长整数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_memory_value<int64_t>(reinterpret_cast<PVOID64>(@<所欲写入的地址>), @<所欲写入的数据>)
    }

    方法 读内存变整数 <公开 类型 = 变整数 注释 = "读取进程中指定虚拟地址的变整数数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory_value<INT_P>(reinterpret_cast<PVOID64>(@<所欲读取的地址>))
    }

    方法 写内存变整数 <公开 类型 = 逻辑型 注释 = "改写进程中指定虚拟地址的变整数数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 变整数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_memory_value<ptrdiff_t>(reinterpret_cast<PVOID64>(@<所欲写入的地址>), @<所欲写入的数据>)
    }

    方法 读内存小数 <公开 类型 = 小数 注释 = "读取进程中指定虚拟地址的双精度小数" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory_value<double>(reinterpret_cast<PVOID64>(@<所欲读取的地址>))
    }

    方法 写内存小数 <公开 类型 = 逻辑型 注释 = "改写进程中指定虚拟地址的双精度小数" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 小数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_memory_value<double>(reinterpret_cast<PVOID64>(@<所欲写入的地址>), @<所欲写入的数据>)
    }

    方法 读内存单精度小数 <公开 类型 = 单精度小数 注释 = "读取进程中指定虚拟地址的单精度小数" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 所欲读取的地址 <注释 = "所欲读取内存数据的虚拟地址" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_memory_value<float>(reinterpret_cast<PVOID64>(@<所欲读取的地址>))
    }

    方法 写内存单精度小数 <公开 类型 = 逻辑型 注释 = "改写进程中指定虚拟地址的单精度小数" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 所欲写入的地址 <注释 = "所欲写入内存数据的虚拟地址" @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 单精度小数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_memory_value<float>(reinterpret_cast<PVOID64>(@<所欲写入的地址>), @<所欲写入的数据>)
    }

    # 模块文件的内存操作

    方法 寻找模块特征码 <公开 类型 = 长整数 注释 = "Sunday算法实现内存快速搜索特征码(支持通配符模糊搜索)." 返回值注释 = "返回找到的虚拟内存地址,未找到则返回0." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 特征码 <类型 = 文本型 注释 = "十六进制文本,中间的空格可以省略,支持通配符?" 注释 = "例如\"BA ?? 00 B4 09 ?? 21\"">
    参数 起始偏移地址 <注释 = "搜索的起始偏移位置,0为模块的基地址,实际地址为模块的虚拟内存基址+偏移地址;" 注释 = "如果提供的偏移地址大于模块尺寸,将返回失败." @默认值 = 0
            @匹配类型 = 通用整数型>
    参数 结束偏移地址 <注释 = "搜索的结束偏移位置,默认值0表示搜索到模块文件的结尾,实际地址为模块的虚拟" 注释 = "内存基址+偏移地址;" 注释 = "如果提供的偏移地址大于模块尺寸,将返回失败."
            @默认值 = 0 @匹配类型 = 通用整数型>
    参数 指定保护属性 <类型 = 整数 注释 = "是否仅寻找指定保护属性的内存地址,0为寻找全部保护属性;" 注释 = "请参考\"内存页面保护属性\"的常量." @默认值 = 0>
    参数 指定页面类型 <类型 = 整数 注释 = "是否仅寻找指定页面类型的内存地址,0为寻找全部类型;" 注释 = "请参考\"内存页面类型\"的常量." @默认值 = 0>
    {
        @ @sn<this>.find_module_signatures(static_cast<ULONG64>(@<模块句柄>), @<特征码>, static_cast<size_t>(@<起始偏移地址>), static_cast<size_t>(@<结束偏移地址>), static_cast<DWORD>(@<指定保护属性>), static_cast<DWORD>(@<指定页面类型>))
    }

    方法 寻找模块字节集 <公开 类型 = 长整数 注释 = "在模块的虚拟内存中寻找指定的字节集数据" 返回值注释 = "返回找到的虚拟内存地址,未找到则返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲寻找的字节集 <类型 = 字节集类 注释 = "所欲寻找的字节集.">
    参数 起始偏移地址 <注释 = "搜索的起始偏移位置,0为模块的基地址,实际地址为模块的虚拟内存基址+偏移地址;" 注释 = "如果提供的偏移地址大于模块尺寸,将返回失败." @默认值 = 0
            @匹配类型 = 通用整数型>
    参数 结束偏移地址 <注释 = "搜索的结束偏移位置,默认值0表示搜索到模块文件的结尾,实际地址为模块的虚拟" 注释 = "内存基址+偏移地址;" 注释 = "如果提供的偏移地址大于模块尺寸,将返回失败."
            @默认值 = 0 @匹配类型 = 通用整数型>
    参数 指定保护属性 <类型 = 整数 注释 = "是否仅寻找指定保护属性的内存地址,0为寻找全部保护属性;" 注释 = "请参考\"内存页面保护属性\"的常量." @默认值 = 0>
    参数 指定页面类型 <类型 = 整数 注释 = "是否仅寻找指定页面类型的内存地址,0为寻找全部类型;" 注释 = "请参考\"内存页面类型\"的常量." @默认值 = 0>
    {
        @ @sn<this>.find_module_memory(static_cast<ULONG64>(@<模块句柄>), @<所欲寻找的字节集>, static_cast<size_t>(@<起始偏移地址>), static_cast<size_t>(@<结束偏移地址>), static_cast<DWORD>(@<指定保护属性>), static_cast<DWORD>(@<指定页面类型>))
    }

    方法 寻找所有模块特征码 <公开 类型 = 整数 注释 = "Sunday算法实现内存快速搜索特征码(支持通配符模糊搜索)." 返回值注释 = "返回找到的虚拟内存地址数量,未找到则返回0." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 特征码 <类型 = 文本型 注释 = "十六进制文本,中间的空格可以省略,支持通配符?" 注释 = "例如\"BA ?? 00 B4 09 ?? 21\"">
    参数 结果地址数组 <类型 = 长整数数组类 注释 = "在此返回所有找到的虚拟内存地址.">
    参数 起始偏移地址 <注释 = "搜索的起始偏移位置,0为模块的基地址,实际地址为模块的虚拟内存基址+偏移地址;" 注释 = "如果提供的偏移地址大于模块尺寸,将返回失败." @默认值 = 0
            @匹配类型 = 通用整数型>
    参数 结束偏移地址 <注释 = "搜索的结束偏移位置,默认值0表示搜索到模块文件的结尾,实际地址为模块的虚拟" 注释 = "内存基址+偏移地址;" 注释 = "如果提供的偏移地址大于模块尺寸,将返回失败."
            @默认值 = 0 @匹配类型 = 通用整数型>
    参数 指定保护属性 <类型 = 整数 注释 = "是否仅寻找指定保护属性的内存地址,0为寻找全部保护属性;" 注释 = "请参考\"内存页面保护属性\"的常量." @默认值 = 0>
    参数 指定页面类型 <类型 = 整数 注释 = "是否仅寻找指定页面类型的内存地址,0为寻找全部类型;" 注释 = "请参考\"内存页面类型\"的常量." @默认值 = 0>
    {
        @ @sn<this>.find_module_signatures (static_cast<ULONG64>(@<模块句柄>), @<特征码>, @<结果地址数组>.data(), static_cast<size_t>(@<起始偏移地址>),
        @     static_cast<size_t>(@<结束偏移地址>), static_cast<DWORD>(@<指定保护属性>), static_cast<DWORD>(@<指定页面类型>))
    }

    方法 寻找所有模块字节集 <公开 类型 = 整数 注释 = "在模块的虚拟内存中寻找指定的字节集数据" 返回值注释 = "返回找到的虚拟内存地址数量,未找到则返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲寻找的字节集 <类型 = 字节集类 注释 = "所欲寻找的字节集">
    参数 结果地址数组 <类型 = 长整数数组类 注释 = "在此返回所有找到的虚拟内存地址">
    参数 起始偏移地址 <注释 = "搜索的起始偏移位置,0为模块的基地址,实际地址为模块的虚拟内存基址+偏移地址;" 注释 = "如果提供的偏移地址大于模块尺寸,将返回失败." @默认值 = 0
            @匹配类型 = 通用整数型>
    参数 结束偏移地址 <注释 = "搜索的结束偏移位置,默认值0表示搜索到模块文件的结尾,实际地址为模块的虚拟" 注释 = "内存基址+偏移地址;" 注释 = "如果提供的偏移地址大于模块尺寸,将返回失败."
            @默认值 = 0 @匹配类型 = 通用整数型>
    参数 指定保护属性 <类型 = 整数 注释 = "是否仅寻找指定保护属性的内存地址,0为寻找全部保护属性;" 注释 = "请参考\"内存页面保护属性\"的常量." @默认值 = 0>
    参数 指定页面类型 <类型 = 整数 注释 = "是否仅寻找指定页面类型的内存地址,0为寻找全部类型;" 注释 = "请参考\"内存页面类型\"的常量." @默认值 = 0>
    {
        @ @sn<this>.find_module_memory(static_cast<ULONG64>(@<模块句柄>), @<所欲寻找的字节集>, @<结果地址数组>.data (), static_cast<size_t>(@<起始偏移地址>),
        @     static_cast<size_t>(@<结束偏移地址>), static_cast<DWORD>(@<指定保护属性>), static_cast<DWORD>(@<指定页面类型>))
    }

    方法 读模块数值 <公开 类型 = 逻辑型 注释 = "读取模块中指定虚拟地址的数值型数据,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 存放读取的值 <注释 = "成功后在此参数中保存所读取的数值,支持所有的数值类型." @匹配类型 = 通用数值型 @需求类型 = 可写入变量>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_num(reinterpret_cast<HMODULE>(@<模块句柄>), @<存放读取的值>, static_cast<size_t>(@<所欲读取的偏移地址>))
    }

    方法 读模块数据 <公开 类型 = 逻辑型 注释 = "读取模块中指定虚拟地址的内存数据,并保存到指定的地址中." 返回值注释 = "返回是否读取成功" 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 保存数据的地址 <注释 = "读取的数据保存在此地址中,请确保该地址分配了足够的空间." @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲读取的长度 <注释 = "所欲读取的内存数据长度" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_memory(static_cast<ULONG64>(@<模块句柄>), reinterpret_cast<void*>(@<保存数据的地址>), static_cast<size_t>(@<所欲读取的偏移地址>), static_cast<size_t>(@<所欲读取的长度>))
    }

    方法 写模块数据 <公开 类型 = 逻辑型 注释 = "用字节集改写模块中指定虚拟地址的内存数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <注释 = "所欲写入的内存数据" @匹配类型 = 通用整数型>
    参数 所欲写入的长度 <注释 = "所欲写入的内存数据长度" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.write_module_memory(static_cast<ULONG64>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), reinterpret_cast<const void*>(@<所欲写入的数据>), static_cast<size_t>(@<所欲写入的长度>))
    }

    方法 读模块字节集 <公开 类型 = 字节集类 注释 = "读取模块中指定虚拟地址的内存数据,并保存到字节集中." 返回值注释 = "成功返回读取的字节集,失败返回空字节集." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲读取的长度 <注释 = "所欲读取的内存数据长度" @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_memory(static_cast<ULONG64>(@<模块句柄>), static_cast<size_t>(@<所欲读取的偏移地址>), @<所欲读取的长度>)
    }

    方法 写模块字节集 <公开 类型 = 逻辑型 注释 = "用字节集改写模块中指定虚拟地址的内存数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 字节集类 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_module_memory(static_cast<ULONG64>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), @<所欲写入的数据>)
    }

    方法 读模块字节 <公开 类型 = 字节 注释 = "读取模块中指定虚拟地址的字节数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_value<S_BYTE>(static_cast<ULONG64>(@<模块句柄>), static_cast<size_t>(@<所欲读取的偏移地址>))
    }

    方法 写模块字节 <公开 类型 = 逻辑型 注释 = "改写模块中指定虚拟地址的字节数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的值 <类型 = 字节 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_module_value<S_BYTE>(static_cast<ULONG64>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), @<所欲写入的值>)
    }

    方法 读模块短整数 <公开 类型 = 短整数 注释 = "读取模块中指定虚拟地址的短整数数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_value<SHORT>(static_cast<ULONG64>(@<模块句柄>), static_cast<size_t>(@<所欲读取的偏移地址>))
    }

    方法 写模块短整数 <公开 类型 = 逻辑型 注释 = "改写模块中指定虚拟地址的短整数数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 短整数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_module_value<SHORT>(static_cast<ULONG64>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), @<所欲写入的数据>)
    }

    方法 读模块整数 <公开 类型 = 整数 注释 = "读取模块中指定虚拟地址的整数数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_value<INT>(static_cast<ULONG64>(@<模块句柄>), static_cast<size_t>(@<所欲读取的偏移地址>))
    }

    方法 写模块整数 <公开 类型 = 逻辑型 注释 = "改写模块中指定虚拟地址的整数数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 整数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_module_value<INT>(static_cast<ULONG64>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), @<所欲写入的数据>)
    }

    方法 读模块长整数 <公开 类型 = 长整数 注释 = "读取模块中指定虚拟地址的长整数数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_value<INT64>(static_cast<ULONG64>(@<模块句柄>), static_cast<size_t>(@<所欲读取的偏移地址>))
    }

    方法 写模块长整数 <公开 类型 = 逻辑型 注释 = "改写模块中指定虚拟地址的长整数数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 长整数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_module_value<INT64>(static_cast<ULONG64>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), @<所欲写入的数据>)
    }

    方法 读模块变整数 <公开 类型 = 变整数 注释 = "读取模块中指定虚拟地址的变整数数据" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_value<INT_P>(static_cast<ULONG64>(@<模块句柄>), static_cast<size_t>(@<所欲读取的偏移地址>))
    }

    方法 写模块变整数 <公开 类型 = 逻辑型 注释 = "改写模块中指定虚拟地址的变整数数据" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 变整数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_module_value<INT_P>(static_cast<ULONG64>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), @<所欲写入的数据>)
    }

    方法 读模块小数 <公开 类型 = 小数 注释 = "读取模块中指定虚拟地址的双精度小数值" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_value<double>(static_cast<ULONG64>(@<模块句柄>), static_cast<size_t>(@<所欲读取的偏移地址>))
    }

    方法 写模块小数 <公开 类型 = 逻辑型 注释 = "改写模块中指定虚拟地址的双精度小数值" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 小数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_module_value<double>(static_cast<ULONG64>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), @<所欲写入的数据>)
    }

    方法 读模块单精度小数 <公开 类型 = 单精度小数 注释 = "读取模块中指定虚拟地址的单精度小数值" 返回值注释 = "成功返回读取的数据,失败返回0." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲读取的偏移地址 <注释 = "所欲读取模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    {
        @ @sn<this>.read_module_value<float>(static_cast<ULONG64>(@<模块句柄>), static_cast<size_t>(@<所欲读取的偏移地址>))
    }

    方法 写模块单精度小数 <公开 类型 = 逻辑型 注释 = "改写模块中指定虚拟地址的单精度小数值" 返回值注释 = "返回是否写入成功,未打开进程始终返回假." 折叠 @嵌入式方法 = "">
    参数 模块句柄 <注释 = "所欲操作的模块句柄,可以用\"取模块句柄\"、\"枚举模块句柄\"、\"枚举模块名称\"获取." @默认值 = 0 @匹配类型 = 通用整数型>
    参数 所欲写入的偏移地址 <注释 = "所欲写入模块虚拟内存数据的偏移地址,实际地址为模块的虚拟内存基址+偏移地址." @匹配类型 = 通用整数型>
    参数 所欲写入的数据 <类型 = 单精度小数 注释 = "所欲写入的内存数据">
    {
        @ @sn<this>.write_module_value<float>(static_cast<ULONG64>(@<模块句柄>), static_cast<size_t>(@<所欲写入的偏移地址>), @<所欲写入的数据>)
    }
}

类 进程辅助类 <公开 注释 = "进程相关的一些辅助方法" 折叠 @文档 = "category = \"进程操作\"" @禁止创建对象 = 真>
{
    方法 取物理内存尺寸 <公开 静态 类型 = 长整数 注释 = "获取系统安装的物理内存大小(单位为KB),该尺寸直接从SMBIOS中获取," 注释 = "必定大于等于系统可使用的内存量." 折叠
            @禁止流程检查 = 真>
    {
        @ ULONGLONG TotalMemoryInKilobytes;
        @ if (::GetPhysicallyInstalledSystemMemory (&TotalMemoryInKilobytes))
        @     return static_cast<INT64>(TotalMemoryInKilobytes);
        @ return 0;
    }

    方法 取系统内存状态信息 <公开 静态 类型 = 逻辑型 注释 = "获取系统的当前物理内存和虚拟内存使用量,返回是否成功." 折叠 @禁止流程检查 = 真>
    参数 内存状态信息 <类型 = 内存状态信息类EX 注释 = "获取的内存状态信息将保存在此参数中">
    {
        @ @<内存状态信息>.ResetObject ();
        @ MEMORYSTATUSEX statex;
        @ statex.dwLength = sizeof (statex);
        @ if (::GlobalMemoryStatusEx (&statex)) {
        @     @<内存状态信息>.dwMemoryLoad     = (INT)  statex.dwMemoryLoad;
        @     @<内存状态信息>.ullTotalPhys     = (INT64)statex.ullTotalPhys;
        @     @<内存状态信息>.ullAvailPhys     = (INT64)statex.ullAvailPhys;
        @     @<内存状态信息>.ullTotalPageFile = (INT64)statex.ullTotalPageFile;
        @     @<内存状态信息>.ullAvailPageFile = (INT64)statex.ullAvailPageFile;
        @     @<内存状态信息>.ullTotalVirtual  = (INT64)statex.ullTotalVirtual;
        @     @<内存状态信息>.ullAvailVirtual  = (INT64)statex.ullAvailVirtual;
        @     return TRUE;
        @ }
        @ return FALSE;

    }

    方法 关闭句柄 <公开 静态 注释 = "关闭进程、线程等的句柄." 折叠 @嵌入式方法 = "">
    参数 句柄 <@匹配类型 = 通用整数型>
    {
        @ ::CloseHandle ((HANDLE)@<句柄>)
    }

    方法 创建进程 <公开 静态 类型 = 整数 注释 = "运行指定的可执行文件或者外部命令." 注释 = "跟核心库的\"运行\"一样,但返回的是进程ID,方便后续调用."
            返回值注释 = "成功返回进程ID,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 欲运行的可执行文件 <类型 = 文本型 注释 = "所欲运行的可执行文件名(必须包含扩展名),建议加上完整的文件路径,没加" 注释 = "完整路径的话,将使用当前盘符和当前目录补全路径\'"
            注释 = "若本参数留空,则将\"欲运行的命令行\"第一个空格之前的文本作为运行的可" 注释 = "执行文件." @默认值 = 空对象>
    参数 欲运行的命令行 <类型 = 文本型 注释 = "所欲执行的命令行,可以为空." @默认值 = 空对象>
    参数 是否等待进程运行完毕 <类型 = 逻辑型 注释 = "是否等待进程运行完毕才返回,为真时会一直等待,直到运行的进程结束," 注释 = "默认是等待进程创建后返回." @默认值 = 假>
    参数 被运行程序窗口显示方式 <类型 = 程序窗口显示方式 @默认值 = 程序窗口显示方式.普通激活>
    {
        @ STARTUPINFO infStartup{0};
        @ infStartup.cb = sizeof(infStartup);
        @ if (@<被运行程序窗口显示方式> >= 0)
        @ {
        @     infStartup.dwFlags |= STARTF_USESHOWWINDOW;
        @     infStartup.wShowWindow = static_cast<WORD>(@<被运行程序窗口显示方式>);
        @ }
        @ PROCESS_INFORMATION pi{0};
        @ CVolMem memCommandLine;
        @ memCommandLine.AddString (@<欲运行的命令行>.GetText());
        @ if (!::CreateProcessW (@<欲运行的可执行文件>.IsEmpty() ? NULL : @<欲运行的可执行文件>.GetText(),
        @                        @<欲运行的命令行>.IsEmpty() ? NULL : memCommandLine.GetTextPtr(),
        @                        NULL, NULL, FALSE, 0, NULL, NULL, &infStartup, &pi)) {
        @     return 0;
        @ }
        @ if (@<是否等待进程运行完毕>) {
        @     ::WaitForSingleObject (pi.hProcess, INFINITE);
        @ } else {
        @     ::WaitForInputIdle (pi.hProcess, 500);
        @ }
        @ ::CloseHandle (pi.hThread);
        @ ::CloseHandle (pi.hProcess);
        @ return static_cast<INT>(pi.dwProcessId);
    }

    方法 提升进程权限 <公开 静态 类型 = 逻辑型 注释 = "提升当前进程的用户权限" 返回值注释 = "返回是否提权成功" 折叠 @禁止流程检查 = 真>
    参数 所需权限 <类型 = 用户权限常量 注释 = "默认为提升到调试级权限,其他权限请参考\"用户权限常量\"中的内容." @默认值 = 用户权限常量.调试程序>
    {
        @ HANDLE hToken;
        @ if (!::OpenProcessToken (::GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
        @     return FALSE;
        @ }
        @ TOKEN_PRIVILEGES tokenPrivilege{0};
        @ if (!::LookupPrivilegeValueW (NULL, @<所需权限>.GetText(), &tokenPrivilege.Privileges[0].Luid)) {
        @     return FALSE;
        @ }
        @ tokenPrivilege.PrivilegeCount = 1;
        @ tokenPrivilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        @ BOOL result = ::AdjustTokenPrivileges (hToken, FALSE, &tokenPrivilege, sizeof(TOKEN_PRIVILEGES), NULL, NULL);
        @ ::CloseHandle(hToken);
        @ return result;
    }

    方法 调整当前权限 <公开 静态 类型 = 整数 注释 = "(RtlAdjustPrivilege)启用或取消当前线程或进程的某个权限." 注释 = "注意本方法只有64位程序能使用."
            返回值注释 = "返回0表示成功,其他为错误码." 折叠 @禁止流程检查 = 真 @视窗.需求目标平台 = @"64位平台">
    参数 权限ID <类型 = 用户权限ID 注释 = "所需的权限ID">
    参数 启用权限 <类型 = 逻辑型 注释 = "真为启用该权限,假为取消." @默认值 = 真>
    参数 是否仅当前线程 <类型 = 逻辑型 注释 = "真为仅调整当前线程的权限,假为提升整个进程的权限." @默认值 = 真>
    参数 原来的权限状态 <类型 = 逻辑型类 注释 = "返回该权限之前的状态(打开或关闭)" @默认值 = 空对象>
    {
        @ typedef DWORD(WINAPI * NT_RtlAdjustPrivilege)(ULONG Privilege, BOOLEAN Enable, BOOLEAN CurrentThread, PBOOLEAN Enabled);
        @ NT_RtlAdjustPrivilege pfn = reinterpret_cast<NT_RtlAdjustPrivilege>(::GetProcAddress(::GetModuleHandle(L"Ntdll.dll"), "RtlAdjustPrivilege"));
        @ if (pfn) {
        @     return static_cast<INT>(pfn(static_cast<ULONG>(@<权限ID>), static_cast<BOOLEAN>(@<启用权限>), static_cast<BOOLEAN>(@<是否仅当前线程>), reinterpret_cast<PBOOLEAN>(&@<原来的权限状态.值>)));
        @ }
        @ return -1;
    }

    方法 取模块句柄 <公开 静态 类型 = 变整数 注释 = "通过模块名称获取模块的句柄,所获取的模块必须已经被当前进程加载." 返回值注释 = "成功返回模块句柄,失败返回0." 折叠
            @禁止流程检查 = 真>
    参数 模块名称 <类型 = 文本型 注释 = "所欲取句柄的模块文件名称(区分大小写);" 注释 = "如省略扩展名则默认为\".dll\". 结尾为\".\"则表示模块名称没有扩展名;"
            注释 = "该名称可以不包含路径,如果指定路径,必须用反斜杠\"\\\\\";" 注释 = "留空为打开当前进程的exe文件." @默认值 = 空对象>
    {
        @ return (INT_P)::GetModuleHandleW ((BOOL)@<模块名称>.IsEmpty () == TRUE ? NULL : (LPCWSTR)@<模块名称>.GetText ());
    }

    方法 取系统DEP策略 <公开 静态 类型 = 整数 注释 = "获取系统的数据执行保护(DEP)策略" 注释 = "当返回值为2或3时,可以通过\"置进程DEP策略\"修改进程的DEP策略."
            返回值注释 = "返回值含义如下:" 返回值注释 = " 0 [AlwaysOff/始终禁用]系统和所有进程禁用DEP,且无法修改进程的DEP设置;"
            返回值注释 = " 1 [AlwaysOn/始终启用]系统和所有进程启用DEP,且无法修改进程的DEP设置;"
            返回值注释 = " 2 [OptIn/选择性启用]仅为系统进程启用DEP,这是桌面系统的默认设置;"
            返回值注释 = " 3 [OptOut/选择性禁用]除了特别指定的进程之外,为系统和使用进程启用DEP,这是服务器系统的默认设置;"
            返回值注释 = "另外也可以使用编译参数默认启用DEP,火山编译的程序也是默认启用DEP,禁用需要手动附加编译参数." 折叠 @嵌入式方法 = "">
    {
        @ (INT)::GetSystemDEPPolicy ()
    }

    方法 置进程DEP策略 <公开 静态 类型 = 逻辑型 注释 = "设置32位进程的数据执行保护(DEP)策略,本方法不适用于64位进程(64位进程始终开启DEP且无法禁用)."
            注释 = "如果想获取进程的DEP策略,可调用\"进程操作类.取进程DEP策略\"." 返回值注释 = "返回是否设置成功,失败一般是因为系统DEP策略的关系." 折叠 @禁止流程检查 = 真>
    参数 DEP设置 <类型 = 整数 注释 = "只能在系统DEP为\"选择性启用\"和\"选择性禁用\"时修改DEP策略,系统的DEP策略可通过\"取系统DEP策略\"获取."
            注释 = "  0 禁用当前进程的DEP;" 注释 = "  1 在当前进程上永久启用DEP,后续将无法在进程的生命周期内禁用DEP;"
            注释 = "  3 当前进程永久启用DEP,并禁用DEP-ATL thunk emulation;">
    {
        @ typedef BOOL(WINAPI * Typedef_SetProcessDEPPolicy)(DWORD);
        @ Typedef_SetProcessDEPPolicy pfn = reinterpret_cast<Typedef_SetProcessDEPPolicy>(::GetProcAddress(::GetModuleHandleW(L"Kernel32.dll"), "SetProcessDEPPolicy"));
        @ if (pfn) {
        @     return pfn(static_cast<DWORD>(@<DEP设置>));
        @ }
        @ return FALSE;
    }

    方法 取当前进程ID <公开 静态 类型 = 整数 注释 = "获取当前进程的ID" 折叠 @嵌入式方法 = "">
    {
        @ (INT)::GetCurrentProcessId ()
    }

    方法 取当前线程ID <公开 静态 类型 = 整数 注释 = "获取当前线程的ID" 折叠 @嵌入式方法 = "">
    {
        @ (INT)::GetCurrentThreadId ()
    }

    方法 取模块函数地址 <公开 静态 类型 = 变整数 注释 = "获取指定模块的函数地址,调用本方法的进程必须已加载指定的模块." 注释 = "*本方法不会加载和释放模块."
            返回值注释 = "成功返回函数地址,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 模块名称 <类型 = 文本型 注释 = "所欲获取函数地址的模块文件名称(区分大小写);" 注释 = "如省略扩展名则默认为\".dll\". 结尾为\".\"则表示该模块名称没有扩展名;"
            注释 = "该名称可以不包含路径,如果指定路径,必须用反斜杠\"\\\\\".">
    参数 函数名称 <类型 = 文本型 注释 = "所欲取地址的函数名称">
    {
        @ @an<CVolMem> buf;
        @ return (INT_P)::GetProcAddress(::GetModuleHandleW(@<模块名称>.GetText()),
        @                                GetMbsText(@<函数名称>.GetText(), buf, NULL));
    }

    方法 进程ID取窗口句柄 <公开 静态 类型 = 变整数 注释 = "根据进程ID获取窗口句柄." 注释 = "本方法通过枚举系统的所有窗口句柄,然后对比其进程ID实现."
            返回值注释 = "成功返回找到的第一个窗口句柄(不能保证是主窗口句柄),失败返回0." 折叠 @禁止流程检查 = 真>
    参数 进程ID <类型 = 整数 注释 = "所欲取窗口句柄的进程ID,0为当前进程." @默认值 = 0>
    {
        @ HWND hWnd = ::GetTopWindow(NULL);
        @ DWORD dwFindPID = @<进程ID> ? static_cast<DWORD>(@<进程ID>) : ::GetCurrentProcessId();
        @ while (hWnd) {
        @     DWORD dwPID = 0;
        @     DWORD dwTheardId = ::GetWindowThreadProcessId(hWnd, &dwPID);
        @     if (dwTheardId) {
        @         if (dwPID == dwFindPID)
        @             return (INT_P)hWnd;
        @     }
        @     hWnd = ::GetNextWindow(hWnd, GW_HWNDNEXT);
        @ }
        @ return 0;
    }

    方法 进程ID取窗口句柄2 <公开 静态 类型 = 变整数 注释 = "根据进程ID获取窗口句柄." 注释 = "本方法通过枚举系统的所有窗口句柄,然后对比其进程ID实现."
            返回值注释 = "成功返回找到的第一个窗口句柄(不能保证是主窗口句柄),失败返回0." 折叠 @禁止流程检查 = 真>
    参数 进程ID <类型 = 整数 注释 = "所欲取窗口句柄的进程ID,0为当前进程." @默认值 = 0>
    参数 窗口句柄数组 <类型 = 变整数数组类 注释 = "所有获取到的窗口句柄都保存在此数组中,并返回找到的第一个窗口句柄;" @默认值 = 空对象>
    {
        窗口句柄数组.删除所有成员 ()
        @ HWND hWnd = ::GetTopWindow(NULL);
        @ DWORD dwFindPID = @<进程ID> ? static_cast<DWORD>(@<进程ID>) : ::GetCurrentProcessId();
        @ while (hWnd) {
        @     DWORD dwPID = 0;
        @     DWORD dwTheardId = ::GetWindowThreadProcessId(hWnd, &dwPID);
        @     if (dwTheardId) {
        @         if (dwPID == dwFindPID)
        @             @<窗口句柄数组>.data().Add((INT_P)hWnd);
        @     }
        @     hWnd = ::GetNextWindow(hWnd, GW_HWNDNEXT);
        @ }
        返回 (选择 (窗口句柄数组.取成员数 () > 0, 窗口句柄数组.取成员 (0), (变整数)0))
    }

    方法 窗口句柄取进程ID <公开 静态 类型 = 整数 注释 = "根据窗口句柄获取进程ID" 返回值注释 = "成功返回进程ID,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数 注释 = "所欲取进程ID的窗口句柄" @输出名 = "hWnd">
    {
        @ DWORD dwProcessId = 0;
        @ ::GetWindowThreadProcessId ((HWND)hWnd, &dwProcessId);
        @ return (INT)dwProcessId;
    }

    方法 是否以管理员身份运行 <公开 静态 类型 = 逻辑型 注释 = "检测当前程序是否以管理员身份运行" 折叠 @禁止流程检查 = 真>
    {
        @ typedef BOOL(WINAPI* IsNTAdmin)(DWORD, DWORD);
        @ HMODULE hModule = LoadLibraryW (L"advpack.dll");
        @ if (!hModule) return FALSE;
        @ IsNTAdmin pfnIsNTAdmin = (IsNTAdmin)GetProcAddress(hModule, "IsNTAdmin");
        @ BOOL bRes = pfnIsNTAdmin(0, 0);
        @ FreeLibrary (hModule);
        @ return bRes;
    }

    方法 以管理员权限运行 <公开 静态 类型 = 逻辑型 注释 = "以管理员身份运行指定的应用程序" 返回值注释 = "返回是否运行成功" 折叠 @禁止流程检查 = 真>
    参数 文件路径 <类型 = 文本型 注释 = "要打开的可执行文件,如果不提供完整路径,则以当前目录为默认路径.">
    参数 运行参数 <类型 = 文本型 注释 = "命令行参数,参数之间必须用空格分隔" @默认值 = 空对象>
    {
        @ SHELLEXECUTEINFOW ExecInfo { 0 };
        @ ExecInfo.cbSize = sizeof (SHELLEXECUTEINFO);
        @ ExecInfo.fMask = SEE_MASK_NO_CONSOLE | SEE_MASK_FLAG_DDEWAIT;
        @ ExecInfo.lpVerb = L"runas";
        @ ExecInfo.lpFile = @<文件路径>.GetText ();
        @ ExecInfo.lpParameters = @<运行参数>.IsEmpty() ? NULL : @<运行参数>.GetText ();
        @ ExecInfo.lpDirectory = NULL;
        @ ExecInfo.nShow = SW_SHOWDEFAULT;
        @ return (BOOL)::ShellExecuteExW (&ExecInfo);
    }

    方法 枚举进程ID <公开 静态 类型 = 整数 注释 = "获取系统当前所有进程的ID" 返回值注释 = "成功返回进程ID数量,失败返回0." 折叠 @禁止流程检查 = 真
            @强制依赖 = "进程操作类">
    参数 进程ID数组 <类型 = 整数数组类 注释 = "获取的进程ID数组" @输出名 = "aProcessID">
    参数 预估进程数量 <类型 = 整数 注释 = "必须大于系统当前运行的进程数量,默认2048个进程,一般足够了;" 注释 = "如果你电脑运行的程序过多,请自行适当调整该参数." @默认值 = 2048
            @输出名 = "nSize">
    {
        @ aProcessID.data ().InitCount (nSize, TRUE);
        @ DWORD cbNeeded;
        @ BOOL bRet = EnumProcesses ((DWORD *)aProcessID.data ().GetData (), nSize * 4, &cbNeeded);
        @ aProcessID.data ().InitCount (cbNeeded / 4, FALSE);
        @ return (INT)aProcessID.data ().GetCount ();
    }

    方法 强制结束进程 <公开 静态 类型 = 逻辑型 注释 = "根据指定的进程ID强制结束进程(进程无法正常收尾,慎用)." 返回值注释 = "返回是否成功" 折叠 @禁止流程检查 = 真>
    参数 进程ID <类型 = 整数 注释 = "所欲结束的进程ID,如果为空将结束自己" @默认值 = 0 @输出名 = "nProcessId">
    参数 结束代码 <类型 = 整数 注释 = "本结束代码值将被返回到程序的调用方" @默认值 = 0 @输出名 = "nExitCode">
    {
        @ DWORD dwProcessId = (nProcessId == 0) ? GetCurrentProcessId () : (DWORD)nProcessId;
        @ HANDLE hProcess;
        @ hProcess = ::OpenProcess (PROCESS_TERMINATE, FALSE, dwProcessId);
        @ if (!hProcess) return FALSE;
        @ BOOL bRet = ::TerminateProcess (hProcess, (UINT)nExitCode);
        @ ::CloseHandle (hProcess);
        @ return bRet;
    }

    方法 是否为WOW64模式 <公开 静态 类型 = 逻辑型 注释 = "判断当前进程是否运行在WOW64模式."
            注释 = "WOW64(Windows-On-Windows 64bit)是X64 Windows的一个子系统,为32位应用程序提供运行环境." 注释 = "注: 本方法不能用来判断进程和系统位数."
            返回值注释 = "为真表示32位进程运行在64位的系统上,其他情况为假." 折叠 @禁止流程检查 = 真>
    {
        @ BOOL bIsWow64 = FALSE;
        @ typedef BOOL(WINAPI* Typedef_IsWow64Process)(HANDLE, PBOOL);
        @ Typedef_IsWow64Process API_IsWow64Process =
        @         (Typedef_IsWow64Process)::GetProcAddress (::GetModuleHandle (L"Kernel32.dll"), "IsWow64Process");
        @ if (API_IsWow64Process)
        @     API_IsWow64Process (::GetCurrentProcess (), &bIsWow64);
        @ return bIsWow64;
    }

    方法 取所有逻辑驱动器根路径 <公开 静态 类型 = 整数 注释 = "获取所有逻辑驱动器的根路径,如\"C:\\\"" 返回值注释 = "成功返回根路径数量,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 根路径数组 <类型 = 文本数组类 注释 = "成功返回包含所有根路径的数组" @输出名 = "aRootPath">
    {
        @ aRootPath.data().RemoveAll();
        @ WCHAR szBuffer[MAX_PATH + 1]{0};
        @ DWORD dwBufLen = ::GetLogicalDriveStringsW(MAX_PATH, szBuffer);
        @ if (dwBufLen == 0) return 0;
        @ for (DWORD i = 0; i < dwBufLen; i += 4)
        @     aRootPath.data().Add(szBuffer + i);
        @ return (INT)aRootPath.data().GetCount();
    }

    方法 取DOS驱动器名称 <公开 静态 类型 = 文本型 注释 = "获取MS-DOS格式的驱动器名称,如\"\\Device\\HarddiskVolume1\""
            返回值注释 = "成功返回驱动器名称,失败返回空文本." 折叠 @禁止流程检查 = 真>
    参数 所欲取名称的盘符 <类型 = 文本型 注释 = "指定要获取MS-DOS名称的盘符,盘符后不能带反斜杠,必须是\"C:\"这种格式;" 注释 = "大小写不敏感."
            @输出名 = "szDeviceName">
    {
        @ WCHAR szBuffer[MAX_PATH] = L"\0";
        @ DWORD dwBufLen = ::QueryDosDeviceW ((LPCWSTR)szDeviceName.GetText (), szBuffer, MAX_PATH);
        @ return @an<CVolString> (szBuffer, dwBufLen);
    }

    方法 DOS名称路径转盘符路径 <公开 静态 类型 = 文本型 注释 = "将\"\\Device\\HarddiskVolume1\\...\"这种MS-DOS路径转换成\"C:\\...\"."
            返回值注释 = "成功返回转换后的路径,失败返回转换前的路径." 折叠 @禁止流程检查 = 真>
    参数 所欲转换的路径 <类型 = 文本型 注释 = "所欲转换的MS-DOS路径,必须是本机取的路径.">
    {
        变量 盘符数组 <类型 = 文本数组类>
        如果 (取所有逻辑驱动器根路径 (盘符数组) == 0)
        {
            返回 (所欲转换的路径)
        }
        盘符数组.枚举循环 ()
        {
            变量 DOS驱动器名称 <类型 = 文本型>
            DOS驱动器名称 = 取DOS驱动器名称 (取文本左边 (盘符数组.取枚举值 (), 2))
            如果 (是否以文本开头 (所欲转换的路径, DOS驱动器名称) == 真)
            {
                变量 结果文本 <类型 = 文本型>
                结果文本 = 所欲转换的路径
                子文本替换 (结果文本, DOS驱动器名称, 取文本左边 (盘符数组.取枚举值 (), 2), 0, 1, 假)
                返回 (结果文本)
            }
        }
        返回 (所欲转换的路径)
    }
}

类 模块操作类 <公开 注释 = "  面向对象加载模块(dll)文件,和获取其中的函数地址." 注释 = "  建议定义为成员变量,以便在退出程序前才释放模块,也"
        注释 = "建议每个模块文件使用一个类实例." 折叠 @文档 = "category = \"进程操作\"">
{

    # @begin
    # <> <include>
    # HMODULE hLibModule = NULL;
    # <> </include>
    # @end

    变量 _自动释放 <类型 = 逻辑型>

    方法 类_清理 <折叠>
    {
        如果 (_自动释放 == 真)
        {
            释放模块 ()
        }
    }

    方法 加载模块 <公开 类型 = 变整数 注释 = "加载模块文件(dll文件),使用本类必须首先调用本方法."
            注释 = "如果其他应用程序已经加载过同样的dll,系统不会加载另一个实例,而是将dll的引用计数加1." 注释 = "重复使用本方法会先释放之前加载的模块(建议每个模块使用一个类实例)."
            返回值注释 = "成功返回模块句柄,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 模块名称 <类型 = 文本型 注释 = "所欲加载的模块文件名称(区分大小写);" 注释 = "如省略扩展名则默认为\".dll\". 结尾为\".\"则表示该模块名称没有扩展名;"
            注释 = "该名称可以不包含路径,如果指定路径,必须用反斜杠\"\\\\\".">
    参数 自动释放模块 <类型 = 逻辑型 注释 = "释放在类析构时自动释放模块;" 注释 = "如果设置为假,则需要自己手动释放,或者程序结束时自动释放." @默认值 = 真>
    {
        _自动释放 = 自动释放模块
        @ if (hLibModule) ::FreeLibrary (hLibModule);
        @ hLibModule = ::LoadLibraryW (@<模块名称>.GetText ());
        @ return (INT_P)hLibModule;
    }

    方法 释放模块 <公开 类型 = 逻辑型 注释 = "释放模块,dll不再使用时应当释放模块." 注释 = "类清理时会自动调用本方法,一般不需要你手动调用,释放后不应再使用获取的函数地址."
            注释 = "每释放一次会将dll的引用计数减1,如果引用计数为0则在内存中彻底卸载该dll,这时再" 注释 = "使用dll里的函数地址将会报错." 返回值注释 = "返回是否释放成功" 折叠
            @禁止流程检查 = 真>
    {
        @ if (hLibModule)
        @ {
        @     if (::FreeLibrary (hLibModule))
        @     {
        @         hLibModule = NULL;
        @         return TRUE;
        @     }
        @ }
        @ return FALSE;
    }

    方法 取函数地址 <公开 类型 = 变整数 注释 = "获取模块文件中某个函数的指针" 返回值注释 = "成功返回函数地址,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 函数名称 <类型 = 文本型 注释 = "所欲取地址的函数名称">
    {
        @ @an<CVolMem> buf;
        @ return (INT_P)::GetProcAddress(hLibModule, GetMbsText(@<函数名称>.GetText(), buf, NULL));
    }

    方法 取函数地址2 <公开 类型 = 变整数 注释 = "获取模块文件中某个函数的指针" 返回值注释 = "成功返回函数地址,失败返回0." 折叠 @嵌入式方法 = "">
    参数 函数序号 <类型 = 整数 注释 = "所欲取地址的函数序号">
    {
        @ (INT_P)::GetProcAddress(@sn<this>.hLibModule, MAKEINTRESOURCEA(@<函数序号>))
    }
}

类 快照辅助类 <公开 注释 = "通过Toolhelp API获取进程、模块和线程的运行状况." 折叠 @文档 = "category = \"进程操作\""
        @视窗.外部头文件 = "tlhelp32.h" @禁止创建对象 = 真>
{
    方法 枚举进程信息 <公开 静态 类型 = 整数 注释 = "通过系统快照获取当前所有进程的基本信息(ID、名称等)." 返回值注释 = "成功返回进程数量,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 进程信息数组 <类型 = 进程快照数组类 注释 = "获取的进程信息保存在此数组中">
    {
        @ @<进程信息数组>.clear();
        @ HANDLE hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        @ if (hProcessSnap == INVALID_HANDLE_VALUE) return 0;
        @ PROCESSENTRY32W pe32{sizeof(PROCESSENTRY32W)};
        @ if (::Process32FirstW(hProcessSnap, &pe32) == FALSE) return 0;
        @ do {
        @     @<进程信息数组>.push_back(pe32);
        @ } while (::Process32NextW(hProcessSnap, &pe32));
        @ ::CloseHandle(hProcessSnap);
        @ return (INT)@<进程信息数组>.size();
    }

    方法 枚举子进程信息 <公开 静态 类型 = 整数 注释 = "通过系统快照获取指定进程的子进程基本信息(ID、名称等)." 注释 = "子进程指的是由另一进程(对应称之为父进程)所创建的进程,"
            注释 = "比如从桌面运行的软件,其父进程皆为\"explorer.exe\"." 返回值注释 = "成功返回子进程数量,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 父进程ID <类型 = 整数 注释 = "所欲取子进程信息的父进程ID,0为当前进程." @输出名 = "nPID">
    参数 子进程信息数组 <类型 = 进程快照数组类 注释 = "获取的子进程信息保存在此数组中">
    {
        @ @<子进程信息数组>.clear();
        @ HANDLE hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        @ DWORD dwParentPID = nPID == 0 ? ::GetCurrentProcessId() : (DWORD)nPID;
        @ if (hProcessSnap == INVALID_HANDLE_VALUE) return 0;
        @ PROCESSENTRY32W pe32{sizeof(PROCESSENTRY32W)};
        @ if (::Process32FirstW(hProcessSnap, &pe32) == FALSE) return 0;
        @ do {
        @     if (pe32.th32ParentProcessID == dwParentPID)
        @         @<子进程信息数组>.push_back(pe32);
        @ } while (::Process32NextW(hProcessSnap, &pe32));
        @ ::CloseHandle(hProcessSnap);
        @ return (INT)@<子进程信息数组>.size();
    }

    方法 枚举模块信息 <公开 静态 类型 = 整数 注释 = "通过系统快照获取某个进程所有模块的基本信息" 返回值注释 = "成功返回进程的模块数量,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 进程ID <类型 = 整数 注释 = "所欲取模块信息的进程ID,0为当前进程." @输出名 = "nPID">
    参数 模块信息数组 <类型 = 模块快照数组类 注释 = "获取的模块信息保存在此数组中">
    {
        @ @<模块信息数组>.clear();
        @ HANDLE hModuleSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, (DWORD)nPID);
        @ if (hModuleSnap == INVALID_HANDLE_VALUE) return 0;
        @ MODULEENTRY32W me32{sizeof(MODULEENTRY32W)};
        @ if (::Module32FirstW(hModuleSnap, &me32) == FALSE) return 0;
        @ do {
        @     @<模块信息数组>.push_back(me32);
        @ } while (::Module32NextW(hModuleSnap, &me32));
        @ ::CloseHandle(hModuleSnap);
        @ return (INT)@<模块信息数组>.size();
    }

    方法 枚举线程信息 <公开 静态 类型 = 整数 注释 = "通过系统快照获取系统所有线程的基本信息." 注释 = "本方法会一次性获取所有的线程信息,请用\"线程快照类.进程ID\"来特定进程."
            返回值注释 = "成功返回线程数量,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 线程信息数组 <类型 = 线程快照数组类 注释 = "获取的线程信息保存在此数组中">
    {
        @ @<线程信息数组>.clear();
        @ HANDLE hThreadSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
        @ if (hThreadSnap == INVALID_HANDLE_VALUE) return 0;
        @ THREADENTRY32 te32{sizeof(THREADENTRY32)};
        @ if (::Thread32First(hThreadSnap, &te32) == FALSE) return 0;
        @ do {
        @     @<线程信息数组>.push_back(te32);
        @ } while (::Thread32Next(hThreadSnap, &te32));
        @ ::CloseHandle(hThreadSnap);
        @ return (INT)@<线程信息数组>.size();
    }

    方法 枚举堆列表 <公开 静态 类型 = 整数 注释 = "通过系统快照获取线程的堆内存列表ID数组." 注释 = "后续可以用\"枚举堆内存\"历遍所有堆块的信息."
            返回值注释 = "成功返回堆列表数量,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 进程ID <类型 = 整数 注释 = "所欲取堆列表的进程ID,0为当前进程." @输出名 = "nPID">
    参数 堆列表ID数组 <类型 = 变整数数组类 注释 = "获取的堆列表ID保存在此数组中" @输出名 = "aHeapID">
    {
        @ aHeapID.data ().RemoveAll ();
        @ HANDLE hHeapSnap = ::CreateToolhelp32Snapshot (TH32CS_SNAPHEAPLIST, (DWORD)nPID);
        @ if (hHeapSnap == INVALID_HANDLE_VALUE) return 0;
        @ HEAPLIST32 hl32 { sizeof (HEAPLIST32) };
        @ if (::Heap32ListFirst (hHeapSnap, &hl32) == FALSE) return 0;
        @ do
        @ {
        @     aHeapID.data ().Add2 ((INT_P)hl32.th32HeapID);
        @ } while (::Heap32ListNext (hHeapSnap, &hl32));
        @ ::CloseHandle (hHeapSnap);
        @ return (INT)aHeapID.data ().GetCount ();
    }

    方法 枚举堆内存 <公开 静态 类型 = 整数 注释 = "枚举指定堆列表的内存块信息." 注释 = "本方法比\"HeapWalk\"慢很多倍,但可以枚举其他进程的堆内存."
            返回值注释 = "成功返回堆块数量,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 进程ID <类型 = 整数 注释 = "所欲取堆块信息的进程ID" @输出名 = "nPID">
    参数 堆列表ID <类型 = 变整数 注释 = "所欲取堆块信息的堆列表ID" @输出名 = "pHeapID">
    参数 堆块结构数组 <类型 = 堆块结构数组类 注释 = "获取的堆块信息保存在此数组中">
    {
        @ @<堆块结构数组>.clear ();
        @ HEAPENTRY32 he32{sizeof(HEAPENTRY32)};
        @ if (::Heap32First(&he32, (DWORD)nPID, (ULONG_PTR)pHeapID) == FALSE) return 0;
        @ do {
        @     @<堆块结构数组>.push_back(he32);
        @ } while (::Heap32Next(&he32));
        @ return (INT)@<堆块结构数组>.size();
    }

    方法 进程ID取进程名 <公开 静态 类型 = 文本型 注释 = "通过系统快照,根据进程ID获取进程名称." 返回值注释 = "成功返回进程名称,失败返回空文本." 折叠 @禁止流程检查 = 真>
    参数 进程ID <类型 = 整数 注释 = "所欲取进程名称的进程ID" @输出名 = "nProcessID">
    {
        @ HANDLE hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        @ if (hProcessSnap == INVALID_HANDLE_VALUE) return 0;
        @ PROCESSENTRY32W pe32{sizeof(PROCESSENTRY32W)};
        @ if (::Process32FirstW(hProcessSnap, &pe32) == FALSE) return 0;
        @ do {
        @     if (pe32.th32ProcessID == nProcessID) {
        @         ::CloseHandle(hProcessSnap);
        @         return @an<CVolString>(pe32.szExeFile);
        @     }
        @ } while (::Process32NextW(hProcessSnap, &pe32));
        @ ::CloseHandle(hProcessSnap);
        @ return @an<CVolString>(L"");
    }

    方法 进程名取进程ID <公开 静态 类型 = 整数 注释 = "通过系统快照,根据进程名称获取进程ID,本方法返回同一个进程名称的所有进程ID."
            返回值注释 = "成功返回进程ID数量,失败或指定的进程名称不存在返回0." 折叠 @禁止流程检查 = 真>
    参数 进程名称 <类型 = 文本型 注释 = "所欲取进程ID的进程名称,不需要包含路径." @输出名 = "ProcessName">
    参数 进程ID数组 <类型 = 整数数组类 注释 = "获取的进程ID保存在此数组中" @输出名 = "aProcessID">
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定进程名称是否区分英文字母的大小写" @默认值 = 真 @输出名 = "bCaseMatch">
    {
        @ aProcessID.data().RemoveAll();
        @ HANDLE hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        @ if (hProcessSnap == INVALID_HANDLE_VALUE) return 0;
        @ PROCESSENTRY32W pe32{sizeof(PROCESSENTRY32W)};
        @ if (::Process32FirstW(hProcessSnap, &pe32) == FALSE) return 0;
        @ do {
        @     if ((bCaseMatch ? ProcessName.compare(pe32.szExeFile) : ProcessName.icompare(pe32.szExeFile)) == 0) {
        @         aProcessID.data().Add2((INT)pe32.th32ProcessID);
        @     }
        @ } while (::Process32NextW(hProcessSnap, &pe32));
        @ ::CloseHandle(hProcessSnap);
        @ return (INT)aProcessID.data().GetCount();
    }

    方法 取进程线程信息 <公开 静态 类型 = 整数 注释 = "通过系统快照获取指定进程的所有线程的基本信息" 返回值注释 = "成功返回线程数量,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 进程ID <类型 = 整数 注释 = "所欲取子进程信息的父进程ID,0为当前进程." @默认值 = 0>
    参数 线程信息数组 <类型 = 线程快照数组类 注释 = "获取的线程信息保存在此数组中">
    {
        @ @<线程信息数组>.clear();
        @ DWORD dwPID = (@<进程ID> == 0) ? ::GetCurrentProcessId() : (DWORD)@<进程ID>;
        @ HANDLE hThreadSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
        @ if (hThreadSnap == INVALID_HANDLE_VALUE) return 0;
        @ THREADENTRY32 te32{sizeof(THREADENTRY32)};
        @ if (::Thread32First(hThreadSnap, &te32) == FALSE) return 0;
        @ do {
        @     if (dwPID == te32.th32OwnerProcessID)
        @         @<线程信息数组>.push_back(te32);
        @ } while (::Thread32Next(hThreadSnap, &te32));
        @ ::CloseHandle(hThreadSnap);
        @ return (INT)@<线程信息数组>.size();
    }

    方法 取进程线程数 <公开 静态 类型 = 整数 注释 = "通过系统快照获取某个进程的线程数量" 返回值注释 = "成功返回进程的线程数量" 折叠 @禁止流程检查 = 真>
    参数 进程ID <类型 = 整数 注释 = "所欲取线程数量的进程ID" @输出名 = "nProcessID">
    {
        @ HANDLE hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        @ if (hProcessSnap == INVALID_HANDLE_VALUE) return 0;
        @ PROCESSENTRY32W pe32{ sizeof(PROCESSENTRY32W)};
        @ if (::Process32FirstW(hProcessSnap, &pe32) == FALSE) return 0;
        @ do {
        @     if (pe32.th32ProcessID == nProcessID) {
        @         ::CloseHandle(hProcessSnap);
        @         return (INT)pe32.cntThreads;
        @     }
        @ } while (::Process32NextW(hProcessSnap, &pe32));
        @ ::CloseHandle(hProcessSnap);
        @ return 0;
    }
}

# ======

类 内存模块PP <公开 注释 = "MemoryModulePP相比原版,支持了异常和线程局部存储."
        注释 = "https://github.com/strivexjun/MemoryModulePP" 注释 = " 1. 本模块是官方\"内存模块库\"的一个分支,所以这两者不能同时使用;"
        注释 = " 2. 封装跟\"内存模块库\"有些不同,需要将本类实例化,每个实例只能同时加载一个模块;" 注释 = " 3. 模块的位数必须跟主程序一致;"
        注释 = " 4. 由于技术上的局限性,有些DLL无法内存加载,比如带MFC窗口的DLL;" 注释 = " 5. 32位调试运行时可能会导致程序异常退出,一般在编译发布版后可用;" 折叠
        @文档 = "category = \"内存注入\"" @视窗.外部头文件 = "src\\MemoryModulePP.h" @视窗.外部源文件 = "src\\MemoryModulePP.c">
{

    # @begin
    # <> <include>
    # MEMORYMODULE* m_module = nullptr;
    # <> </include>
    # @end

    方法 从内存加载 <公开 类型 = 逻辑型 注释 = "从内存加载具有指定大小的EXE/DLL文件." 注释 = "注意: 如果加载的EXE完成运行,本进程也将终止."
            返回值注释 = "返回是否加载成功,如果本对象已经加载了模块将返回假." 折叠 @禁止流程检查 = 真>
    参数 内存指针 <类型 = 变整数 注释 = "欲加载的模块数据指针">
    参数 数据大小 <类型 = 整数 注释 = "欲加载的模块数据大小">
    {
        @ if (m_module) return FALSE;
        @ m_module = MemoryLoadLibrary(reinterpret_cast<const void *>(@<内存指针>), static_cast<size_t>(@<数据大小>));
        @ return (m_module != nullptr);
    }

    方法 从文件加载 <公开 类型 = 逻辑型 注释 = "从文件加载EXE/DLL文件." 注释 = "注意: 如果加载的EXE完成运行,本进程也将终止."
            返回值注释 = "返回是否加载成功,如果本对象已经加载了模块将返回假." 折叠 @禁止流程检查 = 真>
    参数 文件名称 <类型 = 文本型 注释 = "欲加载的模块文件名称">
    {
        @ if (m_module) return FALSE;
        @ @an<CVolMem> module_mem;
        @ module_mem.ReadFromFile(@<文件名称>, -1);
        @ m_module = MemoryLoadLibrary(module_mem.GetPtr(), static_cast<size_t>(module_mem.GetSize()));
        @ return (m_module != nullptr);
    }

    方法 从字节集加载 <公开 类型 = 逻辑型 注释 = "从字节集加载EXE/DLL文件." 注释 = "注意: 如果加载的EXE完成运行,本进程也将终止."
            返回值注释 = "返回是否加载成功,如果本对象已经加载了模块将返回假." 折叠 @禁止流程检查 = 真>
    参数 模块数据 <类型 = 字节集类 注释 = "欲加载的模块数据">
    {
        @ if (m_module) return FALSE;
        @ m_module = MemoryLoadLibrary(@<模块数据>.GetPtr(), static_cast<size_t>(@<模块数据>.GetSize()));
        @ return (m_module != nullptr);
    }

    方法 从资源加载 <公开 类型 = 逻辑型 注释 = "从视窗文件资源加载EXE/DLL文件." 注释 = "注意: 如果加载的EXE完成运行,本进程也将终止."
            返回值注释 = "返回是否加载成功,如果本对象已经加载了模块将返回假." 折叠 @禁止流程检查 = 真>
    参数 模块资源 <类型 = 视窗文件资源 注释 = "欲加载的模块数据">
    {
        @ if (m_module) return FALSE;
        @ HMODULE hModule = g_objVolApp.GetInstanceHandle();
        @ HRSRC hSrc = ::FindResourceW(hModule, MAKEINTRESOURCEW(@<模块资源>), RT_RCDATA);
        @ if (hSrc == NULL) return FALSE;
        @ HGLOBAL resdata = ::LoadResource(hModule, ::FindResourceW(hModule, MAKEINTRESOURCEW(@<模块资源>), RT_RCDATA));
        @ if (resdata == NULL) return FALSE;
        @ m_module = MemoryLoadLibrary(::LockResource(resdata), ::SizeofResource(hModule, hSrc));
        @ return (m_module != nullptr);
    }

    方法 释放模块 <公开 注释 = "释放已加载的内存模块." 注释 = "注意: 对象析构时不会自动释放模块." 折叠 @禁止流程检查 = 真>
    {
        @ if (m_module) {
        @     MemoryFreeLibrary(m_module);
        @     m_module = nullptr;
        @ }
    }

    方法 是否已加载 <公开 类型 = 逻辑型 注释 = "返回当前是否已加载内存模块" 折叠 @嵌入式方法 = "">
    {
        @ (@sn<this>.m_module != nullptr)
    }

    方法 取函数指针 <公开 类型 = 变整数 注释 = "从已加载的内存模块中获取指定名称的函数指针,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 函数名称 <类型 = 文本型 注释 = "函数导出时的名称">
    {
        @ @an<CVolMem> buf;
        @ return reinterpret_cast<INT_P>(MemoryGetProcAddress(m_module, GetMbsText(@<函数名称>.GetText(), buf, NULL)));
    }

    方法 取函数指针2 <公开 类型 = 变整数 注释 = "从已加载的内存模块中获取指定序号的函数指针,失败返回0." 折叠 @嵌入式方法 = "">
    参数 函数名称或序号 <类型 = 变整数 注释 = "提供导出函数的序号或多字节文本指针;" 注释 = "如果为序号,必须从1开始.">
    {
        @ reinterpret_cast<INT_P>(MemoryGetProcAddress(@sn<this>.m_module, reinterpret_cast<LPCSTR>(@<函数名称或序号>)))
    }

    方法 运行程序 <公开 类型 = 整数 注释 = "执行入口点(仅限EXE)." 注释 = "只有当EXE已加载到正确的基址或可以重新定位时(即链接器未剥离重新定位信息),才能执行入口点."
            注释 = "注意: 调用此函数没有退路,一旦加载的EXE完成运行,进程将终止." 返回值注释 = "如果无法执行入口点,则返回负值." 折叠 @嵌入式方法 = "">
    {
        @ MemoryCallEntryPoint(@sn<this>.m_module)
    }

    方法 寻找资源 <公开 类型 = 变整数 注释 = "查找并获取指定标识和类型的资源" 返回值注释 = "成功返回资源句柄,如果失败此函数必定返回0." 折叠 @嵌入式方法 = "">
    参数 资源标识 <类型 = 整数 注释 = "欲获取的资源标识ID">
    参数 资源类型 <类型 = 视窗资源类型 注释 = "欲获取的资源类型" @默认值 = 视窗资源类型.原始数据>
    参数 语言ID <类型 = 整数 注释 = "提供资源的语言ID,0为与当前线程关联的语言;" 注释 = "如果在资源中找不到指定的语言,则使用第一个可用的语言ID;"
            注释 = " 0x0804 简体中文, 0x0009 英文" 注释 = " 0x0404 繁体中文, 0x0411 日文, 0x0412 韩文" @默认值 = 0>
    {
        @ reinterpret_cast<INT_P>(MemoryFindResourceEx(@sn<this>.m_module, MAKEINTRESOURCE(@<资源标识>),
        @                         MAKEINTRESOURCE(@<资源类型>), static_cast<WORD>(@<语言ID>)))
    }

    方法 取资源尺寸 <公开 类型 = 整数 注释 = "获取指定资源的大小(以字节为单位)" 返回值注释 = "成功返回数据尺寸,失败返回0" 折叠 @嵌入式方法 = "">
    参数 资源句柄 <类型 = 变整数 注释 = "请提供\"寻找资源\"返回的句柄">
    {
        @ static_cast<INT>(MemorySizeofResource(@sn<this>.m_module, reinterpret_cast<HMEMORYRSRC>(@<资源句柄>)))
    }

    方法 取资源地址 <公开 类型 = 变整数 注释 = "获取指定资源的指针地址" 返回值注释 = "成功返回数据指针,失败返回0" 折叠 @嵌入式方法 = "">
    参数 资源句柄 <类型 = 变整数 注释 = "请提供\"寻找资源\"返回的句柄">
    {
        @ reinterpret_cast<INT_P>(MemoryLoadResource(@sn<this>.m_module, reinterpret_cast<HMEMORYRSRC>(@<资源句柄>)))
    }

    方法 载入资源 <公开 类型 = 逻辑型 注释 = "将指定资源的数据复制到字节集中" 折叠>
    参数 资源句柄 <类型 = 变整数 注释 = "请提供\"寻找资源\"返回的句柄">
    参数 返回字节集 <类型 = 字节集类 注释 = "载入的资源将复制到此字节集中">
    {
        变量 资源指针 <类型 = 变整数>
        变量 资源尺寸 <类型 = 整数>
        资源指针 = 取资源地址 (资源句柄)
        资源尺寸 = 取资源尺寸 (资源句柄)
        如果 (资源指针 != 0 && 资源尺寸 != 0)
        {
            返回字节集.指针复制字节集 (资源指针, 资源尺寸)
            返回 (真)
        }
        返回字节集.清空字节集 ()
        返回 (假)
    }

    方法 载入字符串资源 <公开 类型 = 整数 注释 = "获取内存模块中的字符串资源" 返回值注释 = "加载失败返回0,否则为文本长度." 折叠 @禁止流程检查 = 真>
    参数 资源标识 <类型 = 整数 注释 = "文本资源索引标识,如:1,10,20...">
    参数 返回文本 <类型 = 文本型 注释 = "载入成功后,字符串资源将保存在此参数中">
    参数 语言ID <类型 = 整数 注释 = "提供资源的语言ID,0为与当前线程关联的语言;" 注释 = "如果在资源中找不到指定的语言,则使用第一个可用的语言ID;"
            注释 = " 0x0804 简体中文, 0x0009 英文" 注释 = " 0x0404 繁体中文, 0x0411 日文, 0x0412 韩文" @默认值 = 0>
    {
        @ if (m_module == nullptr) { return 0; }
        @ UINT id = static_cast<UINT>(@<资源标识>);
        @ HMEMORYRSRC resource = MemoryFindResourceEx(m_module, MAKEINTRESOURCE((id >> 4) + 1), RT_STRING, static_cast<WORD>(@<语言ID>));
        @ if (resource == NULL) { return 0; }
        @ PIMAGE_RESOURCE_DIR_STRING_U data = reinterpret_cast<PIMAGE_RESOURCE_DIR_STRING_U>(MemoryLoadResource(m_module, resource));
        @ id = id & 0x0f;
        @ while (id--) {
        @     data = reinterpret_cast<PIMAGE_RESOURCE_DIR_STRING_U>(reinterpret_cast<uintptr_t>(data) + (data->Length + 1) * sizeof(WCHAR));
        @ }
        @ int size = static_cast<int>(data->Length);
        @ if (data->Length == 0) { return 0; }
        @ @<返回文本>.SetText(data->NameString, size);
        @ return size;
    }
}

类 视窗资源类型 <公开 注释 = "资源类型ID常量" 折叠 @文档 = "category = \"内存注入.辅助类\"" @常量类 = 整数>
{
    常量 光标 <公开 值 = 1 注释 = "RT_CURSOR       光标资源">
    常量 位图 <公开 值 = 2 注释 = "RT_BITMAP       位图资源">
    常量 图标 <公开 值 = 3 注释 = "RT_ICON         图标资源">
    常量 菜单 <公开 值 = 4 注释 = "RT_MENU         菜单资源">
    常量 对话框 <公开 值 = 5 注释 = "RT_DIALOG       对话框资源">
    常量 字符串 <公开 值 = 6 注释 = "RT_STRING       字符串表条目">
    常量 字体目录 <公开 值 = 7 注释 = "RT_FONTDIR      字体资源目录">
    常量 字体 <公开 值 = 8 注释 = "RT_FONT         字体资源">
    常量 加速键表 <公开 值 = 9 注释 = "RT_ACCELERATOR  加速键表">
    常量 原始数据 <公开 值 = 10 注释 = "RT_RCDATA       原始数据资源">
    常量 消息表 <公开 值 = 11 注释 = "RT_MESSAGETABLE 消息表条目">
    常量 光标组 <公开 值 = 12 注释 = "RT_GROUP_CURSOR 光标组资源">
    常量 图标组 <公开 值 = 14 注释 = "RT_GROUP_ICON   图标组资源">
    常量 版本 <公开 值 = 16 注释 = "RT_VERSION      版本资源">
    常量 关联文件 <公开 值 = 17 注释 = "RT_DLGINCLUDE   允许资源编辑工具将字符串与\".rc\"文件相关联."
            注释 = "通常,字符串是提供符号名称的头文件的名称.资源编译器分析字符串,但否则将忽略该值.">
    常量 即插即用 <公开 值 = 19 注释 = "RT_PLUGPLAY     即插即用资源">
    常量 VXD <公开 值 = 20 注释 = "RT_VXD          VXD资源">
    常量 动画光标 <公开 值 = 21 注释 = "RT_ANICURSOR    动画光标资源">
    常量 动画图标 <公开 值 = 22 注释 = "RT_ANIICON      动画图标资源">
    常量 HTML <公开 值 = 23 注释 = "RT_HTML         HTML资源">
    常量 清单 <公开 值 = 24 注释 = "RT_MANIFEST     程序集清单">
}

类 远程注入类 <公开 注释 = "在其他进程中远程注入DLL文件,注入的DLL模块可以被系统检索到." 注释 = "为\"进程操作类\"和\"进程辅助类\"的二次封装." 折叠
        @文档 = "category = \"内存注入\"">
{
    变量 进程操作 <类型 = 进程操作类>
    变量 模块名称 <类型 = 文本型 注释 = "保存成功注入的模块名称">

    方法 注入DLL_Ring3 <公开 类型 = 逻辑型 注释 = "Ring3下的DLL注入工具,NtCreateThreadEx + LdrLoadDll方式实现,可以注入系统进程."
            注释 = "本机(Windows 11)测试64位下可用,32位崩溃." 返回值注释 = "返回是否成功" 折叠>
    参数 进程ID <类型 = 整数>
    参数 DLL文件名 <类型 = 文本型>
    {
        变量 注入结果 <类型 = 逻辑型 值 = 假>
        如果 (是否已注入 ())
        {
            返回 (真)
        }
        如果 (文本是否为空 (DLL文件名) == 真)
        {
            返回 (假)
        }
        如果 (进程辅助类.提升进程权限 () == 假)  // 权限不足
        {
            返回 (假)
        }
        如果 (进程操作.打开进程 (进程ID, 进程访问权限.全部权限) == 假)
        {
            返回 (假)
        }
        变量 结构大小 <类型 = 整数>
        变量 结构指针 <类型 = 变整数>
        变量 参数地址 <类型 = 变整数>
        变量 函数大小 <类型 = 整数>
        变量 函数指针 <类型 = 变整数>
        变量 函数地址 <类型 = 变整数>
        @ THREAD_DATA data;
        @ data.fnRtlInitUnicodeString = (pRtlInitUnicodeString)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "RtlInitUnicodeString");
        @ data.fnLdrLoadDll = (pLdrLoadDll)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "LdrLoadDll");
        @ wcscpy(data.dllname, @<DLL文件名>.GetText());
        @ data.ModuleHandle = INVALID_HANDLE_VALUE;
        @ @<结构指针> = (INT_P)&data;
        @ @<结构大小> = (INT)sizeof(THREAD_DATA);
        参数地址 = 进程操作.分配虚拟内存 (0, 4096, 位或 (内存操作类型.提交内存, 内存操作类型.保留内存), 内存页面保护属性.读写)
        如果 (参数地址 == 0)
        {
            进程操作.释放虚拟内存 (参数地址, 0, 内存操作类型.释放内存)
            返回 (假)
        }
        如果 (进程操作.写内存数据 (参数地址, 结构指针, 结构大小) == 假)
        {
            进程操作.释放虚拟内存 (参数地址, 0, 内存操作类型.释放内存)
            返回 (假)
        }
        @ @<函数大小> = (INT_P)ThreadProcEnd - (INT_P)ThreadProc;
        @ @<函数指针> = (INT_P)ThreadProc;
        函数地址 = 进程操作.分配虚拟内存 (0, 函数大小, 位或 (内存操作类型.提交内存, 内存操作类型.保留内存), 内存页面保护属性.可执行_读写)
        如果 (函数地址 == 0)
        {
            进程操作.释放虚拟内存 (参数地址, 0, 内存操作类型.释放内存)
            返回 (假)
        }
        如果 (进程操作.写内存数据 (函数地址, 函数指针, 函数大小) == 假)
        {
            进程操作.释放虚拟内存 (参数地址, 0, 内存操作类型.释放内存)
            进程操作.释放虚拟内存 (函数地址, 0, 内存操作类型.释放内存)
            返回 (假)
        }
        注入结果 = 进程操作.创建远程线程 (函数地址, 参数地址, 真)
        如果 (注入结果 == 真)
        {
            模块名称 = DLL文件名
        }
        进程操作.释放虚拟内存 (参数地址, 0, 内存操作类型.释放内存)
        进程操作.释放虚拟内存 (函数地址, 0, 内存操作类型.释放内存)
        返回 (注入结果)
    }

    方法 注入DLL <公开 类型 = 逻辑型 注释 = "在指定的进程中注入DLL模块,NtCreateThreadEx + LoadLibraryW方式实现." 返回值注释 = "返回是否成功" 折叠>
    参数 进程ID <类型 = 整数>
    参数 DLL文件名 <类型 = 文本型>
    {
        变量 注入结果 <类型 = 逻辑型 值 = 假>
        如果 (是否已注入 ())
        {
            返回 (真)
        }
        如果 (文本是否为空 (DLL文件名) == 真)
        {
            返回 (假)
        }
        如果 (进程辅助类.提升进程权限 (用户权限常量.调试程序) == 假)  // 权限不足
        {
            返回 (假)
        }
        如果 (进程操作.打开进程 (进程ID, 进程访问权限.全部权限) == 假)
        {
            返回 (假)
        }
        变量 参数大小 <类型 = 整数>
        变量 参数地址 <类型 = 变整数>
        变量 函数地址 <类型 = 变整数>
        参数大小 = (取文本长度 (DLL文件名) + 1) * 2
        参数地址 = 进程操作.分配虚拟内存 (0, 参数大小, 位或 (内存操作类型.提交内存, 内存操作类型.保留内存), 内存页面保护属性.读写)
        如果 (参数地址 == 0)
        {
            返回 (假)
        }
        函数地址 = 进程辅助类.取模块函数地址 ("kernel32.dll", "LoadLibraryW")
        如果 (函数地址 == 0)
        {
            返回 (假)
        }
        如果 (进程操作.写内存数据 (参数地址, 取文本指针 (DLL文件名), 参数大小) == 假)
        {
            进程操作.释放虚拟内存 (参数地址, 0, 内存操作类型.释放内存)
            返回 (假)
        }
        注入结果 = 进程操作.创建远程线程 (函数地址, 参数地址, 真)
        进程操作.释放虚拟内存 (参数地址, 0, 内存操作类型.释放内存)
        如果 (注入结果 == 真)
        {
            模块名称 = DLL文件名
        }
        返回 (注入结果)
    }

    方法 释放DLL <公开 类型 = 逻辑型 注释 = "释放注入的DLL模块,类析构时不会自动调用本方法." 返回值注释 = "返回是否释放成功" 折叠>
    {
        变量 释放结果 <类型 = 逻辑型 值 = 假>
        变量 模块句柄 <类型 = 变整数>
        变量 函数地址 <类型 = 变整数>
        如果 (文本是否为空 (模块名称))
        {
            返回 (假)
        }
        模块句柄 = 进程操作.取模块句柄 (模块名称)
        如果 (模块句柄 == 0)
        {
            返回 (假)
        }
        函数地址 = 进程辅助类.取模块函数地址 ("kernel32.dll", "FreeLibrary")
        如果 (函数地址 == 0)
        {
            返回 (假)
        }
        释放结果 = 进程操作.创建远程线程 (函数地址, 模块句柄, 真)
        如果 (释放结果 == 真)
        {
            模块名称 = ""
        }
        返回 (释放结果)
    }

    方法 是否已注入 <公开 类型 = 逻辑型 注释 = "返回是否已经注入DLL模块" 返回值注释 = "已注入返回真" 折叠>
    {
        如果 (文本是否为空 (模块名称) == 假 && 进程操作.取模块句柄 (模块名称) != 0)
        {
            返回 (真)
        }
        否则
        {
            返回 (假)

        }
    }

    # @begin
    # <> <include>
    # typedef NTSTATUS(NTAPI *pRtlInitUnicodeString)(PUNICODE_STRING, PCWSTR);
    # typedef NTSTATUS(NTAPI *pLdrLoadDll)(PWCHAR, ULONG, PUNICODE_STRING, PHANDLE);
    # typedef struct _THREAD_DATA
    # {
    #     pLdrLoadDll fnLdrLoadDll;
    #     pRtlInitUnicodeString fnRtlInitUnicodeString;
    #     UNICODE_STRING ModuleFileName;
    #     HANDLE ModuleHandle;
    #     WCHAR dllname[MAX_PATH];
    # } THREAD_DATA,*PTHREAD_DATA;
    # static DWORD WINAPI ThreadProc(PTHREAD_DATA data)
    # {
    #     data->fnRtlInitUnicodeString(&data->ModuleFileName, data->dllname);
    #     data->fnLdrLoadDll(NULL, 0, &data->ModuleFileName, &data->ModuleHandle);
    #     return 0;
    # }
    # static DWORD WINAPI ThreadProcEnd() { return 0; }
    # <> </include>
    # @end
}

# ======

类 进程访问权限 <公开 注释 = "打开进程句柄时使用的访问权限,可以为多个常量的组合值(连续位或)." 折叠 @文档 = "category = \"进程操作.辅助类\"">
{
    常量 全部权限 <公开 类型 = 整数 值 = @PROCESS_ALL_ACCESS 注释 = "进程对象所有允许使用的权限">
    常量 创建进程 <公开 类型 = 整数 值 = @PROCESS_CREATE_PROCESS 注释 = "允许创建进程">
    常量 创建线程 <公开 类型 = 整数 值 = @PROCESS_CREATE_THREAD 注释 = "允许创建线程">
    常量 复制句柄 <公开 类型 = 整数 值 = @PROCESS_DUP_HANDLE 注释 = "允许使用DuplicateHandle(将进程内的一个伪句柄,转化为可以用来进程间通信的实句柄).">
    常量 查询进程信息 <公开 类型 = 整数 值 = @PROCESS_QUERY_INFORMATION
            注释 = "允许查询进程某些信息,比如用OpenProcessToken查询进程的令牌、退出代码和优先级等.">
    常量 查询特定进程信息 <类型 = 整数 值 = 0x1000
            注释 = "允许查询进程的特定信息,比如使用GetExitCodeProcess、GetPriorityClass,、IsProcessInJob、QueryFullProcessImageName获取某个特定的信息."
            注释 = "句柄拥有\"查询进程信息\"权限时自动拥有本权限." 注释 = "Windows Server 2003和Windows XP不支持该访问权限.">
    常量 设置进程信息 <公开 类型 = 整数 值 = @PROCESS_SET_INFORMATION 注释 = "允许设置进程的信息,例如使用SetPriorityClass设置进程优先级.">
    常量 设置配额 <公开 类型 = 整数 值 = @PROCESS_SET_QUOTA 注释 = "允许使用SetProcessWorkingSetSize设置内存大小限制">
    常量 暂停进程 <公开 类型 = 整数 值 = @PROCESS_SUSPEND_RESUME 注释 = "允许暂停和恢复进程">
    常量 结束进程 <公开 类型 = 整数 值 = @PROCESS_TERMINATE 注释 = "允许使用TerminateProcess结束进程">
    常量 操作虚拟内存 <公开 类型 = 整数 值 = @PROCESS_VM_OPERATION 注释 = "允许对进程的地址空间执行操作">
    常量 读虚拟内存 <公开 类型 = 整数 值 = @PROCESS_VM_READ 注释 = "允许使用ReadProcessMemory读取进程的虚拟内存">
    常量 写虚拟内存 <公开 类型 = 整数 值 = @PROCESS_VM_WRITE 注释 = "允许使用WriteProcessMemory改写进程的虚拟内存">
    常量 同步 <公开 类型 = 整数 值 = @SYNCHRONIZE 注释 = "允许使用任意的等待函数来等待进程结束."
            注释 = "https://docs.microsoft.com/en-us/windows/win32/sync/wait-functions">
}

类 内存操作类型 <公开 折叠 @文档 = "category = \"进程操作.辅助类\"">
{
    常量 提交内存 <公开 类型 = 整数 值 = @MEM_COMMIT>
    常量 保留内存 <公开 类型 = 整数 值 = @MEM_RESERVE>
    常量 "" <公开 类型 = 整数 值 = @MEM_REPLACE_PLACEHOLDER>
    常量 "" <公开 类型 = 整数 值 = @MEM_RESERVE_PLACEHOLDER>
    常量 "" <公开 类型 = 整数 值 = @MEM_RESET>
    常量 "" <公开 类型 = 整数 值 = @MEM_TOP_DOWN>
    常量 "" <公开 类型 = 整数 值 = @MEM_WRITE_WATCH>
    常量 "" <公开 类型 = 整数 值 = @MEM_PHYSICAL>
    常量 "" <公开 类型 = 整数 值 = @MEM_ROTATE>
    常量 "" <公开 类型 = 整数 值 = @MEM_DIFFERENT_IMAGE_BASE_OK>
    常量 "" <公开 类型 = 整数 值 = @MEM_RESET_UNDO>
    常量 "" <公开 类型 = 整数 值 = @MEM_LARGE_PAGES>
    常量 "" <公开 类型 = 整数 值 = @MEM_4MB_PAGES>
    常量 "" <公开 类型 = 整数 值 = @MEM_64K_PAGES>
    常量 "" <公开 类型 = 整数 值 = @MEM_UNMAP_WITH_TRANSIENT_BOOST>
    常量 ""
    常量 "" <公开 类型 = 整数 值 = @MEM_COALESCE_PLACEHOLDERS
            注释 = "To coalesce two adjacent placeholders, specify . When you coalesce placeholders, lpAddress and dwSize must exactly match those of the placeholder. MEM_RELEASE | MEM_COALESCE_PLACEHOLDERS">
    常量 "" <公开 类型 = 整数 值 = @MEM_PRESERVE_PLACEHOLDER
            注释 = "Frees an allocation back to a placeholder (after you\'ve replaced a placeholder with a private allocation using VirtualAlloc2 or Virtual2AllocFromApp)."
            注释 = "To split a placeholder into two placeholders, specify .MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER">
    常量 取消提交 <公开 类型 = 整数 值 = @MEM_DECOMMIT
            注释 = "Decommits the specified region of committed pages. After the operation, the pages are in the reserved state."
            注释 = "The function does not fail if you attempt to decommit an uncommitted page. This means that you can decommit a range of pages without first determining the current commitment state."
            注释 = "The MEM_DECOMMIT value is not supported when the lpAddress parameter provides the base address for an enclave.">
    常量 释放内存 <公开 类型 = 整数 值 = @MEM_RELEASE
            注释 = "Releases the specified region of pages, or placeholder (for a placeholder, the address space is released and available for other allocations). After this operation, the pages are in the free state."
            注释 = "If you specify this value, dwSize must be 0 (zero), and lpAddress must point to the base address returned by the VirtualAlloc function when the region is reserved. The function fails if either of these conditions is not met."
            注释 = "If any pages in the region are committed currently, the function first decommits, and then releases them."
            注释 = "The function does not fail if you attempt to release pages that are in different states, some reserved and some committed. This means that you can release a range of pages without first determining the current commitment state.">
    常量 "" <公开 类型 = 整数 值 = @MEM_FREE>
}

类 内存页面保护属性 <公开 折叠 @文档 = "category = \"进程操作.辅助类\"">
{
    常量 不可访问 <公开 类型 = 整数 值 = @PAGE_NOACCESS>
    常量 只读 <公开 类型 = 整数 值 = @PAGE_READONLY>
    常量 读写 <公开 类型 = 整数 值 = @PAGE_READWRITE>
    常量 写入时复制 <公开 类型 = 整数 值 = @PAGE_WRITECOPY>
    常量 可执行 <公开 类型 = 整数 值 = @PAGE_EXECUTE>
    常量 可执行_可读 <公开 类型 = 整数 值 = @PAGE_EXECUTE_READ>
    常量 可执行_读写 <公开 类型 = 整数 值 = @PAGE_EXECUTE_READWRITE>
    常量 可执行_写入时复制 <公开 类型 = 整数 值 = @PAGE_EXECUTE_WRITECOPY>
    常量 "//" <公开 类型 = 整数 值 = @PAGE_TARGETS_INVALID>
    常量 "//" <公开 类型 = 整数 值 = @PAGE_TARGETS_NO_UPDATE>
    常量 保护 <公开 类型 = 整数 值 = @PAGE_GUARD 注释 = "如果访问则异常(不能单独使用)">
    常量 禁用缓存 <公开 类型 = 整数 值 = @PAGE_NOCACHE>
    常量 写聚合 <公开 类型 = 整数 值 = @PAGE_WRITECOMBINE>
    常量 "//" <公开 类型 = 整数 值 = @PAGE_ENCLAVE_THREAD_CONTROL>
    常量 "//" <公开 类型 = 整数 值 = @PAGE_ENCLAVE_UNVALIDATED>
}

类 内存页面类型 <公开 折叠 @文档 = "category = \"进程操作.辅助类\"">
{
    常量 私有 <公开 类型 = 整数 值 = @MEM_PRIVATE 注释 = "表示区域内的内存页是私有的(即不与其他进程共享)">
    常量 映射 <公开 类型 = 整数 值 = @MEM_MAPPED 注释 = "表示区域内的内存页已映射到区段的视图中">
    常量 映像 <公开 类型 = 整数 值 = @MEM_IMAGE 注释 = "表示区域内的内存页已映射到映像区段的视图中">
}

类 用户权限常量 <公开 注释 = "用于\"进程辅助类.提升进程权限\""
        注释 = "https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants" 折叠
        @文档 = "category = \"进程操作.辅助类\"" @常量类 = 文本型>
{
    常量 未经请求的输入 <公开 值 = "SeUnsolicitedInputPrivilege" 注释 = "允许从终端设备读取未经请求的输入." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_UNSOLICITED_INPUT_NAME">
    常量 创建令牌对象 <公开 值 = "SeCreateTokenPrivilege" 注释 = "允许创建主令牌,该令牌可以在进程创建访问令牌时用于获取任何本地资源的访问权限."
            编辑时信息 = "5EA30, 482B4, 0, 0" "" = "SE_CREATE_TOKEN_NAME">
    常量 替换进程级令牌 <公开 值 = "SeAssignPrimaryTokenPrivilege" 注释 = "允许在进程中分配主令牌." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_ASSIGNPRIMARYTOKEN_NAME">
    常量 锁定内存页 <公开 值 = "SeLockMemoryPrivilege" 注释 = "允许进程将数据保持在物理内存中,这样可防止系统将数据分页到磁盘上的虚拟内存中."
            编辑时信息 = "5EA30, 482B4, 0, 0" "" = "SE_LOCK_MEMORY_NAME">
    常量 为进程调整内存配额 <公开 值 = "SeIncreaseQuotaPrivilege" 注释 = "允许更改进程可消耗的最大内存." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_INCREASE_QUOTA_NAME">
    常量 将工作站添加到域 <公开 值 = "SeMachineAccountPrivilege" 注释 = "允许将工作站添加到域." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_MACHINE_ACCOUNT_NAME">
    常量 以操作系统方式执行 <公开 值 = "SeTcbPrivilege" 注释 = "允许某个进程模拟任意用户而无须进行身份验证,因此该进程可以与该用户一样获得对本地资源的访问权限."
            编辑时信息 = "5EA30, 482B4, 0, 0" "" = "SE_TCB_NAME">
    常量 管理审核和安全日志 <公开 值 = "SeSecurityPrivilege"
            注释 = "允许指定文件,Active Directory对象和注册表项之类的单个资源的对象访问审核选项.还可以查看和清除安全日志." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_SECURITY_NAME">
    常量 取得文件或其他对象的所有权 <公开 值 = "SeTakeOwnershipPrivilege"
            注释 = "允许取得系统中任何安全对象(包括Active Directory对象、文件和文件夹、打印机、注册表项、进程以及线程)的所有权." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_TAKE_OWNERSHIP_NAME">
    常量 获取同一会话中另一个用户的模拟令牌 <公开 值 = "SeDelegateSessionUserImpersonatePrivilege"
            注释 = "获取同一个会话中以交互方式登录的其他用户的模拟令牌." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_DELEGATE_SESSION_USER_IMPERSONATE_NAME">
    常量 加载和卸载设备驱动程序 <公开 值 = "SeLoadDriverPrivilege" 注释 = "允许安装和卸载驱动程序." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_LOAD_DRIVER_NAME">
    常量 配置文件系统性能 <公开 值 = "SeSystemProfilePrivilege" 注释 = "允许使用性能监视工具来监视整个系统的性能信息."
            编辑时信息 = "5EA30, 482B4, 0, 0" "" = "SE_SYSTEM_PROFILE_NAME">
    常量 更改系统时间 <公开 值 = "SeSystemtimePrivilege" 注释 = "允许更改计算机内部时钟上的日期和时间." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_SYSTEMTIME_NAME">
    常量 配置文件单一进程 <公开 值 = "SeProfileSingleProcessPrivilege" 注释 = "允许使用性能监视工具来监视非系统进程的性能."
            编辑时信息 = "5EA30, 482B4, 0, 0" "" = "SE_PROF_SINGLE_PROCESS_NAME">
    常量 提高计划优先级 <公开 值 = "SeIncreaseBasePriorityPrivilege" 注释 = "允许提高分配给其他进程的执行优先级."
            编辑时信息 = "5EA30, 482B4, 0, 0" "" = "SE_INC_BASE_PRIORITY_NAME">
    常量 创建页面文件 <公开 值 = "SeCreatePagefilePrivilege" 注释 = "允许创建页面文件和更改页面文件的大小." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_CREATE_PAGEFILE_NAME">
    常量 创建永久共享对象 <公开 值 = "SeCreatePermanentPrivilege" 注释 = "允许利用对象管理器创建目录对象." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_CREATE_PERMANENT_NAME">
    常量 备份文件和目录 <公开 值 = "SeBackupPrivilege" 注释 = "允许执行备份文件和目录." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_BACKUP_NAME">
    常量 还原文件和目录 <公开 值 = "SeRestorePrivilege" 注释 = "允许执行还原文件和目录." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_RESTORE_NAME">
    常量 关闭系统 <公开 值 = "SeShutdownPrivilege" 注释 = "允许关闭本地的计算机." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_SHUTDOWN_NAME">
    常量 调试程序 <公开 值 = "SeDebugPrivilege" 注释 = "允许将调试程序连接到任何进程或连接到内核,可以调试和调整属于另一个账户的进程中的内存."
            编辑时信息 = "5EA30, 482B4, 0, 0" "" = "SE_DEBUG_NAME">
    常量 生成安全审核 <公开 值 = "SeAuditPrivilege" 注释 = "允许进程将项目添加到安全日志中." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_AUDIT_NAME">
    常量 修改固件环境值 <公开 值 = "SeSystemEnvironmentPrivilege"
            注释 = "允许修改固件环境值.固件环境变量是在非基于x86的计算机的稳定RAM中存储的设置,该设置的效果依赖于处理器." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_SYSTEM_ENVIRONMENT_NAME">
    常量 绕过遍历检查 <公开 值 = "SeChangeNotifyPrivilege" 注释 = "即使在不具有对已遍历目录的权限时也可以遍历目录树,此权限不允许用户列出目录的内容,仅允许遍历目录."
            编辑时信息 = "5EA30, 482B4, 0, 0" "" = "SE_CHANGE_NOTIFY_NAME">
    常量 从远程系统强制关机 <公开 值 = "SeRemoteShutdownPrivilege" 注释 = "允许从网络上的远程位置关闭计算机." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_REMOTE_SHUTDOWN_NAME">
    常量 从扩展坞上移除计算机 <公开 值 = "SeUndockPrivilege" 注释 = "允许无需登录而从其扩展坞上移除便携式计算机." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_UNDOCK_NAME">
    常量 同步目录服务数据 <公开 值 = "SeSyncAgentPrivilege" 注释 = "允许同步所有目录服务数据,这也称为Active Directory同步."
            编辑时信息 = "5EA30, 482B4, 0, 0" "" = "SE_SYNC_AGENT_NAME">
    常量 信任计算机和用户帐户可以执行委派 <公开 值 = "SeEnableDelegationPrivilege" 注释 = "允许将用户或计算机对象上设置\"已为委派信任\"设置."
            编辑时信息 = "5EA30, 482B4, 0, 0" "" = "SE_ENABLE_DELEGATION_NAME">
    常量 执行卷维护任务 <公开 值 = "SeManageVolumePrivilege" 注释 = "允许在卷上运行维护任务,如远程碎片整理." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_MANAGE_VOLUME_NAME">
    常量 身份验证后模拟客户端 <公开 值 = "SeImpersonatePrivilege" 注释 = "允许在身份验证后模拟客户端." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_IMPERSONATE_NAME">
    常量 创建全局对象 <公开 值 = "SeCreateGlobalPrivilege" 注释 = "允许创建所有会话都可以使用的全局对象." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_CREATE_GLOBAL_NAME">
    常量 作为受信任的呼叫方访问凭据管理器 <公开 值 = "SeTrustedCredManAccessPrivilege" 注释 = "允许以受信任的呼叫方访问凭据管理器."
            编辑时信息 = "5EA30, 482B4, 0, 0" "" = "SE_TRUSTED_CREDMAN_ACCESS_NAME">
    常量 修改对象标签 <公开 值 = "SeRelabelPrivilege" 注释 = "允许修改对象(例如文件、注册表项或其他用户所拥有的进程)的完整性标签."
            编辑时信息 = "5EA30, 482B4, 0, 0" "" = "SE_RELABEL_NAME">
    常量 增加进程工作集 <公开 值 = "SeIncreaseWorkingSetPrivilege" 注释 = "允许增加或减小进程的工作集大小." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_INC_WORKING_SET_NAME">
    常量 更改时区 <公开 值 = "SeTimeZonePrivilege" 注释 = "允许更改计算机用于显示本地时间(计算机的系统时间加上时区偏移)的时区."
            编辑时信息 = "5EA30, 482B4, 0, 0" "" = "SE_TIME_ZONE_NAME">
    常量 创建符号链接 <公开 值 = "SeCreateSymbolicLinkPrivilege" 注释 = "允许创建符号链接." 编辑时信息 = "5EA30, 482B4, 0, 0"
            "" = "SE_CREATE_SYMBOLIC_LINK_NAME">
}

类 用户权限ID <公开 注释 = "用于\"进程辅助类.调整当前权限\"RtlAdjustPrivilege" 折叠 @文档 = "category = \"进程操作.辅助类\"" @常量类 = 整数>
{
    常量 未经请求的输入 <公开 值 = 0x0 注释 = "允许从终端设备读取未经请求的输入" 编辑时信息 = "34C3E, 0, 0, 0"
            "" = "SE_UNSOLICITED_INPUT_NAME">
    常量 创建令牌对象 <公开 值 = 0x2 注释 = "允许创建主令牌,该令牌可以在进程创建访问令牌时用于获取任何本地资源的访问权限." 编辑时信息 = "34C3E, 0, 0, 0"
            "" = "SE_CREATE_TOKEN_NAME">
    常量 替换进程级令牌 <公开 值 = 0x3 注释 = "允许在进程中分配主令牌" 编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_ASSIGNPRIMARYTOKEN_NAME">
    常量 锁定内存页 <公开 值 = 0x4 注释 = "允许进程将数据保持在物理内存中,这样可防止系统将数据分页到磁盘上的虚拟内存中." 编辑时信息 = "34C3E, 0, 0, 0"
            "" = "SE_LOCK_MEMORY_NAME">
    常量 为进程调整内存配额 <公开 值 = 0x5 注释 = "允许更改进程可消耗的最大内存" 编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_INCREASE_QUOTA_NAME">
    常量 将工作站添加到域 <公开 值 = 0x6 注释 = "允许将工作站添加到域" 编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_MACHINE_ACCOUNT_NAME">
    常量 以操作系统方式执行 <公开 值 = 0x7 注释 = "允许某个进程模拟任意用户而无须进行身份验证,因此该进程可以与该用户一样获得对本地资源的访问权限."
            编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_TCB_NAME">
    常量 管理审核和安全日志 <公开 值 = 0x8 注释 = "允许指定文件,Active Directory对象和注册表项之类的单个资源的对象访问审核选项.还可以查看和清除安全日志."
            编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_SECURITY_NAME">
    常量 取得文件或其他对象的所有权 <公开 值 = 0x9 注释 = "允许取得系统中任何安全对象(包括Active Directory对象、文件和文件夹、打印机、注册表项、进程以及线程)的所有权."
            编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_TAKE_OWNERSHIP_NAME">
    常量 获取同一会话中另一个用户的模拟令牌 <公开 值 = 0x10 注释 = "获取同一个会话中以交互方式登录的其他用户的模拟令牌" 编辑时信息 = "34C3E, 0, 0, 0"
            "" = "SE_DELEGATE_SESSION_USER_IMPERSONATE_NAME">
    常量 加载和卸载设备驱动程序 <公开 值 = 0xA 注释 = "允许安装和卸载驱动程序" 编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_LOAD_DRIVER_NAME">
    常量 配置文件系统性能 <公开 值 = 0xB 注释 = "允许使用性能监视工具来监视整个系统的性能信息" 编辑时信息 = "34C3E, 0, 0, 0"
            "" = "SE_SYSTEM_PROFILE_NAME">
    常量 更改系统时间 <公开 值 = 0xC 注释 = "允许更改计算机内部时钟上的日期和时间" 编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_SYSTEMTIME_NAME">
    常量 配置文件单一进程 <公开 值 = 0xD 注释 = "允许使用性能监视工具来监视非系统进程的性能" 编辑时信息 = "34C3E, 0, 0, 0"
            "" = "SE_PROF_SINGLE_PROCESS_NAME">
    常量 提高计划优先级 <公开 值 = 0xE 注释 = "允许提高分配给其他进程的执行优先级" 编辑时信息 = "34C3E, 0, 0, 0"
            "" = "SE_INC_BASE_PRIORITY_NAME">
    常量 创建页面文件 <公开 值 = 0xF 注释 = "允许创建页面文件和更改页面文件的大" 编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_CREATE_PAGEFILE_NAME">
    常量 创建永久共享对象 <公开 值 = 0x10 注释 = "允许利用对象管理器创建目录对象" 编辑时信息 = "34C3E, 0, 0, 0"
            "" = "SE_CREATE_PERMANENT_NAME">
    常量 备份文件和目录 <公开 值 = 0x11 注释 = "允许执行备份文件和目录" 编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_BACKUP_NAME">
    常量 还原文件和目录 <公开 值 = 0x12 注释 = "允许执行还原文件和目录" 编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_RESTORE_NAME">
    常量 关闭系统 <公开 值 = 0x13 注释 = "允许关闭本地的计算机" 编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_SHUTDOWN_NAME">
    常量 调试程序 <公开 值 = 0x14 注释 = "允许将调试程序连接到任何进程或连接到内核,可以调试和调整属于另一个账户的进程中的内存." 编辑时信息 = "34C3E, 0, 0, 0"
            "" = "SE_DEBUG_NAME">
    常量 生成安全审核 <公开 值 = 0x15 注释 = "允许进程将项目添加到安全日志中" 编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_AUDIT_NAME">
    常量 修改固件环境值 <公开 值 = 0x16 注释 = "允许修改固件环境值.固件环境变量是在非基于x86的计算机的稳定RAM中存储的设置,该设置的效果依赖于处理器."
            编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_SYSTEM_ENVIRONMENT_NAME">
    常量 绕过遍历检查 <公开 值 = 0x17 注释 = "即使在不具有对已遍历目录的权限时也可以遍历目录树.此权限不允许用户列出目录的内容,仅允许遍历目录."
            编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_CHANGE_NOTIFY_NAME">
    常量 从远程系统强制关机 <公开 值 = 0x18 注释 = "允许从网络上的远程位置关闭计算机" 编辑时信息 = "34C3E, 0, 0, 0"
            "" = "SE_REMOTE_SHUTDOWN_NAME">
    常量 从扩展坞上移除计算机 <公开 值 = 0x19 注释 = "允许无需登录而从其扩展坞上移除便携式计算机" 编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_UNDOCK_NAME">
    常量 同步目录服务数据 <公开 值 = 0x1A 注释 = "允许同步所有目录服务数据,这也称为Active Directory同步." 编辑时信息 = "34C3E, 0, 0, 0"
            "" = "SE_SYNC_AGENT_NAME">
    常量 信任计算机和用户帐户可以执行委派 <公开 值 = 0x1B 注释 = "允许将用户或计算机对象上设置\"已为委派信任\"设置" 编辑时信息 = "34C3E, 0, 0, 0"
            "" = "SE_ENABLE_DELEGATION_NAME">
    常量 执行卷维护任务 <公开 值 = 0x1C 注释 = "允许在卷上运行维护任务,如远程碎片整理." 编辑时信息 = "34C3E, 0, 0, 0"
            "" = "SE_MANAGE_VOLUME_NAME">
    常量 身份验证后模拟客户端 <公开 值 = 0x1D 注释 = "允许在身份验证后模拟客户端" 编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_IMPERSONATE_NAME">
    常量 创建全局对象 <公开 值 = 0x1E 注释 = "允许创建所有会话都可以使用的全局对象" 编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_CREATE_GLOBAL_NAME">
    常量 作为受信任的呼叫方访问凭据管理器 <公开 值 = 0x1F 注释 = "允许以受信任的呼叫方访问凭据管理器" 编辑时信息 = "34C3E, 0, 0, 0"
            "" = "SE_TRUSTED_CREDMAN_ACCESS_NAME">
    常量 修改对象标签 <公开 值 = 0x20 注释 = "允许修改对象(例如文件、注册表项或其他用户所拥有的进程)的完整性标签." 编辑时信息 = "34C3E, 0, 0, 0"
            "" = "SE_RELABEL_NAME">
    常量 增加进程工作集 <公开 值 = 0x21 注释 = "允许增加或减小进程的工作集大小" 编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_INC_WORKING_SET_NAME">
    常量 更改时区 <公开 值 = 0x22 注释 = "允许更改计算机用于显示本地时间(计算机的系统时间加上时区偏移)的时区" 编辑时信息 = "34C3E, 0, 0, 0"
            "" = "SE_TIME_ZONE_NAME">
    常量 创建符号链接 <公开 值 = 0x23 注释 = "允许创建符号链接" 编辑时信息 = "34C3E, 0, 0, 0" "" = "SE_CREATE_SYMBOLIC_LINK_NAME">
}

类 进程优先级 <公开 注释 = "进程的优先级别,中的常量按优先级从高到低顺序排列." 折叠 @文档 = "category = \"进程操作.辅助类\"" @常量类 = 整数>
{
    常量 实时 <公开 值 = @REALTIME_PRIORITY_CLASS>
    常量 高 <公开 值 = @HIGH_PRIORITY_CLASS>
    常量 高于正常 <公开 值 = @ABOVE_NORMAL_PRIORITY_CLASS>
    常量 正常 <公开 值 = @NORMAL_PRIORITY_CLASS>
    常量 低于正常 <公开 值 = @BELOW_NORMAL_PRIORITY_CLASS>
    常量 低 <公开 值 = @IDLE_PRIORITY_CLASS>
    常量 异常 <公开 值 = 0 注释 = "获取优先级失败或进程未打开会返回该数值">
}

类 模块信息类 <公开 基础类 = PIV结构模板 注释 = "MODULEINFO" 折叠 @文档 = "category = \"进程操作.辅助类\"" @别名 = "MODULEINFO"
        @别名类型 = 本地结构 @模板实现类 = "模块信息类" @强制依赖 = "进程操作类">
{
    变量 lpBaseOfDll <公开 类型 = 通用指针 注释 = "模块文件在虚拟内存中的基址(VA)" @输出名 = "lpBaseOfDll">
    变量 SizeOfImage <公开 类型 = 无符号整数 注释 = "映像文件的尺寸" @输出名 = "SizeOfImage">
    变量 EntryPoint <公开 类型 = 通用指针 注释 = "模块的入口点(VA)" @输出名 = "EntryPoint">
}

类 "// 模块信息类" <公开 基础类 = 扩展对象类 注释 = "MODULEINFO" 折叠 @文档 = "category = \"进程操作.辅助类\"" @视窗.结构类 = 0>
{
    变量 lpBaseOfDll <公开 类型 = 变整数 注释 = "模块文件在虚拟内存中的基址(VA)">
    变量 SizeOfImage <公开 类型 = 整数 注释 = "映像文件的尺寸">
    变量 EntryPoint <公开 类型 = 变整数 注释 = "模块的入口点(VA)">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<MODULEINFO> 总共 3 个成员:\r\n"
        加入文本 (展示内容, "1. lpBaseOfDll: " + 取调试文本2 (最大展示数据尺寸, lpBaseOfDll) + "\r\n")
        加入文本 (展示内容, "2. SizeOfImage: " + 取调试文本2 (最大展示数据尺寸, SizeOfImage) + "\r\n")
        加入文本 (展示内容, "3. EntryPoint: " + 取调试文本2 (最大展示数据尺寸, EntryPoint))
    }
}

类 NT模块信息类 <公开 基础类 = 扩展对象类 折叠 @文档 = "category = \"进程操作.辅助类\"" @强制依赖 = "NT进程操作类">
{
    变量 lpBaseOfDll <公开 类型 = 长整数 注释 = "模块文件在虚拟内存中的基址(VA)">
    变量 SizeOfImage <公开 类型 = 长整数 注释 = "映像文件的字节尺寸">
    变量 EntryPoint <公开 类型 = 长整数 注释 = "模块的入口点(VA)">
    变量 FullDllName <公开 类型 = 文本型 注释 = "模块文件的完整路径">
    变量 BaseDllName <公开 类型 = 文本型 注释 = "模块文件名(无路径)">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<模块信息> 总共 5 个成员:\r\n"
        加入文本 (展示内容, "[1] lpBaseOfDll: " + 取调试文本2 (最大展示数据尺寸, lpBaseOfDll) + "\r\n")
        加入文本 (展示内容, "[2] SizeOfImage: " + 取调试文本2 (最大展示数据尺寸, SizeOfImage) + "\r\n")
        加入文本 (展示内容, "[3] EntryPoint: " + 取调试文本2 (最大展示数据尺寸, EntryPoint) + "\r\n")
        加入文本 (展示内容, "[4] FullDllName: " + 取调试文本2 (最大展示数据尺寸, FullDllName) + "\r\n")
        加入文本 (展示内容, "[5] BaseDllName: " + 取调试文本2 (最大展示数据尺寸, BaseDllName))
    }

    # @begin
    # <> <include>
    # @sn<current_class>(const PivProcessNT::ModuleInfo &info) { SetInfo(info); }
    # inline void SetInfo(const PivProcessNT::ModuleInfo &info) {
    #     @<lpBaseOfDll> = static_cast<INT64>(info.lpBaseOfDll);
    #     @<SizeOfImage> = static_cast<INT64>(info.SizeOfImage);
    #     @<EntryPoint> = static_cast<INT64>(info.EntryPoint);
    #     @<FullDllName> = info.FullDllName;
    #     @<BaseDllName> = info.FullDllName.Right(info.BaseDllNameLen);
    # }
    # <> </include>
    # @end
}

类 NT模块信息数组类 <公开 基础类 = PIV数组模板 @文档 = "category = \"进程操作.辅助类\"" @模板实现类 = "NT模块信息类">

类 进程内存使用情况类 <公开 基础类 = 扩展对象类 注释 = "PROCESS_MEMORY_COUNTERS" 折叠 @视窗.结构类 = 0
        @文档 = "category = \"进程操作.辅助类\"">
{
    变量 结构体尺寸 <公开 类型 = 整数 注释 = "此结构体的尺寸" @输出名 = "cb">
    变量 页面错误数 <公开 类型 = 整数 注释 = "页面的错误计数" @输出名 = "PageFaultCount">
    变量 峰值工作集大小 <公开 类型 = 变整数 注释 = "工作集大小的峰值(字节)" @输出名 = "PeakWorkingSetSize">
    变量 工作集大小 <公开 类型 = 变整数 注释 = "当前的工作集大小(字节)" @输出名 = "WorkingSetSize">
    变量 分页缓冲池用量配额峰值 <公开 类型 = 变整数 注释 = "分页缓冲池的用量配额峰值(字节)" @输出名 = "QuotaPeakPagedPoolUsage">
    变量 分页缓冲池用量配额 <公开 类型 = 变整数 注释 = "当前的分页缓冲池的用量配额(字节)" @输出名 = "QuotaPagedPoolUsage">
    变量 非分页缓冲池用量配额峰值 <公开 类型 = 变整数 注释 = "非分页缓冲池的用量配额峰值(字节)" @输出名 = "QuotaPeakNonPagedPoolUsage">
    变量 非分页缓冲池用量配额 <公开 类型 = 变整数 注释 = "当前的非分页缓冲池的用量配额(字节)" @输出名 = "QuotaNonPagedPoolUsage">
    变量 页面文件用量 <公开 类型 = 变整数 注释 = "此进程的虚拟内存使用值(字节)." 注释 = "是内存管理器为正在运行的进程提交的虚拟内存总量." @输出名 = "PagefileUsage">
    变量 页面文件用量峰值 <公开 类型 = 变整数 注释 = "此进程的生存期内虚拟内存使用的峰值(字节)." @输出名 = "PeakPagefileUsage">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<PROCESS_MEMORY_COUNTERS> 总共 10 个成员:\r\n"
        加入文本 (展示内容, "1. 结构体尺寸: " + 取调试文本2 (最大展示数据尺寸, 结构体尺寸) + "\r\n")
        加入文本 (展示内容, "2. 页面错误数: " + 取调试文本2 (最大展示数据尺寸, 页面错误数) + "\r\n")
        加入文本 (展示内容, "3. 峰值工作集大小: " + 取调试文本2 (最大展示数据尺寸, 峰值工作集大小) + "\r\n")
        加入文本 (展示内容, "4. 工作集大小: " + 取调试文本2 (最大展示数据尺寸, 工作集大小) + "\r\n")
        加入文本 (展示内容, "5. 分页缓冲池用量配额峰值: " + 取调试文本2 (最大展示数据尺寸, 分页缓冲池用量配额峰值) + "\r\n")
        加入文本 (展示内容, "6. 分页缓冲池用量配额: " + 取调试文本2 (最大展示数据尺寸, 分页缓冲池用量配额) + "\r\n")
        加入文本 (展示内容, "7. 非分页缓冲池用量配额峰值: " + 取调试文本2 (最大展示数据尺寸, 非分页缓冲池用量配额峰值) + "\r\n")
        加入文本 (展示内容, "8. 非分页缓冲池用量配额: " + 取调试文本2 (最大展示数据尺寸, 非分页缓冲池用量配额) + "\r\n")
        加入文本 (展示内容, "9. 页面文件用量: " + 取调试文本2 (最大展示数据尺寸, 页面文件用量) + "\r\n")
        加入文本 (展示内容, "10. 页面文件用量峰值: " + 取调试文本2 (最大展示数据尺寸, 页面文件用量峰值))
    }
}

类 进程快照类 <公开 基础类 = PIV结构模板 注释 = "系统快照中的有效进程信息" 折叠 折叠2 @文档 = "category = \"进程操作.辅助类\""
        @别名 = "PROCESSENTRY32W" @别名类型 = 本地结构 @模板实现类 = "进程快照类" @强制依赖 = "快照辅助类">
{
    变量 dwSize <公开 类型 = 整数 @输出名 = "dwSize">
    变量 进程ID <公开 类型 = 整数 注释 = "此进程的ID" @输出名 = "th32ProcessID">
    变量 线程数量 <公开 类型 = 整数 注释 = "此进程已启动的线程数量" @输出名 = "cntThreads">
    变量 父进程ID <公开 类型 = 整数 注释 = "创建此子进程的父进程ID" @输出名 = "th32ParentProcessID">
    变量 线程优先级 <公开 类型 = 整数 注释 = "此进程创建线程的基础优先级" @输出名 = "pcPriClassBase">
    变量 "//进程名称" <公开 类型 = 文本型 注释 = "此进程的可执行文件名" @输出名 = "szExeFile">

    方法 进程名称 <公开 静态 属性读 类型 = 文本型 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 进程快照类>
    {
        @ @an<CVolString>(@<欲操作本对象>.szExeFile)
    }

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = 进程快照类 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 格式文本 <类型 = 文本型
                值 = "<进程快照类 PROCESSENTRY32> 总共 6/10 个成员:\"\r\n1. dwSize: %u\r\n2. 进程ID(th32ProcessID): %u\r\n3. 线程数量(cntThreads): %u\r\n4. 父进程ID(th32ParentProcessID): %u\r\n5. 线程优先级(pcPriClassBase): %u\r\n6. 进程名称(szExeFile): %s">
        返回 (取格式文本 (格式文本, 欲操作本对象.dwSize, 欲操作本对象.进程ID, 欲操作本对象.线程数量, 欲操作本对象.父进程ID, 欲操作本对象.线程优先级, 欲操作本对象.进程名称))
    }
}

类 进程快照数组类 <公开 基础类 = PIV数组模板 注释 = "std::vector<PROCESSENTRY32W>" @文档 = "category = \"进程操作.辅助类\""
        @模板实现类 = "进程快照类">

类 模块快照类 <公开 基础类 = PIV结构模板 注释 = "MODULEENTRY32W 系统快照中的有效模块信息" 注释 = "" 折叠 折叠2
        @文档 = "category = \"进程操作.辅助类\"" @别名 = "MODULEENTRY32W" @别名类型 = 本地结构 @模板实现类 = "模块快照类" @强制依赖 = "快照辅助类">
{
    变量 dwSize <公开 类型 = 整数 @输出名 = "dwSize">
    变量 "// 模块ID" <类型 = 整数 注释 = "当前模块的ID(无用)" @输出名 = "th32ModuleID">
    变量 进程ID <公开 类型 = 整数 注释 = "模块所属进程的ID" @输出名 = "th32ProcessID">
    变量 "//模块基址" <公开 类型 = 变整数 注释 = "模块在所属进程上下文中的基址" @输出名 = "modBaseAddr">
    变量 模块大小 <公开 类型 = 整数 注释 = "模块的大小(字节)" @输出名 = "modBaseSize">
    变量 "// 模块句柄" <公开 类型 = 变整数 注释 = "模块在所属进程上下文中的句柄" @输出名 = "hModule">
    变量 "// 模块名称" <公开 类型 = 文本型 注释 = "模块文件的名称" @输出名 = "szModule">
    变量 "// 模块路径" <公开 类型 = 文本型 注释 = "模块的路径" @输出名 = "szExePath">

    方法 模块基址 <公开 静态 属性读 类型 = 变整数 注释 = "模块在所属进程上下文中的基址" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 模块快照类>
    {
        @ (INT_P)@<欲操作本对象>.modBaseAddr
    }

    方法 模块基址 <公开 静态 属性写 注释 = "模块在所属进程上下文中的基址" 折叠>
    参数 欲操作本对象 <类型 = 模块快照类>
    参数 基址 <类型 = 变整数>
    {
        @ @<欲操作本对象>.modBaseAddr = (BYTE*)@<基址>;
    }

    方法 模块句柄 <公开 静态 属性读 类型 = 变整数 注释 = "模块在所属进程上下文中的句柄" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 模块快照类>
    {
        @ (INT_P)@<欲操作本对象>.hModule
    }

    方法 模块句柄 <公开 静态 属性写 注释 = "模块在所属进程上下文中的句柄" 折叠>
    参数 欲操作本对象 <类型 = 模块快照类>
    参数 句柄 <类型 = 变整数>
    {
        @ @<欲操作本对象>.hModule = (HMODULE)@<句柄>;
    }

    方法 模块名称 <公开 静态 属性读 类型 = 文本型 注释 = "模块文件的名称" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 模块快照类>
    {
        @ @an<CVolString>(@<欲操作本对象>.szModule)
    }

    方法 模块路径 <公开 静态 属性读 类型 = 文本型 注释 = "模块的路径" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 模块快照类>
    {
        @ @an<CVolString>(@<欲操作本对象>.szExePath)
    }

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = 模块快照类 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 格式文本 <类型 = 文本型
                值 = "<模块快照类 MODULEENTRY32> 总共 7/10 个成员:\"\r\n1. dwSize: %u\r\n2. 进程ID(th32ProcessID): %u\r\n3. 模块基址(modBaseAddr): %u\r\n4. 模块大小(modBaseSize): %u\r\n5. 模块句柄(hModule): %I64u\r\n6. 模块名称(szModule): %s\r\n7. 模块路径(szExePath): %s">
        返回 (取格式文本 (格式文本, 欲操作本对象.dwSize, 欲操作本对象.进程ID, 欲操作本对象.模块基址, 欲操作本对象.模块大小, 欲操作本对象.模块句柄, 欲操作本对象.模块名称, 欲操作本对象.模块路径))
    }
}

类 模块快照数组类 <公开 基础类 = PIV数组模板 注释 = "std::vector<MODULEENTRY32W>" @文档 = "category = \"进程操作.辅助类\""
        @模板实现类 = "模块快照类">

类 线程快照类 <公开 基础类 = PIV结构模板 注释 = "THREADENTRY32 系统快照中的线程信息" 注释 = "" 折叠 折叠2
        @文档 = "category = \"进程操作.辅助类\"" @别名 = "THREADENTRY32" @别名类型 = 本地结构 @模板实现类 = "线程快照类" @强制依赖 = "快照辅助类">
{
    变量 dwSize <公开 类型 = 整数 @输出名 = "dwSize">
    变量 线程ID <公开 类型 = 整数 注释 = "线程的ID" @输出名 = "th32ThreadID">
    变量 进程ID <公开 类型 = 整数 注释 = "线程所属进程的ID" @输出名 = "th32OwnerProcessID">
    变量 基本优先级 <公开 类型 = 整数 注释 = "分配给线程的内核基本优先级.优先级为0到31的数字,0是最低优先级." @输出名 = "tpBasePri">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = 线程快照类 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 格式文本 <类型 = 文本型
                值 = "<线程快照类 THREADENTRY32> 总共 4/7 个成员:\"\r\n1. dwSize: %u\r\n2. 线程ID(th32ThreadID): %u\r\n3. 进程ID:(th32OwnerProcessID): %u\r\n4. 基本优先级(tpBasePri): %d">
        返回 (取格式文本 (格式文本, 欲操作本对象.dwSize, 欲操作本对象.线程ID, 欲操作本对象.进程ID, 欲操作本对象.基本优先级))
    }
}

类 线程快照数组类 <公开 基础类 = PIV数组模板 注释 = "std::vector<THREADENTRY32>" @文档 = "category = \"进程操作.辅助类\""
        @模板实现类 = "线程快照类">

类 堆块结构类 <公开 基础类 = PIV结构模板 注释 = "HEAPENTRY32" 折叠 折叠2 @文档 = "category = \"进程操作.辅助类\"" @别名 = "HEAPENTRY32"
        @别名类型 = 本地结构 @模板实现类 = "堆块结构类" @强制依赖 = "快照辅助类">
{
    变量 dwSize <公开 类型 = 变整数 注释 = "HEAPENTRY32的结构体尺寸" @输出名 = "dwSize">
    变量 "// hHandle" <公开 类型 = 变整数 注释 = "堆块的句柄" @输出名 = "hHandle">
    变量 dwAddress <公开 类型 = 变整数 注释 = "块开头的线性地址" @输出名 = "dwAddress">
    变量 dwBlockSize <公开 类型 = 变整数 注释 = "堆的块大小" @输出名 = "dwBlockSize">
    变量 dwFlags <公开 类型 = 整数 注释 = "为以下三个值之一:" 注释 = " 1(LF32_FIXED): 此内存块有一个固定位置;"
            注释 = " 2(LF32_FREE): 此内存块未使用;" 注释 = " 4(LF32_MOVEABLE): 此内存块的位置可以移动;" @输出名 = "dwFlags">
    变量 dwLockCount <公开 类型 = 整数 注释 = "本成员不再使用,始终为0" @输出名 = "dwLockCount">
    变量 dwResvd <公开 类型 = 整数 注释 = "保留成员,不要使用或改动." @输出名 = "dwResvd">
    变量 th32ProcessID <公开 类型 = 整数 注释 = "此堆所属进程的ID" @输出名 = "th32ProcessID">
    变量 th32HeapID <公开 类型 = 变整数 注释 = "堆ID" @输出名 = "th32HeapID">

    方法 hHandle <公开 静态 属性读 类型 = 变整数 注释 = "模块在所属进程上下文中的句柄" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 堆块结构类>
    {
        @ (INT_P)@<欲操作本对象>.hHandle
    }

    方法 hHandle <公开 静态 属性写 注释 = "模块在所属进程上下文中的句柄" 折叠>
    参数 欲操作本对象 <类型 = 堆块结构类>
    参数 句柄 <类型 = 变整数>
    {
        @ @<欲操作本对象>.hHandle = (HANDLE)@<句柄>;
    }

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = 堆块结构类 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 格式文本 <类型 = 文本型
                值 = "<堆块结构类 HEAPENTRY3> 总共 9 个成员:\"\r\n1. dwSize: %u\r\n2. hHandle: %u\r\n3. dwAddress: %I64u\r\n4. dwBlockSize: %I64u\r\n5. dwFlags: %u\r\n6. dwLockCount: %u\r\n7. dwResvd: %u\r\n8. th32ProcessID: %u\r\n9. th32HeapID: %I64u">
        返回 (取格式文本 (格式文本, 欲操作本对象.dwSize, 欲操作本对象.hHandle, 欲操作本对象.dwAddress, 欲操作本对象.dwBlockSize, 欲操作本对象.dwFlags, 欲操作本对象.dwLockCount, 欲操作本对象.dwResvd, 欲操作本对象.th32ProcessID, 欲操作本对象.th32HeapID))
    }
}

类 堆块结构数组类 <公开 基础类 = PIV数组模板 注释 = "std::vector<HEAPENTRY32>" @文档 = "category = \"进程操作.辅助类\""
        @模板实现类 = "堆块结构类">

类 内存状态信息类EX <公开 基础类 = 扩展对象类 折叠 @文档 = "category = \"进程操作.辅助类\"">
{
    变量 内存使用率 <公开 类型 = 整数 注释 = "取值0-100%,表示正在使用的内存占物理内存的百分比." @输出名 = "dwMemoryLoad">
    变量 物理内存大小 <公开 类型 = 长整数 注释 = "系统可用的物理内存大小(单位为字节),其中不包含为硬件保留的内存." @输出名 = "ullTotalPhys">
    变量 可用物理内存 <公开 类型 = 长整数 注释 = "当前可用的物理内存量" @输出名 = "ullAvailPhys">
    变量 页面文件总量 <公开 类型 = 长整数 注释 = "系统或当前进程的当前已提交内存限制(单位为字节)" @输出名 = "ullTotalPageFile">
    变量 可用页面文件 <公开 类型 = 长整数 注释 = "当前进程可以提交的最大内存量(单位为字节)" @输出名 = "ullAvailPageFile">
    变量 虚拟内存总量 <公开 类型 = 长整数 注释 = "当前进程的虚拟地址空间的用户模式部分的大小(单位为字节)" @输出名 = "ullTotalVirtual">
    变量 可用虚拟内存 <公开 类型 = 长整数 注释 = "当前进程的虚拟地址空间的用户模式部分的未保留和未提交的内存量(单位为字节)" @输出名 = "ullAvailVirtual">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<内存状态信息类EX> 总共 7 个成员:\r\n"
        加入文本 (展示内容, "1. 内存使用率: " + 取调试文本2 (最大展示数据尺寸, 内存使用率) + "\r\n")
        加入文本 (展示内容, "2. 物理内存大小: " + 取调试文本2 (最大展示数据尺寸, 物理内存大小) + "\r\n")
        加入文本 (展示内容, "3. 可用物理内存: " + 取调试文本2 (最大展示数据尺寸, 可用物理内存) + "\r\n")
        加入文本 (展示内容, "4. 页面文件总量: " + 取调试文本2 (最大展示数据尺寸, 页面文件总量) + "\r\n")
        加入文本 (展示内容, "5. 可用页面文件: " + 取调试文本2 (最大展示数据尺寸, 可用页面文件) + "\r\n")
        加入文本 (展示内容, "6. 虚拟内存总量: " + 取调试文本2 (最大展示数据尺寸, 虚拟内存总量) + "\r\n")
        加入文本 (展示内容, "7. 可用虚拟内存: " + 取调试文本2 (最大展示数据尺寸, 可用虚拟内存))
    }

    #
}
