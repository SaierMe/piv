<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv" "">

类 ULID类 <公开 基础类 = PIV本地类模板 注释 = "ULID(可排序的唯一标识符);"
        注释 = "它结合毫秒时间戳和随机数生成32个字节长度的标识符,并通过Base32转换到26个字符的ULID文本."
        注释 = "  1. ULID前6个字节是毫秒时间戳,后10个字节通过std::mt19937算法生成的随机数;"
        注释 = "  2. ULID跟UUID/GUID相比,最大的区别是可以按字典序排序,先比较前面的时间戳," 注释 = "如果时间戳相等则继续比较后面的随机数;"
        注释 = "  3. ULID可以提取出时间戳;" 注释 = "  4. ULID文本无特殊字符,可直接用于URL、JSON、SQL语句..."
        注释 = "https://github.com/suyash/ulid" 折叠 @文档 = "category = \"伪随机数\""
        @视窗.外部头文件 = "src\\detail\\ulid_struct.hh" @强制依赖 = "PIV对象类" @别名 = "ulid::ULID" @别名类型 = 本地类
        @模板实现类 = "ULID类">
{
    方法 构造 <公开 静态 类型 = ULID类 注释 = "从现行时间创建一个新的ULID对象" 折叠 @禁止流程检查 = 真>
    {
        变量 ulid <类型 = ULID类>
        返回 (ulid.创建 ())
    }

    方法 创建 <公开 静态 类型 = ULID类 注释 = "从现行时间初始化当前的ULID,并返回自身." 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 欲操作本对象 <类型 = ULID类>
    {
        @ ulid::EncodeTimeSystemClockNow(@<欲操作本对象>);
        @ ulid::EncodeEntropyMt19937(std::mt19937{std::random_device{}()}, @<欲操作本对象>);
        @ return @<欲操作本对象>;
    }

    方法 从文本创建 <公开 静态 类型 = 逻辑型 注释 = "从所指定的ULID文本创建对应的ULID并填入本对象中,返回是否成功." 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = ULID类>
    参数 ULID文本 <类型 = 文本型 注释 = "提供所欲转换的文本格式的ULID,格式类似: \"01H5Z4KY89BKVEWY9CVW2Y3EHB\"">
    {
        @ if (@<ULID文本>.GetLength() != 26)
        @     return FALSE;
        @ ulid::UnmarshalFrom<wchar_t>(@<ULID文本>.GetText(), @<欲操作本对象>);
        @ return TRUE;
    }

    方法 从字节集创建 <公开 静态 类型 = 逻辑型 注释 = "从所指定的ULID字节集创建对应的ULID并填入本对象中,返回是否成功." 折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = ULID类>
    参数 ULID字节集 <类型 = 字节集类 注释 = "提供所欲转换的字节集格式的GUID,该字节集应由本类的\"取字节集\"方法返回.">
    {
        @ if (@<ULID字节集>.GetSize() != sizeof(ulid::ULID))
        @     return FALSE;
        @ ulid::UnmarshalBinaryFrom(@<ULID字节集>.GetPtr(), @<欲操作本对象>);
        @ return TRUE;
    }

    方法 取文本 <公开 静态 类型 = 文本型 注释 = "返回本对象中所保存ULID对应的文本,所返回文本格式类似:" 注释 = "\"01H5Z4KY89BKVEWY9CVW2Y3EHB\"" 折叠
            @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = ULID类>
    {
        @ wchar_t data[27];
        @ data[26] = '\0';
        @ ulid::MarshalTo<wchar_t>(@<欲操作本对象>, data);
        @ return @an<CVolString>(data);
    }

    方法 取文本U <公开 静态 类型 = 标准文本类U 注释 = "返回本对象中所保存ULID对应的文本,所返回文本格式类似:" 注释 = "\"01H5Z4KY89BKVEWY9CVW2Y3EHB\""
            折叠 @禁止流程检查 = 真>
    参数 欲操作本对象 <类型 = ULID类>
    {
        @ char data[27];
        @ data[26] = '\0';
        @ ulid::MarshalTo<char>(@<欲操作本对象>, data);
        @ return std::string{data};
    }

    方法 取字节集 <公开 静态 类型 = 字节集类 注释 = "返回本对象中所保存ULID对应的字节集数据" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = ULID类>
    {
        @ @an<CVolMem>(&@<欲操作本对象>, sizeof(ulid::ULID))
    }

    方法 比较 <公开 静态 类型 = 整数 注释 = "比较两个ULID的字典序大小,返回比较结果." 返回值注释 = "返回-1,表示本ULID小于所比较的ULID;"
            返回值注释 = "返回0,表示本ULID等于所比较的ULID;" 返回值注释 = "返回1,表示本ULID大于所比较的ULID;" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = ULID类>
    参数 欲比较对象 <类型 = ULID类>
    {
        @ @<欲操作本对象>.Compare(@<欲比较对象>)
    }

    方法 取时间戳 <公开 静态 类型 = 长整数 注释 = "返回ULID中的毫秒时间戳" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = ULID类>
    {
        @ static_cast<INT64>(ulid::Time(@<欲操作本对象>))
    }

    # ====
    # 下面演示"输出调试"增加对自定义别名类型的支持
    # 你需要熟识文本型(CVolString)在嵌入式代码中的使用
    # @begin
    # <> <global> // 必须在<global>空间中
    # <> <include>
    # // 第二个参数是最大展示数据尺寸,可以无视;
    # // 第三个参数需要填对应本地类/结构体的指针类型;
    # static void PivDumpStr(CVolString &strDebug, INT nMaxDumpSize, ulid::ULID* value)
    # {
    #     if (value != nullptr) // 为了安全,需要先判断是否为空指针
    #     {
    #         wchar_t strBuf[27]; strBuf[26] = '\0';
    #         ulid::MarshalTo<wchar_t>(*value, strBuf);
    #         strDebug.SetText(strBuf);
    #     }
    #     else
    #         strDebug.SetText(L"ulid::ULID: nullptr");
    # }
    # <> </include>
    # <> </global>
    # @end
}

类 ULID排序集 <公开 基础类 = 通用排序集模板 注释 = "可用于对ULID类(可排序的唯一标识符)进行排序存储" 注释 = "" @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "ULID类">

# 随机数 ===

类 标准随机数模板类 <公开 注释 = "封装了<std::random>的基本操作" 注释 = "请勿直接使用本类" 折叠 @文档 = "category = \"伪随机数\""
        @视窗.外部头文件 = "<random>" @模板基础类 = 真>
{

    # @begin
    # <> <include>
    # std::random_device rd;
    # @m<engine> gen;
    # inline void @an<_OnInitExtra>() { gen.seed(rd()); }
    # inline void @an<_CopySelfFromExtra>(const @sn<current_class>& objCopyFrom) { gen = objCopyFrom.gen; }
    # inline @sn<current_class>& operator=(@sn<current_class>&& rhs) { gen = std::move(rhs.gen); return *this; }
    # inline BOOL @an<_IsSelfEqualExtra>(const @sn<current_class>& objCompare) const { return (gen == objCompare.gen); }
    # template <typename T>
    # inline T GenRandInt(const T & min_value, const T & max_value) {
    #     std::uniform_int_distribution<T> dist(min_value, max_value);
    #     return dist(gen);
    # }
    # <> </include>
    # @end
    # 均匀分布

    方法 重置种子 <公开 注释 = "  为随机数引擎重新初始化一个种子值,不同的种子值将导致" 注释 = "后续的取随机数系列方法返回不同的随机数系列值."
            注释 = "  本方法在类初始化时会自动调用,因此仅在你想要一个新的" 注释 = "种子值时,才需要手动调用." 折叠>
    {
        @ gen.seed(rd());
    }

    方法 取随机数 <公开 注释 = "产生在一个范围内均匀分布的伪随机数." 注释 = "本方法可以自定义返回的整数类型." 返回值注释 = "返回产生的随机数,类型与参数\"数值类型\"相同." 折叠
            @嵌入式方法 = "">
    参数 数值类型 <注释 = "请填写\"短整数\"、\"整数\"、\"长整数\"等基本整数型." @匹配类型 = 通用整数型 @需求类型 = 数据类型 @返回值类型 = 0>
    参数 最小值 <注释 = "指定取值范围的最小值,可使用\"数值范围\"中的常量." @匹配类型 = 匹配前参数值类型>
    参数 最大值 <注释 = "指定取值范围的最大值,必须大于等于最小值,可使用\"数值范围\"中的常量." @匹配类型 = 匹配前参数值类型>
    {
        @ @sn<this>.GenRandInt<@<数值类型>>(@<最小值>, @<最大值>)
    }

    方法 取随机整数 <公开 类型 = 整数 注释 = "产生在一个范围内均匀分布的伪随机整数" 返回值注释 = "返回产生的随机整数." 折叠 @禁止流程检查 = 真>
    参数 最小值 <类型 = 整数 注释 = "指定取值范围的最小值" @默认值 = 0>
    参数 最大值 <类型 = 整数 注释 = "指定取值范围的最大值,必须大于等于最小值" @默认值 = 数值范围.最大整数值>
    {
        @ std::uniform_int_distribution<INT> dist(@<最小值>, @<最大值>);
        @ return dist(gen);
    }

    方法 取随机长整数 <公开 类型 = 长整数 注释 = "产生在一个范围内均匀分布的伪随机长整数" 返回值注释 = "返回产生的随机长整数." 折叠 @禁止流程检查 = 真>
    参数 最小值 <类型 = 长整数 注释 = "指定取值范围的最小值" @默认值 = 0>
    参数 最大值 <类型 = 长整数 注释 = "指定取值范围的最大值,必须大于等于最小值" @默认值 = 数值范围.最大长整数值>
    {
        @ std::uniform_int_distribution<INT64> dist(@<最小值>, @<最大值>);
        @ return dist(gen);
    }

    方法 取随机小数 <公开 类型 = 小数 注释 = "产生在一个范围内均匀分布的伪随机小数" 返回值注释 = "返回产生的随机小数." 折叠 @禁止流程检查 = 真>
    参数 最小值 <类型 = 小数 注释 = "指定取值范围的最小值" @默认值 = 0>
    参数 最大值 <类型 = 小数 注释 = "指定取值范围的最大值,必须大于等于最小值" @默认值 = 1.0>
    {
        @ std::uniform_real_distribution<DOUBLE> dist(@<最小值>, @<最大值>);
        @ return dist(gen);
    }

    方法 取随机单精度小数 <公开 类型 = 单精度小数 注释 = "产生在一个范围内均匀分布的伪随机单精度小数" 返回值注释 = "返回产生的随机单精度小数." 折叠 @禁止流程检查 = 真>
    参数 最小值 <类型 = 单精度小数 注释 = "指定取值范围的最小值" @默认值 = 0>
    参数 最大值 <类型 = 单精度小数 注释 = "指定取值范围的最大值,必须大于等于最小值" @默认值 = 1.0>
    {
        @ std::uniform_real_distribution<float> dist(@<最小值>, @<最大值>);
        @ return dist(gen);
    }

    # 伯努利分布

    方法 取伯努利分布逻辑 <公开 类型 = 逻辑型 注释 = "根据伯努利分布离散概率函数产生随机逻辑值" 返回值注释 = "返回产生的随机逻辑值." 折叠 @禁止流程检查 = 真>
    参数 成功概率 <类型 = 小数 注释 = "  取值范围为 0 ≤ p ≤ 1" 注释 = "  默认为50%的概率产生\"真\"." @默认值 = 0.50>
    {
        @ std::bernoulli_distribution dist(@<成功概率>);
        @ return dist(gen);
    }

    方法 取二项分布整数 <公开 类型 = 整数 注释 = "根据二项分布离散概率函数产生随机正整数值." 注释 = "若每次试验的成功率为p,返回t次试验中的成功次数."
            返回值注释 = "返回随机的成功次数." 折叠 @禁止流程检查 = 真>
    参数 试验次数 <类型 = 整数 注释 = "定义为t,必须大于等于0,为试验次数">
    参数 成功概率 <类型 = 小数 注释 = "定义为p,取值范围为0 ≤ p ≤ 1,为每次试验产生\"真\"的概率." @默认值 = 0.50>
    {
        @ std::binomial_distribution<INT> dist(@<试验次数>, @<成功概率>);
        @ return dist(gen);
    }

    方法 取负二项分布整数 <公开 类型 = 整数 注释 = "根据负二项分布离散概率函数产生随机正整数值." 注释 = "若每次试验的成功率为p,在多次试验后得到的成功次数为k,返回其中的失败次数."
            返回值注释 = "返回随机的失败次数." 折叠 @禁止流程检查 = 真>
    参数 成功次数 <类型 = 整数 注释 = "定义为k,必须大于0,为多次试验的成功次数">
    参数 成功概率 <类型 = 小数 注释 = "定义为p,取值范围为0 < p ≤ 1,为每次试验产生\"真\"的概率." @默认值 = 0.50>
    {
        @ std::negative_binomial_distribution<INT> dist(@<成功次数>, @<成功概率>);
        @ return dist(gen);
    }

    方法 取几何分布整数 <公开 类型 = 整数 注释 = "根据几何分布离散概率函数产生随机正整数值." 注释 = "若每次试验的成功率为p,返回需要试验多少次才能获得成功."
            返回值注释 = "返回随机的试验次数." 折叠 @禁止流程检查 = 真>
    参数 成功概率 <类型 = 小数 注释 = "定义为p,取值范围为0 < p < 1,为每次试验产生\"真\"的概率." @默认值 = 0.50>
    {
        @ std::geometric_distribution<INT> dist(@<成功概率>);
        @ return dist(gen);
    }

    # 泊松分布

    方法 取泊松分布整数 <公开 类型 = 整数 注释 = "根据泊松分布离散概率函数产生随机正整数值." 注释 = "若同一时间或空间内平均发生μ次事件,返回其发生i次的概率."
            返回值注释 = "返回随机的概率." 折叠 @禁止流程检查 = 真>
    参数 平均数 <类型 = 小数 注释 = "定义为μ,取值范围为0 < μ,为随机事件发生的平均数." @默认值 = 1.0>
    {
        @ std::poisson_distribution<INT> dist(@<平均数>);
        @ return dist(gen);
    }

    方法 取指数分布小数 <公开 类型 = 小数 注释 = "根据指数分布离散概率函数产生随机正小数值." 注释 = "若随机事件在每个时间或距离单位发生的频率为λ,返回的值为到一次随机事件的时间或距离."
            返回值注释 = "返回随机的时间或距离小数." 折叠 @禁止流程检查 = 真>
    参数 事件频率 <类型 = 小数 注释 = "定义为λ,取值范围为0 < λ,为每单位事件发生的频率." @默认值 = 1.0>
    {
        @ std::exponential_distribution<DOUBLE> dist(@<事件频率>);
        @ return dist(gen);
    }

    方法 取伽玛分布小数 <公开 类型 = 小数 注释 = "根据伽玛分布离散概率函数产生随机正小数值." 注释 = "返回α个独立指数分布的随机变量的和,每个的平均值为β." 折叠 @禁止流程检查 = 真>
    参数 形状 <类型 = 小数 注释 = "定义为α,为形状参数." @默认值 = 1.0>
    参数 尺度 <类型 = 小数 注释 = "定义为β,为尺度参数." @默认值 = 1.0>
    {
        @ std::gamma_distribution<DOUBLE> dist(@<形状>, @<尺度>);
        @ return dist(gen);
    }

    方法 取威布尔分布小数 <公开 类型 = 小数 注释 = "根据威布尔分布离散概率函数产生随机正小数值" 折叠 @禁止流程检查 = 真>
    参数 形状 <类型 = 小数 注释 = "定义为α,为形状参数." @默认值 = 1.0>
    参数 尺度 <类型 = 小数 注释 = "定义为β,为尺度参数." @默认值 = 1.0>
    {
        @ std::weibull_distribution<DOUBLE> dist(@<形状>, @<尺度>);
        @ return dist(gen);
    }

    方法 取极值分布小数 <公开 类型 = 小数 注释 = "根据极值分布离散概率函数产生随机小数值" 折叠 @禁止流程检查 = 真>
    参数 位置 <类型 = 小数 注释 = "定义为α,为位置参数." @默认值 = 1.0>
    参数 尺度 <类型 = 小数 注释 = "定义为β,为尺度参数." @默认值 = 1.0>
    {
        @ std::extreme_value_distribution<DOUBLE> dist(@<位置>, @<尺度>);
        @ return dist(gen);
    }

    # 正态分布

    方法 取正态分布小数 <公开 类型 = 小数 注释 = "根据正态分布离散概率函数产生随机小数值" 折叠 @禁止流程检查 = 真>
    参数 平均数 <类型 = 小数 注释 = "定义为μ,为位置参数." @默认值 = 1.0>
    参数 标准差 <类型 = 小数 注释 = "定义为σ,为尺度参数." @默认值 = 1.0>
    {
        @ std::normal_distribution<DOUBLE> dist(@<平均数>, @<标准差>);
        @ return dist(gen);
    }

    方法 取卡方分布小数 <公开 类型 = 小数 注释 = "根据卡方分布离散概率函数产生随机小数值" 折叠 @禁止流程检查 = 真>
    参数 自由度 <类型 = 小数 @默认值 = 1.0>
    {
        @ std::chi_squared_distribution<DOUBLE> dist(@<自由度>);
        @ return dist(gen);
    }

    方法 取柯西分布小数 <公开 类型 = 小数 注释 = "根据柯西分布离散概率函数产生随机小数值" 折叠 @禁止流程检查 = 真>
    参数 位置 <类型 = 小数 @默认值 = 1.0>
    参数 尺度 <类型 = 小数 @默认值 = 1.0>
    {
        @ std::cauchy_distribution<DOUBLE> dist(@<位置>, @<尺度>);
        @ return dist(gen);
    }

    方法 取费舍尔分布小数 <公开 类型 = 小数 注释 = "根据费舍尔F分布离散概率函数产生随机小数值" 折叠 @禁止流程检查 = 真>
    参数 自由度m <类型 = 小数 @默认值 = 1.0>
    参数 自由度n <类型 = 小数 @默认值 = 1.0>
    {
        @ std::fisher_f_distribution<DOUBLE> dist(@<自由度m>, @<自由度n>);
        @ return dist(gen);
    }

    方法 取学生T分布小数 <公开 类型 = 小数 注释 = "根据学生T分布离散概率函数产生随机小数值" 折叠 @禁止流程检查 = 真>
    参数 自由度 <类型 = 小数 @默认值 = 1.0>
    {
        @ std::student_t_distribution<DOUBLE> dist(@<自由度>);
        @ return dist(gen);
    }

    # 自定义方法

    方法 取随机字符 <公开 类型 = 文本型 注释 = "获取由指定数量和类型的随机ASCII字符,适合用来生成密码." 返回值注释 = "成功返回指定字符数的随机文本,失败返回空文本." 折叠
            @禁止流程检查 = 真>
    参数 欲取字符数 <类型 = 整数 注释 = "要取的字符个数">
    参数 字符类型 <类型 = 整数 注释 = "为以下数值相加值或位或值,默认为1+2+4;" 注释 = "  1、数字" 注释 = "  2、小写字母" 注释 = "  4、大写字母"
            注释 = "  8、特殊符号" @默认值 = 7>
    {
        @ TCHAR Buffer[96] { 0 };
        @ INT nFlags = @<字符类型>;
        @ if ((nFlags & 1) == 1) wcscat(Buffer, L"0123456789");
        @ if ((nFlags & 2) == 2) wcscat(Buffer, L"abcdefghijklmnopqrstuvwxyz");
        @ if ((nFlags & 4) == 4) wcscat(Buffer, L"ABCDEFGHIJKLMNOPQRSTUVWXYZ");
        @ if ((nFlags & 8) == 8) wcscat(Buffer, L" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~");
        @ size_t Offset = wcslen(Buffer) - 1;
        @ @an<CVolString> szStr;
        @ if (Offset <= 0) return szStr;
        @ wchar_t* pStr = szStr.InitWithChars(@<欲取字符数>, ' ');
        @ std::uniform_int_distribution<INT> dist(0, Offset);
        @ for (INT i = 0; i < @<欲取字符数>; i++) {
        @     pStr[i] = Buffer[dist(gen)];
        @ }
        @ return szStr;
    }

    方法 取随机汉字 <公开 类型 = 文本型 注释 = "获取指定数量的随机汉字." 注释 = "注: 从20902个汉字中获取,有大量非常用汉字,看起来非常像乱码." 折叠 @禁止流程检查 = 真>
    参数 汉字数量 <类型 = 整数 注释 = "提供随机汉字的数量">
    {
        @ @an<CVolString> szStr;
        @ szStr.SetNumAlignChars(@<汉字数量>);
        @ std::uniform_int_distribution<unsigned short> dist(0x4E00, 0x9FA5);
        @ for (INT i = 0; i < @<汉字数量>; i++) {
        @     szStr.AddChar(static_cast<WCHAR>(dist(gen)));
        @ }
        @ return szStr;
    }

    方法 取随机百家姓 <公开 类型 = 文本型 注释 = "获取随机的百家姓" 返回值注释 = "成功返回指定字符数的随机文本,失败返回空文本." 折叠 @禁止流程检查 = 真>
    {
        @ static const WCHAR* surname[] {
        @     L"赵", L"钱", L"孙", L"李", L"周", L"吴", L"郑", L"王", L"冯", L"陈",
        @     L"褚", L"卫", L"蒋", L"沈", L"韩", L"杨", L"朱", L"秦", L"尤", L"许",
        @     L"何", L"吕", L"施", L"张", L"孔", L"曹", L"严", L"华", L"金", L"魏",
        @     L"陶", L"姜", L"戚", L"谢", L"邹", L"喻", L"柏", L"水", L"窦", L"章",
        @     L"云", L"苏", L"潘", L"葛", L"奚", L"范", L"彭", L"郎", L"鲁", L"韦",
        @     L"昌", L"马", L"苗", L"凤", L"花", L"方", L"俞", L"任", L"袁", L"柳",
        @     L"酆", L"鲍", L"史", L"唐", L"费", L"廉", L"岑", L"薛", L"雷", L"贺",
        @     L"倪", L"汤", L"滕", L"殷", L"罗", L"毕", L"郝", L"邬", L"安", L"常",
        @     L"乐", L"于", L"时", L"傅", L"皮", L"卞", L"齐", L"康", L"伍", L"余",
        @     L"元", L"卜", L"顾", L"孟", L"平", L"黄", L"和", L"穆", L"萧", L"尹",
        @     L"姚", L"邵", L"湛", L"汪", L"祁", L"毛", L"禹", L"狄", L"米", L"贝",
        @     L"明", L"臧", L"计", L"伏", L"成", L"戴", L"谈", L"宋", L"茅", L"庞",
        @     L"熊", L"纪", L"舒", L"屈", L"项", L"祝", L"董", L"梁", L"杜", L"阮",
        @     L"蓝", L"闵", L"席", L"季", L"麻", L"强", L"贾", L"路", L"娄", L"危",
        @     L"江", L"童", L"颜", L"郭", L"梅", L"盛", L"林", L"刁", L"钟", L"徐",
        @     L"邱", L"骆", L"高", L"夏", L"蔡", L"田", L"樊", L"胡", L"凌", L"霍",
        @     L"虞", L"万", L"支", L"柯", L"昝", L"管", L"卢", L"莫", L"经", L"房",
        @     L"裘", L"缪", L"干", L"解", L"应", L"宗", L"丁", L"宣", L"贲", L"邓",
        @     L"郁", L"单", L"杭", L"洪", L"包", L"诸", L"左", L"石", L"崔", L"吉",
        @     L"钮", L"龚", L"程", L"嵇", L"邢", L"滑", L"裴", L"陆", L"荣", L"翁",
        @     L"荀", L"羊", L"於", L"惠", L"甄", L"曲", L"家", L"封", L"芮", L"羿",
        @     L"储", L"靳", L"汲", L"邴", L"糜", L"松", L"井", L"段", L"富", L"巫",
        @     L"乌", L"焦", L"巴", L"弓", L"牧", L"隗", L"山", L"谷", L"车", L"侯",
        @     L"宓", L"蓬", L"全", L"郗", L"班", L"仰", L"秋", L"仲", L"伊", L"宫",
        @     L"宁", L"仇", L"栾", L"暴", L"甘", L"钭", L"厉", L"戎", L"祖", L"武",
        @     L"符", L"刘", L"景", L"詹", L"束", L"龙", L"叶", L"幸", L"司", L"韶",
        @     L"郜", L"黎", L"蓟", L"薄", L"印", L"宿", L"白", L"怀", L"蒲", L"邰",
        @     L"从", L"鄂", L"索", L"咸", L"籍", L"赖", L"卓", L"蔺", L"屠", L"蒙",
        @     L"池", L"乔", L"阴", L"胥", L"能", L"苍", L"双", L"闻", L"莘", L"党",
        @     L"翟", L"谭", L"贡", L"劳", L"逄", L"姬", L"申", L"扶", L"堵", L"冉",
        @     L"宰", L"郦", L"雍", L"郤", L"璩", L"桑", L"桂", L"濮", L"牛", L"寿",
        @     L"通", L"边", L"扈", L"燕", L"冀", L"郏", L"浦", L"尚", L"农", L"温",
        @     L"别", L"庄", L"晏", L"柴", L"瞿", L"阎", L"充", L"慕", L"连", L"茹",
        @     L"习", L"宦", L"艾", L"鱼", L"容", L"向", L"古", L"易", L"慎", L"戈",
        @     L"廖", L"庾", L"终", L"暨", L"居", L"衡", L"步", L"都", L"耿", L"满",
        @     L"弘", L"匡", L"国", L"文", L"寇", L"广", L"禄", L"阙", L"东", L"欧",
        @     L"殳", L"沃", L"利", L"蔚", L"越", L"夔", L"隆", L"师", L"巩", L"厍",
        @     L"聂", L"晁", L"勾", L"敖", L"融", L"冷", L"訾", L"辛", L"阚", L"那",
        @     L"简", L"饶", L"空", L"曾", L"毋", L"沙", L"乜", L"养", L"鞠", L"须",
        @     L"丰", L"巢", L"关", L"蒯", L"相", L"查", L"後", L"荆", L"红", L"游",
        @     L"竺", L"权", L"逯", L"盖", L"益", L"桓", L"公", L"万俟", L"司马", L"上官",
        @     L"欧阳", L"夏侯", L"诸葛", L"闻人", L"东方", L"赫连", L"皇甫", L"尉迟",
        @     L"公羊", L"澹台", L"公冶", L"宗政", L"濮阳", L"淳于", L"单于", L"太叔",
        @     L"申屠", L"公孙", L"仲孙", L"轩辕", L"令狐", L"钟离", L"宇文", L"长孙",
        @     L"慕容", L"鲜于", L"闾丘", L"司徒", L"司空", L"亓官", L"司寇", L"仉",
        @     L"督", L"子车", L"颛孙", L"端木", L"巫马", L"公西", L"漆雕", L"乐正",
        @     L"壤驷", L"公良", L"拓跋", L"夹谷", L"宰父", L"谷梁", L"晋", L"楚", L"闫",
        @     L"法", L"汝", L"鄢", L"涂", L"钦", L"段干", L"百里", L"东郭", L"南门",
        @     L"呼延", L"归", L"海", L"羊舌", L"微生", L"岳", L"帅", L"缑", L"亢",
        @     L"况", L"后", L"有", L"琴", L"梁丘", L"左丘", L"东门", L"西门", L"商",
        @     L"牟", L"佘", L"佴", L"伯", L"赏", L"南宫", L"墨", L"哈", L"谯", L"笪",
        @     L"年", L"爱", L"阳", L"佟", L"第五", L"言", L"福"
        @ };
        @ std::uniform_int_distribution<size_t> dist(0, NUM_ELEMENTS_OF(surname) - 1);
        @ return @an<CVolString>(surname[dist(gen)]);
    }

    方法 取随机字节集 <公开 类型 = 字节集类 注释 = "获取指定长度的随机内容字节集" 折叠 @禁止流程检查 = 真>
    参数 字节集长度 <类型 = 整数 注释 = "提供随机字节集的长度">
    参数 去除零值 <类型 = 逻辑型 注释 = "返回的字节集中是否包含0值" @默认值 = 真>
    {
        @ @an<CVolMem> memBuf;
        @ memBuf.SetMemAlignSize(@<字节集长度>);
        @ std::uniform_int_distribution<int> dist(@<去除零值> ? 1 : 0, 255);
        @ for (INT i = 0; i < @<字节集长度>; i++) {
        @     memBuf.AddByte(static_cast<BYTE>(dist(gen)));
        @ }
        @ return memBuf;
    }
}

类 标准随机数类 <公开 基础类 = 标准随机数模板类 注释 = "采用\"std::mt19937\"的32位梅森旋转算法,耗时最慢且状态存储要求较高,但产生的随机数质量最高." 折叠
        @文档 = "category = \"伪随机数\"" @模板实现类 = "">
{

    # @ @def_macro engine std::mt19937
}

类 随机数类_mt19937_64 <公开 基础类 = 标准随机数模板类 注释 = "采用\"std::mt19937_64\"的64位梅森旋转算法,耗时最慢且状态存储要求较高,但产生的随机数质量最高."
        折叠 @文档 = "category = \"伪随机数\"" @模板实现类 = "">
{

    # @ @def_macro engine std::mt19937_64
}

类 随机数类_minstd_rand0 <公开 基础类 = 标准随机数模板类 注释 = "采用\"std::minstd_rand0\"的线性同余算法,速度较快且状态存储要求最低,但产生的随机数质量一般."
        折叠 @文档 = "category = \"伪随机数\"" @模板实现类 = "">
{

    # @ @def_macro engine std::minstd_rand0
}

类 随机数类_minstd_rand <公开 基础类 = 标准随机数模板类 注释 = "采用\"std::minstd_rand\"的线性同余算法,速度较快且状态存储要求最低,但产生的随机数质量一般."
        折叠 @文档 = "category = \"伪随机数\"" @模板实现类 = "">
{

    # @ @def_macro engine std::minstd_rand
}

类 随机数类_ranlux24_base <公开 基础类 = 标准随机数模板类
        注释 = "采用\"std::ranlux24_base\"的带进位减(延迟斐波那契)算法,速度非常快,但状态存储要求最大,也有不太适合的谱特性." 折叠
        @文档 = "category = \"伪随机数\"" @模板实现类 = "">
{

    # @ @def_macro engine std::ranlux24_base
}

类 随机数类_ranlux48_base <公开 基础类 = 标准随机数模板类
        注释 = "采用\"std::ranlux48_base\"的带进位减(延迟斐波那契)算法,速度非常快,但状态存储要求最大,也有不太适合的谱特性." 折叠
        @文档 = "category = \"伪随机数\"" @模板实现类 = "">
{

    # @ @def_macro engine std::ranlux48_base
}

类 随机数类_ranlux24 <公开 基础类 = 标准随机数模板类 注释 = "基于\"随机数类_ranlux24_base\"加上随机数引擎适配器,舍弃了部分不太适合的谱特性." 折叠
        @文档 = "category = \"伪随机数\"" @模板实现类 = "">
{

    # @ @def_macro engine std::ranlux24
}

类 随机数类_ranlux48 <公开 基础类 = 标准随机数模板类 注释 = "基于\"随机数类_ranlux48_base\"加上随机数引擎适配器,舍弃了部分不太适合的谱特性." 折叠
        @文档 = "category = \"伪随机数\"" @模板实现类 = "">
{

    # @ @def_macro engine std::ranlux48
}

类 随机数类_knuth_b <公开 基础类 = 标准随机数模板类 注释 = "基于\"随机数类_minstd_rand0\"加上随机数引擎适配器,打乱了随机数引擎的输出." 折叠
        @文档 = "category = \"伪随机数\"" @模板实现类 = "">
{

    # @ @def_macro engine std::knuth_b
}

# ini 配置文件 ===

类 配置文件操作类 <公开 注释 = "  提供简易的ini配置文件读写操作,支持多字节、UTF-8和UTF-16LE编码."
        注释 = "  所有属性写的方法,都必须在\"打开文件\"、\"创建自文件\"、\"创建自字节集\"" 注释 = "之前设置,后续设置无效."
        注释 = "  源码: https://github.com/brofield/simpleini" 折叠 @文档 = "category = \"配置文件.INI\""
        @视窗.外部头文件 = "src\\SimpleIni.h\r\nsrc\\piv_encoding.hpp">
{
    方法 类_初始化 <折叠>
    {
        @ data().SetUnicode(true); // 默认使用UTF-8
    }

    方法 类_清理 <折叠>
    {
        @ if (m_szIniFile.IsEmpty() == FALSE && m_bAutoSave == true)
        @     this->@<保存>();
    }

    方法 清空 <公开 注释 = "释放本配置对象的所有内存数据" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().Reset()
    }

    方法 是否为空 <公开 类型 = 逻辑型 注释 = "检查本配置对象是否为空(未加载任何数据)" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().IsEmpty()
    }

    方法 是否允许重复键名 <公开 属性写 注释 = "  设置是否允许存在重复的键名,即一个键名允许存在多个键值." 注释 = "  如果开启本属性,使用\"取XX键值\"时只获取到第一个键值,只有"
            注释 = "\"取所有键值\"能获取全部键值." 折叠>
    参数 是否允许 <类型 = 逻辑型 注释 = "默认为假">
    {
        @ data().SetMultiKey(@<是否允许>);
    }

    方法 是否允许重复键名 <公开 属性读 类型 = 逻辑型 注释 = "返回是否允许重复键名" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().IsMultiKey()
    }

    方法 是否允许跨行键值 <公开 属性写 注释 = "  设置是否允许键值可以跨越多行,格式如下:" 注释 = "    key = <<<TAG"
            注释 = "    .... multiline value ...." 注释 = "    TAG"
            注释 = "  其中\"TAG\"标签可以自定义,但一定要成对出现,开始标签前一定要有\"<<<\"," 注释 = "结束标签要单独写一行，而且一定要写在行首."
            注释 = "  中间是跨行的键值,可以有很多行,其中换行符会被替换为\'\\\\n\'字符." 折叠>
    参数 是否允许 <类型 = 逻辑型 注释 = "默认为假">
    {
        @ data().SetMultiLine(@<是否允许>);
    }

    方法 是否允许跨行键值 <公开 属性读 类型 = 逻辑型 注释 = "返回是否允许跨行键值" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().IsMultiLine()
    }

    方法 是否添加空格 <公开 属性写 注释 = "设置是否在键值对的等号两边添加空格." 注释 = " 真: \"key = value\";" 注释 = " 假: \"key=value\"." 折叠>
    参数 是否添加 <类型 = 逻辑型 注释 = "默认为假">
    {
        @ data().SetSpaces(@<是否添加>);
    }

    方法 是否添加空格 <公开 属性读 类型 = 逻辑型 注释 = "返回是否在等号两边添加空格" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().UsingSpaces()
    }

    方法 是否解析引号 <公开 属性写 注释 = "设置是否解析包围单行键值的双引号." 注释 = "为真时会将双引号当作语法解析,不会输出到键值中;" 注释 = "为假时会将双引号输出为字符." 折叠>
    参数 是否解析 <类型 = 逻辑型 注释 = "默认为假">
    {
        @ data().SetQuotes(@<是否解析>);
    }

    方法 是否解析引号 <公开 属性读 类型 = 逻辑型 注释 = "返回是否解析包围单行键值的引号" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().UsingQuotes()
    }

    方法 是否允许单键名 <公开 属性写 注释 = "设置是否允许存在没有等号和键值的单个键名." 注释 = "为假时必须有等号才会解析出键名和键值;" 注释 = "为真时将没有等号的单行文本识别为单个键名."
            折叠>
    参数 是否允许 <类型 = 逻辑型 注释 = "默认为假">
    {
        @ data().SetAllowKeyOnly(@<是否允许>);
    }

    方法 是否允许单键名 <公开 属性读 类型 = 逻辑型 注释 = "返回是否允许存在没有等号和键值的单个键名" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().UsingQuotes()
    }

    # ---

    方法 创建自文本 <公开 类型 = 整数 注释 = "从文本型数据中读入ini配置数据,本方法会覆盖本类之前的数据." 返回值注释 = "返回值大于等于0表示成功,小于0表示失败." 折叠
            @禁止流程检查 = 真>
    参数 配置内容 <类型 = 文本型>
    {
        @ data().Reset();
        @ data().SetUnicode(true);
        @ return data().LoadData(*PivW2U(@<配置内容>.GetText()));
    }

    方法 创建自字节集 <公开 类型 = 整数 注释 = "从字节集数据中读入ini配置数据,本方法会覆盖本类之前的数据." 返回值注释 = "返回值大于等于0表示成功,小于0表示失败." 折叠
            @禁止流程检查 = 真>
    参数 配置内容 <类型 = 字节集类>
    参数 文本编码 <类型 = 文本编码类型 注释 = "指定字节集文本编码,文本编码必须对应,否则可能会乱码;" 注释 = "其中\"未知\"等同多字节." @默认值 = 文本编码类型.UTF8>
    {
        @ data().Reset();
        @ if (@<文本编码> == VSET_UTF_8) {
        @     data().SetUnicode(true);
        @     return data().LoadData(reinterpret_cast<const char*>(@<配置内容>.GetPtr()), @<配置内容>.GetSize());
        @ } else if (@<文本编码> == VSET_UTF_16) {
        @     data().SetUnicode(true);
        @     return data().LoadData(*PivW2U(reinterpret_cast<const wchar_t*>(@<配置内容>.GetPtr()), @<配置内容>.GetSize() / 2));
        @ } else {
        @     data().SetUnicode(false);
        @     return data().LoadData(reinterpret_cast<const char*>(@<配置内容>.GetPtr()), @<配置内容>.GetSize());
        @ }
    }

    方法 创建自文件 <公开 类型 = 整数 注释 = "  从指定的文件中读入ini配置数据,本方法会覆盖本类之前的数据." 注释 = "  注意: 读入配置后就会关闭文件,所以之后修改的配置并不会反映到"
            注释 = "ini文件中,必须调用\"保存/保存文件\"才会将结果保存到文件." 返回值注释 = "返回值大于等于0表示成功,小于0表示失败." 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "所欲打开的ini配置文件,文件不存在时会自动创建.">
    参数 文本编码 <类型 = 文本编码类型 注释 = "指定所打开ini文件的文本编码;" 注释 = "首先会根据文件的BOM签名自动识别编码;"
            注释 = "若不存在签名,则以此参数指定的编码打开,\"未知\"等同多字节;" 注释 = "文本编码必须选择正确,否则可能会乱码." @默认值 = 文本编码类型.未知>
    参数 自动保存 <类型 = 逻辑型 注释 = "是否在对象被释放之前自动保存更改到文件中;" 注释 = "为假时必须手动调用\"保存\",否则可能丢失未保存的编辑内容;"
            注释 = "为真时,即使已经通过\"保存文件\"将配置数据保存到新文件中," 注释 = "仍会将更改保存到原文件." @默认值 = 真>
    {
        @ m_szIniFile.Empty(); m_bAutoSave = false;
        @ data().Reset();
        @ INT nRet = 0;
        @ FILE* fp = NULL;
        @ if (IsOSFileExist(@<文件名>.GetText()))
        @     fp = _wfopen(@<文件名>.GetText(), L"rb");
        @ else
        @     fp = _wfopen(@<文件名>.GetText(), L"ab+");
        @ if (!fp) return -3;
        @ fseek(fp, 0, SEEK_END);
        @ int nSize = ftell(fp);
        @ if (nSize == 0) {
        @     fclose(fp); m_nType = @<文本编码>;
        @     if (m_nType == VSET_UTF_8 || m_nType == VSET_UTF_16)
        @         data().SetUnicode(true);
        @     else
        @         data().SetUnicode(false);
        @     m_szIniFile = @<文件名>;
        @     m_bAutoSave = (bool)@<自动保存>;
        @     return 0;
        @ }
        @ fseek(fp, 0, SEEK_SET);
        @ char* szData = new char [nSize] { 0 };
        @ if (!szData) { fclose(fp); return -2; }
        @ fread(szData, sizeof(char), nSize, fp);
        @ fclose(fp);
        @ m_nType = VSET_UNKNOWN;
        @ bool hasBom = false;
        @ if (memcmp(szData, "\xFF\xFE", 2) == 0) {
        @     m_nType = VSET_UTF_16; hasBom = true;
        @ } else if (memcmp(szData, SI_UTF8_SIGNATURE, 3) == 0) {
        @     m_nType = VSET_UTF_8;
        @ }
        @ if (m_nType == VSET_UTF_16 || (m_nType == VSET_UNKNOWN && @<文本编码> == VSET_UTF_16)) {
        @     data().SetUnicode(true);
        @     nRet = static_cast<INT>(data().LoadData(*PivW2U(reinterpret_cast<const WCHAR*>(szData + (hasBom ? 2 : 0)), (hasBom ? (nSize - 2) : nSize) / 2)));
        @ } else if (m_nType == VSET_UTF_8 || (m_nType == VSET_UNKNOWN && @<文本编码> == VSET_UTF_8)) {
        @     data().SetUnicode(true);
        @     nRet = static_cast<INT>(data().LoadData(reinterpret_cast<const char*>(szData), nSize));
        @ } else {
        @     m_nType = VSET_MBCS;
        @     data().SetUnicode(false);
        @     nRet = static_cast<INT>(data().LoadData(reinterpret_cast<const char*>(szData), nSize));
        @ }
        @ delete [] szData;
        @ if (nRet >= 0) {
        @     m_szIniFile = @<文件名>;
        @     m_bAutoSave = (bool)@<自动保存>;
        @ }
        @ return nRet;
    }

    方法 打开文件 <公开 类型 = 整数 注释 = "  本方法跟\"创建自文件\"一样,只是为了兼容以前的代码才保留." 注释 = "  从指定的文件中获取ini配置数据,本方法会覆盖本类之前的数据."
            注释 = "  注意: 读入配置后就会关闭文件,所以之后修改的配置并不会反映到" 注释 = "ini文件中,必须调用\"保存/保存文件\"才会将结果保存到文件."
            返回值注释 = "返回值大于等于0表示成功,小于0表示失败." 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "所欲打开的ini配置文件,文件不存在时会自动创建.">
    参数 文本编码 <类型 = 文本编码类型 注释 = "指定所打开ini文件的文本编码;" 注释 = "首先会根据文件的BOM签名自动识别编码;"
            注释 = "若不存在签名,则以此参数指定的编码打开,\"未知\"等同多字节;" 注释 = "文本编码必须选择正确,否则可能会乱码." @默认值 = 文本编码类型.未知>
    参数 自动保存 <类型 = 逻辑型 注释 = "是否在对象被释放之前自动保存更改到文件中;" 注释 = "为假时必须手动调用\"保存\",否则可能丢失未保存的编辑内容;"
            注释 = "为真时,即使已经通过\"保存文件\"将配置数据保存到新文件中," 注释 = "仍会将更改保存到原文件中." @默认值 = 真>
    {
        返回 (创建自文件 (文件名, 文本编码, 自动保存))
    }

    方法 保存 <公开 类型 = 整数 注释 = "覆盖保存所打开的ini文件." 注释 = "如果未执行过\"创建自文件/打开文件\",应当使用\"保存文件\"."
            返回值注释 = "返回值大于等于0表示成功,小于0表示失败." 折叠 @禁止流程检查 = 真>
    {
        @ if (m_szIniFile.IsEmpty())
        @     return -3;
        @ else
        @     return this->@<保存文件>(m_szIniFile, m_nType);
    }

    方法 保存文件 <公开 类型 = 整数 注释 = "将当前编辑的内容保存到指定的ini文件中" 返回值注释 = "返回值大于等于0表示成功,小于0表示失败." 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "所欲保存内容的ini配置文件,如果文件不存在将自动创建.">
    参数 文本编码 <类型 = 文本编码类型 注释 = "指定保存文件的文本编码,UTF8和UTF16会添加自动BOM签名,其中\"未知\"等同多字节." @默认值 = 文本编码类型.UTF8>
    {
        @ if (@<文本编码> == @<文本编码类型.UTF8>) {
        @     if (data().IsUnicode()) {
        @         return data().SaveFile(@<文件名>.GetText(), true);
        @     } else {
        @         CVolMem memUtf8;
        @         std::string szBuffer;
        @         data().Save(szBuffer, false);
        @         PivA2U utf8str {szBuffer};
        @         utf8str.to_volmem(memUtf8, false);
        @         memUtf8.InsertValue_S_BYTE(0, (S_BYTE)0xBF); memUtf8.InsertValue_S_BYTE(0, (S_BYTE)0xBB); memUtf8.InsertValue_S_BYTE(0, (S_BYTE)0xEF);
        @         return memUtf8.WriteIntoFile(@<文件名>, -1) ? 0 : -3;
        @     }
        @ } else if (@<文本编码> == @<文本编码类型.UTF16>) {
        @     CVolMem memWStr; std::string szBuffer;
        @     data().Save(szBuffer, false);
        @     if (data().IsUnicode()) {
        @         PivU2W utf16str {szBuffer};
        @         utf16str.to_volmem(memWStr, false);
        @     } else {
        @         PivA2W utf16str {szBuffer};
        @         utf16str.to_volmem(memWStr, false);
        @     }
        @     memWStr.InsertValue_SHORT(0, (SHORT)0xFEFF);
        @     return memWStr.WriteIntoFile(@<文件名>, -1) ? 0 : -3;
        @ } else {
        @     if (data().IsUnicode()) {
        @         CVolMem memMBS;
        @         std::string szBuffer;
        @         data().Save(szBuffer, false);
        @         PivU2A mbstr {szBuffer};
        @         mbstr.to_volmem(memMBS, false);
        @         return memMBS.WriteIntoFile(@<文件名>, -1) ? 0 : -3;
        @     } else {
        @         return static_cast<INT>(data().SaveFile(@<文件名>.GetText(), false));
        @     }
        @ }
    }

    方法 取文件编码 <公开 类型 = 文本编码类型 注释 = "返回已打开ini配置文件的文本编码." 注释 = "若未成功执行过\"打开文件\",则返回\"文本编码类型.未知\"." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.m_nType
    }

    方法 到文本 <公开 类型 = 文本型 注释 = "将内存中的配置数据输出到文本" 折叠 @禁止流程检查 = 真>
    {
        @ std::string szBuffer;
        @ data().Save(szBuffer, false);
        @ if (data().IsUnicode())
        @     return *PivU2Ws{szBuffer};
        @ else
        @     return *PivA2Ws{szBuffer};
    }

    方法 到字节集 <公开 类型 = 字节集类 注释 = "将内存中的配置数据输出到字节集类." 注释 = "本方法不做编码转换,直接返回类的内部数据,内部只使用多字节和UTF8两种编码." 折叠
            @禁止流程检查 = 真>
    参数 添加签名 <类型 = 逻辑型 注释 = "是否对UTF-8数据添加BOM签名(多字节无签名)" @默认值 = 假>
    参数 是否UTF8编码 <类型 = 逻辑型类 注释 = "返回字节集的数据是否为UTF8编码,返回假则说明是多字节编码." @默认值 = 空对象>
    {
        @ std::string szBuffer;
        @ data().Save(szBuffer, @<添加签名>);
        @ @<是否UTF8编码.值> = data().IsUnicode();
        @ return @an<CVolMem>(szBuffer.c_str(), szBuffer.size());
    }

    方法 取所有节名 <公开 注释 = "获取配置数据中所有节的名称" 折叠>
    参数 返回节名数组 <类型 = 文本数组类 注释 = "成功返回节名的数组">
    {
        @ @<返回节名数组>.data().RemoveAll();
        @ CSimpleIniW::TNamesDepend sections;
        @ data().GetAllSections(sections);
        @ for (auto it = sections.begin(); it != sections.end(); it++) {
        @     @<返回节名数组>.data().Add((*it).pItem);
        @ }
    }

    方法 取所有键名 <公开 类型 = 逻辑型 注释 = "获取指定节中的所有唯一键名" 折叠 @禁止流程检查 = 真>
    参数 节名 <类型 = 文本型 注释 = "所欲取所有键名的节">
    参数 返回键名数组 <类型 = 文本数组类 注释 = "成功返回键名的数组">
    {
        @ @<返回键名数组>.data().RemoveAll();
        @ CSimpleIniW::TNamesDepend keys;
        @ BOOL bRet = data().GetAllKeys(@<节名>.GetText(), keys);
        @ if (!bRet) return FALSE;
        @ for (auto it = keys.begin(); it != keys.end(); it++) {
        @     @<返回键名数组>.data().Add((*it).pItem);
        @ }
        @ return bRet;
    }

    方法 取所有键值 <公开 类型 = 逻辑型 注释 = "获取指定节指定键的所有键值." 注释 = "\"是否允许重复键名\"为真时会返回所有同键名的值,为假时只会返回第一个值." 折叠
            @禁止流程检查 = 真>
    参数 节名 <类型 = 文本型 注释 = "所欲取键值的节名">
    参数 键名 <类型 = 文本型 注释 = "所欲取键值的键名">
    参数 返回值数组 <类型 = 文本数组类 注释 = "成功返回键值数组">
    {
        @ @<返回值数组>.data().RemoveAll();
        @ CSimpleIniW::TNamesDepend values;
        @ BOOL bRet = data().GetAllValues(@<节名>.GetText(), @<键名>.GetText(), values);
        @ if (!bRet) return FALSE;
        @ for (auto it = values.begin(); it != values.end(); it++) {
        @     @<返回值数组>.data().Add((*it).pItem);
        @ }
        @ return bRet;
    }

    方法 取所有节名2 <公开 注释 = "获取配置数据中所有节的信息." 注释 = "本方法除了节名,还能返回注释和序号." 折叠>
    参数 返回配置项数组 <类型 = 配置项信息数组类 注释 = "成功返回节名的数组">
    {
        @ @<返回配置项数组>.RemoveAll();
        @ CSimpleIniW::TNamesDepend sections;
        @ data().GetAllSections(sections);
        @ for (auto it = sections.begin(); it != sections.end(); it++) {
        @     @dt<配置项信息类> iniInf;
        @     if ((*it).pItem) { iniInf.pItem.SetText((*it).pItem); }
        @     if ((*it).pComment) { iniInf.pComment.SetText((*it).pComment); };
        @     iniInf.nOrder = (*it).nOrder;
        @     @<返回配置项数组>.Add(iniInf, NULL);
        @ }
    }

    方法 取所有键名2 <公开 类型 = 逻辑型 注释 = "获取指定节中所有唯一键名的信息." 注释 = "本方法除了键名,还能返回注释和序号." 折叠 @禁止流程检查 = 真>
    参数 节名 <类型 = 文本型 注释 = "所欲取所有键名的节">
    参数 返回配置项数组 <类型 = 配置项信息数组类 注释 = "成功返回键名的数组">
    {
        @ @<返回配置项数组>.RemoveAll();
        @ CSimpleIniW::TNamesDepend keys;
        @ BOOL bRet = data().GetAllKeys(@<节名>.GetText(), keys);
        @ if (!bRet) return FALSE;
        @ for (auto it = keys.begin(); it != keys.end(); it++) {
        @     @dt<配置项信息类> iniInf;
        @     if ((*it).pItem) { iniInf.pItem.SetText((*it).pItem); }
        @     if ((*it).pComment) { iniInf.pComment.SetText((*it).pComment); }
        @     iniInf.nOrder = (*it).nOrder;
        @     @<返回配置项数组>.Add(iniInf, NULL);
        @ }
        @ return bRet;
    }

    方法 取所有键值2 <公开 类型 = 逻辑型 注释 = "获取指定节指定键的所有键值信息." 注释 = "本方法除了键值,还能返回注释和序号."
            注释 = "\"是否允许重复键名\"为真时会返回所有同键名的值,为假时只会返回第一个值." 折叠 @禁止流程检查 = 真>
    参数 节名 <类型 = 文本型 注释 = "所欲取键值的节名">
    参数 键名 <类型 = 文本型 注释 = "所欲取键值的键名">
    参数 返回配置项数组 <类型 = 配置项信息数组类 注释 = "成功返回键值数组">
    {
        @ @<返回配置项数组>.RemoveAll();
        @ CSimpleIniW::TNamesDepend values;
        @ BOOL bRet = data().GetAllValues(@<节名>.GetText(), @<键名>.GetText(), values);
        @ if (!bRet) return FALSE;
        @ for (auto it = values.begin(); it != values.end(); it++) {
        @     @dt<配置项信息类> iniInf;
        @     if ((*it).pItem) { iniInf.pItem.SetText((*it).pItem); }
        @     if ((*it).pComment) { iniInf.pComment.SetText((*it).pComment); }
        @     iniInf.nOrder = (*it).nOrder;
        @     @<返回配置项数组>.Add(iniInf, NULL);
        @ }
        @ return bRet;
    }

    方法 取节成员数 <公开 类型 = 整数 注释 = "获取指定节的键数量" 折叠 @嵌入式方法 = "">
    参数 节名 <类型 = 文本型 注释 = "所欲取键数量的节名">
    {
        @ @sn<this>.data().GetSectionSize(@<节名>.GetText())
    }

    方法 取节键值对 <公开 类型 = 文本到文本哈希表 注释 = "获取指定节名的所有键值对" 返回值注释 = "返回键值对哈希表" 折叠>
    参数 节名 <类型 = 文本型 注释 = "所欲取键值对的节名">
    {
        变量 结果 <类型 = 文本到文本哈希表>
        @ const CSimpleIniW::TKeyVal* kv = data().GetSection(@<节名>.GetText());
        @ if (kv) {
        @     for (auto it = kv->begin(); it != kv->end(); it++) {
        @         @<结果>.m_map.emplace(it->first.pItem, it->second);
        @     }
        @ }
        返回 (结果)
    }

    方法 节名是否存在 <公开 类型 = 逻辑型 注释 = "检查指定的节是否存在" 折叠 @嵌入式方法 = "">
    参数 节名 <类型 = 文本型 注释 = "所欲检查的节名">
    {
        @ @sn<this>.data().SectionExists(@<节名>.GetText())
    }

    方法 键名是否存在 <公开 类型 = 逻辑型 注释 = "检查指定的键名是否存在" 折叠 @嵌入式方法 = "">
    参数 节名 <类型 = 文本型 注释 = "所欲检查键名的节名">
    参数 键名 <类型 = 文本型 注释 = "所欲检查的键名">
    {
        @ @sn<this>.data().KeyExists(@<节名>.GetText(), @<键名>.GetText())
    }

    方法 取文本键值 <公开 类型 = 文本型 注释 = "获取指定键的文本型键值." 注释 = "即使\"是否允许重复键名\"为真,也只会返回找到的第一个值." 折叠 @嵌入式方法 = "">
    参数 节名 <类型 = 文本型 注释 = "所欲获取键值的节名称">
    参数 键名 <类型 = 文本型 注释 = "所欲获取键值的键名称">
    参数 默认值 <类型 = 文本型 注释 = "如果所指定键名不存在,将返回此默认值." @默认值 = "">
    参数 是否有多个值 <类型 = 逻辑型类 注释 = "返回当前键是否有多个值,为真时可以用\"取所有键值\"获取." @默认值 = 空对象>
    {
        @ @an<CVolString>(@sn<this>.data().GetValue(@<节名>.GetText(), @<键名>.GetText(), @<默认值>.GetText(), (bool*)&@<是否有多个值.值>))
    }

    方法 取整数键值 <公开 类型 = 整数 注释 = "获取指定键的整数型键值." 注释 = "即使\"是否允许重复键名\"为真,也只会返回找到的第一个值." 折叠 @嵌入式方法 = "">
    参数 节名 <类型 = 文本型 注释 = "所欲获取键值的节名称">
    参数 键名 <类型 = 文本型 注释 = "所欲获取键值的键名称">
    参数 默认值 <类型 = 整数 注释 = "如果所指定键名不存在,将返回此默认值." @默认值 = 0>
    参数 是否有多个值 <类型 = 逻辑型类 注释 = "返回当前键是否有多个值,为真时可以用\"取所有键值\"获取." @默认值 = 空对象>
    {
        @ (INT)@sn<this>.data().GetLongValue(@<节名>.GetText(), @<键名>.GetText(), (long)@<默认值>, (bool*)&@<是否有多个值.值>)
    }

    方法 取小数键值 <公开 类型 = 小数 注释 = "获取指定键的小数型键值." 注释 = "即使\"是否允许重复键名\"为真,也只会返回找到的第一个值." 折叠 @嵌入式方法 = "">
    参数 节名 <类型 = 文本型 注释 = "所欲获取键值的节名称">
    参数 键名 <类型 = 文本型 注释 = "所欲获取键值的键名称">
    参数 默认值 <类型 = 小数 注释 = "如果所指定键名不存在,将返回此默认值." @默认值 = 0>
    参数 是否有多个值 <类型 = 逻辑型类 注释 = "返回当前键是否有多个值,为真时可以用\"取所有键值\"获取." @默认值 = 空对象>
    {
        @ @sn<this>.data().GetDoubleValue(@<节名>.GetText(), @<键名>.GetText(), @<默认值>, (bool*)&@<是否有多个值.值>)
    }

    方法 取逻辑键值 <公开 类型 = 逻辑型 注释 = "获取指定键的逻辑型键值." 注释 = "即使\"是否允许重复键名\"为真,也只会返回找到的第一个值." 折叠 @嵌入式方法 = "">
    参数 节名 <类型 = 文本型 注释 = "所欲获取键值的节名称">
    参数 键名 <类型 = 文本型 注释 = "所欲获取键值的键名称">
    参数 默认值 <类型 = 逻辑型 注释 = "如果所指定键名不存在,将返回此默认值." @默认值 = 假>
    参数 是否有多个值 <类型 = 逻辑型类 注释 = "返回当前键是否有多个值,为真时可以用\"取所有键值\"获取." @默认值 = 空对象>
    {
        @ (BOOL)@sn<this>.data().GetBoolValue(@<节名>.GetText(), @<键名>.GetText(), (bool)@<默认值>, (bool*)&@<是否有多个值.值>)
    }

    方法 置文本键值 <公开 类型 = 整数 注释 = "添加或更新一个节或文本型键值." 注释 = "当\"是否允许重复键名\"为真时,始终为添加键值."
            返回值注释 = "返回值大于等于0表示成功,小于0表示失败." 折叠 @嵌入式方法 = "">
    参数 节名 <类型 = 文本型 注释 = "所欲添加或更新的节">
    参数 键名 <类型 = 文本型 注释 = "所欲添加或更新的键,留空表示创建一个空节." @默认值 = 空对象>
    参数 键值 <类型 = 文本型 注释 = "所欲设置的键值,留空表示创建一个空节." @默认值 = 空对象>
    参数 注释 <类型 = 文本型 注释 = "设置节或键的注释,如果键名为空则是设置节的注释;" 注释 = "可空,注释文本必须以字符\';\'或\'#\'开头;"
            注释 = "仅在第一次创建新的节或键名时才会写入注释." @默认值 = 空对象>
    参数 强制替换 <类型 = 逻辑型 注释 = "\"是否允许重复键名\"为真时,是否强制将同一个键名的" 注释 = "所有键值都替换成新值." @默认值 = 假>
    {
        @ (INT)@sn<this>.data().SetValue(@<节名>.GetText(), @<键名>.GetTextMaybeNull(), @<键值>.GetTextMaybeNull(),
        @     @<注释>.GetTextMaybeNull(), (bool)@<强制替换>)
    }

    方法 置整数键值 <公开 类型 = 整数 注释 = "添加或更新一个整数型键值." 注释 = "当\"是否允许重复键名\"为真时,始终为添加键值."
            返回值注释 = "返回值大于等于0表示成功,小于0表示失败." 折叠 @嵌入式方法 = "">
    参数 节名 <类型 = 文本型 注释 = "所欲添加或更新的节">
    参数 键名 <类型 = 文本型 注释 = "所欲添加或更新的键">
    参数 键值 <类型 = 整数 注释 = "所欲设置的键值">
    参数 注释 <类型 = 文本型 注释 = "设置节或键的注释,如果键名为空则是设置节的注释;" 注释 = "可空,注释文本必须以字符\';\'或\'#\'开头;"
            注释 = "仅在第一次创建新的节或键名时才会写入注释." @默认值 = 空对象>
    参数 使用十六进制 <类型 = 逻辑型 注释 = "是否以十六进制文本的格式来写入整数型键值" @默认值 = 假>
    参数 强制替换 <类型 = 逻辑型 注释 = "\"是否允许重复键名\"为真时,是否强制将同一个键名的" 注释 = "所有键值都替换成新值." @默认值 = 假>
    {
        @ (INT)@sn<this>.data().SetLongValue(@<节名>.GetText(), @<键名>.GetText(), (long)@<键值>,
        @     @<注释>.GetTextMaybeNull(), (bool)@<使用十六进制>, (bool)@<强制替换>)
    }

    方法 置小数键值 <公开 类型 = 整数 注释 = "添加或更新一个小数型键值." 注释 = "当\"是否允许重复键名\"为真时,始终为添加键值."
            返回值注释 = "返回值大于等于0表示成功,小于0表示失败." 折叠 @嵌入式方法 = "">
    参数 节名 <类型 = 文本型 注释 = "所欲添加或更新的节">
    参数 键名 <类型 = 文本型 注释 = "所欲添加或更新的键">
    参数 键值 <类型 = 小数 注释 = "所欲设置的键值">
    参数 注释 <类型 = 文本型 注释 = "设置节或键的注释,如果键名为空则是设置节的注释;" 注释 = "可空,注释文本必须以字符\';\'或\'#\'开头;"
            注释 = "仅在第一次创建新的节或键名时才会写入注释." @默认值 = 空对象>
    参数 强制替换 <类型 = 逻辑型 注释 = "\"是否允许重复键名\"为真时,是否强制将同一个键名的" 注释 = "所有键值都替换成新值." @默认值 = 假>
    {
        @ (INT)@sn<this>.data().SetDoubleValue(@<节名>.GetText(), @<键名>.GetText(), @<键值>,
        @     @<注释>.GetTextMaybeNull(), (bool)@<强制替换>)
    }

    方法 置逻辑键值 <公开 类型 = 整数 注释 = "添加或更新一个逻辑型键值." 注释 = "当\"是否允许重复键名\"为真时,始终为添加键值."
            返回值注释 = "返回值大于等于0表示成功,小于0表示失败." 折叠 @嵌入式方法 = "">
    参数 节名 <类型 = 文本型 注释 = "所欲添加或更新的节">
    参数 键名 <类型 = 文本型 注释 = "所欲添加或更新的键">
    参数 键值 <类型 = 逻辑型 注释 = "所欲设置的键值">
    参数 注释 <类型 = 文本型 注释 = "设置节或键的注释,如果键名为空则是设置节的注释;" 注释 = "可空,注释文本必须以字符\';\'或\'#\'开头;"
            注释 = "仅在第一次创建新的节或键名时才会写入注释." @默认值 = 空对象>
    参数 强制替换 <类型 = 逻辑型 注释 = "\"是否允许重复键名\"为真时,是否强制将同一个键名的" 注释 = "所有键值都替换成新值." @默认值 = 假>
    {
        @ (INT)@sn<this>.data().SetBoolValue(@<节名>.GetText(), @<键名>.GetText(), (bool)@<键值>,
        @     @<注释>.GetTextMaybeNull(), (bool)@<强制替换>)
    }

    方法 删除配置 <公开 类型 = 逻辑型 注释 = "  删除整个节,或节中的某个键." 注释 = "  当\"是否允许重复键名\"为真时,将删除所有同名的键,"
            注释 = "如果要单独删除某个键值对,请用\"删除键值\"." 返回值注释 = "返回值大于等于0表示成功,小于0表示失败." 折叠 @嵌入式方法 = "">
    参数 节名 <类型 = 文本型 注释 = "所欲删除配置的节,如果如果键名为空,则表示删除整个节." @默认值 = 空对象>
    参数 键名 <类型 = 文本型 注释 = "所欲删除的键,如果键名为空,则表示删除整个节." @默认值 = 空对象>
    参数 删除空节 <类型 = 逻辑型 注释 = "如果删除指定键后,节已经没有其他内容,是否把这个空节也删除掉?" @默认值 = 假>
    {
        @ (BOOL)@sn<this>.data().Delete(@<节名>.GetTextMaybeNull(), @<键名>.GetTextMaybeNull(), (bool)@<删除空节>)
    }

    方法 删除键值 <公开 类型 = 逻辑型 注释 = "删除整个节,或节中的某个键.如果提供了键值,则只删除对应的键." 返回值注释 = "返回值大于等于0表示成功,小于0表示失败." 折叠
            @嵌入式方法 = "">
    参数 节名 <类型 = 文本型 注释 = "所欲删除配置的节,如果如果键名为空,则表示删除整个节." @默认值 = 空对象>
    参数 键名 <类型 = 文本型 注释 = "所欲删除的键,如果键名为空,则表示删除整个节." @默认值 = 空对象>
    参数 键值 <类型 = 文本型 注释 = "所欲删除的指定键值,如果留空则表示删除所有同名的键." @默认值 = 空对象>
    参数 删除空节 <类型 = 逻辑型 注释 = "如果删除指定键后,节已经没有其他内存,是否把这个空节也删除掉." @默认值 = 假>
    {
        @ (BOOL)@sn<this>.data().DeleteValue(@<节名>.GetTextMaybeNull(), @<键名>.GetTextMaybeNull(),
        @     @<键值>.GetTextMaybeNull(), (bool)@<删除空节>)
    }

    # @begin
    # @m<DECLARE_REF_OBJECT_CLASS_WITH_DATA>(CSimpleIniW)
    # <> <include>
    # CVolString m_szIniFile;
    # bool m_bAutoSave;
    # INT m_nType = VSET_UNKNOWN;
    # <> </include>
    # @end
}

类 配置项信息类 <公开 基础类 = 扩展对象类 折叠 @文档 = "category = \"配置文件.INI.辅助类\"">
{
    变量 项目 <公开 类型 = 文本型 注释 = "节名、键名、键值" @输出名 = "pItem">
    变量 注释 <公开 类型 = 文本型 注释 = "配置项的注释" @输出名 = "pComment">
    变量 序号 <公开 类型 = 整数 注释 = "配置项的序号,从0开始,为ini配置数据除去空行和注释之后的排序." @输出名 = "nOrder">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<配置项信息类> 总共 3 个成员:\r\n"
        加入文本 (展示内容, "1. 项目: " + 取调试文本2 (最大展示数据尺寸, 项目) + "\r\n")
        加入文本 (展示内容, "2. 注释: " + 取调试文本2 (最大展示数据尺寸, 注释) + "\r\n")
        加入文本 (展示内容, "3. 序号: " + 取调试文本2 (最大展示数据尺寸, 序号))
    }
}

类 配置项信息数组类 <公开 基础类 = 对象数组模板类 @文档 = "category = \"配置文件.INI.辅助类\"" @模板实现类 = "配置项信息类">

# 快捷方式 ===

类 快捷方式操作 <公开 注释 = "自己写的快捷方式解析,别问我为什么不用IShellLink对象,我写完才发现有这玩意…"
        注释 = "基本把我电脑上的快捷方式都测试了一遍,如果还遇到不能解析的,可以提交给我." 注释 = "另外,部分快捷方式文件没有目标文件属性、时间等信息是正常的." 折叠
        @文档 = "category = \"快捷方式\"">
{
    方法 解析 <公开 静态 类型 = 逻辑型 注释 = "解析快捷方式文件中的信息." 返回值注释 = "返回是否成功." 折叠>
    参数 文件路径 <类型 = 文本型 注释 = "快捷方式文件的文件路径.">
    参数 快捷方式信息 <类型 = 快捷方式信息类 注释 = "成功返回快捷方式的各项信息.">
    {
        变量 数据 <类型 = 字节集类>
        变量 数据长度 <类型 = 整数>
        快捷方式信息.重置为空对象 ()
        数据长度 = 数据.从文件读字节集 (文件路径)
        如果 (数据长度 == -1 || 数据长度 < 78)
        {
            返回 (假)
        }
        如果 (数据.取字节集数据 (0, 整数) != 76)  // 字符"L"
        {
            返回 (假)
        }
        快捷方式信息.GUID.从字节集创建 (数据.取字节集中间 (4, 16))  // GUID
        快捷方式信息.可选属性 = 数据.取字节集数据 (20, 整数)
        快捷方式信息.目标文件属性 = 数据.取字节集数据 (24, 整数)
        快捷方式信息.创建时间 = 数据.取字节集数据 (28, 长整数)
        快捷方式信息.修改时间 = 数据.取字节集数据 (36, 长整数)
        快捷方式信息.访问时间 = 数据.取字节集数据 (44, 长整数)
        快捷方式信息.目标文件长度 = 数据.取字节集数据 (52, 整数)
        快捷方式信息.图标个数 = 数据.取字节集数据 (56, 整数)
        快捷方式信息.运行方式 = 数据.取字节集数据 (60, 整数)
        快捷方式信息.快捷键 = 数据.取字节集数据 (64, 整数)
        变量 信息段位置 <类型 = 整数>
        如果 (位与 (快捷方式信息.可选属性, 1) == 1)  // 判断是否存在shell item id list
        {
            信息段位置 = 78 + 数据.取字节集数据 (76, 短整数)  // 跳过shell item id list段
            如果 (位与 (快捷方式信息.可选属性, 2) != 2)  // 文件或文件夹段不存在时,尝试在shell item id list中获取
            {
                变量 item_ID偏移 <类型 = 整数>
                变量 item_ID长度 <类型 = 整数>
                变量 item_ID <类型 = 字节集数组类>
                变量 GUID索引 <类型 = 整数>
                // 取出所有shell item id
                item_ID偏移 = 78
                item_ID长度 = 数据.取字节集数据 (item_ID偏移, 短整数)
                循环判断首 ()
                {
                    变量 成员索引 <类型 = 整数>
                    成员索引 = item_ID.加入成员 (数据.取字节集中间 (item_ID偏移 + 2, item_ID长度 - 2))
                    如果 (item_ID长度 == 20)  // 判断是否存在"我的电脑"的GUID,如果存在则表示本地卷有目标文件
                    {
                        变量 我的电脑 <类型 = GUID类>
                        我的电脑.从字节集创建 (数据.取字节集中间 (item_ID偏移 + 4, 16))
                        如果 (文本比较 (我的电脑.取文本 (), "{20D04FE0-3AEA-1069-A2D8-08002B30309D}") == 0)
                        {
                            GUID索引 = 成员索引
                        }
                    }
                    item_ID偏移 = item_ID偏移 + item_ID长度
                    item_ID长度 = 数据.取字节集数据 (item_ID偏移, 短整数)
                }
                循环判断尾 (item_ID长度 > 0)
                // 获取本地卷目标文件
                如果 (GUID索引 + 1 < item_ID.取成员数 () && item_ID.取成员 (GUID索引 + 1).取字节集数据 (0, 字节) == 0x2F)
                {
                    加入文本 (快捷方式信息.本地目标, 多字节指针到文本 (item_ID.取成员 (GUID索引 + 1).取字节集指针 () + 1))
                    GUID索引 = GUID索引 + 2
                    判断循环 (item_ID.取成员 (GUID索引).取字节集数据 (0, 字节) == 0x31)
                    {
                        加入文本 (快捷方式信息.本地目标, 多字节指针到文本 (item_ID.取成员 (GUID索引).取字节集指针 () + 12))
                        检查加入路径字符 (快捷方式信息.本地目标)
                        如果 (GUID索引 + 1 < item_ID.取成员数 ())
                        {
                            GUID索引 = GUID索引 + 1
                        }
                    }
                    如果 (item_ID.取成员 (GUID索引).取字节集数据 (0, 字节) == 0x32)
                    {
                        加入文本 (快捷方式信息.本地目标, 多字节指针到文本 (item_ID.取成员 (GUID索引).取字节集指针 () + 12))
                    }
                }
            }
        }
        否则
        {
            信息段位置 = 76
        }
        如果 (位与 (快捷方式信息.可选属性, 2) == 2)  // 指向文件或文件夹
        {
            变量 本地路径位置 <类型 = 整数>
            变量 网络卷位置 <类型 = 整数>
            变量 附加信息位置 <类型 = 整数>
            变量 附加信息结尾 <类型 = 整数>
            变量 卷位置标志 <类型 = 整数>
            变量 结尾字符位置 <类型 = 整数>
            如果 (数据长度 < 信息段位置 + 4 || 数据长度 < 信息段位置 + 数据.取字节集数据 (信息段位置, 整数) + 4)
            {
                返回 (假)
            }
            本地路径位置 = 信息段位置 + 数据.取字节集数据 (信息段位置 + 16, 整数)
            网络卷位置 = 数据.取字节集数据 (信息段位置 + 20, 整数)
            如果 (网络卷位置 != 0)
            {
                网络卷位置 = 网络卷位置 + 信息段位置
            }
            附加信息位置 = 信息段位置 + 数据.取字节集数据 (信息段位置 + 24, 整数)
            附加信息结尾 = 数据.寻找字节集 (取空白字节集 (1), 附加信息位置)
            卷位置标志 = 数据.取字节集数据 (信息段位置 + 8, 整数)
            如果 (位与 (卷位置标志, 1) == 1)  // 文件在本地卷
            {
                结尾字符位置 = 数据.寻找字节集 (取空白字节集 (1), 本地路径位置)
                快捷方式信息.本地目标 = 多字节到文本 (数据.取字节集中间 (本地路径位置, 结尾字符位置 - 本地路径位置))
                加入文本 (快捷方式信息.本地目标, 多字节到文本 (数据.取字节集中间 (附加信息位置, 附加信息结尾 - 附加信息位置)))
            }
            如果 (位与 (卷位置标志, 2) == 2)  // 文件在网络卷
            {
                结尾字符位置 = 数据.寻找字节集 (取空白字节集 (1), 网络卷位置 + 20)
                快捷方式信息.网络目标 = 多字节到文本 (数据.取字节集中间 (网络卷位置 + 20, 结尾字符位置 - 网络卷位置 + 20))
                检查加入路径字符 (快捷方式信息.网络目标)
                加入文本 (快捷方式信息.网络目标, 多字节到文本 (数据.取字节集中间 (附加信息位置, 附加信息结尾 - 附加信息位置)))
            }
            如果 (附加信息结尾 == 0)
            {
                信息段位置 = 信息段位置 + 数据.取字节集数据 (信息段位置, 整数)
            }
            否则
            {
                信息段位置 = 附加信息结尾 + 1
            }
        }
        变量 字符串长度 <类型 = 整数>
        如果 (位与 (快捷方式信息.可选属性, 4) == 4)  // 备注
        {
            字符串长度 = 数据.取字节集数据 (信息段位置, 短整数) * 2
            如果 (数据长度 < 信息段位置 + 字符串长度 + 4)
            {
                返回 (假)
            }
            快捷方式信息.备注 = 字节集到文本 (数据.取字节集中间 (信息段位置 + 2, 字符串长度))
            信息段位置 = 信息段位置 + 字符串长度 + 2
        }
        如果 (位与 (快捷方式信息.可选属性, 8) == 8)  // 相对路径
        {
            字符串长度 = 数据.取字节集数据 (信息段位置, 短整数) * 2
            如果 (数据长度 < 信息段位置 + 字符串长度 + 4)
            {
                返回 (假)
            }
            快捷方式信息.相对路径 = 字节集到文本 (数据.取字节集中间 (信息段位置 + 2, 字符串长度))
            信息段位置 = 信息段位置 + 字符串长度 + 2
        }
        如果 (位与 (快捷方式信息.可选属性, 16) == 16)  // 起始位置
        {
            字符串长度 = 数据.取字节集数据 (信息段位置, 短整数) * 2
            如果 (数据长度 < 信息段位置 + 字符串长度 + 4)
            {
                返回 (假)
            }
            快捷方式信息.起始位置 = 字节集到文本 (数据.取字节集中间 (信息段位置 + 2, 字符串长度))
            信息段位置 = 信息段位置 + 字符串长度 + 2
        }
        如果 (位与 (快捷方式信息.可选属性, 32) == 32)  // 命令行参数
        {
            字符串长度 = 数据.取字节集数据 (信息段位置, 短整数) * 2
            如果 (数据长度 < 信息段位置 + 字符串长度 + 4)
            {
                返回 (假)
            }
            快捷方式信息.命令行参数 = 字节集到文本 (数据.取字节集中间 (信息段位置 + 2, 字符串长度))
            信息段位置 = 信息段位置 + 字符串长度 + 2
        }
        如果 (位与 (快捷方式信息.可选属性, 64) == 64)  // 图标文件
        {
            字符串长度 = 数据.取字节集数据 (信息段位置, 短整数) * 2
            如果 (数据长度 < 信息段位置 + 字符串长度 + 4)
            {
                返回 (假)
            }
            快捷方式信息.自定义图标文件 = 字节集到文本 (数据.取字节集中间 (信息段位置 + 2, 字符串长度))
            信息段位置 = 信息段位置 + 字符串长度 + 2
        }
        返回 (真)
    }
}

类 快捷方式信息类 <公开 基础类 = 扩展对象类 注释 = "备注的\"可空\"是可能为空的意思..." 折叠 @文档 = "category = \"快捷方式.辅助类\"">
{
    变量 本地目标 <公开 类型 = 文本型 注释 = "快捷方式所指向的本地卷目标">
    变量 网络目标 <公开 类型 = 文本型 注释 = "快捷方式所指向的网络卷目标">
    变量 起始位置 <公开 类型 = 文本型 注释 = "快捷方式所指向目标的工作路径">
    变量 备注 <公开 类型 = 文本型 注释 = "(可空)快捷方式文件的备注">
    变量 相对路径 <公开 类型 = 文本型 注释 = "(可空)快捷方式文件的相对路径">
    变量 命令行参数 <公开 类型 = 文本型 注释 = "(可空)快捷方式文件的命令行参数">
    变量 自定义图标文件 <公开 类型 = 文本型 注释 = "(可空)自定义图标文件的路径">
    变量 可选属性 <公开 类型 = 整数 注释 = "快捷方式文件的可选属性,为\"快捷方式可选属性\"类中常量的组合值.">
    变量 目标文件属性 <公开 类型 = 整数 注释 = "(可空)目标文件属性,为\"快捷方式目标文件属性\"类中常量的组合值.">
    变量 创建时间 <公开 类型 = 长整数 注释 = "(可空)快捷方式文件的创建时间">
    变量 修改时间 <公开 类型 = 长整数 注释 = "(可空)快捷方式文件的创建时间">
    变量 访问时间 <公开 类型 = 长整数 注释 = "(可空)快捷方式文件的上一次访问时间">
    变量 目标文件长度 <公开 类型 = 整数 注释 = "(可空)目标文件的字节长度">
    变量 图标个数 <公开 类型 = 整数 注释 = "(可空)快捷方式的自定义图标个数">
    变量 运行方式 <公开 类型 = 整数 注释 = "(可空)目标文件执行时窗口显示方式：" 注释 = "  1. 常规窗口" 注释 = "  2. 最小化" 注释 = "  3. 最大化">
    变量 快捷键 <公开 类型 = 整数 注释 = "(可空)快捷方式的快捷键">
    变量 GUID <公开 类型 = GUID类 注释 = "快捷方式文件的GUID">

    方法 取目标文件属性描述 <公开 类型 = 文本型 折叠>
    {
        如果 (目标文件属性 == 0)
        {
            返回 ("")
        }
        变量 结果 <类型 = 文本型>
        如果 (是否为指定属性 (目标文件属性, 快捷方式目标文件属性.只读文件) == 真)
        {
            加入文本 (结果, "只读文件")
        }
        如果 (是否为指定属性 (目标文件属性, 快捷方式目标文件属性.隐藏文件) == 真)
        {
            加入文本 (结果, "、隐藏文件")
        }
        如果 (是否为指定属性 (目标文件属性, 快捷方式目标文件属性.系统文件) == 真)
        {
            加入文本 (结果, "、系统文件")
        }
        如果 (是否为指定属性 (目标文件属性, 快捷方式目标文件属性.卷标) == 真)
        {
            加入文本 (结果, "、卷标")
        }
        如果 (是否为指定属性 (目标文件属性, 快捷方式目标文件属性.文件夹) == 真)
        {
            加入文本 (结果, "、文件夹")
        }
        如果 (是否为指定属性 (目标文件属性, 快捷方式目标文件属性.可以存档文件) == 真)
        {
            加入文本 (结果, "、可以存档文件")
        }
        如果 (是否为指定属性 (目标文件属性, 快捷方式目标文件属性.加密文件) == 真)
        {
            加入文本 (结果, "、加密文件")
        }
        如果 (是否为指定属性 (目标文件属性, 快捷方式目标文件属性.常规文件) == 真)
        {
            加入文本 (结果, "、常规文件")
        }
        如果 (是否为指定属性 (目标文件属性, 快捷方式目标文件属性.临时文件) == 真)
        {
            加入文本 (结果, "、临时文件")
        }
        如果 (是否为指定属性 (目标文件属性, 快捷方式目标文件属性.稀疏文件) == 真)
        {
            加入文本 (结果, "、稀疏文件")
        }
        如果 (是否为指定属性 (目标文件属性, 快捷方式目标文件属性.重分析点数据) == 真)
        {
            加入文本 (结果, "、重分析点数据")
        }
        如果 (是否为指定属性 (目标文件属性, 快捷方式目标文件属性.压缩内容) == 真)
        {
            加入文本 (结果, "、压缩内容")
        }
        如果 (是否为指定属性 (目标文件属性, 快捷方式目标文件属性.脱机文件) == 真)
        {
            加入文本 (结果, "、脱机文件")
        }
        如果 (是否以字符开头 (结果, '、') == 真)
        {
            删除字符 (结果, 0, 1)
        }
        返回 (结果)
    }

    方法 是否为指定属性 <公开 类型 = 逻辑型 折叠>
    参数 标志值 <类型 = 整数>
    参数 欲匹配的属性 <类型 = 整数 注释 = "请参考\"快捷方式目标文件属性\"">
    {
        返回 (位与 (标志值, 欲匹配的属性) == 欲匹配的属性)
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<快捷方式信息类> 总共 15 个成员:\r\n"
        加入文本 (展示内容, "1. 本地目标: " + 取调试文本2 (最大展示数据尺寸, 本地目标) + "\r\n")
        加入文本 (展示内容, "2. 网络目标: " + 取调试文本2 (最大展示数据尺寸, 网络目标) + "\r\n")
        加入文本 (展示内容, "3. 起始位置: " + 取调试文本2 (最大展示数据尺寸, 起始位置) + "\r\n")
        加入文本 (展示内容, "4. 备注: " + 取调试文本2 (最大展示数据尺寸, 备注) + "\r\n")
        加入文本 (展示内容, "5. 相对路径: " + 取调试文本2 (最大展示数据尺寸, 相对路径) + "\r\n")
        加入文本 (展示内容, "6. 命令行参数: " + 取调试文本2 (最大展示数据尺寸, 命令行参数) + "\r\n")
        加入文本 (展示内容, "7. 自定义图标文件: " + 取调试文本2 (最大展示数据尺寸, 自定义图标文件) + "\r\n")
        加入文本 (展示内容, "8. 可选属性: " + 取调试文本2 (最大展示数据尺寸, 可选属性) + "\r\n")
        加入文本 (展示内容, "9. 目标文件属性: " + 到文本 (目标文件属性) + "(" + 取目标文件属性描述 () + ")\r\n")
        加入文本 (展示内容, "10. 创建时间: " + 取调试文本2 (最大展示数据尺寸, 创建时间) + "\r\n")
        加入文本 (展示内容, "11. 修改时间: " + 取调试文本2 (最大展示数据尺寸, 修改时间) + "\r\n")
        加入文本 (展示内容, "12. 访问时间: " + 取调试文本2 (最大展示数据尺寸, 访问时间) + "\r\n")
        加入文本 (展示内容, "13. 目标文件长度: " + 取调试文本2 (最大展示数据尺寸, 目标文件长度) + "\r\n")
        加入文本 (展示内容, "14. 图标个数: " + 取调试文本2 (最大展示数据尺寸, 图标个数) + "\r\n")
        加入文本 (展示内容, "15. 运行方式: " + 取调试文本2 (最大展示数据尺寸, 图标个数) + 多项选择 (运行方式 - 1, " (常规窗口)", " (最小化)", " (最大化)") + "\r\n")
        加入文本 (展示内容, "16. 快捷键: " + 取调试文本2 (最大展示数据尺寸, 快捷键) + "\r\n")
        加入文本 (展示内容, "17. GUID: " + 取调试文本2 (最大展示数据尺寸, GUID.取文本 ()))
    }
}

类 快捷方式目标文件属性 <公开 折叠 @文档 = "category = \"快捷方式.辅助类\"">
{
    常量 只读文件 <公开 类型 = 整数 值 = 1 注释 = "快捷方式所指目标文件有只读属性">
    常量 隐藏文件 <公开 类型 = 整数 值 = 2 注释 = "快捷方式所指目标文件有隐藏属性">
    常量 系统文件 <公开 类型 = 整数 值 = 4 注释 = "快捷方式所指目标文件是系统文件">
    常量 卷标 <公开 类型 = 整数 值 = 8 注释 = "快捷方式所指目标是卷标">
    常量 文件夹 <公开 类型 = 整数 值 = 16 注释 = "快捷方式所指目标是文件夹">
    常量 可以存档文件 <公开 类型 = 整数 值 = 32 注释 = "快捷方式所指目标文件在上次存档后被修改过." 注释 = "(跟系统备份有关,系统备份文件后会取消这个属性,之后修改文件就会加回来)">
    常量 加密文件 <公开 类型 = 整数 值 = 64 注释 = "快捷方式所指目标文件被加密(加密内容以便保护数据)">
    常量 常规文件 <公开 类型 = 整数 值 = 128 注释 = "快捷方式所指目标文件属性为一般">
    常量 临时文件 <公开 类型 = 整数 值 = 256 注释 = "快捷方式所指目标文件为临时">
    常量 稀疏文件 <公开 类型 = 整数 值 = 512 注释 = "快捷方式所指目标文件为稀疏文件">
    常量 重分析点数据 <公开 类型 = 整数 值 = 1024 注释 = "快捷方式所指目标文件有重分析点数据">
    常量 压缩内容 <公开 类型 = 整数 值 = 2048 注释 = "快捷方式所指目标文件被压缩(压缩内容以便节省磁盘空间)">
    常量 脱机文件 <公开 类型 = 整数 值 = 4096 注释 = "快捷方式所指目标文件脱机">
}

类 快捷方式可选属性 <公开 折叠 @文档 = "category = \"快捷方式.辅助类\"">
{
    常量 存在list段 <公开 类型 = 整数 值 = 1 注释 = "是否存在Shell item ID list段">
    常量 指向文件或文件夹 <公开 类型 = 整数 值 = 2 注释 = "存在是快捷方式指向文件或文件夹,否则为指向其他.">
    常量 存在备注 <公开 类型 = 整数 值 = 4 注释 = "存在备注字符串">
    常量 存在相对路径 <公开 类型 = 整数 值 = 8 注释 = "存在相对路径">
    常量 存在起始位置 <公开 类型 = 整数 值 = 16 注释 = "存在起始位置">
    常量 存在命令行参数 <公开 类型 = 整数 值 = 32 注释 = "存在命令行参数">
    常量 存在自定义图标 <公开 类型 = 整数 值 = 64 注释 = "存在自定义图标">
}
