<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "PE文件解析与操作" 注释 = "https://github.com/SaierMe/piv" @视窗.外部头文件 = "src\\PEfile.hpp">

类 PE文件操作类 <公开 注释 = "解析可执行文件的各种数据" 折叠 @文档 = "category = \"PE文件操作\"">
{

    # @ @m<DECLARE_REF_OBJECT_CLASS_WITH_DATA> (PivPeFile)

    方法 打开文件 <公开 类型 = 逻辑型 注释 = "打开并解析指定文件路径的可执行文件" 返回值注释 = "返回是否解析成功" 折叠 @嵌入式方法 = "">
    参数 文件名 <类型 = 文本型 注释 = "请提供包含完整路径的文件名">
    {
        @ @sn<this>.data().OpenPeFile(@<文件名>.GetText())
    }

    方法 打开数据 <公开 类型 = 逻辑型 注释 = "打开并解析内存中的可执行数据" 返回值注释 = "返回是否解析成功" 折叠 @嵌入式方法 = "">
    参数 数据指针 <类型 = 变整数 注释 = "可执行数据的首地址(基址)">
    参数 数据大小 <类型 = 整数 注释 = "可执行文件的字节大小">
    参数 是否已对齐 <类型 = 逻辑型 注释 = "请确定可执行数据是否已经内存对齐;" 注释 = "如果是原始的PE文件,请设置为假;" 注释 = "如果节区已经被对齐,请设置为真." @默认值 = 假>
    参数 是否已加载 <类型 = 逻辑型 注释 = "请确定可执行数据是否已经被加载运行;" 注释 = "如果是原始的PE文件,请设置为假;" 注释 = "如果是系统已经加载运行的模块,请设置为真."
            @默认值 = 假>
    {
        @ @sn<this>.data().OpenPeData(reinterpret_cast<void*>(@<数据指针>), static_cast<DWORD>(@<数据大小>), @<是否已对齐>, @<是否已加载>)
    }

    方法 打开模块 <公开 类型 = 逻辑型 注释 = "打开并解析系统中已加载的模块" 返回值注释 = "返回是否解析成功" 折叠 @禁止流程检查 = 真>
    参数 进程ID <类型 = 整数 注释 = "0为当前进程" @默认值 = 0>
    参数 模块名称 <类型 = 文本型 注释 = "请提供模块的文件名称(区分大小写);" 注释 = "如省略扩展名则默认为\".dll\". 结尾为\".\"则表示模块名称没有扩展名;"
            注释 = "该名称可以不包含路径,如果指定路径,必须用反斜杠\"\\\\\";" 注释 = "留空为打开进程的exe文件." @默认值 = 空对象>
    {
        变量 进程操作 <类型 = NT进程操作类>
        变量 模块信息 <类型 = NT模块信息类>
        变量 模块句柄 <类型 = 长整数>
        如果 (进程操作.打开进程 (进程ID) == 真)
        {
            模块句柄 = 进程操作.取模块句柄 (模块名称)
            如果 (进程操作.取模块信息 (模块句柄, 模块信息) == 真)
            {
                @ return (BOOL)data().OpenPeData(reinterpret_cast<void*>(@<模块信息.lpBaseOfDll>), static_cast<DWORD>(@<模块信息.SizeOfImage>), TRUE, TRUE);
            }
        }
        返回 (假)
    }

    方法 关闭数据 <公开 注释 = "关闭文件并释放数据,类析构时会自动执行." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().ClosePeData()
    }

    方法 保存数据 <公开 类型 = 逻辑型 注释 = "将当前打开的可执行数据保存到新文件中" 返回值注释 = "返回是否保存成功" 折叠 @嵌入式方法 = "">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲写到文件的路径名称">
    参数 是否修复PE结构 <类型 = 逻辑型 注释 = "是否将已加载到内存中运行的PE数据还原成PE文件结构." @默认值 = 真>
    {
        @ @sn<this>.data().SavePeDatas(@<文件名>.GetText(), @<是否修复PE结构>)
    }

    方法 是否可写 <公开 类型 = 逻辑型 注释 = "返回当前的PE数据是否处于可写的内存区域中" 返回值注释 = "返回真表示数据可写" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().IsWriteable()
    }

    方法 复制到新内存 <公开 类型 = 变整数 注释 = "将可执行数据复制到新的内存地址." 注释 = "本类默认以只读方式打开PE数据,如果要进行改写操作,必须执行本方法."
            注释 = "新的内存尺寸跟\"取映像尺寸\"一样." 注释 = "成功后将关闭之前打开的文件句柄和内存映射文件." 返回值注释 = "成功返回新的内存地址,失败返回0;" 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data().CopyToNewMem(TRUE)
    }

    方法 加载内存PE <公开 类型 = 逻辑型 注释 = "将PE数据复制到可执行可读写的新内存,并进行内存对齐、地址重定位和绑定导入表函数地址." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().MemLoadPE()
    }

    方法 取最后错误 <公开 类型 = 整数 注释 = "  返回本类最后一次的操作结果,0表示操作成功,其他值表示有错误," 注释 = "可以调用\"取错误信息\"得知具体的中文错误信息." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.data().GetErrorCode()
    }

    方法 取最后错误信息 <公开 类型 = 文本型 注释 = "返回本类最后一次的操作结果" 返回值注释 = "返回的是含错误代码和中文错误描述的文本型" 折叠 @嵌入式方法 = "">
    {
        @ @an<CVolString>(@sn<this>.data().GetErrorMessage())
    }

    方法 取数据指针 <公开 类型 = 变整数 注释 = "  获取可执行文件在内存中的基址,请勿对不可写的内存区域进行写操作," 注释 = "可能会导致程序崩溃,进行写操作前请先用\"是否可写\"方法判断."
            返回值注释 = "必须先\"解析文件\"成功才能返回有效数据." 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data().GetBaseAddress()
    }

    方法 取数据尺寸 <公开 类型 = 整数 注释 = "获取可执行文件当前占用的内存大小" 返回值注释 = "成功返回内存大小,失败返回0." 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data().GetDataSize()
    }

    方法 取映像尺寸 <公开 类型 = 整数 注释 = "计算出可执行文件被系统加载到内存之后的映像尺寸" 返回值注释 = "成功返回映像文件大小,失败返回0." 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data().CalcTotalImageSize()
    }

    方法 取文件尺寸 <公开 类型 = 整数 注释 = "计算出可执行文件的原始文件尺寸" 返回值注释 = "成功返回文件尺寸,失败返回0." 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data().CalcPeFileSize()
    }

    方法 是否为64位 <公开 类型 = 逻辑型 注释 = "返回可执行文件是否为64位" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().Is64Pe()
    }

    方法 是否为DLL <公开 注释 = "返回可执行文件是否为DLL文件." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().IsDllData()
    }

    方法 是否为EXE <公开 类型 = 逻辑型 注释 = "返回可执行文件是否为EXE文件." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().IsExeData()
    }

    方法 取映像基址 <公开 类型 = 长整数 注释 = "获取可执行文件的映像基址(ImageBase),32位PE可强制转换到整数." 返回值注释 = "失败返回0." 折叠 @嵌入式方法 = "">
    {
        @ (INT64)@sn<this>.data().GetImageBase()
    }

    方法 取入口点 <公开 类型 = 整数 注释 = "获取可执行文件的代码入口点(EntryPoint)." 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data().GetEntryPoint()
    }

    方法 取DOS头 <公开 类型 = IMAGE_DOS_HEADER 注释 = "获取可执行文件的DOS头数据." 折叠 @禁止流程检查 = 真>
    {
        @ PIMAGE_DOS_HEADER dos = data().GetDosHeader();
        @ if (dos)
        @     return *dos;
        @ return IMAGE_DOS_HEADER{0};
    }

    方法 取NT头32 <公开 类型 = IMAGE_NT_HEADERS32 注释 = "获取32位可执行文件的NT头数据." 折叠 @禁止流程检查 = 真>
    {
        @ if (data ().Is64Pe () == FALSE)
        @ {
        @     PIMAGE_NT_HEADERS32 pNt32 = data().GetNtHeader();
        @     if (pNt32)
        @         return *pNt32;
        @ }
        @ return IMAGE_NT_HEADERS32{0};
    }

    方法 取NT头64 <公开 类型 = IMAGE_NT_HEADERS64 注释 = "获取64位可执行文件的NT头数据." 折叠 @禁止流程检查 = 真>
    {
        @ if (data ().Is64Pe ())
        @ {
        @     PIMAGE_NT_HEADERS64 pNt64 = (PIMAGE_NT_HEADERS64)data().GetNtHeader();
        @     if (pNt64)
        @         return *pNt64;
        @ }
        @ return IMAGE_NT_HEADERS64{0};
    }

    方法 取节区表 <公开 类型 = 整数 注释 = "获取可执行文件的节区表." 返回值注释 = "成功返回节区数量,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 节区表数组 <类型 = 节区表数组类 注释 = "成功在此返回节区表数组">
    {
        @ @<节区表数组>.clear();
        @ DWORD dwSectionCount;
        @ PIMAGE_SECTION_HEADER pSection = data().GetSectionHeader(&dwSectionCount);
        @ if (dwSectionCount > 0)
        @ {
        @     for (DWORD i = 0; i < dwSectionCount; ++i) // 解析节区表
        @     {
        @         @<节区表数组>.push_back(pSection[i]);
        @     }
        @     return (INT)@<节区表数组>.size();
        @ }
        @ return 0;
    }

    方法 取导出表头 <公开 类型 = IMAGE_EXPORT_DIRECTORY 注释 = "获取DLL文件的函数导出表头数据,EXE文件没有导出表." 返回值注释 = "返回是否成功." 折叠
            @禁止流程检查 = 真>
    {
        @ PIMAGE_EXPORT_DIRECTORY pExport = data().GetExportHeader();
        @ if (pExport)
        @     return *pExport;
        @ return IMAGE_EXPORT_DIRECTORY{0};
    }

    方法 取导入表描述符 <公开 类型 = 整数 注释 = "获取可执行文件的导入表头数据." 返回值注释 = "成功返回导入表描述符数量,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 导入表描述符数组 <类型 = 导入表描述符数组类 注释 = "成功在此返回导入表描述符数组">
    {
        @ @<导入表描述符数组>.clear();
        @ PIMAGE_IMPORT_DESCRIPTOR pImport = data().GetImportDescriptor();
        @ if (pImport)
        @ {
        @     while (pImport->Name)
        @     {
        @         @<导入表描述符数组>.push_back(*pImport);
        @         pImport++;
        @     }
        @     return (INT)@<导入表描述符数组>.size();
        @ }
        @ return 0;
    }

    # ---

    方法 取导入表 <公开 类型 = 整数 注释 = "获取可执行文件的模块导入表信息." 返回值注释 = "成功返回导入的模块数量,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 导入表 <类型 = 导入表数组类 注释 = "成功在此返回导入表信息">
    {
        @ @<导入表>.data().clear();
        @ std::vector<CVolString> vModuleName;
        @ std::vector<std::vector<DWORD> > vFunOrdinal;
        @ std::vector<std::vector<ULONGLONG> > vFunAddress;
        @ std::vector<std::vector<CVolString> > vFunName;
        @ DWORD dwNumOfModule = data ().GetImportInfo (&vModuleName, &vFunOrdinal, &vFunAddress, &vFunName);
        @ for (DWORD i = 0; i < dwNumOfModule; i++)
        @ {
        @     @dt<导出表类> Dir;
        @     Dir.ModuleName = vModuleName[i];
        @     for (DWORD y = 0; y < vFunOrdinal[i].size(); y++)
        @     {
        @         Dir.aFunctions.data().emplace_back(vFunName[i][y], vFunAddress[i][y], vFunOrdinal[i][y]);
        @     }
        @     @<导入表>.data().push_back(Dir);
        @ }
        @ return (INT)@<导入表>.data().size();
    }

    方法 取导出表 <公开 类型 = 整数 注释 = "获取DLL文件的函数导出表信息,EXE文件没有导出表." 返回值注释 = "成功返回导出的函数数量,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 导出表 <类型 = 导出表类 注释 = "成功在此返回导出表信息">
    {
        @ @<导出表>.ResetToNullObject ();
        @ CVolString sModuleName;
        @ std::vector<DWORD> vFunOrdinal;
        @ std::vector<DWORD> vFunAddress;
        @ std::vector<CVolString> vFunName;
        @ DWORD dwNumOfFun = data ().GetExportInfo (&sModuleName, &vFunOrdinal, &vFunAddress, &vFunName);
        @ if (dwNumOfFun == 0) return 0;
        @ @<导出表>.ModuleName = sModuleName;
        @ for (DWORD i = 0; i < dwNumOfFun; i++)
        @ {
        @     @<导出表>.aFunctions.data().emplace_back(vFunName[i], vFunAddress[i], vFunOrdinal[i]);
        @ }
        @ return (INT)@<导出表>.aFunctions.data().size();
    }

    # ---

    方法 相对虚拟地址到文件偏移 <公开 类型 = 整数 注释 = "将相对虚拟地址(RVA)转换到文件偏移量(FOA)." 折叠 @嵌入式方法 = "">
    参数 相对虚拟地址 <类型 = 整数>
    {
        @ (INT)@sn<this>.data().Rva2Foa(static_cast<DWORD>(@<相对虚拟地址>))
    }

    方法 文件偏移到相对虚拟地址 <公开 类型 = 整数 注释 = "将文件偏移量(FOA)转换到相对虚拟地址(RVA)." 返回值注释 = "失败返回0" 折叠 @嵌入式方法 = "">
    参数 文件偏移 <类型 = 整数>
    {
        @ (INT)@sn<this>.data().Foa2Rva(static_cast<DWORD>(@<文件偏移>))
    }
}

# ---

类 内存DLL加载类 <公开 注释 = "注意: 这个类库是我自己写的,是否\"PE文件操作类\"的副产物,可能不够完善," 注释 = "一般建议用\"内存模块PP\"."
        注释 = "  1. 本类不使用系统的加载器载正常加载DLL模块,而是手动修改DLL的PE数据" 注释 = "并运行,因此成功加载的DLL不会被系统API枚举出来;"
        注释 = "  2. 在类析构或卸载模块之前,可以获取DLL导出表里的函数并调用;" 注释 = "  3. 只能在当前进程中加载,不支持注入到其他进程;"
        注释 = "  4. 兼容32位和64位的程序,DLL模块和进程的位数不符会返回失败;" 折叠 @文档 = "category = \"内存注入\"">
{

    # @ @m<DECLARE_REF_OBJECT_CLASS_WITH_DATA> (PivMemLoader)

    方法 保存数据 <公开 类型 = 逻辑型 注释 = "!!!功能未完成,未修复内存中的PE数据!!!" 注释 = "将当前打开的可执行数据保存到新文件中." 返回值注释 = "返回是否保存成功." 折叠
            @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "提供所欲写到文件的路径名称">
    {
        @ return WriteDataIntoFile(@<文件名>.GetText(), data().GetBaseAddress(), (INT_P)data().GetDataSize());
    }

    方法 加载模块 <公开 类型 = 逻辑型 注释 = "  在内存中加载DLL数据,并运行DLL的入口点函数.提供的DLL数据" 注释 = "必须是未经修改的(内容跟磁盘的DLL文件一致),否则会崩溃."
            注释 = "  除非DLL已经被卸载,再次调用此方法不会重复加载DLL." 注释 = "  本方法不支持EXE."
            返回值注释 = "  返回是否加载成功.本类只支持加载DLL文件,如果程序和DLL的程序" 返回值注释 = "位数不同亦返回假." 折叠 @嵌入式方法 = "">
    参数 DLL数据地址 <类型 = 变整数 注释 = "DLL数据在内存中的地址,请提供原始的DLL数据">
    参数 DLL数据大小 <类型 = 整数 注释 = "DLL数据的字节大小">
    {
        @ @sn<this>.data().MemLoadLibrary((void*)@<DLL数据地址>, (DWORD)@<DLL数据大小>)
    }

    方法 卸载模块 <公开 注释 = "  卸载内存DLL,卸载后请勿再调用DLL中的函数,否则会造成崩溃." 注释 = "  类析构时会自动卸载,一般不需要手动调用." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().MemFreeLibrary()
    }

    方法 函数名取地址 <公开 类型 = 变整数 注释 = "获取DLL模块中指定名称的函数地址(VA)." 返回值注释 = "成功返回函数地址,失败返回0." 折叠 @嵌入式方法 = "">
    参数 函数名称 <类型 = 文本型 注释 = "所欲取地址的函数名称">
    {
        @ (INT_P)@sn<this>.data().MemGetProcAddress(PivW2A{@<函数名称>}.c_str())
    }

    方法 函数序号取地址 <公开 类型 = 变整数 注释 = "获取DLL模块中指定序号的函数地址(VA)." 返回值注释 = "成功返回函数地址,失败返回0." 折叠 @嵌入式方法 = "">
    参数 函数序号 <类型 = 整数 注释 = "所欲取地址的函数序号,起始序号应大于等于1.">
    {
        @ (INT_P)@sn<this>.data().MemGetProcAddress((LPCSTR)@<函数序号>)
    }

    方法 取模块基址 <公开 类型 = 变整数 注释 = "获取内存DLL在虚拟内存中的模块基址(VA)." 返回值注释 = "未加载时返回0." 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data().GetBaseAddress()
    }

    方法 取模块尺寸 <公开 类型 = 整数 注释 = "  获取DLL数据在内存对齐之后的映像尺寸,该尺寸不等于DLL" 注释 = "的文件尺寸." 返回值注释 = "成功返回模块的尺寸,失败返回0." 折叠
            @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data().CalcTotalImageSize()
    }

    方法 是否已加载 <公开 类型 = 逻辑型 注释 = "返回是否已经成功加载了内存DLL." 返回值注释 = "已加载返回真,否则返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().IsLoadOk()
    }

    方法 取最后错误 <公开 类型 = 整数 注释 = "  返回本类最后一次的操作结果,0表示操作成功,其他值表示有错误," 注释 = "可以调用\"取错误信息\"得知具体的中文错误信息." 折叠
            @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data().GetErrorCode()
    }

    方法 取最后错误信息 <公开 类型 = 文本型 注释 = "返回本类最后一次的操作结果." 返回值注释 = "返回的是含错误代码和中文错误描述的文本型." 折叠 @嵌入式方法 = "">
    {
        @ @an<CVolString>(@sn<this>.data().GetErrorMessage())
    }
}

# ------

类 IMAGE_DOS_HEADER <公开 基础类 = PIV结构模板 注释 = "PE文件DOS头,64字节" 折叠 折叠2 @文档 = "category = \"PE文件操作.辅助类\""
        @别名 = "IMAGE_DOS_HEADER" @别名类型 = 本地结构 @模板实现类 = "IMAGE_DOS_HEADER">
{
    变量 e_magic <公开 类型 = 短整数 注释 = "DOS可执行文件头标记,必定为\"MZ\"(0x5A4D 4Dh 5Ah/23117)IMAGE_DOS_SIGNATURE"
            @输出名 = "e_magic">
    变量 e_cblp <公开 类型 = 短整数 注释 = "文件最后页的字节数" @输出名 = "e_cblp">
    变量 e_cp <公开 类型 = 短整数 注释 = "文件中的全部和部分页数" @输出名 = "e_cp">
    变量 e_crlc <公开 类型 = 短整数 注释 = "重定位表中的指针数" @输出名 = "e_crlc">
    变量 e_cparhdr <公开 类型 = 短整数 注释 = "头部尺寸,以段落为单位" @输出名 = "e_cparhdr">
    变量 e_minalloc <公开 类型 = 短整数 注释 = "所需的最小附加段" @输出名 = "e_minalloc">
    变量 e_maxalloc <公开 类型 = 短整数 注释 = "所需的最大附加段" @输出名 = "e_maxalloc">
    变量 e_ss <公开 类型 = 短整数 注释 = "初始的堆栈段(SS)相对偏移量值" @输出名 = "e_ss">
    变量 e_sp <公开 类型 = 短整数 注释 = "初始的堆栈指针(SP)值" @输出名 = "e_sp">
    变量 e_csum <公开 类型 = 短整数 注释 = "校验和" @输出名 = "e_csum">
    变量 e_ip <公开 类型 = 短整数 注释 = "初始的指令指针(IP)值" @输出名 = "e_ip">
    变量 e_cs <公开 类型 = 短整数 注释 = "初始的代码段(CS)相对偏移量值" @输出名 = "e_cs">
    变量 e_lfarlc <公开 类型 = 短整数 注释 = "重定位表在文件中的偏移地址" @输出名 = "e_lfarlc">
    变量 e_ovno <公开 类型 = 短整数 注释 = "覆盖号" @输出名 = "e_ovno">
    变量 e_res <公开 类型 = "短整数 [4]" 注释 = "保留字(一般是为确保对齐而预留)" @输出名 = "e_res">
    变量 e_oemid <公开 类型 = 短整数 注释 = "OEM标识符(相对于e_oeminfo)" @输出名 = "e_oemid">
    变量 e_oeminfo <公开 类型 = 短整数 注释 = "OEM信息,即e_oemid的细节" @输出名 = "e_oeminfo">
    变量 e_res2 <公开 类型 = "短整数 [10]" 注释 = "保留字(一般是为确保对齐而预留)" @输出名 = "e_res2">
    变量 e_lfanew <公开 类型 = 整数 注释 = "NT头(IMAGE_NT_HEADERS)在文件中的偏移地址" @输出名 = "e_lfanew">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = IMAGE_DOS_HEADER 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 展示内容 <类型 = 文本型>
        变量 格式文本 <类型 = 文本型
                值 = "<IMAGE_DOS_HEADER> 总共 19 个成员:\r\n1. e_magic: %u\r\n2. e_cblp: %u\r\n3. e_cp: %u\r\n4. e_crlc: %u\r\n5. e_cparhdr: %u\r\n6. e_minalloc: %u\r\n7. e_maxalloc: %u\r\n8. e_ss: %u\r\n9. e_sp: %u\r\n10. e_csum: %u\r\n11. e_ip: %u\r\n12. e_cs: %u\r\n13. e_lfarlc: %u\r\n14. e_ovno: %u\r\n">
        变量 i <类型 = 整数>
        加入格式文本 (展示内容, 格式文本, 欲操作本对象.e_magic, 欲操作本对象.e_cblp, 欲操作本对象.e_cp, 欲操作本对象.e_crlc, 欲操作本对象.e_cparhdr, 欲操作本对象.e_minalloc, 欲操作本对象.e_maxalloc, 欲操作本对象.e_ss, 欲操作本对象.e_sp, 欲操作本对象.e_csum, 欲操作本对象.e_ip, 欲操作本对象.e_cs, 欲操作本对象.e_lfarlc, 欲操作本对象.e_ovno)
        加入格式文本 (展示内容, "15. e_res: {%u, %u, %u, %u}\r\n", 欲操作本对象.e_res [0], 欲操作本对象.e_res [1], 欲操作本对象.e_res [2], 欲操作本对象.e_res [3])
        加入格式文本 (展示内容, "16. e_oemid: %u\r\n17. e_oeminfo: %u\r\n", 欲操作本对象.e_oemid, 欲操作本对象.e_oeminfo)
        加入格式文本 (展示内容, "18. e_res2: {%u", 欲操作本对象.e_res2 [0])
        循环 (1, 10, i, 1)
        {
            加入格式文本 (展示内容, ", %u", 欲操作本对象.e_res2 [i])
        }
        加入格式文本 (展示内容, "}\r\n19. e_lfanew: %u", 欲操作本对象.e_lfanew)
        返回 (展示内容)
    }
}

类 IMAGE_FILE_HEADER <公开 基础类 = PIV结构模板 注释 = "PE文件逻辑分布信息,20字节."
        注释 = "https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_file_header" 折叠 折叠2
        @文档 = "category = \"PE文件操作.辅助类\"" @别名 = "IMAGE_FILE_HEADER" @别名类型 = 本地结构 @模板实现类 = "IMAGE_FILE_HEADER">
{
    变量 Machine <公开 类型 = 短整数 注释 = "  可执行文件的目标CPU类型" 注释 = "  IMAGE_FILE_MACHINE_I386   0x014c  x86"
            注释 = "  IMAGE_FILE_MACHINE_IA64   0x0200  Intel Itanium"
            注释 = "  IMAGE_FILE_MACHINE_AMD64  0x8664  x64" @输出名 = "Machine">
    变量 NumberOfSections <公开 类型 = 短整数 注释 = "节区的数目,如果我们要在文件中增加或删除一个节区,就需要修改这个值." @输出名 = "NumberOfSections">
    变量 TimeDateStamp <公开 类型 = 整数 注释 = "文件创建的时间戳" @输出名 = "TimeDateStamp">
    变量 PointerToSymbolTable <公开 类型 = 整数 注释 = "COFF符号表格的文件偏移位置"
            注释 = "仅用于带有COFF类型调试信息的COFF类型的object files和PE files." @输出名 = "PointerToSymbolTable">
    变量 NumberOfSymbols <公开 类型 = 整数 注释 = "如果有COFF符号表格,它代表其中的符号数目"
            注释 = "COFF符号是一个大小固定的结构,如果想找到COFF符号表的结束位置,则需要这个变量" @输出名 = "NumberOfSymbols">
    变量 SizeOfOptionalHeader <公开 类型 = 短整数 注释 = "IMAGE_OPTIONAL_HEADER结构体的大小,32位和64位有差别"
            @输出名 = "SizeOfOptionalHeader">
    变量 Characteristics <公开 类型 = 短整数 注释 = "  文件属性标志,比如文件是exe还是dll.标志的值定义在 WINNT.H 中,是为组合值."
            注释 = "  IMAGE_FILE_RELOCS_STRIPPED     0x0001  文件中不存在重定位信息"
            注释 = "  IMAGE_FILE_EXECUTABLE_IMAGE    0x0002  文件可执行"
            注释 = "  IMAGE_FILE_LINE_NUMS_STRIPPED  0x0004  行号信息已从文件中移除"
            注释 = "  IMAGE_FILE_LOCAL_SYMS_STRIPPED 0x0008  符号信息已从文件中移除"
            注释 = "  IMAGE_FILE_DLL                 0x2000  DLL文件"
            注释 = "  IMAGE_FILE_SYSTEM              0x1000  系统文件"
            注释 = "  IMAGE_FILE_32BIT_MACHINE       0x0100  目标平台为32位平台" @输出名 = "Characteristics">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = IMAGE_FILE_HEADER 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 展示内容 <类型 = 文本型>
        变量 格式文本 <类型 = 文本型
                值 = "<IMAGE_FILE_HEADER> 总共 7 个成员:\r\n1. Machine: %u\r\n2. NumberOfSections: %u\r\n3. TimeDateStamp: %u\r\n4. PointerToSymbolTable: %u\r\n5. NumberOfSymbols: %u\r\n6. SizeOfOptionalHeader: %u\r\n7. Characteristics: %u">
        加入格式文本 (展示内容, 格式文本, 欲操作本对象.Machine, 欲操作本对象.NumberOfSections, 欲操作本对象.TimeDateStamp, 欲操作本对象.PointerToSymbolTable, 欲操作本对象.NumberOfSymbols, 欲操作本对象.SizeOfOptionalHeader, 欲操作本对象.Characteristics)
        返回 (展示内容)
    }
}

类 IMAGE_OPTIONAL_HEADER32 <公开 基础类 = PIV结构模板 注释 = "32位PE文件可选头" 折叠 折叠2 @文档 = "category = \"PE文件操作.辅助类\""
        @别名 = "IMAGE_OPTIONAL_HEADER32" @别名类型 = 本地结构 @模板实现类 = "IMAGE_OPTIONAL_HEADER32">
{
    变量 Magic <公开 类型 = 短整数 注释 = "  映像文件类型" 注释 = "  IMAGE_NT_OPTIONAL_HDR32_MAGIC  0x10b  32位程序"
            注释 = "  IMAGE_NT_OPTIONAL_HDR64_MAGIC  0x20b  64位程序"
            注释 = "  IMAGE_ROM_OPTIONAL_HDR_MAGIC   0x107  ROM文件" @输出名 = "Magic">
    变量 MajorLinkerVersion <公开 类型 = 字节 注释 = "链接器的主版本号" @输出名 = "MajorLinkerVersion">
    变量 MinorLinkerVersion <公开 类型 = 字节 注释 = "链接器的副版本号" @输出名 = "MinorLinkerVersion">
    变量 SizeOfCode <公开 类型 = 整数 注释 = "可执行代码的大小,这些值(包括下面2个也是不可靠的,你可以通过查看可选头后面的各个\"节\"来获得更准确的大小."
            @输出名 = "SizeOfCode">
    变量 SizeOfInitializedData <公开 类型 = 整数 注释 = "已初始化数据的大小" @输出名 = "SizeOfInitializedData">
    变量 SizeOfUninitializedData <公开 类型 = 整数 注释 = "未初始化数据的大小,所谓的\"bss段\"" @输出名 = "SizeOfUninitializedData">
    变量 AddressOfEntryPoint <公开 类型 = 整数 注释 = "代码入口点的偏移量,RVA" @输出名 = "AddressOfEntryPoint">
    变量 BaseOfCode <公开 类型 = 整数 注释 = "代码基址,可执行代码的偏移量,RVA" @输出名 = "BaseOfCode">
    变量 BaseOfData <公开 类型 = 整数 注释 = "数据基址,已初始化数据的偏移量,RVA" @输出名 = "BaseOfData">
    变量 ImageBase <公开 类型 = 整数 注释 = "PE文件的优先装载地址,提供整个二进制文件包括所有头的优先(线性)载入地址,RVA" @输出名 = "ImageBase">
    变量 SectionAlignment <公开 类型 = 整数 注释 = "内存中节对齐的粒度" @输出名 = "SectionAlignment">
    变量 FileAlignment <公开 类型 = 整数 注释 = "文件中节对齐的粒度" @输出名 = "FileAlignment">
    变量 MajorOperatingSystemVersion <公开 类型 = 短整数 注释 = "主操作系统最低主版本号" @输出名 = "MajorOperatingSystemVersion">
    变量 MinorOperatingSystemVersion <公开 类型 = 短整数 注释 = "主操作系统最低副版本号" @输出名 = "MinorOperatingSystemVersion">
    变量 MajorImageVersion <公开 类型 = 短整数 注释 = "主映像文件版本" @输出名 = "MajorImageVersion">
    变量 MinorImageVersion <公开 类型 = 短整数 注释 = "副映像文件版本" @输出名 = "MinorImageVersion">
    变量 MajorSubsystemVersion <公开 类型 = 短整数 注释 = "子系统主版本号" @输出名 = "MajorSubsystemVersion">
    变量 MinorSubsystemVersion <公开 类型 = 短整数 注释 = "子系统副版本号" @输出名 = "MinorSubsystemVersion">
    变量 Win32VersionValue <公开 类型 = 整数 注释 = "Win32版本值,可能为0" @输出名 = "Win32VersionValue">
    变量 SizeOfImage <公开 类型 = 整数 注释 = "内存中整个PE映像体的尺寸.它是所有头和节经过节对齐处理后的大小." @输出名 = "SizeOfImage">
    变量 SizeOfHeaders <公开 类型 = 整数 注释 = "所有头+节表的大小,也就等于文件尺寸减去文件中所有节的尺寸.可以以此值作为PE文件第一节的文件偏移量."
            @输出名 = "SizeOfHeaders">
    变量 CheckSum <公开 类型 = 整数 注释 = "校验和" @输出名 = "CheckSum">
    变量 Subsystem <公开 类型 = 短整数 注释 = "  子系统,NT用来识别PE文件属于哪个子系统."
            注释 = "  IMAGE_SUBSYSTEM_WINDOWS_GUI  2  Windows graphical user interface (GUI) subsystem."
            注释 = "  IMAGE_SUBSYSTEM_WINDOWS_CUI  3  Windows character-mode user interface (CUI) subsystem."
            @输出名 = "Subsystem">
    变量 DllCharacteristics <公开 类型 = 短整数 注释 = "  DLL特性,指明,如果是DLL文件,何时调用DLL文件的入口点,一般不用"
            注释 = "  IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA       0x0020  Image can handle a high entropy 64-bit virtual address space."
            注释 = "  IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE          0x0040  DLL can move."
            注释 = "  IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY       0x0080  Code Integrity Image"
            注释 = "  IMAGE_DLLCHARACTERISTICS_NX_COMPAT             0x0100  Image is NX compatible"
            注释 = "  IMAGE_DLLCHARACTERISTICS_NO_ISOLATION          0x0200  Image understands isolation and doesn\'t want it"
            注释 = "  IMAGE_DLLCHARACTERISTICS_NO_SEH                0x0400  Image does not use SEH.  No SE handler may reside in this image"
            注释 = "  IMAGE_DLLCHARACTERISTICS_NO_BIND               0x0800  Do not bind this image."
            注释 = "  IMAGE_DLLCHARACTERISTICS_APPCONTAINER          0x1000  Image should execute in an AppContainer"
            注释 = "  IMAGE_DLLCHARACTERISTICS_WDM_DRIVER            0x2000  Driver uses WDM model"
            注释 = "  IMAGE_DLLCHARACTERISTICS_GUARD_CF              0x4000  Image supports Control Flow Guard."
            注释 = "  IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE 0x8000" @输出名 = "DllCharacteristics">
    变量 SizeOfStackReserve <公开 类型 = 整数 注释 = "保留栈的大小" @输出名 = "SizeOfStackReserve">
    变量 SizeOfStackCommit <公开 类型 = 整数 注释 = "初始时指定栈大小" @输出名 = "SizeOfStackCommit">
    变量 SizeOfHeapReserve <公开 类型 = 整数 注释 = "保留堆的大小" @输出名 = "SizeOfHeapReserve">
    变量 SizeOfHeapCommit <公开 类型 = 整数 注释 = "指定堆大小" @输出名 = "SizeOfHeapCommit">
    变量 LoaderFlags <公开 类型 = 整数 注释 = "加载器标志(已废弃)" @输出名 = "LoaderFlags">
    变量 NumberOfRvaAndSizes <公开 类型 = 整数 注释 = "Rva数和大小" @输出名 = "NumberOfRvaAndSizes">
    变量 DataDirectory <公开 类型 = "IMAGE_DATA_DIRECTORY [16]" 注释 = "  映像文件数据目录,索引可选:"
            注释 = "  IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table"
            注释 = "  IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory"
            注释 = " /IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)"
            注释 = "  IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data"
            注释 = "  IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP"
            注释 = "  IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers"
            注释 = "  IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table"
            注释 = "  IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors"
            注释 = "  IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor" @输出名 = "DataDirectory">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = IMAGE_OPTIONAL_HEADER32 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 展示内容 <类型 = 文本型>
        变量 格式文本 <类型 = 文本型
                值 = "<IMAGE_OPTIONAL_HEADER32> 总共 31 个成员:\r\n1. Magic: %u\r\n2. MajorLinkerVersion: %u\r\n3. MinorLinkerVersion: %u\r\n4. SizeOfCode: %u\r\n5. SizeOfInitializedData: %u\r\n6. SizeOfUninitializedData: %u\r\n7. AddressOfEntryPoint: %u\r\n8. BaseOfCode: %u\r\n9. BaseOfData: %u\r\n10. ImageBase: %u\r\n11. SectionAlignment: %u\r\n12. FileAlignment: %u\r\n13. MajorOperatingSystemVersion: %u\r\n14. MinorOperatingSystemVersion: %u\r\n15. MajorImageVersion: %u\r\n16. MinorImageVersion: %u\r\n17. MajorSubsystemVersion: %u\r\n18. MinorSubsystemVersion: %u\r\n19. Win32VersionValue: %u\r\n20. SizeOfImage: %u\r\n21. SizeOfHeaders: %u\r\n22. CheckSum: %u\r\n23. Subsystem: %u\r\n24. DllCharacteristics: %u\r\n25. SizeOfStackReserve: %u\r\n26. SizeOfStackCommit: %u\r\n27. SizeOfHeapReserve: %u\r\n28. SizeOfHeapCommit: %u\r\n29. LoaderFlags: %u\r\n30. NumberOfRvaAndSizes: %u\r\n31. DataDirectory: IMAGE_DATA_DIRECTORY [16]">
        加入格式文本 (展示内容, 格式文本, 欲操作本对象.Magic, 欲操作本对象.MajorLinkerVersion, 欲操作本对象.MinorLinkerVersion, 欲操作本对象.SizeOfCode, 欲操作本对象.SizeOfInitializedData, 欲操作本对象.SizeOfUninitializedData, 欲操作本对象.AddressOfEntryPoint, 欲操作本对象.BaseOfCode, 欲操作本对象.BaseOfData, 欲操作本对象.ImageBase, 欲操作本对象.SectionAlignment, 欲操作本对象.FileAlignment, 欲操作本对象.MajorOperatingSystemVersion, 欲操作本对象.MinorOperatingSystemVersion, 欲操作本对象.MajorImageVersion, 欲操作本对象.MinorImageVersion, 欲操作本对象.MajorSubsystemVersion, 欲操作本对象.MinorSubsystemVersion, 欲操作本对象.Win32VersionValue, 欲操作本对象.SizeOfImage, 欲操作本对象.SizeOfHeaders, 欲操作本对象.CheckSum, 欲操作本对象.Subsystem, 欲操作本对象.DllCharacteristics, 欲操作本对象.SizeOfStackReserve, 欲操作本对象.SizeOfStackCommit, 欲操作本对象.SizeOfHeapReserve, 欲操作本对象.SizeOfHeapCommit, 欲操作本对象.LoaderFlags, 欲操作本对象.NumberOfRvaAndSizes)
        返回 (展示内容)
    }
}

类 IMAGE_OPTIONAL_HEADER64 <公开 基础类 = PIV结构模板 注释 = "64位PE文件可选头" 注释 = "" 折叠 折叠2
        @文档 = "category = \"PE文件操作.辅助类\"" @别名 = "IMAGE_OPTIONAL_HEADER64" @别名类型 = 本地结构
        @模板实现类 = "IMAGE_OPTIONAL_HEADER64">
{
    变量 Magic <公开 类型 = 短整数 注释 = "  映像文件类型" 注释 = "  IMAGE_NT_OPTIONAL_HDR32_MAGIC  0x10b  32位程序"
            注释 = "  IMAGE_NT_OPTIONAL_HDR64_MAGIC  0x20b  64位程序"
            注释 = "  IMAGE_ROM_OPTIONAL_HDR_MAGIC   0x107  ROM文件" @输出名 = "Magic">
    变量 MajorLinkerVersion <公开 类型 = 字节 注释 = "链接器的主版本号" @输出名 = "MajorLinkerVersion">
    变量 MinorLinkerVersion <公开 类型 = 字节 注释 = "链接器的副版本号" @输出名 = "MinorLinkerVersion">
    变量 SizeOfCode <公开 类型 = 整数 注释 = "可执行代码的大小,这些值(包括下面2个也是不可靠的,你可以通过查看可选头后面的各个\"节\"来获得更准确的大小."
            @输出名 = "SizeOfCode">
    变量 SizeOfInitializedData <公开 类型 = 整数 注释 = "已初始化数据的大小" @输出名 = "SizeOfInitializedData">
    变量 SizeOfUninitializedData <公开 类型 = 整数 注释 = "未初始化数据的大小,所谓的\"bss段\"" @输出名 = "SizeOfUninitializedData">
    变量 AddressOfEntryPoint <公开 类型 = 整数 注释 = "代码入口点的偏移量,RVA" @输出名 = "AddressOfEntryPoint">
    变量 BaseOfCode <公开 类型 = 整数 注释 = "代码基址,可执行代码的偏移值,RVA" @输出名 = "BaseOfCode">
    变量 ImageBase <公开 类型 = 长整数 注释 = "PE文件的优先装载地址,提供整个二进制文件包括所有头的优先(线性)载入地址,RVA" @输出名 = "ImageBase">
    变量 SectionAlignment <公开 类型 = 整数 注释 = "内存中节对齐的粒度" @输出名 = "SectionAlignment">
    变量 FileAlignment <公开 类型 = 整数 注释 = "文件中节对齐的粒度" @输出名 = "FileAlignment">
    变量 MajorOperatingSystemVersion <公开 类型 = 短整数 注释 = "主操作系统最低主版本号" @输出名 = "MajorOperatingSystemVersion">
    变量 MinorOperatingSystemVersion <公开 类型 = 短整数 注释 = "主操作系统最低副版本号" @输出名 = "MinorOperatingSystemVersion">
    变量 MajorImageVersion <公开 类型 = 短整数 注释 = "主映像文件版本" @输出名 = "MajorImageVersion">
    变量 MinorImageVersion <公开 类型 = 短整数 注释 = "副映像文件版本" @输出名 = "MinorImageVersion">
    变量 MajorSubsystemVersion <公开 类型 = 短整数 注释 = "主子系统版本" @输出名 = "MajorSubsystemVersion">
    变量 MinorSubsystemVersion <公开 类型 = 短整数 注释 = "副子系统版本" @输出名 = "MinorSubsystemVersion">
    变量 Win32VersionValue <公开 类型 = 整数 注释 = "Win32版本值,可能为0" @输出名 = "Win32VersionValue">
    变量 SizeOfImage <公开 类型 = 整数 注释 = "内存中整个PE映像体的尺寸.它是所有头和节经过节对齐处理后的大小." @输出名 = "SizeOfImage">
    变量 SizeOfHeaders <公开 类型 = 整数 注释 = "所有头+节表的大小,也就等于文件尺寸减去文件中所有节的尺寸.可以以此值作为PE文件第一节的文件偏移量."
            @输出名 = "SizeOfHeaders">
    变量 CheckSum <公开 类型 = 整数 注释 = "校验和" @输出名 = "CheckSum">
    变量 Subsystem <公开 类型 = 短整数 注释 = "  子系统,NT用来识别PE文件属于哪个子系统."
            注释 = "  IMAGE_SUBSYSTEM_WINDOWS_GUI  2  Windows graphical user interface (GUI) subsystem."
            注释 = "  IMAGE_SUBSYSTEM_WINDOWS_CUI  3  Windows character-mode user interface (CUI) subsystem."
            @输出名 = "Subsystem">
    变量 DllCharacteristics <公开 类型 = 短整数 注释 = "  DLL特性,指明,如果是DLL文件,何时调用DLL文件的入口点,一般不用"
            注释 = "  IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA       0x0020  Image can handle a high entropy 64-bit virtual address space."
            注释 = "  IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE          0x0040  DLL can move."
            注释 = "  IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY       0x0080  Code Integrity Image"
            注释 = "  IMAGE_DLLCHARACTERISTICS_NX_COMPAT             0x0100  Image is NX compatible"
            注释 = "  IMAGE_DLLCHARACTERISTICS_NO_ISOLATION          0x0200  Image understands isolation and doesn\'t want it"
            注释 = "  IMAGE_DLLCHARACTERISTICS_NO_SEH                0x0400  Image does not use SEH.No SE handler may reside in this image"
            注释 = "  IMAGE_DLLCHARACTERISTICS_NO_BIND               0x0800  Do not bind this image."
            注释 = "  IMAGE_DLLCHARACTERISTICS_APPCONTAINER          0x1000  Image should execute in an AppContainer"
            注释 = "  IMAGE_DLLCHARACTERISTICS_WDM_DRIVER            0x2000  Driver uses WDM model"
            注释 = "  IMAGE_DLLCHARACTERISTICS_GUARD_CF              0x4000  Image supports Control Flow Guard."
            注释 = "  IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE 0x8000" @输出名 = "DllCharacteristics">
    变量 SizeOfStackReserve <公开 类型 = 长整数 注释 = "保留栈的大小" @输出名 = "SizeOfStackReserve">
    变量 SizeOfStackCommit <公开 类型 = 长整数 注释 = "初始时指定栈大小" @输出名 = "SizeOfStackCommit">
    变量 SizeOfHeapReserve <公开 类型 = 长整数 注释 = "保留堆的大小" @输出名 = "SizeOfHeapReserve">
    变量 SizeOfHeapCommit <公开 类型 = 长整数 注释 = "指定堆大小" @输出名 = "SizeOfHeapCommit">
    变量 LoaderFlags <公开 类型 = 整数 注释 = "加载器标志" @输出名 = "LoaderFlags">
    变量 NumberOfRvaAndSizes <公开 类型 = 整数 注释 = "Rva数和大小" @输出名 = "NumberOfRvaAndSizes">
    变量 DataDirectory <公开 类型 = "IMAGE_DATA_DIRECTORY [16]"
            注释 = "  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];"
            注释 = "  映像文件数据目录,索引可选:" 注释 = "  IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table"
            注释 = "  IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory"
            注释 = " /IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)"
            注释 = "  IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data"
            注释 = "  IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP"
            注释 = "  IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers"
            注释 = "  IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table"
            注释 = "  IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors"
            注释 = "  IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor" @输出名 = "DataDirectory">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = IMAGE_OPTIONAL_HEADER64 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 展示内容 <类型 = 文本型>
        变量 格式文本 <类型 = 文本型
                值 = "<IMAGE_OPTIONAL_HEADER64> 总共 30 个成员:\r\n1. Magic: %u\r\n2. MajorLinkerVersion: %u\r\n3. MinorLinkerVersion: %u\r\n4. SizeOfCode: %u\r\n5. SizeOfInitializedData: %u\r\n6. SizeOfUninitializedData: %u\r\n7. AddressOfEntryPoint: %u\r\n8. BaseOfCode: %u\r\n9. ImageBase: %I64u\r\n10. SectionAlignment: %u\r\n11. FileAlignment: %u\r\n12. MajorOperatingSystemVersion: %u\r\n13. MinorOperatingSystemVersion: %u\r\n14. MajorImageVersion: %u\r\n15. MinorImageVersion: %u\r\n16. MajorSubsystemVersion: %u\r\n17. MinorSubsystemVersion: %u\r\n18. Win32VersionValue: %u\r\n19. SizeOfImage: %u\r\n20. SizeOfHeaders: %u\r\n21. CheckSum: %u\r\n22. Subsystem: %u\r\n23. DllCharacteristics: %u\r\n24. SizeOfStackReserve: %I64u\r\n25. SizeOfStackCommit: %I64u\r\n26. SizeOfHeapReserve: %I64u\r\n27. SizeOfHeapCommit: %I64u\r\n28. LoaderFlags: %u\r\n39. NumberOfRvaAndSizes: %u\r\n30. DataDirectory: IMAGE_DATA_DIRECTORY [16]">
        加入格式文本 (展示内容, 格式文本, 欲操作本对象.Magic, 欲操作本对象.MajorLinkerVersion, 欲操作本对象.MinorLinkerVersion, 欲操作本对象.SizeOfCode, 欲操作本对象.SizeOfInitializedData, 欲操作本对象.SizeOfUninitializedData, 欲操作本对象.AddressOfEntryPoint, 欲操作本对象.BaseOfCode, 欲操作本对象.ImageBase, 欲操作本对象.SectionAlignment, 欲操作本对象.FileAlignment, 欲操作本对象.MajorOperatingSystemVersion, 欲操作本对象.MinorOperatingSystemVersion, 欲操作本对象.MajorImageVersion, 欲操作本对象.MinorImageVersion, 欲操作本对象.MajorSubsystemVersion, 欲操作本对象.MinorSubsystemVersion, 欲操作本对象.Win32VersionValue, 欲操作本对象.SizeOfImage, 欲操作本对象.SizeOfHeaders, 欲操作本对象.CheckSum, 欲操作本对象.Subsystem, 欲操作本对象.DllCharacteristics, 欲操作本对象.SizeOfStackReserve, 欲操作本对象.SizeOfStackCommit, 欲操作本对象.SizeOfHeapReserve, 欲操作本对象.SizeOfHeapCommit, 欲操作本对象.LoaderFlags, 欲操作本对象.NumberOfRvaAndSizes)
        返回 (展示内容)
    }
}

类 IMAGE_NT_HEADERS32 <公开 基础类 = PIV结构模板 注释 = "32位PE文件NT头" 注释 = "" 折叠 折叠2
        @文档 = "category = \"PE文件操作.辅助类\"" @别名 = "IMAGE_NT_HEADERS32" @别名类型 = 本地结构
        @模板实现类 = "IMAGE_NT_HEADERS32">
{
    变量 Signature <公开 类型 = 整数 注释 = "PE文件的标识,固定为\"PE\\0\\0\"{50,45,00,00},整数为 0x4550/17744"
            注释 = "  IMAGE_DOS_SIGNATURE    0x5A4D      MZ" 注释 = "  IMAGE_OS2_SIGNATURE    0x454E      NE"
            注释 = "  IMAGE_OS2_SIGNATURE_LE 0x454C      LE" 注释 = "  IMAGE_VXD_SIGNATURE    0x454C      LE"
            注释 = "  IMAGE_NT_SIGNATURE     0x00004550  PE00" @输出名 = "Signature">
    变量 FileHeader <公开 类型 = IMAGE_FILE_HEADER 注释 = "映像文件头结构体(20个字节)" @输出名 = "FileHeader">
    变量 OptionalHeader <公开 类型 = IMAGE_OPTIONAL_HEADER32 注释 = "映像可选头结构体32位" @输出名 = "OptionalHeader">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = IMAGE_NT_HEADERS32 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 展示内容 <类型 = 文本型>
        加入格式文本 (展示内容, "<IMAGE_NT_HEADERS32> 总共 3 个成员:\r\n1. Signature: %u\r\n", 欲操作本对象.Signature)
        加入文本 (展示内容, "2. FileHeader:\r\n")
        加入多行文本 (展示内容, 欲操作本对象.FileHeader.取展示内容 (), 2)
        加入文本 (展示内容, "3. OptionalHeader:\r\n")
        加入多行文本 (展示内容, 欲操作本对象.OptionalHeader.取展示内容 (), 2)
        返回 (展示内容)
    }
}

类 IMAGE_NT_HEADERS64 <公开 基础类 = PIV结构模板 注释 = "64位PE文件NT头" 折叠 折叠2 @文档 = "category = \"PE文件操作.辅助类\""
        @别名 = "IMAGE_NT_HEADERS64" @别名类型 = 本地结构 @模板实现类 = "IMAGE_NT_HEADERS64">
{
    变量 Signature <公开 类型 = 整数 注释 = "  PE文件的标识,固定为\"PE\\0\\0\"{50,45,00,00},整数为 0x4550/17744"
            注释 = "  IMAGE_DOS_SIGNATURE    0x5A4D      MZ" 注释 = "  IMAGE_OS2_SIGNATURE    0x454E      NE"
            注释 = "  IMAGE_OS2_SIGNATURE_LE 0x454C      LE" 注释 = "  IMAGE_VXD_SIGNATURE    0x454C      LE"
            注释 = "  IMAGE_NT_SIGNATURE     0x00004550  PE00" @输出名 = "Signature">
    变量 FileHeader <公开 类型 = IMAGE_FILE_HEADER 注释 = "映像文件头部结构体(20个字节)" @输出名 = "FileHeader">
    变量 OptionalHeader <公开 类型 = IMAGE_OPTIONAL_HEADER64 注释 = "映像可选头部结构体64位" @输出名 = "OptionalHeader">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = IMAGE_NT_HEADERS64 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 展示内容 <类型 = 文本型>
        加入格式文本 (展示内容, "<IMAGE_NT_HEADERS64> 总共 3 个成员:\r\n1. Signature: %u\r\n", 欲操作本对象.Signature)
        加入文本 (展示内容, "2. FileHeader:\r\n")
        加入多行文本 (展示内容, 欲操作本对象.FileHeader.取展示内容 (), 2)
        加入文本 (展示内容, "3. OptionalHeader:\r\n")
        加入多行文本 (展示内容, 欲操作本对象.OptionalHeader.取展示内容 (), 2)
        返回 (展示内容)
    }
}

类 IMAGE_DATA_DIRECTORY <公开 基础类 = PIV结构模板 注释 = "PE文件数据目录" 折叠 折叠2 @文档 = "category = \"PE文件操作.辅助类\""
        @别名 = "IMAGE_DATA_DIRECTORY" @别名类型 = 本地结构 @模板实现类 = "IMAGE_DATA_DIRECTORY">
{
    变量 VirtualAddress <公开 类型 = 整数 注释 = "指向的数据结构的虚拟地址(RAV)" 折叠 @输出名 = "VirtualAddress">
    变量 Size <公开 类型 = 整数 注释 = "数据结构的大小" @输出名 = "Size">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用.">
    参数 欲操作本对象 <类型 = IMAGE_DATA_DIRECTORY 注释 = "用作填入本对象中所有数据的展示文本">
    {
        返回 (取格式文本 ("<IMAGE_DATA_DIRECTORY> 总共 2 个成员:\r\n1. VirtualAddress: %u\r\n2. Size: %u", 欲操作本对象.VirtualAddress, 欲操作本对象.Size))
    }
}

类 IMAGE_SECTION_HEADER <公开 基础类 = PIV结构模板 注释 = "PE文件的节区表" 折叠 折叠2 @文档 = "category = \"PE文件操作.辅助类\""
        @别名 = "IMAGE_SECTION_HEADER" @别名类型 = 本地结构 @模板实现类 = "IMAGE_SECTION_HEADER">
{
    变量 Name <公开 类型 = "字节 [8]" 注释 = "节名称" @输出名 = "Name">
    变量 PhysicalAddress <公开 类型 = 整数 注释 = "也可以是VirtualSize,在可执行文件中,它是内容的大小.在目标文件中,它是内容重定位到的地址."
            @输出名 = "Misc.PhysicalAddress">
    变量 VirtualSize <公开 类型 = 整数 注释 = "也可以是PhysicalAddress,在可执行文件中,它是内容的大小.在目标文件中,它是内容重定位到的地址."
            @输出名 = "Misc.VirtualSize">
    变量 VirtualAddress <公开 类型 = 整数 注释 = "节的RVA(相对虚拟地址)节中数据的RVA." @输出名 = "VirtualAddress">
    变量 SizeOfRawData <公开 类型 = 整数 注释 = "原始数据大小,经过文件对齐处理后节尺寸,PE装载器提取本值了解需映射入内存的节字节数." @输出名 = "SizeOfRawData">
    变量 PointerToRawData <公开 类型 = 整数 注释 = "文件偏移,这是节基于文件的偏移量,PE装载器通过本值找到节数据在文件中的位置."
            @输出名 = "PointerToRawData">
    变量 PointerToRelocations <公开 类型 = 整数 注释 = "重定位指针" @输出名 = "PointerToRelocations">
    变量 PointerToLinenumbers <公开 类型 = 整数 注释 = "行数指针" @输出名 = "PointerToLinenumbers">
    变量 NumberOfRelocations <公开 类型 = 短整数 注释 = "重定位数" @输出名 = "NumberOfRelocations">
    变量 NumberOfLinenumbers <公开 类型 = 短整数 注释 = "行数数" @输出名 = "NumberOfLinenumbers">
    变量 Characteristics <公开 类型 = 整数 注释 = "特性,包含标记以指示节属性,比如节是否含有可执行代码、初始化数据、未初始数据、是否可写、可读等."
            @输出名 = "Characteristics">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = IMAGE_SECTION_HEADER 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 展示内容 <类型 = 文本型>
        变量 格式文本 <类型 = 文本型
                值 = "<IMAGE_SECTION_HEADER> 总共 10 个成员:\r\n1. Name: %s\r\n2. VirtualSize: %u\r\n3. VirtualAddress: %u\r\n4. SizeOfRawData: %u\r\n5. PointerToRawData: %u\r\n6. PointerToRelocations: %u\r\n7. PointerToLinenumbers: %u\r\n8. NumberOfRelocations: %u\r\n9. NumberOfLinenumbers: %u\r\n10. Characteristics: %u">
        加入格式文本 (展示内容, 格式文本, 多字节指针到文本 (取数组变量地址 (欲操作本对象.Name)), 欲操作本对象.VirtualSize, 欲操作本对象.VirtualAddress, 欲操作本对象.SizeOfRawData, 欲操作本对象.PointerToRawData, 欲操作本对象.PointerToRelocations, 欲操作本对象.PointerToLinenumbers, 欲操作本对象.NumberOfRelocations, 欲操作本对象.NumberOfLinenumbers, 欲操作本对象.Characteristics)
        返回 (展示内容)
    }
}

类 节区表数组类 <公开 基础类 = PIV数组模板 注释 = "节区表数组" @文档 = "category = \"PE文件操作.辅助类\""
        @模板实现类 = "IMAGE_SECTION_HEADER">

类 IMAGE_IMPORT_DESCRIPTOR <公开 基础类 = PIV结构模板 注释 = "PE文件的导入表描述符结构体" 折叠 折叠2
        @文档 = "category = \"PE文件操作.辅助类\"" @别名 = "IMAGE_IMPORT_DESCRIPTOR" @别名类型 = 本地结构
        @模板实现类 = "IMAGE_IMPORT_DESCRIPTOR">
{
    变量 Characteristics <公开 类型 = 整数 注释 = "如果是数组的最后一项,则为0" @输出名 = "Characteristics">
    变量 OriginalFirstThunk <公开 类型 = 整数 注释 = "原始未绑定IAT(PIMAGE_THUNK_DATA)的相对虚拟地址"
            注释 = "由于存在单桥结构的DLL,最好别用该成员进程分析" @输出名 = "OriginalFirstThunk">
    变量 TimeDateStamp <公开 类型 = 整数 注释 = "文件创建时间戳" 注释 = "  0    未绑定导入表"
            注释 = "  -1   如果已绑定,真实的时间戳在IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT表中"
            注释 = "  其他 导入表已绑定,该时间戳与IMAGE_FILE_HEADER.TimeDateStamp一致" @输出名 = "TimeDateStamp">
    变量 ForwarderChain <公开 类型 = 短整数 注释 = "链表的前一结构" @输出名 = "ForwarderChain">
    变量 Name <公开 类型 = 整数 注释 = "模块的名称地址(ASCII字符串的RVA)" @输出名 = "Name">
    变量 FirstThunk <公开 类型 = 整数 注释 = "  导入表的IAT结构的相对虚拟地址" 注释 = "  绑定导入表后,该地址数组指向真实的函数地址(VA)"
            @输出名 = "FirstThunk">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = IMAGE_IMPORT_DESCRIPTOR 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 展示内容 <类型 = 文本型>
        变量 格式文本 <类型 = 文本型
                值 = "<IMAGE_IMPORT_DESCRIPTOR> 总共 5 个成员:\r\n1. OriginalFirstThunk: %u\r\n2. TimeDateStamp: %u\r\n3. ForwarderChain: %u\r\n4. Name: %u\r\n5. FirstThunk: %u">
        加入格式文本 (展示内容, 格式文本, 欲操作本对象.OriginalFirstThunk, 欲操作本对象.TimeDateStamp, 欲操作本对象.ForwarderChain, 欲操作本对象.Name, 欲操作本对象.FirstThunk)
        返回 (展示内容)
    }
}

类 导入表描述符数组类 <公开 基础类 = PIV数组模板 @文档 = "category = \"PE文件操作.辅助类\"" @模板实现类 = "IMAGE_IMPORT_DESCRIPTOR">

类 IMAGE_EXPORT_DIRECTORY <公开 基础类 = PIV结构模板 注释 = "PE文件的导出表结构体" 折叠 折叠2 @文档 = "category = \"PE文件操作.辅助类\""
        @别名 = "IMAGE_EXPORT_DIRECTORY" @别名类型 = 本地结构 @模板实现类 = "IMAGE_EXPORT_DIRECTORY">
{
    变量 Characteristics <公开 类型 = 整数 注释 = "未使用,总为0" @输出名 = "Characteristics">
    变量 TimeDateStamp <公开 类型 = 整数 注释 = "文件创建时间戳" @输出名 = "TimeDateStamp">
    变量 MajorVersion <公开 类型 = 短整数 注释 = "未使用,总为0" @输出名 = "MajorVersion">
    变量 MinorVersion <公开 类型 = 短整数 注释 = "未使用,总为0" @输出名 = "MinorVersion">
    变量 Name <公开 类型 = 整数 注释 = "模块的内部名称地址(UTF8编码字符串的RVA)" 注释 = "即使DLL文件的名称被修改,仍可以从这个字符串得知编译时的名称"
            @输出名 = "Name">
    变量 Base <公开 类型 = 整数 注释 = "函数的起始序号." 注释 = "比如一个函数的序号是4,Base是2,就表示该函数位于导出地址列表第三个成员."
            注释 = "导出地址列表中的首成员(索引0)对应序号1,而不是序号0." 注释 = "序号的起始数字可以在.DEF文件中定义." @输出名 = "Base">
    变量 NumberOfFunctions <公开 类型 = 整数 注释 = "导出函数的个数" @输出名 = "NumberOfFunctions">
    变量 NumberOfNames <公开 类型 = 整数 注释 = "以名称导出的函数的个数" @输出名 = "NumberOfNames">
    变量 AddressOfFunctions <公开 类型 = 整数 注释 = "导出地址列表(Export Address Table, EAT 其实就是一个地址数组)的首地址(RVA)"
            @输出名 = "AddressOfFunctions">
    变量 AddressOfNames <公开 类型 = 整数 注释 = "导出名称列表(Export Name Table, ENT)的首地址(RVA)" @输出名 = "AddressOfNames">
    变量 AddressOfNameOrdinals <公开 类型 = 整数 注释 = "导出序号列表(Export Ordinal Table, EOT)的首地址(RVA)"
            注释 = "该数组的元素都是16-bit(一个字)长度的整数." @输出名 = "AddressOfNameOrdinals">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = IMAGE_EXPORT_DIRECTORY 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 展示内容 <类型 = 文本型>
        变量 格式文本 <类型 = 文本型
                值 = "<IMAGE_EXPORT_DIRECTORY> 总共 11 个成员:\r\n1. Characteristics: %u\r\n2. TimeDateStamp: %u\r\n3. MajorVersion: %u\r\n4. MinorVersion: %u\r\n5. Name: %u\r\n6. Base: %u\r\n7. NumberOfFunctions: %u\r\n8. NumberOfNames: %u\r\n9. AddressOfFunctions: %u\r\n10. AddressOfNames: %u\r\n11. AddressOfNameOrdinals: %u">
        加入格式文本 (展示内容, 格式文本, 欲操作本对象.Characteristics, 欲操作本对象.TimeDateStamp, 欲操作本对象.MajorVersion, 欲操作本对象.MinorVersion, 欲操作本对象.Name, 欲操作本对象.Base, 欲操作本对象.NumberOfFunctions, 欲操作本对象.NumberOfNames, 欲操作本对象.AddressOfFunctions, 欲操作本对象.AddressOfNames, 欲操作本对象.AddressOfNameOrdinals)
        返回 (展示内容)
    }
}

类 PE函数类 <公开 基础类 = 扩展对象类 注释 = "PE文件导出表中的函数信息" 折叠 @文档 = "category = \"PE文件操作.辅助类\"">
{
    变量 函数名称 <公开 类型 = 文本型 @输出名 = "FunctionName">
    变量 函数地址 <公开 类型 = 长整数 @输出名 = "FunctionAddress">
    变量 函数序号 <公开 类型 = 整数 @输出名 = "FunctionOrdinal">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        加入格式文本 (展示内容, "<PE函数类> 总共 3 个成员:\r\n1. 函数名称: %s\r\n2. 函数地址: %I64u\r\n3. 函数序号: %u", 函数名称, 函数地址, 函数序号)
    }

    # @begin
    # <> <include>
    # @sn<current_class>(const CVolString& name, ULONGLONG address, DWORD ordinal) {
    #     FunctionName = name;
    #     FunctionAddress = static_cast<INT64>(address);
    #     FunctionOrdinal = static_cast<INT>(ordinal);
    # }
    # <> </include>
    # @end
}

类 PE函数数组类 <公开 基础类 = 对象动态数组模板 注释 = "PE文件导出表中的函数信息数组" @文档 = "category = \"PE文件操作.辅助类\"" @模板实现类 = "PE函数类">

类 导出表类 <公开 注释 = "导出表" 折叠 @文档 = "category = \"PE文件操作.辅助类\"">
{
    变量 模块名称 <公开 类型 = 文本型 @输出名 = "ModuleName">
    变量 函数列表 <公开 类型 = PE函数数组类 @输出名 = "aFunctions">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." @虚拟方法 = 可覆盖 @输出名 = "GetDumpString"
            @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<PE函数表类> 总共 2 个成员:\r\n"
        加入文本 (展示内容, "1. 模块名称: " + 取调试文本2 (最大展示数据尺寸, 模块名称) + "\r\n")
        加入文本 (展示内容, "2. 函数列表: " + 取调试文本2 (最大展示数据尺寸, 函数列表))
    }
}

类 导入表数组类 <公开 基础类 = 对象动态数组模板 注释 = "导入表数组" @文档 = "category = \"PE文件操作.辅助类\"" @模板实现类 = "导出表类">
