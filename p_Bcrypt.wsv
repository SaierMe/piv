<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "  提供密码学的加解密支持,封装自系统的 CNG API (Cryptography API: Next Generation),"
        注释 = "即下一代加密技术,其中有Bcrypt和Ncrypt两个家族." 注释 = "  Bcrypt主要用于临时性的加解密,而Ncrypt主要用于持久化的密钥存储(生成的密钥会存储在"
        注释 = "Windows的加密存储中),这里封装的是Bcrypt." 注释 = "  与OpenSSL相比,不需要附带额外的dll,但对系统版本有要求."
        注释 = "  - 桌面系统需要Windows Vista及更高版本." 注释 = "  - 服务器系统需要Windows Server 2008及更高版本."
        注释 = "  - 部分加密算法有更高的系统版本要求." @视窗.外部头文件 = "bcrypt.h" @视窗.外部库 = "Bcrypt.lib">

类 CNG加解密 <公开 注释 = "提供密码学的加解密支持" 折叠 @文档 = "category = \"CNG加解密\"" @禁止创建对象 = 真>
{

    # 对称加解密算法

    方法 对称加解密 <静态 类型 = 字节集类 注释 = "内部使用的对称加解密算法函数" 返回值注释 = "返回数据加解密后的原始结果,如果加解密失败将会返回空字节集." 折叠 @禁止流程检查 = 真>
    参数 类型 <类型 = 整数 注释 = "1=加密 2=解密">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加解密的数据">
    参数 密钥 <类型 = 字节集类 注释 = "提供加密所使用的密码" "">
    参数 算法类型 <类型 = CNG_算法类型 注释 = "使用的算法类型.\"CNG_算法类型.对称加密_\"">
    参数 密钥位 <类型 = 整数 注释 = "  请根据所提供的密码字节数选择,支持64,128,192,256" 注释 = "  密码位 = 字节长度 * 8">
    参数 密码链接模式 <类型 = CNG_链接模式 注释 = "\"CNG_链接模式\"">
    参数 填充方式 <类型 = CNG_填充方式 注释 = "\"CNG_填充方式.对称_\"">
    参数 初始向量 <类型 = 字节集类 @默认值 = 空对象>
    参数 向量大小 <类型 = 整数 @默认值 = 0>
    参数 预留参数1 <类型 = 整数 注释 = "预留的额外参数" @默认值 = 0>
    {
        @ BCRYPT_ALG_HANDLE phAlgorithm;
        @ BCRYPT_KEY_HANDLE phKey;
        @ NTSTATUS Status;
        @ @<类型> = GetClipValue ((INT)@<类型>, 1, 2);
        @ Status = ::BCryptOpenAlgorithmProvider (&phAlgorithm, (LPCWSTR)@<算法类型>.GetText (), NULL, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return CVolMem ();
        @ }
        @ // 设置算法属性
        @ Status = ::BCryptSetProperty ((BCRYPT_HANDLE)phAlgorithm, L"ChainingMode",
        @                               (PUCHAR)@<密码链接模式>.GetText (), (ULONG)@<密码链接模式>.GetLength () * 2 + 2, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        @ if (@<算法类型> == @<CNG_算法类型.对称加密_RC2>) { // RC2 设置密码位数
        @     Status = ::BCryptSetProperty ((BCRYPT_HANDLE)phAlgorithm, L"EffectiveKeyLength", (PUCHAR)&@<密钥位>, 4, 0);
        @     if (!BCRYPT_SUCCESS(Status)) {
        @         ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @         return CVolMem ();
        @     }
        @ }
        @ if (@<密码链接模式> == @<CNG_链接模式.CFB>) { // CFB 模式时设置位数(只支持8位和128位,1/8)
        @     Status = ::BCryptSetProperty ((BCRYPT_HANDLE)phAlgorithm, L"MessageBlockLength", (PUCHAR)&@<预留参数1>, 4, 0);
        @     if (!BCRYPT_SUCCESS(Status)) {
        @         ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @         return CVolMem ();
        @     }
        @ }
        // 获取块大小
        @ DWORD dwBlockLen, dwPropertySize;
        @ Status = ::BCryptGetProperty ((BCRYPT_HANDLE)phAlgorithm, L"BlockLength", (PUCHAR)&dwBlockLen, 4, &dwPropertySize, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        // 设置初始向量
        @ @an<CVolMem> IV = @<初始向量>;
        @ if (@<初始向量>.GetSize () > @<向量大小>)
        @     IV.RemoveToEnd (@<向量大小>);
        @ else
        @     IV.AddSpace (@<向量大小> - @<初始向量>.GetSize (), TRUE);
        @ // 生成密钥
        @ @an<CVolMem> Key = @<密钥>;
        @ if (@<密钥>.GetSize () > @<密钥位> / 8)
        @     Key.RemoveToEnd (@<密钥位> / 8);
        @ else
        @     Key.AddSpace (@<密钥位> / 8 - @<密钥>.GetSize (), TRUE);
        @ Status = ::BCryptGenerateSymmetricKey (phAlgorithm, &phKey, NULL, 0, (PUCHAR)Key.GetPtr (), (ULONG)Key.GetSize (), 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        @ @an<CVolMem> OutputData;
        @ DWORD dwDataLen; // 返回的数据长度
        @ ULONG dwFlag = (@<填充方式> < 0) ? 0 : (ULONG)@<填充方式>;
        @ if (@<类型> == 1) {
        // 加密
        @     // 处理数据对齐
        @     @an<CVolMem> InputData = @<数据>; // 欲加密的数据
        @     if (@<填充方式> == @<CNG_填充方式.对称_零填充>) // 用零字节填充,对齐数据
        @         InputData.AddSpace (dwBlockLen - ((DWORD)@<数据>.GetSize () % dwBlockLen), TRUE);
        @     // 获取加密后的长度
        @     Status = ::BCryptEncrypt (phKey, (PUCHAR)InputData.GetPtr (), (ULONG)InputData.GetSize (), NULL,
        @                               NULL, 0, OutputData.GetPtr (), NULL, &dwDataLen, dwFlag);
        @     if (!BCRYPT_SUCCESS(Status)) {
        @         ::BCryptDestroyKey (phKey);
        @         ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @         return CVolMem ();
        @     }
        @     OutputData.Alloc (dwDataLen, TRUE);
        @     // 获取加密后的数据
        @     Status = ::BCryptEncrypt (phKey, (PUCHAR)InputData.GetPtr (), (ULONG)InputData.GetSize (), NULL,
        @                               (@<初始向量>.IsNullObject ()) ? NULL : (PUCHAR)IV.GetPtr (), (@<初始向量>.IsNullObject ()) ? 0 : (ULONG)IV.GetSize (),
        @                               (PUCHAR)OutputData.GetPtr (), dwDataLen, &dwDataLen, dwFlag);
        @ } else {
        // 解密
        @     // 获取解密后的长度
        @     Status = ::BCryptDecrypt (phKey, (PUCHAR)@<数据>.GetPtr (), (ULONG)@<数据>.GetSize (), NULL,
        @                               NULL, 0, (PUCHAR)OutputData.GetPtr (), NULL, &dwDataLen, dwFlag);
        @     if (!BCRYPT_SUCCESS(Status)) {
        @         BCryptDestroyKey (phKey);
        @         BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @         return CVolMem ();
        @     }
        @     OutputData.Alloc (dwDataLen, TRUE);
        @     // 获取解密后的数据
        @     Status = ::BCryptDecrypt (phKey, (PUCHAR)@<数据>.GetPtr (), (ULONG)@<数据>.GetSize (), NULL,
        @                              (@<初始向量>.IsNullObject ()) ? NULL : (PUCHAR)IV.GetPtr (), (@<初始向量>.IsNullObject ()) ? 0 : (ULONG)IV.GetSize (),
        @                              (PUCHAR)OutputData.GetPtr (), dwDataLen, &dwDataLen, dwFlag);
        @ }
        @ ::BCryptDestroyKey (phKey);
        @ ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return CVolMem (); // 失败返回原数据
        @ }
        @ OutputData.RemoveToEnd (dwDataLen);
        @ return OutputData;
    }

    方法 对称加解密_GCM <静态 类型 = 字节集类 注释 = "内部使用的对称加解密算法函数,GCM模式专用." 返回值注释 = "返回数据加解密后的原始结果,如果加解密失败将会返回空字节集." 折叠
            @禁止流程检查 = 真>
    参数 类型 <类型 = 整数 注释 = "1=加密 2=解密">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加解密的数据">
    参数 密钥 <类型 = 字节集类 注释 = "提供加密所使用的密码" "">
    参数 算法类型 <类型 = CNG_算法类型 注释 = "使用的算法类型.\"CNG_算法类型.对称加密_\"">
    参数 密钥位 <类型 = 整数 注释 = "  请根据所提供的密码字节数选择,支持64,128,192,256" 注释 = "  密码位 = 字节长度 * 8">
    参数 密码链接模式 <类型 = CNG_链接模式 注释 = "\"CNG_链接模式\"">
    参数 填充方式 <类型 = CNG_填充方式 注释 = "\"CNG_填充方式.对称_\"">
    参数 初始向量 <类型 = 字节集类 @默认值 = 空对象>
    参数 向量大小 <类型 = 整数 @默认值 = 0>
    参数 预留参数1 <类型 = 整数 注释 = "预留的额外参数" @默认值 = 0>
    {
        @ BCRYPT_ALG_HANDLE phAlgorithm;
        @ BCRYPT_KEY_HANDLE phKey;
        @ NTSTATUS Status;
        @ @<类型> = GetClipValue ((INT)@<类型>, 1, 2);
        @ Status = ::BCryptOpenAlgorithmProvider (&phAlgorithm, (LPCWSTR)@<算法类型>.GetText (), NULL, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return CVolMem ();
        @ }
        @ // 设置算法属性
        @ Status = ::BCryptSetProperty ((BCRYPT_HANDLE)phAlgorithm, L"ChainingMode",
        @                               (PUCHAR)@<密码链接模式>.GetText (), (ULONG)@<密码链接模式>.GetLength () * 2 + 2, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        // 获取块大小
        @ DWORD dwBlockLen, dwPropertySize;
        @ Status = ::BCryptGetProperty ((BCRYPT_HANDLE)phAlgorithm, L"BlockLength", (PUCHAR)&dwBlockLen, 4, &dwPropertySize, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        @ // 获取属性(GCM)
        @ BCRYPT_AUTH_TAG_LENGTHS_STRUCT authTagLen;
        @ Status = ::BCryptGetProperty ((BCRYPT_HANDLE)phAlgorithm, L"AuthTagLength", (PUCHAR)&authTagLen, sizeof(authTagLen), &dwPropertySize, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        // 设置初始向量
        @ @an<CVolMem> IV = @<初始向量>;
        @ if (@<初始向量>.GetSize () > @<向量大小>)
        @     IV.RemoveToEnd (@<向量大小>);
        @ else
        @     IV.AddSpace (@<向量大小> - @<初始向量>.GetSize () , TRUE);
        @ // 生成密钥
        @ @an<CVolMem> Key = @<密钥>;
        @ if (@<密钥>.GetSize () > @<密钥位> / 8)
        @     Key.RemoveToEnd (@<密钥位> / 8);
        @ else
        @     Key.AddSpace (@<密钥位> / 8 - @<密钥>.GetSize () , TRUE);
        @ Status = ::BCryptGenerateSymmetricKey (phAlgorithm, &phKey, NULL, 0, (PUCHAR)Key.GetPtr (), (ULONG)Key.GetSize (), 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        @ @an<CVolMem> OutputData;
        @ DWORD dwDataLen; // 返回的数据长度
        @ BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO authInfo;
        @ // 自动授权结构体
        @ BCRYPT_INIT_AUTH_MODE_INFO (authInfo);
        @ @an<CVolMem> Tag;
        @ Tag.Alloc (authTagLen.dwMaxLength, FALSE);
        @ authInfo.pbNonce = (PUCHAR)IV.GetPtr ();
        @ authInfo.cbNonce = (ULONG)IV.GetSize ();
        @ authInfo.pbTag = (PUCHAR)Tag.GetPtr ();
        @ authInfo.cbTag = (ULONG)Tag.GetSize ();
        @ ULONG dwFlag = (@<填充方式> < 0) ? 0 : (ULONG)@<填充方式>;
        @ if (@<类型> == 1) {
        // 加密
        @     // 处理数据对齐
        @     @an<CVolMem> InputData = @<数据>; // 欲加密的数据
        @     if (@<填充方式> == @<CNG_填充方式.对称_零填充>) // 用零字节填充,对齐数据
        @         InputData.AddSpace (dwBlockLen - (DWORD)@<数据>.GetSize () % dwBlockLen , TRUE);
        @     // 获取加密后的长度
        @     Status = ::BCryptEncrypt (phKey, (PUCHAR)InputData.GetPtr (), (ULONG)InputData.GetSize (), &authInfo,
        @                               (@<初始向量>.IsNullObject ()) ? NULL : (PUCHAR)IV.GetPtr (), (@<初始向量>.IsNullObject ()) ? 0 : (ULONG)IV.GetSize (),
        @                               (PUCHAR)OutputData.GetPtr (), 0, &dwDataLen, dwFlag);
        @     if (!BCRYPT_SUCCESS(Status)) {
        @         ::BCryptDestroyKey (phKey);
        @         ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @         return CVolMem ();
        @     }
        @     OutputData.Alloc (dwDataLen, TRUE);
        @     // 获取加密后的数据
        @     Status = ::BCryptEncrypt (phKey, (PUCHAR)InputData.GetPtr (), (ULONG)InputData.GetSize (), &authInfo,
        @                               (@<初始向量>.IsNullObject ()) ? NULL : (PUCHAR)IV.GetPtr (), (@<初始向量>.IsNullObject ()) ? 0 : (ULONG)IV.GetSize (),
        @                               (PUCHAR)OutputData.GetPtr (), dwDataLen, &dwDataLen, dwFlag);
        @ } else // 解密
        @ {
        @     DWORD HalfSize = (DWORD)@<数据>.GetSize () / 2;
        @     OutputData.Alloc (@<数据>.GetSize (), TRUE);
        @     @an<CVolMem> macContext;
        @     macContext.Alloc (authTagLen.dwMaxLength, TRUE);
        @     authInfo.pbMacContext = (PUCHAR)macContext.GetPtr ();
        @     authInfo.cbMacContext = (ULONG)macContext.GetSize ();
        @     authInfo.dwFlags = BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG;
        @     // 第一次解密,每次一半
        @     Status = ::BCryptDecrypt (phKey, (PUCHAR)@<数据>.GetPtr (), HalfSize, &authInfo,
        @                               (@<初始向量>.IsNullObject ()) ? NULL : (PUCHAR)IV.GetPtr (), (@<初始向量>.IsNullObject ()) ? 0 : (ULONG)IV.GetSize (),
        @                               (PUCHAR)OutputData.GetPtr (), HalfSize, &dwDataLen, dwFlag);
        @     if (!BCRYPT_SUCCESS(Status)) {
        @         ::BCryptDestroyKey (phKey);
        @         ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @         return CVolMem ();
        @     }
        @     // 第二次解密,每次一半
        @     Status = ::BCryptDecrypt (phKey, (PUCHAR)@<数据>.GetPtr () + HalfSize, HalfSize,
        @                               (@<密码链接模式> == @<CNG_链接模式.GCM>)? &authInfo : NULL,
        @                               (@<初始向量>.IsNullObject ()) ? NULL : (PUCHAR)IV.GetPtr (), (@<初始向量>.IsNullObject ()) ? 0 : (ULONG)IV.GetSize (),
        @                               (PUCHAR)OutputData.GetPtr () + HalfSize, HalfSize, &dwDataLen, dwFlag);
        @ }
        @ ::BCryptDestroyKey (phKey);
        @ ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return CVolMem (); // 失败返回原数据
        @ }
        @ OutputData.RemoveToEnd (dwDataLen);
        @ return OutputData;
    }

    方法 加密_AES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(ECB模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_AES_ECB (数据, 文本到多字节 (密码, 假), 密钥位, 填充方式))
    }

    方法 加密_字节集_AES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(ECB模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, CNG_算法类型.对称加密_AES, 密钥位, CNG_链接模式.ECB, 填充方式))
    }

    方法 解密_AES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(ECB模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_AES_ECB (数据, 文本到多字节 (密码, 假), 密钥位, 填充方式))
    }

    方法 解密_字节集_AES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(ECB模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, CNG_算法类型.对称加密_AES, 密钥位, CNG_链接模式.ECB, 填充方式))
    }

    方法 加密_AES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(CBC模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_AES_CBC (数据, 文本到多字节 (密码, 假), 向量, 密钥位, 填充方式))
    }

    方法 加密_字节集_AES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(CBC模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据.">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256." @默认值 = 128>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, CNG_算法类型.对称加密_AES, 密钥位, CNG_链接模式.CBC, 填充方式, 向量, 16))
    }

    方法 解密_AES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(CBC模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_AES_CBC (数据, 文本到多字节 (密码, 假), 向量, 密钥位, 填充方式))
    }

    方法 解密_字节集_AES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(CBC模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, CNG_算法类型.对称加密_AES, 密钥位, CNG_链接模式.CBC, 填充方式, 向量, 16))
    }

    方法 加密_AES_CFB8 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(CFB-8位模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_AES_CFB8 (数据, 文本到多字节 (密码, 假), 向量, 密钥位, 填充方式))
    }

    方法 加密_字节集_AES_CFB8 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(CFB-8位模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, CNG_算法类型.对称加密_AES, 密钥位, CNG_链接模式.CFB, 填充方式, 向量, 16, 1))
    }

    方法 解密_AES_CFB8 <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(CFB-8位模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供解密所使用的密码,最大长度不能超过32.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_AES_CFB8 (数据, 文本到多字节 (密码, 假), 向量, 密钥位, 填充方式))
    }

    方法 解密_字节集_AES_CFB8 <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(CFB-8位模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, CNG_算法类型.对称加密_AES, 密钥位, CNG_链接模式.CFB, 填充方式, 向量, 16, 1))
    }

    方法 加密_AES_CFB128 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(CFB-128位模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_AES_CFB128 (数据, 文本到多字节 (密码, 假), 向量, 密钥位, 填充方式))
    }

    方法 加密_字节集_AES_CFB128 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(CFB-128位模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集."
            折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, CNG_算法类型.对称加密_AES, 密钥位, CNG_链接模式.CFB, 填充方式, 向量, 16, 16))
    }

    方法 解密_AES_CFB128 <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(CFB-128位模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_AES_CFB128 (数据, 文本到多字节 (密码, 假), 向量, 密钥位, 填充方式))
    }

    方法 解密_字节集_AES_CFB128 <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(CFB-128位模式)"
            返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供16字节." @默认值 = 空对象>
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, CNG_算法类型.对称加密_AES, 密钥位, CNG_链接模式.CFB, 填充方式, 向量, 16, 16))
    }

    方法 加密_AES_GCM <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(GCM模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供12字节.">
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    {
        返回 (加密_字节集_AES_GCM (数据, 文本到多字节 (密码, 假), 向量, 密钥位))
    }

    方法 加密_字节集_AES_GCM <公开 静态 类型 = 字节集类 注释 = "将指定数据进行AES加密(GCM模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供12字节.">
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    {
        返回 (对称加解密_GCM (1, 数据, 密码, CNG_算法类型.对称加密_AES, 密钥位, CNG_链接模式.GCM, CNG_填充方式.对称_零填充, 向量, 12))
    }

    方法 解密_AES_GCM <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(GCM模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供12字节.">
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    {
        返回 (解密_字节集_AES_GCM (数据, 文本到多字节 (密码, 假), 向量, 密钥位))
    }

    方法 解密_字节集_AES_GCM <公开 静态 类型 = 字节集类 注释 = "将指定AES加密的数据进行解密(GCM模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,请提供三种标准长度的密码,支持16,24,32">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供12字节.">
    参数 密钥位 <类型 = 整数 注释 = "请根据所提供的密码字节数选择,支持128,192,256" @默认值 = 128>
    {
        返回 (对称加解密_GCM (2, 数据, 密码, CNG_算法类型.对称加密_AES, 密钥位, CNG_链接模式.GCM, CNG_填充方式.对称_零填充, 向量, 12))
    }

    方法 加密_DES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DES加密(ECB模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_DES_ECB (数据, 文本到多字节 (密码, 假), 填充方式))
    }

    方法 加密_字节集_DES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DES加密(ECB模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, CNG_算法类型.对称加密_DES, 64, CNG_链接模式.ECB, 填充方式))
    }

    方法 解密_DES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定DES加密的数据进行解密(ECB模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_DES_ECB (数据, 文本到多字节 (密码, 假), 填充方式))
    }

    方法 解密_字节集_DES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定DES加密的数据进行解密(ECB模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, CNG_算法类型.对称加密_DES, 64, CNG_链接模式.ECB, 填充方式))
    }

    方法 加密_DES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DES加密(CBC模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_DES_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 加密_字节集_DES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DES加密(CBC模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, CNG_算法类型.对称加密_DES, 64, CNG_链接模式.CBC, 填充方式, 向量, 8))
    }

    方法 解密_DES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定DES加密的数据进行解密(CBC模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_DES_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 解密_字节集_DES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定DES加密的数据进行解密(CBC模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, CNG_算法类型.对称加密_DES, 64, CNG_链接模式.CBC, 填充方式, 向量, 8))
    }

    方法 加密_DES_CFB8 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DES加密(CFB-8位模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_DES_CFB8 (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 加密_字节集_DES_CFB8 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DES加密(CFB-8位模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, CNG_算法类型.对称加密_DES, 64, CNG_链接模式.CFB, 填充方式, 向量, 8, 1))
    }

    方法 解密_DES_CFB8 <公开 静态 类型 = 字节集类 注释 = "将指定DES加密的数据进行解密(CFB-8位模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_DES_CFB8 (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 解密_字节集_DES_CFB8 <公开 静态 类型 = 字节集类 注释 = "将指定DES加密的数据进行解密(CFB-8位模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, CNG_算法类型.对称加密_DES, 64, CNG_链接模式.CFB, 填充方式, 向量, 8, 1))
    }

    方法 加密_DES_CFB64 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DES加密(CFB-64位模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_DES_CFB64 (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 加密_字节集_DES_CFB64 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DES加密(CFB-64位模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集."
            折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, CNG_算法类型.对称加密_DES, 64, CNG_链接模式.CFB, 填充方式, 向量, 8, 8))
    }

    方法 解密_DES_CFB64 <公开 静态 类型 = 字节集类 注释 = "将指定DES加密的数据进行解密(CFB-64位模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_DES_CFB64 (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 解密_字节集_DES_CFB64 <公开 静态 类型 = 字节集类 注释 = "将指定DES加密的数据进行解密(CFB-64位模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集."
            折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, CNG_算法类型.对称加密_DES, 64, CNG_链接模式.CFB, 填充方式, 向量, 8, 8))
    }

    方法 加密_DESX_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DESX加密(CBC模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度24字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_DESX_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 加密_字节集_DESX_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DESX加密(CBC模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度24字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, CNG_算法类型.对称加密_DESX, 192, CNG_链接模式.CBC, 填充方式, 向量, 8))
    }

    方法 解密_DESX_CBC <公开 静态 类型 = 字节集类 注释 = "将指定DESX加密的数据进行解密(CBC模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度24字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_DESX_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 解密_字节集_DESX_CBC <公开 静态 类型 = 字节集类 注释 = "将指定DESX加密的数据进行解密(CBC模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度24字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, CNG_算法类型.对称加密_DESX, 192, CNG_链接模式.CBC, 填充方式, 向量, 8))
    }

    方法 加密_3DES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定数据进行3DES(ECB模式)加密,3DES即将DES算法进行三次(加密-解密-加密)计算."
            返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度24字节.">
    参数 高强度 <类型 = 逻辑型 注释 = "是否采用高强度方式加密,为真时加密过程中会采用三个不同密钥,为假时仅使用两个相同密钥." @默认值 = 真>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_3DES_ECB (数据, 文本到多字节 (密码, 假), 高强度, 填充方式))
    }

    方法 加密_字节集_3DES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定数据进行3DES(ECB模式)加密,3DES即将DES算法进行三次(加密-解密-加密)计算."
            返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 高强度 <类型 = 逻辑型 注释 = "是否采用高强度方式加密,为真时加密过程中会采用三个不同密钥,为假时仅使用两个相同密钥." @默认值 = 真>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, 选择 (高强度, CNG_算法类型.对称加密_3DES, CNG_算法类型.对称加密_3DES_112), 192, CNG_链接模式.ECB, 填充方式))
    }

    方法 解密_3DES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定3DES(ECB模式)加密的数据进行解密,3DES即将DES算法进行三次(加密-解密-加密)计算."
            返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度24字节.">
    参数 高强度 <类型 = 逻辑型 注释 = "是否采用高强度方式加密,为真时加密过程中会采用三个不同密钥,为假时仅使用两个相同密钥." @默认值 = 真>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_3DES_ECB (数据, 文本到多字节 (密码, 假), 高强度, 填充方式))
    }

    方法 解密_字节集_3DES_ECB <公开 静态 类型 = 字节集类 注释 = "将指定3DES(ECB模式)加密的数据进行解密,3DES即将DES算法进行三次(加密-解密-加密)计算."
            返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度24字节.">
    参数 高强度 <类型 = 逻辑型 注释 = "是否采用高强度方式加密,为真时加密过程中会采用三个不同密钥,为假时仅使用两个相同密钥." @默认值 = 真>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, 选择 (高强度, CNG_算法类型.对称加密_3DES, CNG_算法类型.对称加密_3DES_112), 192, CNG_链接模式.ECB, 填充方式))
    }

    方法 加密_3DES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行3DES(CBC模式)加密,3DES即将DES算法进行三次(加密-解密-加密)计算."
            返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度24字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 高强度 <类型 = 逻辑型 注释 = "是否采用高强度方式加密,为真时加密过程中会采用三个不同密钥,为假时仅使用两个相同密钥." @默认值 = 真>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_3DES_CBC (数据, 文本到多字节 (密码, 假), 向量, 高强度, 填充方式))
    }

    方法 加密_字节集_3DES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行3DES(CBC模式)加密,3DES即将DES算法进行三次(加密-解密-加密)计算."
            返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度24字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 高强度 <类型 = 逻辑型 注释 = "是否采用高强度方式加密,为真时加密过程中会采用三个不同密钥,为假时仅使用两个相同密钥." @默认值 = 真>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, 选择 (高强度, CNG_算法类型.对称加密_3DES, CNG_算法类型.对称加密_3DES_112), 192, CNG_链接模式.CBC, 填充方式, 向量, 8))
    }

    方法 解密_3DES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定3DES(CBC模式)加密的数据进行解密,3DES即将DES算法进行三次(加密-解密-加密)计算."
            返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度24字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 高强度 <类型 = 逻辑型 注释 = "是否采用高强度方式加密,为真时加密过程中会采用三个不同密钥,为假时仅使用两个相同密钥." @默认值 = 真>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_3DES_CBC (数据, 文本到多字节 (密码, 假), 向量, 高强度, 填充方式))
    }

    方法 解密_字节集_3DES_CBC <公开 静态 类型 = 字节集类 注释 = "将指定3DES(CBC模式)加密的数据进行解密,3DES即将DES算法进行三次(加密-解密-加密)计算."
            返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度24字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 高强度 <类型 = 逻辑型 注释 = "是否采用高强度方式加密,为真时加密过程中会采用三个不同密钥,为假时仅使用两个相同密钥." @默认值 = 真>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, 选择 (高强度, CNG_算法类型.对称加密_3DES, CNG_算法类型.对称加密_3DES_112), 192, CNG_链接模式.CBC, 填充方式, 向量, 8))
    }

    方法 加密_3DES_CFB8 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行3DES(CFB-8位模式)加密,3DES即将DES算法进行三次(加密-解密-加密)计算."
            返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度24字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 高强度 <类型 = 逻辑型 注释 = "是否采用高强度方式加密,为真时加密过程中会采用三个不同密钥,为假时仅使用两个相同密钥." @默认值 = 真>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_3DES_CFB8 (数据, 文本到多字节 (密码, 假), 向量, 高强度, 填充方式))
    }

    方法 加密_字节集_3DES_CFB8 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行3DES(CFB-8位模式)加密,3DES即将DES算法进行三次(加密-解密-加密)计算."
            返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 高强度 <类型 = 逻辑型 注释 = "是否采用高强度方式加密,为真时加密过程中会采用三个不同密钥,为假时仅使用两个相同密钥." @默认值 = 真>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, 选择 (高强度, CNG_算法类型.对称加密_3DES, CNG_算法类型.对称加密_3DES_112), 192, CNG_链接模式.CFB, 填充方式, 向量, 8, 1))
    }

    方法 解密_3DES_CFB8 <公开 静态 类型 = 字节集类 注释 = "将指定3DES(CFB-8位模式)加密的数据进行解密,3DES即将DES算法进行三次(加密-解密-加密)计算."
            返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度24字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 高强度 <类型 = 逻辑型 注释 = "是否采用高强度方式加密,为真时加密过程中会采用三个不同密钥,为假时仅使用两个相同密钥." @默认值 = 真>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_3DES_CFB8 (数据, 文本到多字节 (密码, 假), 向量, 高强度, 填充方式))
    }

    方法 解密_字节集_3DES_CFB8 <公开 静态 类型 = 字节集类 注释 = "将指定3DES(CFB-8位模式)加密的数据进行解密,3DES即将DES算法进行三次(加密-解密-加密)计算."
            返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度24字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 高强度 <类型 = 逻辑型 注释 = "是否采用高强度方式加密,为真时加密过程中会采用三个不同密钥,为假时仅使用两个相同密钥." @默认值 = 真>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, 选择 (高强度, CNG_算法类型.对称加密_3DES, CNG_算法类型.对称加密_3DES_112), 192, CNG_链接模式.CFB, 填充方式, 向量, 8, 1))
    }

    方法 加密_3DES_CFB64 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行3DES(CFB-64位模式)加密,3DES即将DES算法进行三次(加密-解密-加密)计算."
            返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度24字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 高强度 <类型 = 逻辑型 注释 = "是否采用高强度方式加密,为真时加密过程中会采用三个不同密钥,为假时仅使用两个相同密钥." @默认值 = 真>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_3DES_CFB64 (数据, 文本到多字节 (密码, 假), 向量, 高强度, 填充方式))
    }

    方法 加密_字节集_3DES_CFB64 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行3DES(CFB-64位模式)加密,3DES即将DES算法进行三次(加密-解密-加密)计算."
            返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 高强度 <类型 = 逻辑型 注释 = "是否采用高强度方式加密,为真时加密过程中会采用三个不同密钥,为假时仅使用两个相同密钥." @默认值 = 真>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, 选择 (高强度, CNG_算法类型.对称加密_3DES, CNG_算法类型.对称加密_3DES_112), 192, CNG_链接模式.CFB, 填充方式, 向量, 8, 8))
    }

    方法 解密_3DES_CFB64 <公开 静态 类型 = 字节集类 注释 = "将指定3DES(CFB-64位模式)加密的数据进行解密,3DES即将DES算法进行三次(加密-解密-加密)计算."
            返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度24字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 高强度 <类型 = 逻辑型 注释 = "是否采用高强度方式加密,为真时加密过程中会采用三个不同密钥,为假时仅使用两个相同密钥." @默认值 = 真>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_3DES_CFB64 (数据, 文本到多字节 (密码, 假), 向量, 高强度, 填充方式))
    }

    方法 解密_字节集_3DES_CFB64 <公开 静态 类型 = 字节集类 注释 = "将指定3DES(CFB-64位模式)加密的数据进行解密,3DES即将DES算法进行三次(加密-解密-加密)计算."
            返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度24字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 高强度 <类型 = 逻辑型 注释 = "是否采用高强度方式加密,为真时加密过程中会采用三个不同密钥,为假时仅使用两个相同密钥." @默认值 = 真>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, 选择 (高强度, CNG_算法类型.对称加密_3DES, CNG_算法类型.对称加密_3DES_112), 192, CNG_链接模式.CFB, 填充方式, 向量, 8, 8))
    }

    方法 加密_RC2_ECB <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC2加密(ECB模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度16字节.">
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_RC2_ECB (数据, 文本到多字节 (密码, 假), 填充方式))
    }

    方法 加密_字节集_RC2_ECB <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC2加密(ECB模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度16字节.">
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, CNG_算法类型.对称加密_RC2, 128, CNG_链接模式.ECB, 填充方式))
    }

    方法 解密_RC2_ECB <公开 静态 类型 = 字节集类 注释 = "将指定RC2加密的数据进行解密(ECB模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度16字节.">
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_RC2_ECB (数据, 文本到多字节 (密码, 假), 填充方式))
    }

    方法 解密_字节集_RC2_ECB <公开 静态 类型 = 字节集类 注释 = "将指定RC2加密的数据进行解密(ECB模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度16字节.">
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, CNG_算法类型.对称加密_RC2, 128, CNG_链接模式.ECB, 填充方式))
    }

    方法 加密_RC2_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC2加密(CBC模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度16字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_RC2_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 加密_字节集_RC2_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC2加密(CBC模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度16字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, CNG_算法类型.对称加密_RC2, 128, CNG_链接模式.CBC, 填充方式, 向量, 8))
    }

    方法 解密_RC2_CBC <公开 静态 类型 = 字节集类 注释 = "将指定RC2加密的数据进行解密(CBC模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度16字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_RC2_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 解密_字节集_RC2_CBC <公开 静态 类型 = 字节集类 注释 = "将指定RC2加密的数据进行解密(CBC模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度16字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, CNG_算法类型.对称加密_RC2, 128, CNG_链接模式.CBC, 填充方式, 向量, 8))
    }

    方法 加密_RC2_40_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC2(40位)加密(CBC模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度5字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_RC2_40_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 加密_字节集_RC2_40_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC2(40位)加密(CBC模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集."
            折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度5字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, CNG_算法类型.对称加密_RC2, 40, CNG_链接模式.CBC, 填充方式, 向量, 8))
    }

    方法 解密_RC2_40_CBC <公开 静态 类型 = 字节集类 注释 = "将指定RC2(40位)加密的数据进行解密(CBC模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度5字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_RC2_40_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 解密_字节集_RC2_40_CBC <公开 静态 类型 = 字节集类 注释 = "将指定RC2(40位)加密的数据进行解密(CBC模式)"
            返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度5字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, CNG_算法类型.对称加密_RC2, 40, CNG_链接模式.CBC, 填充方式, 向量, 8))
    }

    方法 加密_RC2_64_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC2(64位)加密(CBC模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_RC2_64_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 加密_字节集_RC2_64_CBC <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC2(64位)加密(CBC模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集."
            折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, CNG_算法类型.对称加密_RC2, 64, CNG_链接模式.CBC, 填充方式, 向量, 8))
    }

    方法 解密_RC2_64_CBC <公开 静态 类型 = 字节集类 注释 = "将指定RC2(64位)加密的数据进行解密(CBC模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_RC2_64_CBC (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 解密_字节集_RC2_64_CBC <公开 静态 类型 = 字节集类 注释 = "将指定RC2(64位)加密的数据进行解密(CBC模式)"
            返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度8字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, CNG_算法类型.对称加密_RC2, 64, CNG_链接模式.CBC, 填充方式, 向量, 8))
    }

    方法 加密_RC2_CFB64 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC2加密(CFB-64位模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度16字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (加密_字节集_RC2_CFB64 (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 加密_字节集_RC2_CFB64 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC2加密(CFB-64位模式)" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集."
            折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度16字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (1, 数据, 密码, CNG_算法类型.对称加密_RC2, 128, CNG_链接模式.CFB, 填充方式, 向量, 8, 8))
    }

    方法 解密_RC2_CFB64 <公开 静态 类型 = 字节集类 注释 = "将指定RC2加密的数据进行解密(CFB-64位模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度16字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (解密_字节集_RC2_CFB64 (数据, 文本到多字节 (密码, 假), 向量, 填充方式))
    }

    方法 解密_字节集_RC2_CFB64 <公开 静态 类型 = 字节集类 注释 = "将指定RC2加密的数据进行解密(CFB-64位模式)" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集."
            折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度16字节.">
    参数 向量 <类型 = 字节集类 注释 = "初始向量数据,最少要提供8字节." @默认值 = 空对象>
    参数 填充方式 <类型 = CNG_填充方式 注释 = "在提供的数据未对齐的情况下,所欲使用的填充方式." @默认值 = CNG_填充方式.对称_零填充>
    {
        返回 (对称加解密 (2, 数据, 密码, CNG_算法类型.对称加密_RC2, 128, CNG_链接模式.CFB, 填充方式, 向量, 8, 8))
    }

    方法 加密_RC4 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC4加密" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度16字节.">
    {
        返回 (加密_字节集_RC4 (数据, 文本到多字节 (密码, 假)))
    }

    方法 加密_字节集_RC4 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC4加密" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度16字节.">
    {
        返回 (对称加解密 (1, 数据, 密码, CNG_算法类型.对称加密_RC4, 128, CNG_链接模式.无, CNG_填充方式.对称_块填充))
    }

    方法 解密_RC4 <公开 静态 类型 = 字节集类 注释 = "将指定RC4加密的数据进行解密" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定长度16字节.">
    {
        返回 (解密_字节集_RC4 (数据, 文本到多字节 (密码, 假)))
    }

    方法 解密_字节集_RC4 <公开 静态 类型 = 字节集类 注释 = "将指定RC4加密的数据进行解密" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定长度16字节.">
    {
        返回 (对称加解密 (2, 数据, 密码, CNG_算法类型.对称加密_RC4, 128, CNG_链接模式.无, CNG_填充方式.对称_块填充))
    }

    方法 加密_RC4_40位 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC4(40位)加密" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定5字节.">
    {
        返回 (加密_字节集_RC4_40位 (数据, 文本到多字节 (密码, 假)))
    }

    方法 加密_字节集_RC4_40位 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RC4(40位)加密" 返回值注释 = "返回数据加密后的结果,加密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定5字节.">
    {
        返回 (对称加解密 (1, 数据, 密码, CNG_算法类型.对称加密_RC4, 40, CNG_链接模式.无, CNG_填充方式.对称_块填充))
    }

    方法 解密_RC4_40位 <公开 静态 类型 = 字节集类 注释 = "将指定RC4(40位)加密的数据进行解密" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 文本型 注释 = "提供加密所使用的密码,固定5字节.">
    {
        返回 (解密_字节集_RC4_40位 (数据, 文本到多字节 (密码, 假)))
    }

    方法 解密_字节集_RC4_40位 <公开 静态 类型 = 字节集类 注释 = "将指定RC4(40位)加密的数据进行解密" 返回值注释 = "返回解密后的结果,解密失败将返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供加密所使用的密码,固定5字节.">
    {
        返回 (对称加解密 (2, 数据, 密码, CNG_算法类型.对称加密_RC4, 40, CNG_链接模式.无, CNG_填充方式.对称_块填充))
    }

    # ===
    # 哈希算法/摘要算法

    方法 取数据Hash <静态 类型 = 字节集类 返回值注释 = "返回摘要计算后的结果" 折叠 @禁止流程检查 = 真>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 算法类型 <类型 = CNG_算法类型 注释 = "默认为MD5,其他参考\"CNG_算法类型.哈希_\"">
    参数 密码 <类型 = 字节集类 注释 = "提供所欲使用的密码内容" @默认值 = 空对象>
    {
        @ @an<CVolMem> HashData;
        @ BCRYPT_ALG_HANDLE phAlgorithm;
        @ BCRYPT_HASH_HANDLE phHash;
        @ NTSTATUS Status;
        @ if (@<密码>.IsNullObject ()) { // 无密码 Hash
        @     Status = ::BCryptOpenAlgorithmProvider (&phAlgorithm, (LPCWSTR)@<算法类型>.GetText (), NULL, 0);
        @     if (!BCRYPT_SUCCESS(Status)) {
        @         return CVolMem ();
        @     }
        @     Status = ::BCryptCreateHash (phAlgorithm, &phHash, NULL, NULL, NULL, 0, 0);
        @ } else { // 加密 Hash
        @     Status = ::BCryptOpenAlgorithmProvider (&phAlgorithm, (LPCWSTR)@<算法类型>.GetText (), NULL, BCRYPT_ALG_HANDLE_HMAC_FLAG);
        @     if (!BCRYPT_SUCCESS(Status)) {
        @         return CVolMem ();
        @     }
        @     Status = ::BCryptCreateHash (phAlgorithm, &phHash, NULL, NULL, (PUCHAR)@<密码>.GetPtr (), (ULONG)@<密码>.GetSize (), 0);
        @ }
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        @ Status = ::BCryptHashData (phHash, (PUCHAR)@<数据>.GetPtr (), (ULONG)@<数据>.GetSize (), 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptDestroyHash (phHash);
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        @ DWORD dwHashDigLen, dwPropertySize;
        @ Status = ::BCryptGetProperty (phAlgorithm, BCRYPT_HASH_LENGTH, (PUCHAR)&dwHashDigLen, 4, &dwPropertySize, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptDestroyHash (phHash);
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        @ HashData.Alloc ((INT)dwHashDigLen, TRUE);
        @ Status = ::BCryptFinishHash (phHash, (PUCHAR)HashData.GetPtr (), (ULONG)HashData.GetSize (), 0);
        @ ::BCryptDestroyHash (phHash);
        @ ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return CVolMem ();
        @ }
        @ return HashData;
    }

    方法 取数据MD5 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的MD5数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_MD5).字节集到十六进制文本 ())
    }

    方法 取数据MD5_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的MD5数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_MD5))
    }

    方法 取数据HMAC_MD5 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的HMAC-MD5数据摘要" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 文本型 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据HMAC_字节集_MD5 (数据, 文本到多字节 (密码, 假)))
    }

    方法 取数据HMAC_字节集_MD5 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的HMAC-MD5数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_MD5, 密码).字节集到十六进制文本 ())
    }

    方法 取数据HMAC_MD5_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的HMAC-MD5数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_MD5, 密码))
    }

    方法 取数据MD4 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的MD4数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_MD4).字节集到十六进制文本 ())
    }

    方法 取数据MD4_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的MD4数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_MD4))
    }

    方法 取数据HMAC_MD4 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的HMAC-MD4数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 文本型 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据HMAC_字节集_MD4 (数据, 文本到多字节 (密码, 假)))
    }

    方法 取数据HMAC_字节集_MD4 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的HMAC-MD4数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_MD4, 密码).字节集到十六进制文本 ())
    }

    方法 取数据HMAC_MD4_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的HMAC-MD4数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_MD4, 密码))
    }

    方法 取数据MD2 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的MD2数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_MD2).字节集到十六进制文本 ())
    }

    方法 取数据MD2_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的MD2数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_MD2))
    }

    方法 取数据HMAC_MD2 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的HMAC-MD2数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 文本型 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据HMAC_字节集_MD2 (数据, 文本到多字节 (密码, 假)))
    }

    方法 取数据HMAC_字节集_MD2 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的HMAC-MD2数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_MD2, 密码).字节集到十六进制文本 ())
    }

    方法 取数据HMAC_MD2_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的HMAC-MD2数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_MD2, 密码))
    }

    方法 取数据SHA1 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的SHA1数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_SHA1).字节集到十六进制文本 ())
    }

    方法 取数据SHA1_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的SHA1数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_SHA1))
    }

    方法 取数据HMAC_SHA1 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的HMAC-SHA1数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 文本型 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据HMAC_字节集_SHA1 (数据, 文本到多字节 (密码, 假)))
    }

    方法 取数据HMAC_字节集_SHA1 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的HMAC-SHA1数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_SHA1, 密码).字节集到十六进制文本 ())
    }

    方法 取数据HMAC_SHA1_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的HMAC-SHA1数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_SHA1, 密码))
    }

    方法 取数据SHA256 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的SHA256数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_SHA256).字节集到十六进制文本 ())
    }

    方法 取数据SHA256_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的SHA256数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_SHA256))
    }

    方法 取数据HMAC_SHA256 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的HMAC-SHA256数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 文本型 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据HMAC_字节集_SHA256 (数据, 文本到多字节 (密码, 假)))
    }

    方法 取数据HMAC_字节集_SHA256 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的HMAC-SHA256数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_SHA256, 密码).字节集到十六进制文本 ())
    }

    方法 取数据HMAC_SHA256_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的HMAC-SHA256数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_SHA256, 密码))
    }

    方法 取数据SHA384 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的SHA384数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_SHA384).字节集到十六进制文本 ())
    }

    方法 取数据SHA384_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的SHA384数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_SHA384))
    }

    方法 取数据HMAC_SHA384 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的HMAC-SHA384数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 文本型 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据HMAC_字节集_SHA384 (数据, 文本到多字节 (密码, 假)))
    }

    方法 取数据HMAC_字节集_SHA384 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的HMAC-SHA384数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_SHA384, 密码).字节集到十六进制文本 ())
    }

    方法 取数据HMAC_SHA384_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的HMAC-SHA384数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_SHA384, 密码))
    }

    方法 取数据SHA512 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的SHA512数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_SHA512).字节集到十六进制文本 ())
    }

    方法 取数据SHA512_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的SHA512数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_SHA512))
    }

    方法 取数据HMAC_SHA512 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的HMAC-SHA512数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 文本型 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据HMAC_字节集_SHA512 (数据, 文本到多字节 (密码, 假)))
    }

    方法 取数据HMAC_字节集_SHA512 <公开 静态 类型 = 文本型 注释 = "用作获取指定数据的HMAC-SHA512数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_SHA512, 密码).字节集到十六进制文本 ())
    }

    方法 取数据HMAC_SHA512_字节集 <公开 静态 类型 = 字节集类 注释 = "用作获取指定数据的HMAC-SHA512数据摘要" 返回值注释 = "返回摘要计算后的结果" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲计算摘要的数据">
    参数 密码 <类型 = 字节集类 注释 = "提供所欲使用的密码内容">
    {
        返回 (取数据Hash (数据, CNG_算法类型.哈希_SHA512, 密码))
    }

    # ===
    # 非对称加密

    方法 RSA加解密 <静态 类型 = 字节集类 注释 = "内部使用的非对称加解密算法函数" 返回值注释 = "返回数据加解密后的原始结果,如果加解密失败将会返回空字节集." 折叠 @禁止流程检查 = 真>
    参数 类型 <类型 = 整数 注释 = "1=加密 2=解密">
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加解密的数据">
    参数 密钥 <类型 = 字节集类 注释 = "提供加密所使用的密码" "">
    参数 算法类型 <类型 = CNG_算法类型>
    参数 密钥类型 <类型 = CNG_密钥类型>
    参数 填充方式 <类型 = CNG_填充方式>
    {
        @ if (@<密钥>.IsEmpty()) return CVolMem ();
        @ BCRYPT_ALG_HANDLE phAlgorithm;
        @ BCRYPT_KEY_HANDLE phKey;
        @ NTSTATUS Status;
        @ Status = ::BCryptOpenAlgorithmProvider (&phAlgorithm, @<算法类型>.GetText (), NULL, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return CVolMem ();
        @ }
        @ const WCHAR* keyType = @<密钥类型>.GetText ();
        @ if (@<算法类型>.compare (BCRYPT_RSA_ALGORITHM, TRUE) == 0) {
        @     switch (reinterpret_cast<BCRYPT_RSAKEY_BLOB*>(@<密钥>.GetPtr())->Magic) {
        @         case BCRYPT_RSAPUBLIC_MAGIC : keyType = BCRYPT_RSAPUBLIC_BLOB; break;
        @         case BCRYPT_RSAPRIVATE_MAGIC : keyType = BCRYPT_RSAPRIVATE_BLOB; break;
        @         case BCRYPT_RSAFULLPRIVATE_MAGIC : keyType = BCRYPT_RSAFULLPRIVATE_BLOB; break;
        @     }
        @ }
        // 导入密钥
        @ Status = ::BCryptImportKeyPair (phAlgorithm, NULL, keyType, &phKey,
        @                       (PUCHAR)@<密钥>.GetPtr (), (ULONG)@<密钥>.GetSize (), BCRYPT_NO_KEY_VALIDATION);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        @ @an<CVolMem> OutputData;
        @ DWORD dwDataLen; // 返回的数据长度
        @ if (@<类型> == 1) {
        // 加密
        @     // 获取加密后的长度
        @     Status = ::BCryptEncrypt (phKey, (PUCHAR)@<数据>.GetPtr (), (ULONG)@<数据>.GetSize (), NULL,
        @                               NULL, 0, NULL, 0, &dwDataLen, (ULONG)@<填充方式>);
        @     if (!BCRYPT_SUCCESS(Status)) {
        @         ::BCryptDestroyKey (phKey);
        @         ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @         return CVolMem ();
        @     }
        @     OutputData.Alloc (dwDataLen, TRUE);
        @     // 获取加密后的数据
        @     Status = ::BCryptEncrypt (phKey, (PUCHAR)@<数据>.GetPtr (), (ULONG)@<数据>.GetSize (), NULL,
        @                               NULL, 0, (PUCHAR)OutputData.GetPtr (), dwDataLen, &dwDataLen, (ULONG)@<填充方式>);
        @ } else {
        // 解密
        @     // 获取解密后的长度
        @     Status = ::BCryptDecrypt (phKey, (PUCHAR)@<数据>.GetPtr (), (ULONG)@<数据>.GetSize (), NULL,
        @                               NULL, 0, NULL, 0, &dwDataLen, (ULONG)@<填充方式>);
        @     if (!BCRYPT_SUCCESS(Status)) {
        @         ::BCryptDestroyKey (phKey);
        @         ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @         return CVolMem ();
        @     }
        @     OutputData.Alloc (dwDataLen, TRUE);
        @     // 获取解密后的数据
        @     Status = ::BCryptDecrypt (phKey, (PUCHAR)@<数据>.GetPtr (), (ULONG)@<数据>.GetSize (), NULL,
        @                               NULL, 0, (PUCHAR)OutputData.GetPtr (), dwDataLen, &dwDataLen, (ULONG)@<填充方式>);
        @ }
        @ ::BCryptDestroyKey (phKey);
        @ ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return CVolMem (); // 失败返回原数据
        @ }
        @ OutputData.RemoveToEnd (dwDataLen);
        @ return OutputData;
    }

    方法 加密_RSA_私钥 <公开 静态 类型 = 字节集类 注释 = "使用私钥对指定数据进行RSA加密" 返回值注释 = "成功返回加密后的数据,失败返回空字节集." 折叠 @禁止流程检查 = 真>
    参数 数据 <类型 = 字节集类 注释 = "  提供所欲加密的数据" 注释 = "  注意输入的数据长度,不能超过(密钥位/8-填充尺寸),例如生成密钥为2048位,"
            注释 = "无填充的情况下可加密256字节的数据.">
    参数 指定私钥 <类型 = 字节集类 注释 = "提供本次加密所欲使用的BLOB格式私钥数据">
    {
        返回 (RSA加解密 (1, 数据, 指定私钥, CNG_算法类型.公钥_RSA, CNG_密钥类型.RSA_完整私钥, CNG_填充方式.非对称_PKCS1))
    }

    方法 加密_RSA_公钥 <公开 静态 类型 = 字节集类 注释 = "使用公钥对指定数据进行RSA加密" 返回值注释 = "成功返回加密后的数据,失败返回空字节集." 折叠
            编辑时信息 = "12E4B, 0, 0, 0" @禁止流程检查 = 真>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲加密的数据" 注释 = "注意输入的数据长度,不能超过(密钥位/8-填充尺寸),例如生成密钥为2048位,无填充的情况下可加密256字节的数据."
            编辑时信息 = "12E4B, 0, 0, 0">
    参数 指定公钥 <类型 = 字节集类 注释 = "提供本次加密所欲使用的BLOB格式公钥数据" 编辑时信息 = "12E4B, 0, 0, 0">
    {
        返回 (RSA加解密 (1, 数据, 指定公钥, CNG_算法类型.公钥_RSA, CNG_密钥类型.RSA_公钥, CNG_填充方式.非对称_PKCS1))
    }

    方法 解密_RSA_私钥 <公开 静态 类型 = 字节集类 注释 = "使用私钥对指定RSA公钥/私钥加密的数据进行解密" 返回值注释 = "成功返回解密后的数据,失败返回空字节集" 折叠
            编辑时信息 = "11B3A, 0, 0, 0" @禁止流程检查 = 真>
    参数 数据 <类型 = 字节集类 注释 = "提供待解密的数据" 编辑时信息 = "11B3A, 0, 0, 0">
    参数 指定私钥 <类型 = 字节集类 注释 = "提供本次解密所欲使用的BLOB格式私钥数据" 编辑时信息 = "11B3A, 0, 0, 0">
    {
        返回 (RSA加解密 (2, 数据, 指定私钥, CNG_算法类型.公钥_RSA, CNG_密钥类型.RSA_完整私钥, CNG_填充方式.非对称_PKCS1))
    }

    方法 加密_RSA_PEM私钥 <公开 静态 类型 = 字节集类 注释 = "使用私钥对指定数据进行RSA加密." 注释 = "注: 本方法支持PKCS#1 PEM格式密钥."
            返回值注释 = "成功返回加密后的数据,失败返回空字节集." 折叠 @禁止流程检查 = 真>
    参数 数据 <类型 = 字节集类 注释 = "  提供所欲加密的数据." 注释 = "  注意输入的数据长度,不能超过(密钥位/8-填充尺寸),例如生成密钥为2048位,"
            注释 = "无填充的情况下可加密256字节的数据.">
    参数 PEM私钥 <类型 = 文本型 注释 = "提供本次加密所欲使用的PEM格式私钥,自动识别PKCS#1和PKCS#8版本.">
    {
        返回 (RSA加解密 (1, 数据, PEM密钥到BLOB (PEM私钥, 真), CNG_算法类型.公钥_RSA, CNG_密钥类型.RSA_完整私钥, CNG_填充方式.非对称_PKCS1))
    }

    方法 加密_RSA_PEM公钥 <公开 静态 类型 = 字节集类 注释 = "使用公钥对指定数据进行RSA加密." 注释 = "注: 本方法支持PKCS#1 PEM格式密钥."
            返回值注释 = "成功返回加密后的数据,失败返回空字节集." 折叠 @禁止流程检查 = 真>
    参数 数据 <类型 = 字节集类 注释 = "  提供所欲加密的数据." 注释 = "  注意输入的数据长度,不能超过(密钥位/8-填充尺寸),例如生成密钥为2048位,"
            注释 = "无填充的情况下可加密256字节的数据." 编辑时信息 = "12E4B, 0, 0, 0">
    参数 PEM公钥 <类型 = 文本型 注释 = "提供本次加密所欲使用的PEM格式公钥" 编辑时信息 = "12E4B, 0, 0, 0">
    {
        返回 (RSA加解密 (1, 数据, PEM密钥到BLOB (PEM公钥, 假), CNG_算法类型.公钥_RSA, CNG_密钥类型.RSA_公钥, CNG_填充方式.非对称_PKCS1))
    }

    方法 解密_RSA_PEM私钥 <公开 静态 类型 = 字节集类 注释 = "使用私钥对指定RSA公钥/私钥加密的数据进行解密." 注释 = "注: 本方法支持PKCS#1 PEM格式密钥."
            返回值注释 = "成功返回解密后的数据,失败返回空字节集." 折叠 @禁止流程检查 = 真>
    参数 数据 <类型 = 字节集类 注释 = "提供待解密的数据" 编辑时信息 = "11B3A, 0, 0, 0">
    参数 PEM私钥 <类型 = 文本型 注释 = "提供本次解密所欲使用的PEM格式私钥,自动识别PKCS#1和PKCS#8版本." 编辑时信息 = "11B3A, 0, 0, 0">
    {
        返回 (RSA加解密 (2, 数据, PEM密钥到BLOB (PEM私钥, 真), CNG_算法类型.公钥_RSA, CNG_密钥类型.RSA_完整私钥, CNG_填充方式.非对称_PKCS1))
    }

    # ===
    # 密钥对格式转换
    # 参考源码: https://github.com/xiangyuecn/RSA-csharp

    方法 PEM密钥到BLOB <公开 静态 类型 = 字节集类 注释 = "将PEM格式的RSA密钥转换为CNG加解密专用的BLOB格式,然后以字节集返回." 返回值注释 = "失败返回空字节集" 折叠>
    参数 PEM密钥 <类型 = 文本型 注释 = "所欲转换的PEM格式密钥,自动识别PKCS#1和PKCS#8版本.">
    参数 是否为私钥 <类型 = 逻辑型 注释 = "指定提供的密钥是否为私钥,否则为公钥." @默认值 = 真>
    {
        变量 DER <类型 = 字节集类>
        变量 位置 <类型 = 整数>
        位置 = 倒找文本 (PEM密钥, "-----END")
        如果 (位置 == -1)
        {
            DER = BASE64文本到字节集 (PEM密钥)
        }
        否则
        {
            变量 PEM <类型 = 文本型>
            PEM = 取文本左边 (PEM密钥, 位置)
            位置 = 倒找文本 (PEM, "-----")
            如果 (位置 != -1)
            {
                删除字符 (PEM, 0, 位置 + 5)

            }
            DER = BASE64文本到字节集 (PEM)

        }
        变量 BLOB <类型 = 字节集类>
        变量 长度占位 <类型 = 整数类>
        如果 (DER.取字节集长度 () <= 60 || DER.取字节集长度 () < _取DER长度 (DER, 1, 长度占位))
        {
            返回 (BLOB)

        }
        变量 索引 <类型 = 整数>
        变量 长度 <类型 = 整数>
        变量 PublicExp <类型 = 字节集类>
        变量 Modulus <类型 = 字节集类>
        如果 (是否为私钥)
        {
            变量 Prime1 <类型 = 字节集类>
            变量 Prime2 <类型 = 字节集类>
            变量 Exponent1 <类型 = 字节集类>
            变量 Exponent2 <类型 = 字节集类>
            变量 Coefficient <类型 = 字节集类>
            变量 PrivateExponent <类型 = 字节集类>
            索引 = 长度占位.值 + 4  // 判断是否KCS#8
            如果 (DER.取字节集数据 (索引, 字节) == 0x30)
            {
                // 跳过固定内容和后续内容长度1
                索引 = 索引 + 长度占位.值 + 15
                长度 = _取DER长度 (DER, 索引, 长度占位)
                // 跳过后续内容长度2
                索引 = 索引 + 长度占位.值 + 1
                长度 = _取DER长度 (DER, 索引, 长度占位)
                // 跳过固定版本号
                索引 = 索引 + 长度占位.值 + 4  // Modulus
            }
            否则
            {
                索引 = 索引 + 1  // Modulus

            }
            长度 = _取DER长度 (DER, 索引, 长度占位)
            Modulus = DER.取字节集中间 (索引 + 长度占位.值, 长度)
            // PublicExp
            索引 = 索引 + 长度占位.值 + 长度 + 1
            长度 = _取DER长度 (DER, 索引, 长度占位)
            PublicExp = DER.取字节集中间 (索引 + 长度占位.值, 长度)
            // PrivateExponent
            索引 = 索引 + 长度占位.值 + 长度 + 1
            长度 = _取DER长度 (DER, 索引, 长度占位)
            PrivateExponent = DER.取字节集中间 (索引 + 长度占位.值, 长度)
            // Prime1
            索引 = 索引 + 长度占位.值 + 长度 + 1
            长度 = _取DER长度 (DER, 索引, 长度占位)
            Prime1 = DER.取字节集中间 (索引 + 长度占位.值, 长度)
            // Prime2
            索引 = 索引 + 长度占位.值 + 长度 + 1
            长度 = _取DER长度 (DER, 索引, 长度占位)
            Prime2 = DER.取字节集中间 (索引 + 长度占位.值, 长度)
            // Exponent1
            索引 = 索引 + 长度占位.值 + 长度 + 1
            长度 = _取DER长度 (DER, 索引, 长度占位)
            Exponent1 = DER.取字节集中间 (索引 + 长度占位.值, 长度)
            // Exponent2
            索引 = 索引 + 长度占位.值 + 长度 + 1
            长度 = _取DER长度 (DER, 索引, 长度占位)
            Exponent2 = DER.取字节集中间 (索引 + 长度占位.值, 长度)
            // Coefficient
            索引 = 索引 + 长度占位.值 + 长度 + 1
            长度 = _取DER长度 (DER, 索引, 长度占位)
            Coefficient = DER.取字节集中间 (索引 + 长度占位.值, 长度)
            // 移除首部的零字节
            如果 (Modulus.取字节集数据 (0, 字节) == 0)
            {
                Modulus.字节集删除 (0, 1)
            }
            如果 (PublicExp.取字节集数据 (0, 字节) == 0)
            {
                PublicExp.字节集删除 (0, 1)
            }
            如果 (Prime1.取字节集数据 (0, 字节) == 0)
            {
                Prime1.字节集删除 (0, 1)
            }
            如果 (Prime2.取字节集数据 (0, 字节) == 0)
            {
                Prime2.字节集删除 (0, 1)
            }
            如果 (Exponent1.取字节集数据 (0, 字节) == 0)
            {
                Exponent1.字节集删除 (0, 1)
            }
            如果 (Exponent2.取字节集数据 (0, 字节) == 0)
            {
                Exponent2.字节集删除 (0, 1)
            }
            如果 (Coefficient.取字节集数据 (0, 字节) == 0)
            {
                Coefficient.字节集删除 (0, 1)
            }
            如果 (PrivateExponent.取字节集数据 (0, 字节) == 0)
            {
                PrivateExponent.字节集删除 (0, 1)
            }
            // 组装BCRYPT_RSAKEY_BLOB
            BLOB.添加值到字节集 ((整数)0x33415352)  // Magic
            BLOB.添加值到字节集 (Modulus.取字节集长度 () * 8)  // BitLength
            BLOB.添加值到字节集 (PublicExp.取字节集长度 ())  // cbPublicExp
            BLOB.添加值到字节集 (Modulus.取字节集长度 ())  // cbModulus
            BLOB.添加值到字节集 (Prime1.取字节集长度 ())  // cbPrime1
            BLOB.添加值到字节集 (Prime2.取字节集长度 ())  // cbPrime2
            BLOB.添加字节集 (PublicExp)  // PublicExponent[cbPublicExp]
            BLOB.添加字节集 (Modulus)  // Modulus[cbModulus]
            BLOB.添加字节集 (Prime1)  // Prime1[cbPrime1]
            BLOB.添加字节集 (Prime2)  // Prime2[cbPrime2]
            BLOB.添加字节集 (Exponent1)  // Exponent1[cbPrime1]
            BLOB.添加字节集 (Exponent2)  // Exponent2[cbPrime2]
            BLOB.添加字节集 (Coefficient)  // Coefficient[cbPrime1]
            BLOB.添加字节集 (PrivateExponent)  // PrivateExponent[cbModulus]

        }
        否则
        {
            如果 (DER.取字节集数据 (长度占位.值 + 1, 字节) != 0x02)
            {
                // 第一个后续内容长度
                索引 = 长度占位.值 + 17
                _取DER长度 (DER, 索引, 长度占位)
                // 第二个后续内容长度
                索引 = 索引 + 长度占位.值 + 2
                _取DER长度 (DER, 索引, 长度占位)
                索引 = 索引 + 长度占位.值 + 1  // Modulus
            }
            否则
            {
                索引 = 长度占位.值 + 2  // Modulus

            }
            // Modulus
            长度 = _取DER长度 (DER, 索引, 长度占位)
            Modulus = DER.取字节集中间 (索引 + 长度占位.值, 长度)
            // PublicExp 位置
            索引 = 索引 + 长度占位.值 + 长度 + 1
            长度 = _取DER长度 (DER, 索引, 长度占位)
            PublicExp = DER.取字节集中间 (索引 + 长度占位.值, 长度)
            如果 (Modulus.取字节集数据 (0, 字节) == 0)
            {
                Modulus.字节集删除 (0, 1)

            }
            如果 (PublicExp.取字节集数据 (0, 字节) == 0)
            {
                PublicExp.字节集删除 (0, 1)

            }
            // 组装BCRYPT_RSAKEY_BLOB
            BLOB.添加值到字节集 ((整数)0x31415352)  // Magic
            BLOB.添加值到字节集 (Modulus.取字节集长度 () * 8)  // BitLength
            BLOB.添加值到字节集 (PublicExp.取字节集长度 ())  // cbPublicExp
            BLOB.添加值到字节集 (Modulus.取字节集长度 ())  // cbModulus
            BLOB.添加值到字节集 (0)  // cbPrime1
            BLOB.添加值到字节集 (0)  // cbPrime2
            BLOB.添加字节集 (PublicExp)  // PublicExponent[cbPublicExp]
            BLOB.添加字节集 (Modulus)  // Modulus[cbModulus]

        }
        返回 (BLOB)
    }

    方法 BLOB密钥到PEM <公开 静态 类型 = 文本型 注释 = "将CNG加解密专用的BLOB格式RSA密钥,转换为通用的PEM格式文本." 返回值注释 = "失败返回空文本" 折叠>
    参数 BLOB密钥 <类型 = 字节集类 注释 = "  所欲转换的BCRYPT_RSAKEY_BLOB密钥,可以自动识别出是私钥还是公钥."
            注释 = "  不完整的私钥不能转换到PEM,请在\"生成密钥对_RSA\"时,将\"是否为完整私钥\"设置为真.">
    参数 添加PEM头 <类型 = 逻辑型 注释 = "指定是否在首尾加上PEM格式,比如\"-----BEGIN PUBLIC KEY-----\"" @默认值 = 真>
    参数 PKCS8格式 <类型 = 逻辑型 注释 = "指定是否以PKCS#8格式返回私钥PEM,否则为PKCS#1." @默认值 = 假>
    {
        如果 (BLOB密钥.取字节集长度 () < 24)
        {
            返回 ("")

        }
        变量 PEM <类型 = 文本型>
        变量 cbPublicExp <类型 = 整数>
        变量 cbModulus <类型 = 整数>
        变量 DER <类型 = 字节集类>
        变量 临时数据 <类型 = 字节集类>
        cbPublicExp = BLOB密钥.取字节集数据 (8, 整数)
        cbModulus = BLOB密钥.取字节集数据 (12, 整数)
        如果 (BLOB密钥.取字节集数据 (0, 整数) == 0x31415352)  // 公钥
        {
            如果 (BLOB密钥.取字节集长度 () < 24 + cbPublicExp + cbModulus)
            {
                返回 ("")

            }
            // Modulus
            _添加DER内容 (DER, 0x02, cbModulus, BLOB密钥.取字节集中间 (24 + cbPublicExp, cbModulus))
            // PubicExponent
            _添加DER内容 (DER, 0x02, cbPublicExp, BLOB密钥.取字节集中间 (24, cbPublicExp))
            如果 (PKCS8格式 == 真)
            {
                // 后续内容长度
                _添加DER内容 (临时数据, 0x30, DER.取字节集长度 ())
                DER.插入字节集 (0, 临时数据)
                临时数据.清空字节集 ()
                // 后续内容长度
                _添加DER内容 (临时数据, 0x03, DER.取字节集长度 ())
                DER.插入字节集 (0, 临时数据)
                临时数据.清空字节集 ()
                // 固定内容 encoded OID sequence for PKCS #1 rsaEncryption szOID_RSA_RSA = "1.2.840.113549.1.1.1"
                DER.插入字节集 (0, 十六进制文本到字节集 ("300D06092A864886F70D0101010500"))

            }
            // SEQUENCE
            _添加DER内容 (临时数据, 0x30, DER.取字节集长度 ())
            DER.插入字节集 (0, 临时数据)
            如果 (添加PEM头)
            {
                加入文本 (PEM, "-----BEGIN PUBLIC KEY-----\n")

            }
            加入文本 (PEM, DER.字节集到BASE64文本 (, 64))
            如果 (添加PEM头)
            {
                加入文本 (PEM, "\n-----END PUBLIC KEY-----\n")

            }

        }
        否则 (BLOB密钥.取字节集数据 (0, 整数) == 0x33415352)  // 完整私钥
        {
            变量 cbPrime1 <类型 = 整数>
            变量 cbPrime2 <类型 = 整数>
            cbPrime1 = BLOB密钥.取字节集数据 (16, 整数)
            cbPrime2 = BLOB密钥.取字节集数据 (20, 整数)
            如果 (BLOB密钥.取字节集长度 () < 24 + cbPublicExp + cbModulus * 2 + cbPrime1 * 3 + cbPrime2 * 2)
            {
                返回 ("")

            }
            // Modulus
            _添加DER内容 (DER, 0x02, cbModulus, BLOB密钥.取字节集中间 (24 + cbPublicExp, cbModulus))
            // PubicExponent
            _添加DER内容 (DER, 0x02, cbPublicExp, BLOB密钥.取字节集中间 (24, cbPublicExp))
            // PrivateExponent
            _添加DER内容 (DER, 0x02, cbModulus, BLOB密钥.取字节集中间 (24 + cbPublicExp + cbModulus + cbPrime1 * 3 + cbPrime2 * 2, cbModulus))
            // Prime1
            _添加DER内容 (DER, 0x02, cbPrime1, BLOB密钥.取字节集中间 (24 + cbPublicExp + cbModulus, cbPrime1))
            // Prime2
            _添加DER内容 (DER, 0x02, cbPrime2, BLOB密钥.取字节集中间 (24 + cbPublicExp + cbModulus + cbPrime1, cbPrime2))
            // Exponent1
            _添加DER内容 (DER, 0x02, cbPrime1, BLOB密钥.取字节集中间 (24 + cbPublicExp + cbModulus + cbPrime1 + cbPrime2, cbPrime1))
            // Exponent2
            _添加DER内容 (DER, 0x02, cbPrime2, BLOB密钥.取字节集中间 (24 + cbPublicExp + cbModulus + cbPrime1 * 2 + cbPrime2, cbPrime2))
            // Coefficient
            _添加DER内容 (DER, 0x02, cbPrime1, BLOB密钥.取字节集中间 (24 + cbPublicExp + cbModulus + cbPrime1 * 2 + cbPrime2 * 2, cbPrime1))
            如果 (PKCS8格式 == 真)
            {
                // 固定版本号
                DER.插入字节集 (0, 创建字节集 (0x02, 0x01, 0x00))
                // 后续内容长度
                _添加DER内容 (临时数据, 0x30, DER.取字节集长度 ())
                DER.插入字节集 (0, 临时数据)
                临时数据.清空字节集 ()
                // 后续内容长度
                _添加DER内容 (临时数据, 0x04, DER.取字节集长度 ())
                DER.插入字节集 (0, 临时数据)
                临时数据.清空字节集 ()
                // 固定内容 encoded OID sequence for PKCS #1 rsaEncryption szOID_RSA_RSA = "1.2.840.113549.1.1.1"
                DER.插入字节集 (0, 十六进制文本到字节集 ("300D06092A864886F70D0101010500"))

            }
            // 固定版本号
            DER.插入字节集 (0, 创建字节集 (0x02, 0x01, 0x00))
            // SEQUENCE
            _添加DER内容 (临时数据, 0x30, DER.取字节集长度 ())
            DER.插入字节集 (0, 临时数据)
            临时数据.清空字节集 ()
            如果 (添加PEM头)
            {
                加入文本 (PEM, "-----BEGIN PRIVATE KEY-----\n")

            }
            加入文本 (PEM, DER.字节集到BASE64文本 (, 64))
            如果 (添加PEM头)
            {
                加入文本 (PEM, "\n-----END PRIVATE KEY-----\n")

            }
        }
        否则 (BLOB密钥.取字节集数据 (0, 整数) == 0x32415352)  // 私钥
        {
            // 不完整的私钥无法导出PEM
            返回 ("")

        }
        子文本替换 (PEM, "", "")
        返回 (PEM)
    }

    方法 _取DER长度 <静态 类型 = 整数 注释 = "内部函数" 折叠>
    参数 所欲操作字节集 <类型 = 字节集类>
    参数 位置 <类型 = 整数>
    参数 长度占位 <类型 = 整数类 @默认值 = 空对象>
    {
        变量 长度 <类型 = 整数>
        长度 = 无符号字节到整数 (所欲操作字节集.取字节集数据 (位置, 字节))
        如果 (长度 < 0x80)
        {
            长度占位.值 = 1
            返回 (长度)
        }
        否则 (长度 == 0x81)
        {
            长度 = 无符号字节到整数 (所欲操作字节集.取字节集数据 (位置 + 1, 字节))
            长度占位.值 = 2
            返回 (长度)
        }
        否则 (长度 == 0x82)
        {
            长度 = 无符号短整数到整数 (_反转短整数字节序 (所欲操作字节集.取字节集数据 (位置 + 1, 短整数)))
            长度占位.值 = 3
            返回 (长度)

        }
        返回 (0)
    }

    方法 _添加DER内容 <静态 注释 = "内部函数" 折叠>
    参数 所欲操作字节集 <类型 = 字节集类>
    参数 类型 <类型 = 字节>
    参数 内容长度 <类型 = 整数>
    参数 内容 <类型 = 字节集类 @默认值 = 空对象>
    {
        如果 (内容.字节集是否为空 () == 假)
        {
            如果 (类型 == 0x02 && 位右移 (无符号字节到整数 (内容.取字节集数据 (0, 字节)), 4) >= 8)
            {
                内容.插入值到字节集 (0, (字节)0x00)
                内容长度 = 内容长度 + 1

            }

        }
        如果 (内容长度 < 0x80)
        {
            所欲操作字节集.添加字节集内容 (类型, 内容长度)
        }
        否则 (内容长度 > 0xFF)
        {
            所欲操作字节集.添加字节集内容 (类型, 0x82)
            所欲操作字节集.添加值到字节集 (_反转短整数字节序 ((短整数)内容长度))
        }
        否则
        {
            所欲操作字节集.添加字节集内容 (类型, 0x81, 内容长度)

        }
        如果 (类型 == 0x03)
        {
            所欲操作字节集.添加字节集内容 (0x00)

        }
        如果 (内容.字节集是否为空 () == 假)
        {
            所欲操作字节集.添加字节集 (内容)

        }

    }

    方法 _反转短整数字节序 <静态 类型 = 短整数 注释 = "  将所指定整数的组成字节的顺序反转,返回反转后的结果值.譬如十六进制整数0x12345678,"
            注释 = "反转后将返回0x78563412. 本命令在与类似Java这样的语言进行数据交互时很有用处." 折叠 @禁止流程检查 = 真>
    参数 所欲反转的短整数 <类型 = 短整数>
    {
        @ WORD wResult = ((@<所欲反转的短整数> & 0x00FF) << 8);
        @ wResult |= ((@<所欲反转的短整数> & 0xFF00) >> 8);
        @ return (SHORT)wResult;
    }

    # ===
    # 非对称加密-生成密钥对

    方法 生成密钥对 <静态 类型 = 逻辑型 注释 = "随机生成一个新的密钥对,包含私钥以及公钥." 返回值注释 = "返回密钥对是否生成成功" 折叠 @禁止流程检查 = 真>
    参数 公钥数据 <类型 = 字节集类 注释 = "返回公钥数据">
    参数 私钥数据 <类型 = 字节集类 注释 = "返回私钥数据">
    参数 密钥位 <类型 = 整数 注释 = "生成密钥对使用的位数,不同算法对密钥大小的要求不同">
    参数 算法类型 <类型 = CNG_算法类型 注释 = "请使用\"CNG_算法类型.公钥_RSA\"或使用\"CNG_算法类型.密钥交换_\"" "">
    参数 公钥类型 <类型 = CNG_密钥类型>
    参数 私钥类型 <类型 = CNG_密钥类型>
    {
        @ BCRYPT_ALG_HANDLE phAlgorithm;
        @ BCRYPT_KEY_HANDLE phKey;
        @ NTSTATUS Status;
        @ Status = ::BCryptOpenAlgorithmProvider (&phAlgorithm, (LPCWSTR)@<算法类型>.GetText (), NULL, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return FALSE;
        @ }
        // 生成密钥对
        @ Status = ::BCryptGenerateKeyPair (phAlgorithm, &phKey, (ULONG)@<密钥位>, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return FALSE;
        @ }
        // 完成密钥对设置
        @ Status = ::BCryptFinalizeKeyPair (phKey, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptDestroyKey (phKey);
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return FALSE;
        @ }
        // 取公钥数据
        @ ULONG dwResultSize;
        @ Status = ::BCryptExportKey (phKey, NULL, (LPCWSTR)@<公钥类型>.GetText (), NULL, 0, &dwResultSize, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptDestroyKey (phKey);
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return FALSE;
        @ }
        @ @<公钥数据>.Alloc (dwResultSize, TRUE);
        @ Status = ::BCryptExportKey (phKey, NULL, (LPCWSTR)@<公钥类型>.GetText (), (PUCHAR)@<公钥数据>.GetPtr(), dwResultSize, &dwResultSize, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptDestroyKey (phKey);
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return FALSE;
        @ }
        @ @<公钥数据>.RemoveToEnd (dwResultSize);
        // 取私钥数据
        @ Status = ::BCryptExportKey (phKey, NULL, (LPCWSTR)@<私钥类型>.GetText (), NULL, 0, &dwResultSize, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptDestroyKey (phKey);
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return FALSE;
        @ }
        @ @<私钥数据>.Alloc (dwResultSize, TRUE);
        @ Status = ::BCryptExportKey (phKey, NULL, (LPCWSTR)@<私钥类型>.GetText (), (PUCHAR)@<私钥数据>.GetPtr (), dwResultSize, &dwResultSize, 0);
        @ ::BCryptDestroyKey (phKey);
        @ ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return FALSE;
        @ }
        @ @<私钥数据>.RemoveToEnd (dwResultSize);
        @ return TRUE;
    }

    方法 生成密钥对_RSA <公开 静态 类型 = 逻辑型 注释 = "随机生成用于数据加解密的RAS密钥对,包含私钥以及公钥." 返回值注释 = "返回密钥对是否生成成功" 折叠>
    参数 公钥数据 <类型 = 字节集类 注释 = "成功将返回公钥数据">
    参数 私钥数据 <类型 = 字节集类 注释 = "成功将返回私钥数据">
    参数 密钥位 <类型 = 整数 注释 = "密钥大小必须大于等于512位,小于等于16384位,且必须是64的倍数." @默认值 = 1024>
    参数 返回完整私钥 <类型 = 逻辑型 注释 = "指定返回的私钥是否为包含公钥的完整密钥对,只有完整的密钥可以转换到PEM格式." @默认值 = 真>
    {
        返回 (生成密钥对 (公钥数据, 私钥数据, 密钥位, CNG_算法类型.公钥_RSA, CNG_密钥类型.RSA_公钥, 选择 (返回完整私钥, CNG_密钥类型.RSA_完整私钥, CNG_密钥类型.RSA_私钥)))
    }

    方法 生成密钥对_DH <公开 静态 类型 = 逻辑型 注释 = "随机生成用于密钥交换的DH密钥对,包含私钥以及公钥." 返回值注释 = "返回密钥对是否生成成功" 折叠>
    参数 公钥数据 <类型 = 字节集类 注释 = "成功将返回公钥数据">
    参数 私钥数据 <类型 = 字节集类 注释 = "成功将返回私钥数据">
    参数 密钥位 <类型 = 整数 注释 = "密钥大小必须大于等于512位,小于等于4096 位,且必须是64的倍数." @默认值 = 1024>
    {
        返回 (生成密钥对 (公钥数据, 私钥数据, 密钥位, CNG_算法类型.密钥交换_DH, CNG_密钥类型.DH_公钥, CNG_密钥类型.DH_私钥))
    }

    方法 生成密钥对_ECDH_P256 <公开 静态 类型 = 逻辑型 注释 = "随机生成用于密钥交换的ECDH-P256密钥对,包含私钥以及公钥." 返回值注释 = "返回密钥对是否生成成功" 折叠>
    参数 公钥数据 <类型 = 字节集类 注释 = "成功将返回公钥数据">
    参数 私钥数据 <类型 = 字节集类 注释 = "成功将返回私钥数据">
    {
        返回 (生成密钥对 (公钥数据, 私钥数据, 256, CNG_算法类型.密钥交换_ECDH_P256, CNG_密钥类型.通用公钥, CNG_密钥类型.通用私钥))
    }

    方法 生成密钥对_ECDH_P384 <公开 静态 类型 = 逻辑型 注释 = "随机生成用于密钥交换的ECDH-P384密钥对,包含私钥以及公钥." 返回值注释 = "返回密钥对是否生成成功" 折叠>
    参数 公钥数据 <类型 = 字节集类 注释 = "成功将返回公钥数据">
    参数 私钥数据 <类型 = 字节集类 注释 = "成功将返回私钥数据">
    {
        返回 (生成密钥对 (公钥数据, 私钥数据, 384, CNG_算法类型.密钥交换_ECDH_P384, CNG_密钥类型.通用公钥, CNG_密钥类型.通用私钥))
    }

    方法 生成密钥对_ECDH_P521 <公开 静态 类型 = 逻辑型 注释 = "随机生成用于密钥交换的ECDH-P521密钥对,包含私钥以及公钥." 返回值注释 = "返回密钥对是否生成成功" 折叠>
    参数 公钥数据 <类型 = 字节集类 注释 = "成功将返回公钥数据">
    参数 私钥数据 <类型 = 字节集类 注释 = "成功将返回私钥数据">
    {
        返回 (生成密钥对 (公钥数据, 私钥数据, 521, CNG_算法类型.密钥交换_ECDH_P521, CNG_密钥类型.通用公钥, CNG_密钥类型.通用私钥))
    }

    # --

    方法 生成密钥对_RSA_SIGN <公开 静态 类型 = 逻辑型 注释 = "随机生成用于数字签名的RAS-SIGN密钥对,包含私钥以及公钥." 返回值注释 = "返回密钥对是否生成成功" 折叠>
    参数 公钥数据 <类型 = 字节集类 注释 = "成功将返回公钥数据">
    参数 私钥数据 <类型 = 字节集类 注释 = "成功将返回私钥数据">
    参数 密钥位 <类型 = 整数 注释 = "密钥大小必须大于等于512位,小于等于16384位,且必须是64的倍数." @默认值 = 1024>
    {
        返回 (生成密钥对 (公钥数据, 私钥数据, 密钥位, CNG_算法类型.数字签名_RSA, CNG_密钥类型.RSA_公钥, CNG_密钥类型.RSA_私钥))
    }

    方法 生成密钥对_DSA <公开 静态 类型 = 逻辑型 注释 = "随机生成用于数字签名的DSA密钥对,包含私钥以及公钥." 返回值注释 = "返回密钥对是否生成成功" 折叠>
    参数 公钥数据 <类型 = 字节集类 注释 = "成功将返回公钥数据">
    参数 私钥数据 <类型 = 字节集类 注释 = "成功将返回私钥数据">
    参数 密钥位 <类型 = 整数 注释 = " 必须大于等于512,少于等于3072,且为64的倍数." 注释 = " 密钥位需要和哈希算法相配合,否则会失败." @默认值 = 1024>
    {
        返回 (生成密钥对 (公钥数据, 私钥数据, 密钥位, CNG_算法类型.数字签名_DSA, CNG_密钥类型.DSA_公钥, CNG_密钥类型.DSA_私钥))
    }

    方法 生成密钥对_ECDSA_P256 <公开 静态 类型 = 逻辑型 注释 = "随机生成用于数字签名的ECDSA-P256密钥对,包含私钥以及公钥." 返回值注释 = "返回密钥对是否生成成功" 折叠>
    参数 公钥数据 <类型 = 字节集类 注释 = "成功将返回公钥数据">
    参数 私钥数据 <类型 = 字节集类 注释 = "成功将返回私钥数据">
    {
        返回 (生成密钥对 (公钥数据, 私钥数据, 256, CNG_算法类型.数字签名_ECDSA_P256, CNG_密钥类型.通用公钥, CNG_密钥类型.通用私钥))
    }

    方法 生成密钥对_ECDSA_P384 <公开 静态 类型 = 逻辑型 注释 = "随机生成用于数字签名的ECDSA-P384密钥对,包含私钥以及公钥." 返回值注释 = "返回密钥对是否生成成功" 折叠>
    参数 公钥数据 <类型 = 字节集类 注释 = "成功将返回公钥数据">
    参数 私钥数据 <类型 = 字节集类 注释 = "成功将返回私钥数据">
    {
        返回 (生成密钥对 (公钥数据, 私钥数据, 384, CNG_算法类型.数字签名_ECDSA_P384, CNG_密钥类型.通用公钥, CNG_密钥类型.通用私钥))
    }

    方法 生成密钥对_ECDSA_P521 <公开 静态 类型 = 逻辑型 注释 = "随机生成用于数字签名的ECDSA-P521密钥对,包含私钥以及公钥." 返回值注释 = "返回密钥对是否生成成功" 折叠>
    参数 公钥数据 <类型 = 字节集类 注释 = "成功将返回公钥数据">
    参数 私钥数据 <类型 = 字节集类 注释 = "成功将返回私钥数据">
    {
        返回 (生成密钥对 (公钥数据, 私钥数据, 521, CNG_算法类型.数字签名_ECDSA_P521, CNG_密钥类型.通用公钥, CNG_密钥类型.通用私钥))
    }

    # ===
    # 数字签名

    方法 数字签名 <静态 类型 = 字节集类 注释 = "将指定数据进行数字签名,可通过\"验证签名\"验证数据完整性." 返回值注释 = "签名成功将会返回签名内容,签名失败返回空字节集." 折叠
            @禁止流程检查 = 真>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲签名的数据">
    参数 私钥数据 <类型 = 字节集类 注释 = "成功返回公钥">
    参数 签名算法 <类型 = CNG_算法类型 注释 = "使用\"CNG_算法类型.数字签名_\"">
    参数 私钥类型 <类型 = CNG_密钥类型 注释 = "使用\"CNG_密钥类型\"">
    参数 摘要算法 <类型 = CNG_算法类型 注释 = "签名所使用的摘要算法. 请使用\"CNG_算法类型.哈希_\"">
    {
        变量 数据摘要 <类型 = 字节集类>
        // 计算数据哈希值
        数据摘要 = 取数据Hash (数据, 摘要算法)
        @ if (@<数据摘要>.IsNullObject () == TRUE) {
        @     return CVolMem ();
        @ }
        @ BCRYPT_ALG_HANDLE phAlgorithm;
        @ BCRYPT_KEY_HANDLE phKey;
        @ NTSTATUS Status;
        // 打开数字签名算法句柄
        @ Status = ::BCryptOpenAlgorithmProvider (&phAlgorithm, (LPCWSTR)@<签名算法>.GetText (), NULL, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return CVolMem ();
        @ }
        // 导入私钥
        @ Status = ::BCryptImportKeyPair (phAlgorithm, NULL, (LPCWSTR)@<私钥类型>.GetText (), &phKey,
        @                                 (PUCHAR)@<私钥数据>.GetPtr (), (ULONG)@<私钥数据>.GetSize (), BCRYPT_NO_KEY_VALIDATION);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        // 哈希值签名
        @ ULONG SignatureLen;
        @ Status = ::BCryptSignHash (phKey, NULL, (PUCHAR)@<数据摘要>.GetPtr (), (ULONG)@<数据摘要>.GetSize (),
        @                            NULL, 0, &SignatureLen, 0);
        @ if (!BCRYPT_SUCCESS(Status)) { // 获取签名长度失败
        @     ::BCryptDestroyKey (phKey);
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        @ @an<CVolMem> SignatureBlob;
        @ SignatureBlob.Alloc (SignatureLen, TRUE);
        @ ULONG ResultLen;
        @ Status = ::BCryptSignHash (phKey, NULL, (PUCHAR)@<数据摘要>.GetPtr (), (ULONG)@<数据摘要>.GetSize (),
        @                            (PUCHAR)SignatureBlob.GetPtr(), SignatureLen, &ResultLen, 0);
        @ if (!BCRYPT_SUCCESS(Status)) { // 获取签名数据失败
        @     ::BCryptDestroyKey (phKey);
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        // 清理句柄
        @ ::BCryptDestroyKey (phKey);
        @ ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @ SignatureBlob.RemoveToEnd (ResultLen);
        @ return SignatureBlob;
    }

    方法 验证签名 <静态 类型 = 逻辑型 注释 = "提供指定的数据以及该数据对应的签名内容,验证数据与签名是否对应,以保障数据的完整性." 返回值注释 = "返回该数据签名是否验证成功" 折叠
            @禁止流程检查 = 真>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲验证签名的数据">
    参数 签名内容 <类型 = 字节集类 注释 = "提供该数据对应的签名内容">
    参数 公钥数据 <类型 = 字节集类 注释 = "提供本次验证所使用的公钥数据">
    参数 签名算法 <类型 = CNG_算法类型 注释 = "使用\"CNG_算法类型.数字签名_\"">
    参数 公钥类型 <类型 = CNG_密钥类型 注释 = "使用\"CNG_密钥类型\"">
    参数 摘要算法 <类型 = CNG_算法类型 注释 = "提供验签所使用的摘要算法,必须与签名时保持一致,否则会导致验签失败. 请使用\"CNG_算法类型.哈希_\"">
    {
        变量 数据摘要 <类型 = 字节集类>
        // 计算数据哈希值
        数据摘要 = 取数据Hash (数据, 摘要算法)
        @ if (@<数据摘要>.IsNullObject () == TRUE) {
        @     return CVolMem ();
        @ }
        @ BCRYPT_ALG_HANDLE phAlgorithm;
        @ BCRYPT_KEY_HANDLE phKey;
        @ NTSTATUS Status;
        // 打开数字签名算法句柄
        @ Status = ::BCryptOpenAlgorithmProvider (&phAlgorithm, (LPCWSTR)@<签名算法>.GetText (), NULL, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return FALSE;
        @ }
        // 导入公钥
        @ Status = ::BCryptImportKeyPair (phAlgorithm, NULL, (LPCWSTR)@<公钥类型>.GetText (), &phKey,
        @                                 (PUCHAR)@<公钥数据>.GetPtr (), (ULONG)@<公钥数据>.GetSize (), BCRYPT_NO_KEY_VALIDATION);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return FALSE;
        @ }
        // 验证签名
        @ Status = ::BCryptVerifySignature (phKey, NULL, (PUCHAR)@<数据摘要>.GetPtr (), (ULONG)@<数据摘要>.GetSize (),
        @                                   (PUCHAR)@<签名内容>.GetPtr (), (ULONG)@<签名内容>.GetSize (), 0);
        @ ::BCryptDestroyKey (phKey);
        @ ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return FALSE;
        @ }
        @ return TRUE;
    }

    方法 数字签名_DSA <公开 静态 类型 = 字节集类 注释 = "将指定数据进行DSA数字签名,可通过\"验证签名\"验证数据完整性." 注释 = "请先用\"生成密钥对_DSA\"生成私钥和公钥."
            返回值注释 = "签名成功将会返回签名内容,签名失败返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲签名的数据">
    参数 私钥数据 <类型 = 字节集类 注释 = "提供本次签名所使用的私钥数据">
    参数 摘要算法 <类型 = CNG_算法类型 注释 = "签名所使用的摘要算法" @默认值 = CNG_算法类型.哈希_SHA1>
    {
        返回 (数字签名 (数据, 私钥数据, CNG_算法类型.数字签名_DSA, CNG_密钥类型.DSA_私钥, 摘要算法))
    }

    方法 验证签名_DSA <公开 静态 类型 = 逻辑型 注释 = "提供指定的数据以及该数据对应的签名内容,验证数据与签名是否对应,以保障数据的完整性." 返回值注释 = "返回该数据签名是否验证成功"
            折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲验证签名的数据">
    参数 签名内容 <类型 = 字节集类 注释 = "提供该数据对应的签名内容">
    参数 公钥数据 <类型 = 字节集类 注释 = "提供本次验证所使用的公钥数据">
    参数 摘要算法 <类型 = CNG_算法类型 注释 = "提供验签所使用的摘要算法,必须与签名时保持一致,否则会导致验签失败." @默认值 = CNG_算法类型.哈希_SHA1>
    {
        返回 (验证签名 (数据, 签名内容, 公钥数据, CNG_算法类型.数字签名_DSA, CNG_密钥类型.DSA_公钥, 摘要算法))
    }

    方法 数字签名_RSA <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RSA数字签名,可通过\"验证签名\"验证数据完整性."
            注释 = "请先用\"生成密钥对_RSA_SIGN\"生成私钥和公钥." 返回值注释 = "签名成功将会返回签名内容,签名失败返回空字节集." 折叠 @禁止流程检查 = 真>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲签名的数据">
    参数 私钥数据 <类型 = 字节集类 注释 = "提供本次签名所使用的私钥数据">
    参数 摘要算法 <类型 = CNG_算法类型 注释 = "签名所使用的摘要算法" @默认值 = CNG_算法类型.哈希_SHA1>
    {
        变量 数据摘要 <类型 = 字节集类>
        // 计算数据哈希值
        数据摘要 = 取数据Hash (数据, 摘要算法)
        @ if (@<数据摘要>.IsNullObject () == TRUE) return CVolMem ();
        @ BCRYPT_ALG_HANDLE phAlgorithm;
        @ BCRYPT_KEY_HANDLE phKey;
        @ NTSTATUS Status;
        // 打开数字签名算法句柄
        @ if (!BCRYPT_SUCCESS(::BCryptOpenAlgorithmProvider (&phAlgorithm, BCRYPT_RSA_SIGN_ALGORITHM, NULL, 0)))
        @     return CVolMem ();
        // 导入私钥
        @ if (!BCRYPT_SUCCESS(::BCryptImportKeyPair (phAlgorithm, NULL, BCRYPT_RSAPRIVATE_BLOB, &phKey,
        @                                            (PUCHAR)@<私钥数据>.GetPtr (), (ULONG)@<私钥数据>.GetSize (), BCRYPT_NO_KEY_VALIDATION)))
        @ {
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        // 哈希值签名
        @ BCRYPT_PKCS1_PADDING_INFO padding_PKCS1;
        @ padding_PKCS1.pszAlgId = (LPCWSTR)@<摘要算法>.GetText ();
        @ ULONG SignatureLen;
        @ if (!BCRYPT_SUCCESS(::BCryptSignHash (phKey, &padding_PKCS1, (PUCHAR)@<数据摘要>.GetPtr (), (ULONG)@<数据摘要>.GetSize (),
        @                                       NULL, 0, &SignatureLen, BCRYPT_PAD_PKCS1)))
        @ { // 获取签名长度失败
        @     ::BCryptDestroyKey (phKey);
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        @ @an<CVolMem> SignatureBlob;
        @ SignatureBlob.Alloc (SignatureLen, TRUE);
        @ ULONG ResultLen;
        @ if (!BCRYPT_SUCCESS(::BCryptSignHash (phKey, &padding_PKCS1, (PUCHAR)@<数据摘要>.GetPtr (), (ULONG)@<数据摘要>.GetSize (),
        @                                       (PUCHAR)SignatureBlob.GetPtr(), SignatureLen, &ResultLen, BCRYPT_PAD_PKCS1)))
        @ { // 获取签名数据失败
        @     ::BCryptDestroyKey (phKey);
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        // 清理句柄
        @ ::BCryptDestroyKey (phKey);
        @ ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @ return SignatureBlob;
    }

    方法 验证签名_RSA <公开 静态 类型 = 逻辑型 注释 = "提供指定的数据以及该数据对应的签名内容,验证数据与签名是否对应,以保障数据的完整性." 返回值注释 = "返回该数据签名是否验证成功"
            折叠 @禁止流程检查 = 真>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲验证签名的数据">
    参数 签名内容 <类型 = 字节集类 注释 = "提供该数据对应的签名内容">
    参数 公钥数据 <类型 = 字节集类 注释 = "提供本次验证所使用的公钥数据">
    参数 摘要算法 <类型 = CNG_算法类型 注释 = "提供验签所使用的摘要算法,必须与签名时保持一致,否则会导致验签失败." @默认值 = CNG_算法类型.哈希_SHA1>
    {
        变量 数据摘要 <类型 = 字节集类>
        // 计算数据哈希值
        数据摘要 = 取数据Hash (数据, 摘要算法)
        如果 (数据摘要.是否为空对象 () == 真)
        {
            返回 (假)
        }
        @ BCRYPT_ALG_HANDLE phAlgorithm;
        @ BCRYPT_KEY_HANDLE phKey;
        @ NTSTATUS Status;
        // 打开数字签名算法句柄
        @ if (!BCRYPT_SUCCESS(::BCryptOpenAlgorithmProvider (&phAlgorithm, BCRYPT_RSA_SIGN_ALGORITHM, NULL, 0)))
        @     return FALSE;
        // 导入公钥
        @ if (!BCRYPT_SUCCESS(::BCryptImportKeyPair (phAlgorithm, NULL, BCRYPT_RSAPUBLIC_BLOB, &phKey,
        @                                            (PUCHAR)@<公钥数据>.GetPtr (), (ULONG)@<公钥数据>.GetSize (), BCRYPT_NO_KEY_VALIDATION)))
        @ {
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return FALSE;
        @ }
        @ BCRYPT_PKCS1_PADDING_INFO padding_PKCS1;
        @ padding_PKCS1.pszAlgId = (LPCWSTR)@<摘要算法>.GetText ();
        // 验证签名
        @ Status = ::BCryptVerifySignature (phKey, &padding_PKCS1, (PUCHAR)@<数据摘要>.GetPtr (), (ULONG)@<数据摘要>.GetSize (),
        @                                   (PUCHAR)@<签名内容>.GetPtr (), (ULONG)@<签名内容>.GetSize (), BCRYPT_PAD_PKCS1);
        @ ::BCryptDestroyKey (phKey);
        @ ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @ if (!BCRYPT_SUCCESS(Status)) return FALSE;
        @ return TRUE;
    }

    方法 数字签名_RSA_PEM <公开 静态 类型 = 字节集类 注释 = "将指定数据进行RSA数字签名,可通过\"验证签名\"验证数据完整性."
            返回值注释 = "签名成功将会返回签名内容,签名失败返回空字节集." 折叠 @禁止流程检查 = 真>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲签名的数据">
    参数 私钥数据 <类型 = 文本型 注释 = "提供本次签名所使用的PEM格式私钥数据">
    参数 摘要算法 <类型 = CNG_算法类型 注释 = "签名所使用的摘要算法" @默认值 = CNG_算法类型.哈希_SHA1>
    {
        返回 (数字签名_RSA (数据, PEM密钥到BLOB (私钥数据, 真), 摘要算法))
    }

    方法 验证签名_RSA_PEM <公开 静态 类型 = 逻辑型 注释 = "提供指定的数据以及该数据对应的签名内容,验证数据与签名是否对应,以保障数据的完整性."
            返回值注释 = "返回该数据签名是否验证成功" 折叠 @禁止流程检查 = 真>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲验证签名的数据">
    参数 签名内容 <类型 = 字节集类 注释 = "提供该数据对应的签名内容">
    参数 公钥数据 <类型 = 文本型 注释 = "提供本次验证所使用的PEM格式公钥数据">
    参数 摘要算法 <类型 = CNG_算法类型 注释 = "提供验签所使用的摘要算法,必须与签名时保持一致,否则会导致验签失败." @默认值 = CNG_算法类型.哈希_SHA1>
    {
        返回 (验证签名_RSA (数据, 签名内容, PEM密钥到BLOB (公钥数据, 假), 摘要算法))
    }

    方法 数字签名_ECDSA_P256 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行ECDSA-P256数字签名,可通过\"验证签名\"验证数据完整性."
            注释 = "请先用\"生成密钥对_ECDSA_P256\"生成私钥和公钥." 返回值注释 = "签名成功将会返回签名内容,签名失败返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲签名的数据">
    参数 私钥数据 <类型 = 字节集类 注释 = "提供本次签名所使用的私钥数据">
    参数 摘要算法 <类型 = CNG_算法类型 注释 = "签名所使用的摘要算法" @默认值 = CNG_算法类型.哈希_SHA256>
    {
        返回 (数字签名 (数据, 私钥数据, CNG_算法类型.数字签名_ECDSA_P256, CNG_密钥类型.通用私钥, 摘要算法))
    }

    方法 验证签名_ECDSA_P256 <公开 静态 类型 = 逻辑型 注释 = "提供指定的数据以及该数据对应的签名内容,验证数据与签名是否对应,以保障数据的完整性."
            返回值注释 = "返回该数据签名是否验证成功" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲验证签名的数据">
    参数 签名内容 <类型 = 字节集类 注释 = "提供该数据对应的签名内容">
    参数 公钥数据 <类型 = 字节集类 注释 = "提供本次验证所使用的公钥数据">
    参数 摘要算法 <类型 = CNG_算法类型 注释 = "提供验签所使用的摘要算法,必须与签名时保持一致,否则会导致验签失败." @默认值 = CNG_算法类型.哈希_SHA256>
    {
        返回 (验证签名 (数据, 签名内容, 公钥数据, CNG_算法类型.数字签名_ECDSA_P256, CNG_密钥类型.通用公钥, 摘要算法))
    }

    方法 数字签名_ECDSA_P384 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行ECDSA-P384数字签名,可通过\"验证签名\"验证数据完整性."
            注释 = "请先用\"生成密钥对_ECDSA_P384\"生成私钥和公钥." 返回值注释 = "签名成功将会返回签名内容,签名失败返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲签名的数据">
    参数 私钥数据 <类型 = 字节集类 注释 = "提供本次签名所使用的私钥数据">
    参数 摘要算法 <类型 = CNG_算法类型 注释 = "签名所使用的摘要算法" @默认值 = CNG_算法类型.哈希_SHA384>
    {
        返回 (数字签名 (数据, 私钥数据, CNG_算法类型.数字签名_ECDSA_P384, CNG_密钥类型.通用私钥, 摘要算法))
    }

    方法 验证签名_ECDSA_P384 <公开 静态 类型 = 逻辑型 注释 = "提供指定的数据以及该数据对应的签名内容,验证数据与签名是否对应,以保障数据的完整性."
            返回值注释 = "返回该数据签名是否验证成功" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲验证签名的数据">
    参数 签名内容 <类型 = 字节集类 注释 = "提供该数据对应的签名内容">
    参数 公钥数据 <类型 = 字节集类 注释 = "提供本次验证所使用的公钥数据">
    参数 摘要算法 <类型 = CNG_算法类型 注释 = "提供验签所使用的摘要算法,必须与签名时保持一致,否则会导致验签失败." @默认值 = CNG_算法类型.哈希_SHA384>
    {
        返回 (验证签名 (数据, 签名内容, 公钥数据, CNG_算法类型.数字签名_ECDSA_P384, CNG_密钥类型.通用公钥, 摘要算法))
    }

    方法 数字签名_ECDSA_P521 <公开 静态 类型 = 字节集类 注释 = "将指定数据进行ECDSA-P521数字签名,可通过\"验证签名\"验证数据完整性."
            注释 = "请先用\"生成密钥对_ECDSA_P521\"生成私钥和公钥." 返回值注释 = "签名成功将会返回签名内容,签名失败返回空字节集." 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲签名的数据">
    参数 私钥数据 <类型 = 字节集类 注释 = "提供本次签名所使用的私钥数据">
    参数 摘要算法 <类型 = CNG_算法类型 注释 = "签名所使用的摘要算法" @默认值 = CNG_算法类型.哈希_SHA512>
    {
        返回 (数字签名 (数据, 私钥数据, CNG_算法类型.数字签名_ECDSA_P521, CNG_密钥类型.通用私钥, 摘要算法))
    }

    方法 验证签名_ECDSA_P521 <公开 静态 类型 = 逻辑型 注释 = "提供指定的数据以及该数据对应的签名内容,验证数据与签名是否对应,以保障数据的完整性."
            返回值注释 = "返回该数据签名是否验证成功" 折叠>
    参数 数据 <类型 = 字节集类 注释 = "提供所欲验证签名的数据">
    参数 签名内容 <类型 = 字节集类 注释 = "提供该数据对应的签名内容">
    参数 公钥数据 <类型 = 字节集类 注释 = "提供本次验证所使用的公钥数据">
    参数 摘要算法 <类型 = CNG_算法类型 注释 = "提供验签所使用的摘要算法,必须与签名时保持一致,否则会导致验签失败." @默认值 = CNG_算法类型.哈希_SHA512>
    {
        返回 (验证签名 (数据, 签名内容, 公钥数据, CNG_算法类型.数字签名_ECDSA_P521, CNG_密钥类型.通用公钥, 摘要算法))
    }

    # ===
    # 随机数

    方法 生成随机数 <静态 类型 = 整数 注释 = "内部使用的随机数生成函数" 折叠 @禁止流程检查 = 真>
    参数 算法类型 <类型 = CNG_算法类型 注释 = "使用的算法类型.\"CNG_算法类型.随机数_\"">
    {
        @ BCRYPT_ALG_HANDLE phAlgorithm;
        @ NTSTATUS Status;
        @ INT dwRandom;
        @ Status = ::BCryptOpenAlgorithmProvider (&phAlgorithm, (LPCWSTR)@<算法类型>.GetText (), NULL, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return 0;
        @ }
        @ Status = ::BCryptGenRandom (phAlgorithm, (PUCHAR)&dwRandom, 4, 0);
        @ ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return 0;
        @ }
        @ return (INT)dwRandom;
    }

    方法 取随机数_RNG <公开 静态 类型 = 整数 注释 = "用椭圆曲线算法生成随机数" 返回值注释 = "返回随机数" 折叠 @禁止流程检查 = 真>
    {
        @ INT dwRandom;
        @ ::BCryptGenRandom (NULL, (PUCHAR)&dwRandom, 4, BCRYPT_USE_SYSTEM_PREFERRED_RNG);
        @ return (INT)dwRandom;
    }

    方法 取随机数_DUALECRNG <公开 静态 类型 = 整数 注释 = "用双椭圆曲线算法生成随机数" 返回值注释 = "返回随机数" 折叠>
    {
        返回 (生成随机数 (CNG_算法类型.随机数_DUALECRNG))
    }

    方法 取随机数_FIPS186DSARNG <公开 静态 类型 = 整数 注释 = "用FIPS186DSARNG算法生成随机数" 返回值注释 = "返回随机数" 折叠>
    {
        返回 (生成随机数 (CNG_算法类型.随机数_FIPS186DSARNG))
    }

    # ===
    # 密钥派生函数

    方法 密钥派生函数 <静态 类型 = 字节集类 注释 = "内部使用的密钥派生函数" 注释 = "最低系统要求: Windows 8" 返回值注释 = "返回派生的密钥,失败返回空字节集类." 折叠
            @禁止流程检查 = 真>
    参数 密钥 <类型 = 字节集类 注释 = "所欲派生密钥的主密钥">
    参数 参数列表 <类型 = 变整数 注释 = "需要根据不同的密钥派生算法写参数列表">
    参数 派生密钥长度 <类型 = 整数 注释 = "派生密钥的长度. PBKDF2派生的密码长度没有限制,不过部分大小可能会出错.">
    参数 密钥派生算法 <类型 = CNG_算法类型 注释 = "请使用\"CNG_算法类型.密钥派生_\"">
    {
        @ typedef NTSTATUS(WINAPI* Typedef_BCryptKeyDerivation)(BCRYPT_KEY_HANDLE, BCryptBufferDesc*, PUCHAR, ULONG, ULONG*, ULONG);
        @ Typedef_BCryptKeyDerivation API_BCryptKeyDerivation =
        @     (Typedef_BCryptKeyDerivation)::GetProcAddress(::GetModuleHandle (L"Bcrypt.dll"), "BCryptKeyDerivation");
        @ if (!API_BCryptKeyDerivation) {
        @     return CVolMem ();
        @ }
        @ BCRYPT_ALG_HANDLE phAlgorithm;
        @ BCRYPT_KEY_HANDLE phKey;
        @ NTSTATUS Status;
        @ Status = ::BCryptOpenAlgorithmProvider (&phAlgorithm, (LPCWSTR)@<密钥派生算法>.GetText (), NULL, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return CVolMem ();
        @ }
        @ Status = ::BCryptGenerateSymmetricKey (phAlgorithm, &phKey, NULL, 0, (PUCHAR)@<密钥>.GetPtr (), (ULONG)@<密钥>.GetSize (), 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @     return CVolMem ();
        @ }
        @ @an<CVolMem> DerivedKey;
        @ ULONG ResultLen;
        @ DerivedKey.Alloc (@<派生密钥长度>, TRUE);
        @ Status = API_BCryptKeyDerivation (phKey, (BCryptBufferDesc*)@<参数列表>,
        @                                   (PUCHAR)DerivedKey.GetPtr (), (ULONG)DerivedKey.GetSize (),
        @                                   (ULONG*)&ResultLen, 0);
        @ ::BCryptDestroyKey (phKey);
        @ ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return CVolMem ();
        @ }
        @ DerivedKey.RemoveToEnd (ResultLen);
        @ return DerivedKey;
    }

    方法 密钥派生_SP800_108 <公开 静态 类型 = 字节集类 注释 = "使用SP800-108密钥派生算法从哈希值中派生密钥."
            注释 = "密钥派生函数(KDF)使用伪随机函数从主密钥派生一个或多个密钥." 注释 = "可用于将密钥扩展到更长的密钥或获得所需格式的密钥." 注释 = "最低系统要求: Windows 8"
            返回值注释 = "返回派生的密钥,失败返回空字节集类." 折叠 @禁止流程检查 = 真>
    参数 密钥 <类型 = 字节集类 注释 = "所欲派生密钥的主密钥">
    参数 标签 <类型 = 字节集类 注释 = "可表示派生密钥的用途">
    参数 上下文 <类型 = 字节集类 注释 = " ANSI文本,请用\"文本到多字节(PRF标签, 真)\"" 注释 = " 可以是执行KDF的人,或使用派生密钥的人.">
    参数 派生密钥长度 <类型 = 整数 注释 = "派生密钥的长度,最大长度为688" @默认值 = 128>
    参数 哈希算法 <类型 = CNG_算法类型 注释 = "请使用\"CNG_算法类型.哈希_\"" @默认值 = CNG_算法类型.哈希_SHA1>
    {
        @ BCryptBuffer SP800108ParamBuffer[]=
        @ {
        @     {
        @         (ULONG)@<标签>.GetSize(), 0xD, (PVOID)@<标签>.GetPtr (),
        @     }, {
        @         (ULONG)@<上下文>.GetSize(), 0xE, (PVOID)@<上下文>.GetPtr (),
        @     }, {
        @         sizeof(@<哈希算法>), KDF_HASH_ALGORITHM, (PVOID)@<哈希算法>.GetText (),
        @     }
        @ };
        @ BCryptBufferDesc ParamList[] { BCRYPTBUFFER_VERSION, 3, SP800108ParamBuffer };
        @ return @<密钥派生函数> (@<密钥>, (INT_P)&ParamList, @<派生密钥长度>, @<CNG_算法类型.密钥派生_SP800108>);
    }

    方法 密钥派生_SP800_56A <公开 静态 类型 = 字节集类 注释 = "使用SP800-56A密钥派生算法从哈希值中派生密钥."
            注释 = "密钥派生函数(KDF)使用伪随机函数从主密钥派生一个或多个密钥." 注释 = "可用于将密钥扩展到更长的密钥或获得所需格式的密钥." 注释 = "最低系统要求: Windows 8"
            返回值注释 = "返回派生的密钥,失败返回空字节集类." 折叠 @禁止流程检查 = 真>
    参数 密钥 <类型 = 字节集类 注释 = "所欲派生密钥的主密钥">
    参数 AlgorithmID <类型 = 字节集类 注释 = "算法ID">
    参数 PartyUInfo <类型 = 字节集类 注释 = "UI信息">
    参数 PartyVInfo <类型 = 字节集类 注释 = "VI信息">
    参数 派生密钥长度 <类型 = 整数 注释 = "派生密钥的长度,最大长度为688" @默认值 = 128>
    参数 哈希算法 <类型 = CNG_算法类型 注释 = "请使用\"CNG_算法类型.哈希_\"" @默认值 = CNG_算法类型.哈希_SHA256>
    参数 SuppPubInfo <类型 = 字节集类 注释 = "可选参数" @默认值 = 空对象>
    参数 SuppPrivInfo <类型 = 字节集类 注释 = "可选参数" @默认值 = 空对象>
    {
        @ BCryptBuffer SP80056AParamBuffer[] =
        @ {
        @     {
        @         sizeof(@<哈希算法>), KDF_HASH_ALGORITHM, (PVOID)@<哈希算法>.GetText (), // KDF_HASH_ALGORITHM
        @     }, {
        @         (ULONG)@<AlgorithmID>.GetSize(), 0x8, (PVOID)@<AlgorithmID>.GetPtr (), // KDF_ALGORITHMID
        @     }, {
        @         (ULONG)@<PartyUInfo>.GetSize(), 0x9, (PVOID)@<PartyUInfo>.GetPtr (), // KDF_PARTYUINFO
        @     }, {
        @         (ULONG)@<PartyVInfo>.GetSize(), 0xA, (PVOID)@<PartyVInfo>.GetPtr (), // KDF_PARTYVINFO
        @     }, {
        @         (ULONG)@<SuppPubInfo>.GetSize(), 0xB, (PVOID)@<SuppPubInfo>.GetPtr (), // KDF_SUPPPUBINFO,可选
        @     }, {
        @         (ULONG)@<SuppPrivInfo>.GetSize(), 0xC, (PVOID)@<SuppPrivInfo>.GetPtr (), // KDF_SUPPPRIVINFO,可选
        @     }
        @ };
        @ ULONG dwNum { 4 };
        @ if (@<SuppPubInfo>.GetSize() > 0) dwNum++;
        @ if (@<SuppPrivInfo>.GetSize() > 0) dwNum++;
        @ BCryptBufferDesc ParamList[] {BCRYPTBUFFER_VERSION, dwNum, SP80056AParamBuffer};
        @ return @<密钥派生函数> (@<密钥>, (INT_P)&ParamList, @<派生密钥长度>, @<CNG_算法类型.密钥派生_SP800_56A>);
    }

    方法 密钥派生_PBKDF2 <公开 静态 类型 = 字节集类 注释 = "使用PBKDF2密钥派生算法从哈希值中派生密钥." 注释 = "密钥派生函数(KDF)使用伪随机函数从主密钥派生一个或多个密钥."
            注释 = "可用于将密钥扩展到更长的密钥或获得所需格式的密钥." 注释 = "最低系统要求: Windows 8" 返回值注释 = "返回派生的密钥,失败返回空字节集类." 折叠 @禁止流程检查 = 真>
    参数 密钥 <类型 = 字节集类 注释 = "所欲派生密钥的主密钥">
    参数 盐 <类型 = 字节集类 注释 = "在主密钥上加盐" @默认值 = 空对象>
    参数 派生密钥长度 <类型 = 整数 注释 = "派生密钥的长度. PBKDF2派生的密码长度没有限制" @默认值 = 128>
    参数 哈希算法 <类型 = CNG_算法类型 注释 = "请使用\"CNG_算法类型.哈希_\"" @默认值 = CNG_算法类型.哈希_SHA1>
    参数 迭代次数 <类型 = 长整数 注释 = "哈希算法的计算次数,次数越大,耗时越高." @默认值 = 10000>
    {
        @ BCryptBuffer PBKDF2ParamBuffer[] =
        @ {
        @     {
        @         sizeof(@<哈希算法>), KDF_HASH_ALGORITHM, (PVOID)@<哈希算法>.GetText (),
        @     }, {
        @         sizeof(@<迭代次数>), 0x10, (PVOID)&@<迭代次数>,
        @     }, {
        @         (ULONG)@<盐>.GetSize (), 0xF, (PVOID)@<盐>.GetPtr (),
        @     }
        @ };
        @ BCryptBufferDesc ParamList[] { BCRYPTBUFFER_VERSION, (@<盐>.GetSize() > 0) ? 3 : 2, PBKDF2ParamBuffer };
        @ return @<密钥派生函数> (@<密钥>, (INT_P)&ParamList, @<派生密钥长度>, @<CNG_算法类型.密钥派生_PBKDF2>);
    }

    方法 密钥派生_PBKDF2_2 <公开 静态 类型 = 字节集类 注释 = "结果跟\"密钥派生_PBKDF2\"一样,只是使用的API和方法不一样." 注释 = "速度稍慢一些."
            注释 = "最低系统要求: Windows 7" 返回值注释 = "返回派生的密钥,失败返回空字节集类." 折叠 @禁止流程检查 = 真>
    参数 密钥 <类型 = 字节集类 注释 = "所欲派生密钥的主密钥">
    参数 盐 <类型 = 字节集类 注释 = "在主密钥上加盐" @默认值 = 空对象>
    参数 派生密钥长度 <类型 = 整数 注释 = "派生密钥的长度. PBKDF2派生的密码长度没有限制." @默认值 = 128>
    参数 哈希算法 <类型 = CNG_算法类型 注释 = "请使用\"CNG_算法类型.哈希_\"" @默认值 = CNG_算法类型.哈希_SHA256>
    参数 迭代次数 <类型 = 长整数 注释 = "哈希算法的计算次数,次数越大,耗时越高." @默认值 = 10000>
    {
        @ typedef NTSTATUS(WINAPI* Typedef_BCryptDeriveKeyPBKDF2)(BCRYPT_ALG_HANDLE, PUCHAR, ULONG, PUCHAR, ULONG, ULONGLONG, PUCHAR, ULONG, ULONG);
        @ Typedef_BCryptDeriveKeyPBKDF2 API_BCryptDeriveKeyPBKDF2 =
        @     (Typedef_BCryptDeriveKeyPBKDF2)::GetProcAddress(::GetModuleHandle (L"Bcrypt.dll"), "BCryptDeriveKeyPBKDF2");
        @ if (!API_BCryptDeriveKeyPBKDF2) {
        @     return CVolMem ();
        @ }
        @ BCRYPT_ALG_HANDLE phAlgorithm;
        @ NTSTATUS Status;
        @ Status = ::BCryptOpenAlgorithmProvider (&phAlgorithm, (LPCWSTR)@<哈希算法>.GetText (), NULL, BCRYPT_ALG_HANDLE_HMAC_FLAG);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return CVolMem ();
        @ }
        @ @an<CVolMem> DerivedKey;
        @ DerivedKey.Alloc (@<派生密钥长度>, TRUE);
        @ Status = API_BCryptDeriveKeyPBKDF2 (phAlgorithm,
        @                      (PUCHAR)@<密钥>.GetPtr (), (ULONG)@<密钥>.GetSize (),
        @                      (PUCHAR)@<盐>.GetPtr (), (ULONG)@<盐>.GetSize (),
        @                      (ULONGLONG)@<迭代次数>, (PUCHAR)DerivedKey.GetPtr (), (ULONG)@<派生密钥长度>, 0);
        @ ::BCryptCloseAlgorithmProvider (phAlgorithm, 0);
        @ if (!BCRYPT_SUCCESS(Status)) {
        @     return CVolMem ();
        @ }
        @ return DerivedKey;
    }

    方法 密钥派生_CAPI <公开 静态 类型 = 字节集类 注释 = "使用CAPI密钥派生算法从哈希值中派生密钥. 该算法兼容旧版的加解密API."
            注释 = "密钥派生函数(KDF)使用伪随机函数从主密钥派生一个或多个密钥." 注释 = "可用于将密钥扩展到更长的密钥或获得所需格式的密钥." 注释 = "最低系统要求: Windows 8"
            返回值注释 = "返回派生的密钥,失败返回空字节集类." 折叠 @禁止流程检查 = 真>
    参数 密钥 <类型 = 字节集类 注释 = "所欲派生密钥的主密钥">
    参数 派生密钥长度 <类型 = 整数 注释 = "派生密钥的长度, 最大长度为哈希算法的位数除以4(例: SHA512最大128)." @默认值 = 40>
    参数 哈希算法 <类型 = CNG_算法类型 注释 = "请使用\"CNG_算法类型.哈希_\",CAPI了限制不能使用大于512位的哈希算法." @默认值 = CNG_算法类型.哈希_SHA1>
    {
        @ BCryptBuffer CAPIParamBuffer[]=
        @ {
        @     {
        @         sizeof(@<哈希算法>), KDF_HASH_ALGORITHM, (PVOID)@<哈希算法>.GetText (),
        @     }
        @ };
        @ BCryptBufferDesc ParamList[] { BCRYPTBUFFER_VERSION, 1, CAPIParamBuffer };
        @ return @<密钥派生函数> (@<密钥>, (INT_P)&ParamList, @<派生密钥长度>, @<CNG_算法类型.密钥派生_CAPI>);
    }

    方法 密钥派生_TLS1_1 <公开 静态 类型 = 字节集类 注释 = "使用TLS1_1密钥派生算法从哈希值中派生密钥." 注释 = "密钥派生函数(KDF)使用伪随机函数从主密钥派生一个或多个密钥."
            注释 = "可用于将密钥扩展到更长的密钥或获得所需格式的密钥." 注释 = "最低系统要求: Windows 8" 返回值注释 = "返回派生的密钥,失败返回空字节集类." 折叠 @禁止流程检查 = 真>
    参数 密钥 <类型 = 字节集类 注释 = "所欲派生密钥的主密钥">
    参数 PRF标签 <类型 = 文本型>
    参数 PRF种子 <类型 = 字节集类 注释 = "建议为64个字节长度">
    参数 派生密钥长度 <类型 = 整数 注释 = "派生密钥的长度,最大长度为688" @默认值 = 128>
    {
        变量 PRF_LABEL <类型 = 字节集类>
        PRF_LABEL = 文本到多字节 (PRF标签, 真)
        @ BCryptBuffer TLS1_1ParamBuffer[] =
        @ {
        @     {
        @         (ULONG)@<PRF_LABEL>.GetSize (), KDF_TLS_PRF_LABEL, (PVOID)@<PRF_LABEL>.GetPtr (),
        @     }, {
        @         (ULONG)@<PRF种子>.GetSize (), KDF_TLS_PRF_SEED, (PVOID)@<PRF种子>.GetPtr (),
        @     }
        @ };
        @ BCryptBufferDesc ParamList[] { BCRYPTBUFFER_VERSION, 2, TLS1_1ParamBuffer };
        @ return @<密钥派生函数> (@<密钥>, (INT_P)&ParamList, @<派生密钥长度>, @<CNG_算法类型.密钥派生_TLS1_1>);
    }

    方法 密钥派生_TLS1_2 <公开 静态 类型 = 字节集类 注释 = "使用TLS1_2密钥派生算法从哈希值中派生密钥." 注释 = "密钥派生函数(KDF)使用伪随机函数从主密钥派生一个或多个密钥."
            注释 = "可用于将密钥扩展到更长的密钥或获得所需格式的密钥." 注释 = "最低系统要求: Windows 8" 返回值注释 = "返回派生的密钥,失败返回空字节集类." 折叠 @禁止流程检查 = 真>
    参数 密钥 <类型 = 字节集类 注释 = "所欲派生密钥的主密钥">
    参数 PRF标签 <类型 = 文本型>
    参数 PRF种子 <类型 = 字节集类 注释 = "建议为64个字节长度">
    参数 派生密钥长度 <类型 = 整数 注释 = "派生密钥的长度,最大长度为688" @默认值 = 128>
    参数 哈希算法 <类型 = CNG_算法类型 注释 = "请使用\"CNG_算法类型.哈希_\",必须为SHA256或以上." @默认值 = CNG_算法类型.哈希_SHA512>
    {
        变量 PRF_LABEL <类型 = 字节集类>
        PRF_LABEL = 文本到多字节 (PRF标签, 真)
        @ BCryptBuffer TLS1_2ParamBuffer[] =
        @ {
        @     {
        @         sizeof(@<哈希算法>), KDF_HASH_ALGORITHM, (PVOID)@<哈希算法>.GetText (),
        @     }, {
        @         (ULONG)@<PRF_LABEL>.GetSize (), KDF_TLS_PRF_LABEL, (PVOID)@<PRF_LABEL>.GetPtr (),
        @     }, {
        @         (ULONG)@<PRF种子>.GetSize (), KDF_TLS_PRF_SEED, (PVOID)@<PRF种子>.GetPtr (),
        @     }
        @ };
        @ BCryptBufferDesc ParamList[] { BCRYPTBUFFER_VERSION, 3, TLS1_2ParamBuffer };
        @ return @<密钥派生函数> (@<密钥>, (INT_P)&ParamList, @<派生密钥长度>, @<CNG_算法类型.密钥派生_TLS1_2>);
    }

    方法 "//密钥派生_HKDF" <公开 静态 类型 = 字节集类 注释 = "!!!不起作用,需要修复!!!" 注释 = "(挖坑: 找不到资料,不知道怎样实现)"
            注释 = "使用HKDF密钥派生算法从哈希值中派生密钥." 注释 = "密钥派生函数(KDF)使用伪随机函数从主密钥派生一个或多个密钥."
            注释 = "可用于将密钥扩展到更长的密钥或获得所需格式的密钥." 注释 = "最低系统要求: Windows 10" 返回值注释 = "返回派生的密钥,失败返回空字节集类." 折叠
            @禁止流程检查 = 真>
    参数 密钥 <类型 = 字节集类 注释 = "所欲派生密钥的主密钥">
    参数 HKDF信息 <类型 = 字节集类 @默认值 = 空对象>
    参数 派生密钥长度 <类型 = 整数 注释 = "派生密钥的长度. PBKDF2派生的密码长度没有限制." @默认值 = 128>
    {
        @ BCryptBuffer PBKDF2ParamBuffer[] =
        @ {
        @     {
        @         (ULONG)@<HKDF信息>.GetSize (), 0x14, (PVOID)@<HKDF信息>.GetPtr (),
        @     }
        @ };
        @ BCryptBufferDesc ParamList[] { BCRYPTBUFFER_VERSION, 1, PBKDF2ParamBuffer };
        @ return @<密钥派生函数> (@<密钥>, (INT_P)&ParamList, @<派生密钥长度>, @<CNG_算法类型.密钥派生_HKDF>);
    }
}

类 CNG_算法类型 <公开 注释 = "CNG的算法类型" 折叠 @文档 = "category = \"CNG加解密.辅助类\"" @常量类 = 文本型>
{
    常量 对称加密_3DES <公开 值 = @BCRYPT_3DES_ALGORITHM
            注释 = "The triple data encryption standard symmetric encryption algorithm."
            注释 = "Standard: SP800-67, SP800-38A">
    常量 对称加密_3DES_112 <公开 值 = @BCRYPT_3DES_112_ALGORITHM
            注释 = "The 112-bit triple data encryption standard symmetric encryption algorithm."
            注释 = "Standard: SP800-67, SP800-38A">
    常量 对称加密_AES <公开 值 = @BCRYPT_AES_ALGORITHM
            注释 = "The advanced encryption standard symmetric encryption algorithm." 注释 = "Standard: FIPS 197">
    常量 对称加密_AES_GMAC <公开 值 = @BCRYPT_AES_GMAC_ALGORITHM
            注释 = "The advanced encryption standard (AES) Galois message authentication code (GMAC) symmetric encryption algorithm."
            注释 = "Standard: SP800-38D"
            注释 = "Windows Vista: This algorithm is supported beginning with Windows Vista with SP1.">
    常量 对称加密_AES_CMAC <公开 值 = @BCRYPT_AES_CMAC_ALGORITHM
            注释 = "The advanced encryption standard (AES) cipher based message authentication code (CMAC) symmetric encryption algorithm."
            注释 = "Standard: SP 800-38B" 注释 = "Windows 8: Support for this algorithm begins.">
    常量 对称加密_DES <公开 值 = @BCRYPT_DES_ALGORITHM
            注释 = "The data encryption standard symmetric encryption algorithm."
            注释 = "Standard: FIPS 46-3, FIPS 81">
    常量 对称加密_DESX <公开 值 = @BCRYPT_DESX_ALGORITHM
            注释 = "The extended data encryption standard symmetric encryption algorithm." 注释 = "Standard: None">
    常量 对称加密_RC2 <公开 值 = @BCRYPT_RC2_ALGORITHM 注释 = "The RC2 block symmetric encryption algorithm."
            注释 = "Standard: RFC 2268">
    常量 对称加密_RC4 <公开 值 = @BCRYPT_RC4_ALGORITHM 注释 = "The RC4 symmetric encryption algorithm."
            注释 = "Standard: Various">
    常量 对称加密_XTS_AES <公开 值 = "XTS-AES"
            注释 = "The advanced encryption standard symmetric encryption algorithm in XTS mode."
            注释 = "Standard: SP-800-38E, IEEE Std 1619-2007."
            注释 = "Windows 10: Support for this algorithm begins.">
    常量 ""
    常量 哈希_MD2 <公开 值 = @BCRYPT_MD2_ALGORITHM 注释 = "The MD2 hash algorithm." 注释 = "Standard: RFC 1319">
    常量 哈希_MD4 <公开 值 = @BCRYPT_MD4_ALGORITHM 注释 = "The MD4 hash algorithm." 注释 = "Standard: RFC 1320">
    常量 哈希_MD5 <公开 值 = @BCRYPT_MD5_ALGORITHM 注释 = "The MD5 hash algorithm." 注释 = "Standard: RFC 1321">
    常量 哈希_SHA1 <公开 值 = @BCRYPT_SHA1_ALGORITHM 注释 = "The 160-bit secure hash algorithm."
            注释 = "Standard: FIPS 180-2, FIPS 198.">
    常量 哈希_SHA256 <公开 值 = @BCRYPT_SHA256_ALGORITHM 注释 = "The 256-bit secure hash algorithm."
            注释 = "Standard: FIPS 180-2, FIPS 198.">
    常量 哈希_SHA384 <公开 值 = @BCRYPT_SHA384_ALGORITHM 注释 = "The 384-bit secure hash algorithm."
            注释 = "Standard: FIPS 180-2, FIPS 198.">
    常量 哈希_SHA512 <公开 值 = @BCRYPT_SHA512_ALGORITHM 注释 = "The 512-bit secure hash algorithm."
            注释 = "Standard: FIPS 180-2, FIPS 198.">
    常量 ""
    常量 公钥_RSA <公开 值 = @BCRYPT_RSA_ALGORITHM 注释 = "The RSA public key algorithm."
            注释 = "Standard: PKCS #1 v1.5 and v2.0."
            注释 = "The key size must be greater than or equal to 512 bits, less than or equal to 16384 bits, and must be a multiple of 64.">
    常量 密钥交换_DH <公开 值 = @BCRYPT_DH_ALGORITHM 注释 = "The Diffie-Hellman key exchange algorithm."
            注释 = "Standard: PKCS #3"
            注释 = "The key size must be greater than or equal to 512 bits, less than or equal to 4096 bits, and must be a multiple of 64.">
    常量 密钥交换_ECDH_P256 <公开 值 = @BCRYPT_ECDH_P256_ALGORITHM
            注释 = "The 256-bit prime elliptic curve Diffie-Hellman key exchange algorithm."
            注释 = "Standard: SP800-56A" 注释 = "The key size must be 256 bits.">
    常量 密钥交换_ECDH_P384 <公开 值 = @BCRYPT_ECDH_P384_ALGORITHM
            注释 = "The 384-bit prime elliptic curve Diffie-Hellman key exchange algorithm."
            注释 = "Standard: SP800-56A" 注释 = "The key size must be 384 bits.">
    常量 密钥交换_ECDH_P521 <公开 值 = @BCRYPT_ECDH_P521_ALGORITHM
            注释 = "The 521-bit prime elliptic curve Diffie-Hellman key exchange algorithm."
            注释 = "Standard: SP800-56A" 注释 = "The key size must be 521 bits.">
    常量 密钥交换_ECDH <公开 值 = "ECDH"
            注释 = "Generic prime elliptic curve Diffie-Hellman key exchange algorithm (see Remarks for more information)."
            注释 = "Standard: SP800-56A.">
    常量 ""
    常量 数字签名_ECDSA_P256 <公开 值 = @BCRYPT_ECDSA_P256_ALGORITHM
            注释 = "The 256-bit prime elliptic curve digital signature algorithm (FIPS 186-2)."
            注释 = "Standard: FIPS 186-2, X9.62" 注释 = "The key size must be 256 bits.">
    常量 数字签名_ECDSA_P384 <公开 值 = @BCRYPT_ECDSA_P384_ALGORITHM
            注释 = "The 384-bit prime elliptic curve digital signature algorithm (FIPS 186-2)."
            注释 = "Standard: FIPS 186-2, X9.62" 注释 = "The key size must be 384 bits.">
    常量 数字签名_ECDSA_P521 <公开 值 = @BCRYPT_ECDSA_P521_ALGORITHM
            注释 = "The 521-bit prime elliptic curve digital signature algorithm (FIPS 186-2)."
            注释 = "Standard: FIPS 186-2, X9.62" 注释 = "The key size must be 521 bits.">
    常量 数字签名_DSA <公开 值 = @BCRYPT_DSA_ALGORITHM 注释 = "The digital signature algorithm."
            注释 = "Standard: FIPS 186-2"
            注释 = "Prior to Windows 8, the key size must be greater than or equal to 512 bits, less than or equal to 1024 bits, and must be a multiple of 64."
            注释 = "Beginning with Windows 8, the key size must be greater than or equal to 512 bits, less than or equal to 3072 bits, and must be a multiple of 64."
            注释 = "Processing for key sizes less than or equal to 1024 bits adheres to FIPS 186-2."
            注释 = "Processing for key sizes greater than 1024 and less than or equal to 3072 adheres to FIPS 186-3.">
    常量 数字签名_ECDSA <公开 值 = "ECDSA"
            注释 = "Generic prime elliptic curve digital signature algorithm (see Remarks for more information)."
            注释 = "Standard: ANSI X9.62." 注释 = "#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)">
    常量 数字签名_RSA <公开 值 = @BCRYPT_RSA_SIGN_ALGORITHM
            注释 = "The RSA signature algorithm. This algorithm is not currently supported. You can use the BCRYPT_RSA_ALGORITHM algorithm to perform RSA signing operations."
            注释 = "Standard: PKCS #1 v1.5 and v2.0.">
    常量 ""
    常量 随机数_RNG <公开 值 = @BCRYPT_RNG_ALGORITHM 注释 = "The random-number generator algorithm."
            注释 = "Standard: FIPS 186-2, FIPS 140-2, NIST SP 800-90" 注释 = "[!Note]"
            注释 = "Beginning with Windows Vista with SP1 and Windows Server 2008, the random number generator is based on the AES counter mode specified in the NIST SP 800-90 standard."
            注释 = ""
            注释 = "Windows Vista: The random number generator is based on the hash-based random number generator specified in the FIPS 186-2 standard."
            注释 = "Windows 8: Beginning with Windows 8, the RNG algorithm supports FIPS 186-3. Keys less than or equal to 1024 bits adhere to FIPS 186-2 and keys greater than 1024 to FIPS 186-3.">
    常量 随机数_DUALECRNG <公开 值 = @BCRYPT_RNG_DUAL_EC_ALGORITHM
            注释 = "The dual elliptic curve random-number generator algorithm." 注释 = "Standard: SP800-90."
            注释 = "Windows 8: Beginning with Windows 8, the EC RNG algorithm supports FIPS 186-3. Keys less than or equal to 1024 bits adhere to FIPS 186-2 and keys greater than 1024 to FIPS 186-3."
            注释 = "Windows 10: Beginning with Windows 10, the dual elliptic curve random number generator algorithm has been removed. Existing uses of this algorithm will continue to work; however, the random number generator is based on the AES counter mode specified in the NIST SP 800-90 standard. New code should use BCRYPT_RNG_ALGORITHM, and it is recommended that existing code be changed to use BCRYPT_RNG_ALGORITHM.">
    常量 随机数_FIPS186DSARNG <公开 值 = @BCRYPT_RNG_FIPS186_DSA_ALGORITHM
            注释 = "The random-number generator algorithm suitable for DSA (Digital Signature Algorithm)."
            注释 = "Standard: FIPS 186-2." 注释 = "Windows 8: Support for FIPS 186-3 begins.">
    常量 ""
    常量 密钥派生_CAPI <公开 值 = "CAPI_KDF" 注释 = "Crypto API (CAPI) key derivation function algorithm.">
    常量 密钥派生_PBKDF2 <公开 值 = "PBKDF2" 注释 = "Password-based key derivation function 2 (PBKDF2) algorithm.">
    常量 密钥派生_SP800108 <公开 值 = "SP800_108_CTR_HMAC"
            注释 = "Counter mode, hash-based message authentication code (HMAC) key derivation function algorithm.">
    常量 密钥派生_SP800_56A <公开 值 = "SP800_56A_CONCAT" 注释 = "SP800-56A key derivation function algorithm.">
    常量 密钥派生_TLS1_1 <公开 值 = "TLS1_1_KDF">
    常量 密钥派生_TLS1_2 <公开 值 = "TLS1_2_KDF">
    常量 密钥派生_HKDF <公开 值 = "HKDF" 注释 = "WIN10_RS4">

    #
}

类 CNG_链接模式 <公开 注释 = "CNG加密算法的加密分组链接模式" 折叠 @文档 = "category = \"CNG加解密.辅助类\"" @常量类 = 文本型>
{
    常量 无 <公开 值 = @BCRYPT_CHAIN_MODE_NA 注释 = "此算法不支持链接模式">
    常量 CBC <公开 值 = @BCRYPT_CHAIN_MODE_CBC 注释 = "将算法的链接模式设置为加密块链接">
    常量 ECB <公开 值 = @BCRYPT_CHAIN_MODE_ECB 注释 = "将算法的链接模式设置为电子密码本">
    常量 CFB <公开 值 = @BCRYPT_CHAIN_MODE_CFB 注释 = "将算法的链接模式设置为密码反馈">
    常量 CCM <公开 值 = @BCRYPT_CHAIN_MODE_CCM 注释 = "将算法的链接模式设置为带CBC-MAC的计数器模式(CCM)."
            注释 = "注: Windows Vista SP1之后才支持本模式.">
    常量 GCM <公开 值 = @BCRYPT_CHAIN_MODE_GCM 注释 = "将算法的链接模式设置为伽罗瓦计数器模式(GCM)."
            注释 = "注: Windows Vista SP1之后才支持本模式.">
}

类 CNG_填充方式 <公开 注释 = "CNG的数据填充方式,部分加解密算法需要填充数据来对齐块大小" 折叠 @文档 = "category = \"CNG加解密.辅助类\"" @常量类 = 整数>
{
    常量 对称_无填充 <公开 值 = 0x00000110 注释 = "不进行任何填充,如果数据本身没有对齐,加密/解密会失败.">
    常量 对称_零填充 <公开 值 = -1 注释 = "即ZeroPadding,在数据对齐时使用0补位." 注释 = "用这种填充方式加密的数据在解密后,尾部会有冗余数据.">
    常量 对称_PKCS7 <公开 值 = @BCRYPT_BLOCK_PADDING 注释 = "PKCS#7块填充,仅对称加密可用.允许加密算法将数据填充到下一个块大小."
            注释 = "如果未指定此标志,则cbInput参数中指定的纯文本大小必须是算法块大小的倍数."
            注释 = "可以通过调用BCryptGetProperty函数来获取密钥的BCRYPT_BLOCK_LENGTH属性来获取块大小,这将为算法提供块的大小."
            注释 = "此标志不得与经过身份验证的加密模式(AES-CCM和AES-GCM)一起使用." 注释 = "BCryptEncrypt/Decrypt">
    常量 对称_块填充 <公开 值 = @BCRYPT_BLOCK_PADDING 注释 = "PKCS#7块填充,仅对称加密可用.允许加密算法将数据填充到下一个块大小."
            注释 = "如果未指定此标志,则cbInput参数中指定的纯文本大小必须是算法块大小的倍数."
            注释 = "可以通过调用BCryptGetProperty函数来获取密钥的BCRYPT_BLOCK_LENGTH属性来获取块大小,这将为算法提供块的大小."
            注释 = "此标志不得与经过身份验证的加密模式(AES-CCM和AES-GCM)一起使用." 注释 = "BCryptEncrypt/Decrypt">
    常量 非对称_无填充 <公开 值 = @BCRYPT_PAD_NONE 注释 = "仅非对称加密可用. 不进行任何填充,不使用pPaddingInfo参数."
            注释 = "cbInput参数中指定的明文大小必须是算法块大小的倍数.">
    常量 非对称_PKCS1 <公开 值 = @BCRYPT_PAD_PKCS1 注释 = "仅非对称加密可用. 数据将填充一个随机数,以完善块大小.不使用pPaddingInfo参数."
            注释 = "BCryptEncrypt/Decrypt BCryptSignHash/VerifySignature">
    常量 非对称_OAEP <公开 值 = @BCRYPT_PAD_OAEP
            注释 = "仅非对称加密可用. 使用最佳非对称加密填充(OAEP)方案.pPaddingInfo参数是指向BCRYPT_OAEP_PADDING_INFO结构的指针."
            注释 = "BCryptEncrypt/Decrypt">
    常量 非对称_PSS <公开 值 = @BCRYPT_PAD_PSS 注释 = "BCryptSignHash/VerifySignature">
    常量 非对称_PKCS1_OPTIONAL_HASH_OID <公开 值 = 0x00000010 注释 = "BCRYPT_PAD_PKCS1_OPTIONAL_HASH_OID"
            注释 = "BCryptVerifySignature">
}

类 CNG_密钥类型 <公开 注释 = "CNG的密钥类型" 折叠 @文档 = "category = \"CNG加解密.辅助类\"" @常量类 = 文本型>
{
    常量 AES_WRAP_KEY <公开 值 = "Rfc3565KeyWrapBlob" 注释 = "Export an AES key wrapped key."
            注释 = "The hExportKey parameter must reference a valid BCRYPT_KEY_HANDLE pointer to the key encryption key,"
            注释 = "and the key represented by the hKey parameter must be a multiple of 8 bytes long."
            注释 = "Windows Server 2008 and Windows Vista:  This BLOB type is not supported.">
    常量 DH_私钥 <公开 值 = @BCRYPT_DH_PRIVATE_BLOB 注释 = "Export a Diffie-Hellman public/private key pair."
            注释 = "The pbOutput buffer receives a BCRYPT_DH_KEY_BLOB structure immediately followed by the key data.">
    常量 DH_公钥 <公开 值 = @BCRYPT_DH_PUBLIC_BLOB 注释 = "Export a Diffie-Hellman public key."
            注释 = "The pbOutput buffer receives a BCRYPT_DH_KEY_BLOB structure immediately followed by the key data.">
    常量 DSA_私钥 <公开 值 = @BCRYPT_DSA_PRIVATE_BLOB 注释 = "Export a DSA public/private key pair."
            注释 = "The pbOutput buffer receives a BCRYPT_DSA_KEY_BLOB or BCRYPT_DSA_KEY_BLOB_V2 structure immediately followed by the key data."
            注释 = "BCRYPT_DSA_KEY_BLOB is used for key lengths from 512 to 1024 bits."
            注释 = "BCRYPT_DSA_KEY_BLOB_V2 is used for key lengths that exceed 1024 bits but are less than or equal to 3072 bits."
            注释 = "Windows 8:  Support for BCRYPT_DSA_KEY_BLOB_V2 begins.">
    常量 DSA_公钥 <公开 值 = @BCRYPT_DSA_PUBLIC_BLOB 注释 = "Export a DSA public key."
            注释 = "The pbOutput buffer receives a BCRYPT_DSA_KEY_BLOB or BCRYPT_DSA_KEY_BLOB_V2 structure immediately followed by the key data."
            注释 = "BCRYPT_DSA_KEY_BLOB is used for key lengths from 512 to 1024 bits."
            注释 = "BCRYPT_DSA_KEY_BLOB_V2 is used for key lengths that exceed 1024 bits but are less than or equal to 3072 bits."
            注释 = "Windows 8:  Support for BCRYPT_DSA_KEY_BLOB_V2 begins.">
    常量 ECC_私钥 <公开 值 = @BCRYPT_ECCPRIVATE_BLOB
            注释 = "Export an elliptic curve cryptography (ECC) private key."
            注释 = "The pbOutput buffer receives a BCRYPT_ECCKEY_BLOB structure immediately followed by the key data.">
    常量 ECC_公钥 <公开 值 = @BCRYPT_ECCPUBLIC_BLOB 注释 = "Export an ECC public key."
            注释 = "The pbOutput buffer receives a BCRYPT_ECCKEY_BLOB structure immediately followed by the key data.">
    常量 KEY_DATA <公开 值 = @BCRYPT_KEY_DATA_BLOB 注释 = "Export a symmetric key to a data BLOB."
            注释 = "The pbOutput buffer receives a BCRYPT_KEY_DATA_BLOB_HEADER structure immediately followed by the key BLOB.">
    常量 OPAQUE_KEY <公开 值 = @BCRYPT_OPAQUE_KEY_BLOB
            注释 = "Export a symmetric key in a format that is specific to a single cryptographic service provider (CSP)."
            注释 = "Opaque BLOBs are not transferable and must be imported by using the same CSP that generated the BLOB."
            注释 = "Opaque BLOBs are only intended to be used for interprocess transfer of keys and are not suitable to be persisted and read across versions of a provider.">
    常量 通用公钥 <公开 值 = @BCRYPT_PUBLIC_KEY_BLOB 注释 = "Export a generic public key of any type."
            注释 = "The type of key in this BLOB is determined by the Magic member of the BCRYPT_KEY_BLOB structure.">
    常量 通用私钥 <公开 值 = @BCRYPT_PRIVATE_KEY_BLOB 注释 = "Export a generic private key of any type."
            注释 = "The private key does not necessarily contain the public key."
            注释 = "The type of key in this BLOB is determined by the Magic member of the BCRYPT_KEY_BLOB structure.">
    常量 RSA_完整私钥 <公开 值 = @BCRYPT_RSAFULLPRIVATE_BLOB 注释 = "Export a full RSA public/private key pair."
            注释 = "The pbOutput buffer receives a BCRYPT_RSAKEY_BLOB structure immediately followed by the key data."
            注释 = "This BLOB will include additional key material compared to the BCRYPT_RSAPRIVATE_BLOB type.">
    常量 RSA_私钥 <公开 值 = @BCRYPT_RSAPRIVATE_BLOB 注释 = "Export an RSA public/private key pair."
            注释 = "The pbOutput buffer receives a BCRYPT_RSAKEY_BLOB structure immediately followed by the key data.">
    常量 RSA_公钥 <公开 值 = @BCRYPT_RSAPUBLIC_BLOB 注释 = "Export an RSA public key."
            注释 = "The pbOutput buffer receives a BCRYPT_RSAKEY_BLOB structure immediately followed by the key data.">
    常量 DH_私钥_旧版 <公开 值 = @LEGACY_DH_PRIVATE_BLOB
            注释 = "Export a legacy Diffie-Hellman Version 3 Private Key BLOB that contains a Diffie-Hellman public/private key pair that can be imported by using CryptoAPI.">
    常量 DH_公钥_旧版 <公开 值 = @LEGACY_DH_PUBLIC_BLOB
            注释 = "Export a legacy Diffie-Hellman Version 3 Public Key BLOB that contains a Diffie-Hellman public key that can be imported by using CryptoAPI."
            注释 = "">
    常量 DSA_私钥_旧版 <公开 值 = @LEGACY_DSA_PRIVATE_BLOB
            注释 = "Export a DSA public/private key pair in a form that can be imported by using CryptoAPI.">
    常量 DSA_公钥_旧版 <公开 值 = @LEGACY_DSA_PUBLIC_BLOB
            注释 = "Export a DSA public key in a form that can be imported by using CryptoAPI.">
    常量 DSA_V2_私钥_旧版 <公开 值 = @LEGACY_DSA_V2_PRIVATE_BLOB
            注释 = "Export a DSA version 2 private key in a form that can be imported by using CryptoAPI.">
    常量 RSA_私钥_旧版 <公开 值 = @LEGACY_RSAPRIVATE_BLOB
            注释 = "Export an RSA public/private key pair in a form that can be imported by using CryptoAPI.">
    常量 RSA_公钥_旧版 <公开 值 = @LEGACY_RSAPUBLIC_BLOB
            注释 = "Export an RSA public key in a form that can be imported by using CryptoAPI.">
}

类 CNG_RSA填充 <公开 注释 = "RSA加解密专用的填充方式" 折叠 @文档 = "category = \"CNG加解密.辅助类\"" @常量类 = 整数>
{
    常量 ROUTER <公开 值 = @BCRYPT_SUPPORTED_PAD_ROUTER 注释 = "让提供程序支持通过路由器添加填充">
    常量 PKCS1 <公开 值 = @BCRYPT_SUPPORTED_PAD_PKCS1_ENC 注释 = "让提供程序支持PKCS1加密填充方案">
    常量 "//PKCS1_SIG" <公开 值 = @BCRYPT_SUPPORTED_PAD_PKCS1_SIG 注释 = "让提供程序支持PKCS1签名填充方案">
    常量 OAEP <公开 值 = @BCRYPT_SUPPORTED_PAD_OAEP 注释 = "让提供程序支持OAEP填充方案">
    常量 PSS <公开 值 = @BCRYPT_SUPPORTED_PAD_PSS 注释 = "让提供程序支持PSS填充方案">
}

#
