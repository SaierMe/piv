<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "  7-zip  https://github.com/rikyoz/bit7z" 注释 = "  bit7z  https://www.7-zip.org"
        注释 = "  本类库需要依赖bit7z的lib静态库和\"7z.dll\"文件,其中dll文件是" 注释 = "从7-zip官网下载,使用VS 2017编译器和32位时支持XP."
        注释 = "  bit7z的很多方法都会抛出异常,封装时已经在内部俘获了大部分异" 注释 = "常,其他少量异常请自行俘获或者严格做好判断吧.">

# 7-zip: 23.01        2023-06-20  开源协议: GNU LGPL
# bit7z: v4.0.5       2023-12-23  开源协议: MPL-2.0

类 存档读写类 <公开 基础类 = PIV对象类 注释 = "提供简单易用的压缩和解压命令,只需要调用一个方法即可完成压缩或解压."
        注释 = "功能没有\"存档解压类\"和\"存档压缩类\"全面,也没有进度反馈,但胜在简单." 折叠 @文档 = "category = \"文件压缩\"" @禁止创建对象 = 真
        @视窗.外部头文件 = "bit7z\\include\\piv_bit7z.hpp" @视窗.外部库 = "bit7z\\lib\\$(p)\\$(d)\\bit7z_$(crt).lib"
        @视窗.附属文件 = "bit7z\\lib\\$(p)\\7z.dll" @视窗.需求VS版本 = "15-"
        @视窗.需求系统头文件 = "user\\piv\\bit7z\\lib\\$(p)\\$(d)\\bit7z_$(crt).lib | 缺少bit7z的静态库文件(文件太大，默认未安装),请自行下载安装PIV模块的附加静态库文件 https://piv.ink/volpiv/">
{
    方法 加载动态库 <公开 静态 类型 = 逻辑型 注释 = "程序默认在执行本类库的任意方法时会自动加载与程序文件同位置的\"7z.dll\"文件."
            注释 = "如果你想将\"7z.dll\"放在其他位置或更改dll的名称,请在执行其他方法前调用本方法手动加载." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 动态库路径 <类型 = 文本型>
    {
        @ Piv7zLib::data().Load(@<动态库路径>)
    }

    方法 卸载动态库 <公开 静态 注释 = "手动卸载7z的动态库,一般不需要执行本方法." 折叠 @嵌入式方法 = "">
    {
        @ Piv7zLib::data().Free()
    }

    方法 取最后错误 <公开 静态 类型 = 文本型 注释 = "返回最后一次操作的错误信息,返回\"OK\"表示操作成功无错误." 注释 = "本方法线程安全." 折叠 @嵌入式方法 = "">
    {
        @ PivArchiveOperate::GetLastError()
    }

    # 压缩 ---

    方法 添加到压缩包 <公开 静态 类型 = 逻辑型 注释 = "将提供的文件和目录添加到压缩包中" 返回值注释 = "返回是否压缩成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 路径数组 <类型 = 文本数组类 注释 = "所欲压缩的路径数组;" 注释 = "提供的相对或绝对路径必须指向存在的文件或目录,否则会失败.">
    参数 输出文件名 <类型 = 文本型 注释 = "输出压缩文件的相对或绝对路径">
    参数 压缩密码 <类型 = 文本型 注释 = "设置压缩密码,只有SevenZip和Zip格式支持设置密码." @默认值 = "">
    参数 压缩格式 <类型 = 存档输出格式 注释 = "设置压缩格式;" 注释 = "注意BZip2、GZip、Xz格式只能压缩单个文件,提供了多个文件路径或目录就会失败."
            @默认值 = 存档输出格式.SevenZip>
    参数 压缩等级 <类型 = 存档压缩等级 注释 = "设置压缩等级,会影响压缩速度和压缩包大小;" 注释 = "其中Wim和Tar格式不支持设置压缩等级,会无视该参数;"
            注释 = "还有一些格式不支持\"仅存储\"或\"极速压缩\",使用了会返回失败." @默认值 = 存档压缩等级.标准压缩>
    参数 更新方式 <类型 = 存档更新方式 注释 = "如果目标压缩包已经存在,选择以何种方式更新目标压缩包的内容;" 注释 = "BZip2、GZip、Xz不支持更新模式,若压缩包已存在就会返回失败."
            @默认值 = 存档更新方式.添加并替换文件>
    {
        @ PivArchiveOperate::CompressPaths(@<路径数组>.data(), @<输出文件名>, @<压缩密码>, piv::Archive::GetOutFormat(@<压缩格式>), @<压缩等级>, @<更新方式>)
    }

    方法 添加别名到压缩包 <公开 静态 类型 = 逻辑型 注释 = "将提供的文件和目录路径以别名的方式添加到压缩包中" 返回值注释 = "返回是否压缩成功,失败时可调用\"取最后错误\"获取错误信息."
            折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 路径键值对 <类型 = 文本到文本哈希表 注释 = "所欲压缩的路径到别名键值对;" 注释 = "其中键为文件或目录的相对或绝对路径,值为相对路径的别名;"
            注释 = "提供的键名必须指向存在的文件或目录,否则会失败.">
    参数 输出文件名 <类型 = 文本型 注释 = "输出压缩文件的相对或绝对路径">
    参数 压缩密码 <类型 = 文本型 注释 = "设置压缩密码,只有SevenZip和Zip格式支持设置密码." @默认值 = "">
    参数 压缩格式 <类型 = 存档输出格式 注释 = "设置压缩格式;" 注释 = "注意BZip2、GZip、Xz格式只能压缩单个文件,提供了多个文件路径或目录就会失败."
            @默认值 = 存档输出格式.SevenZip>
    参数 压缩等级 <类型 = 存档压缩等级 注释 = "设置压缩等级,会影响压缩速度和压缩包大小;" 注释 = "其中Wim和Tar格式不支持设置压缩等级,会无视该参数;"
            注释 = "还有一些格式不支持\"仅存储\"或\"极速压缩\",使用了会返回失败." @默认值 = 存档压缩等级.标准压缩>
    参数 更新方式 <类型 = 存档更新方式 注释 = "如果目标压缩包已经存在,选择以何种方式更新目标压缩包的内容;" 注释 = "BZip2、GZip、Xz不支持更新模式,若压缩包已存在就会返回失败."
            @默认值 = 存档更新方式.添加并替换文件>
    {
        @ PivArchiveOperate::CompressPaths(@<路径键值对>.m_map, @<输出文件名>, @<压缩密码>, piv::Archive::GetOutFormat(@<压缩格式>), @<压缩等级>, @<更新方式>)
    }

    方法 添加文件到压缩包 <公开 静态 类型 = 逻辑型 注释 = "将提供的文件数组添加到压缩包中,本方法会忽略数组中的目录路径."
            返回值注释 = "返回是否压缩成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 路径数组 <类型 = 文本数组类 注释 = "所欲压缩的文件路径数组;" 注释 = "提供的相对或绝对路径必须指向存在的文件,否则会失败;" 注释 = "本方法只支持添加文件,数组中的目录将被忽略.">
    参数 输出文件名 <类型 = 文本型 注释 = "输出压缩文件的相对或绝对路径">
    参数 压缩密码 <类型 = 文本型 注释 = "设置压缩密码,只有SevenZip和Zip格式支持设置密码." @默认值 = "">
    参数 压缩格式 <类型 = 存档输出格式 注释 = "设置压缩格式;" 注释 = "注意BZip2、GZip、Xz格式只能压缩单个文件,提供了多个文件路径或目录就会失败."
            @默认值 = 存档输出格式.SevenZip>
    参数 压缩等级 <类型 = 存档压缩等级 注释 = "设置压缩等级,会影响压缩速度和压缩包大小;" 注释 = "其中Wim和Tar格式不支持设置压缩等级,会无视该参数;"
            注释 = "还有一些格式不支持\"仅存储\"或\"极速压缩\",使用了会返回失败." @默认值 = 存档压缩等级.标准压缩>
    参数 更新方式 <类型 = 存档更新方式 注释 = "如果目标压缩包已经存在,选择以何种方式更新目标压缩包的内容;" 注释 = "BZip2、GZip、Xz不支持更新模式,若压缩包已存在就会返回失败."
            @默认值 = 存档更新方式.添加并替换文件>
    {
        @ PivArchiveOperate::compressFiles(@<路径数组>, @<输出文件名>, @<压缩密码>, piv::Archive::GetOutFormat(@<压缩格式>), @<压缩等级>, @<更新方式>)
    }

    方法 添加匹配文件到压缩包 <公开 静态 类型 = 逻辑型 注释 = "将指定目录中的文件添加到压缩包中,可以选择是否递归添加子目录,以及使用通配符筛选添加文件."
            注释 = "本方法只支持SevenZip、Zip、Tar、Wim这4个格式." 返回值注释 = "返回是否压缩成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 输入目录 <类型 = 文本型 注释 = "请提供输入目录的相对或绝对路径;" 注释 = "目录中的文件或子目录将被添加到压缩包中,但不包含输入目录本身.">
    参数 输出文件名 <类型 = 文本型 注释 = "输出压缩文件的相对或绝对路径">
    参数 筛选器 <类型 = 文本型 注释 = "用通配符筛选要压缩的部分文件" @默认值 = "*.*">
    参数 递归子目录 <类型 = 逻辑型 注释 = "是否递归搜寻\"输入目录\"下所有子目录中的文件" @默认值 = 真>
    参数 压缩密码 <类型 = 文本型 注释 = "设置压缩密码,只有SevenZip和Zip格式支持设置密码." @默认值 = "">
    参数 压缩格式 <类型 = 存档输出格式 注释 = "设置压缩格式;" 注释 = "注意BZip2、GZip、Xz格式只能压缩单个文件,提供了多个文件路径或目录就会失败."
            @默认值 = 存档输出格式.SevenZip>
    参数 压缩等级 <类型 = 存档压缩等级 注释 = "设置压缩等级,会影响压缩速度和压缩包大小;" 注释 = "其中Wim和Tar格式不支持设置压缩等级,会无视该参数;"
            注释 = "还有一些格式不支持\"仅存储\"或\"极速压缩\",使用了会返回失败." @默认值 = 存档压缩等级.标准压缩>
    参数 更新方式 <类型 = 存档更新方式 注释 = "如果目标压缩包已经存在,选择以何种方式更新目标压缩包的内容;" 注释 = "BZip2、GZip、Xz不支持更新模式,若压缩包已存在就会返回失败."
            @默认值 = 存档更新方式.添加并替换文件>
    {
        @ PivArchiveOperate::compressFiles(@<输入目录>, @<输出文件名>, @<筛选器>, @<递归子目录>, @<压缩密码>, piv::Archive::GetOutFormat(@<压缩格式>), @<压缩等级>, @<更新方式>)
    }

    方法 添加目录到压缩包 <公开 静态 类型 = 逻辑型 注释 = "将指定的整个目录添加到压缩包中." 注释 = "本方法只支持SevenZip、Zip、Tar、Wim这4个格式."
            返回值注释 = "返回是否压缩成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 输入目录 <类型 = 文本型 注释 = "请提供输入目录的相对或绝对路径;" 注释 = "目录自身和其中的所有文件和子目录都会被添加到压缩包中.">
    参数 输出文件名 <类型 = 文本型 注释 = "输出压缩文件的相对或绝对路径">
    参数 压缩密码 <类型 = 文本型 注释 = "设置压缩密码,只有SevenZip和Zip格式支持设置密码." @默认值 = "">
    参数 压缩格式 <类型 = 存档输出格式 注释 = "设置压缩格式;" 注释 = "注意BZip2、GZip、Xz格式只能压缩单个文件,提供了多个文件路径或目录就会失败."
            @默认值 = 存档输出格式.SevenZip>
    参数 压缩等级 <类型 = 存档压缩等级 注释 = "设置压缩等级,会影响压缩速度和压缩包大小;" 注释 = "其中Wim和Tar格式不支持设置压缩等级,会无视该参数;"
            注释 = "还有一些格式不支持\"仅存储\"或\"极速压缩\",使用了会返回失败." @默认值 = 存档压缩等级.标准压缩>
    参数 更新方式 <类型 = 存档更新方式 注释 = "如果目标压缩包已经存在,选择以何种方式更新目标压缩包的内容;" 注释 = "BZip2、GZip、Xz不支持更新模式,若压缩包已存在就会返回失败."
            @默认值 = 存档更新方式.添加并替换文件>
    {
        @ PivArchiveOperate::CompressDirectory(@<输入目录>, @<输出文件名>, @<压缩密码>, piv::Archive::GetOutFormat(@<压缩格式>), @<压缩等级>, @<更新方式>)
    }

    # 解压 ---

    方法 解压到 <公开 静态 类型 = 逻辑型 注释 = "将压缩文件完整解压到指定目录" 返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 压缩文件 <类型 = 文本型 注释 = "所欲解压的压缩文件,包含完整路径.">
    参数 输出路径 <类型 = 文本型 注释 = "所欲解压到的位置">
    参数 密码 <类型 = 文本型 注释 = "设置解压密码,如果压缩包没有密码则不会有任何效果." @默认值 = "">
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ PivArchiveOperate::Extract(@<压缩文件>, @<输出路径>, @<密码>, piv::Archive::GetInFormat(@<解压格式>))
    }

    方法 解压到内存 <公开 静态 类型 = 逻辑型 注释 = "将压缩文件的全部内容解压到内存中." 注释 = "请勿使用本方法解压大文件,以免爆内存."
            返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 压缩文件 <类型 = 文本型 注释 = "所欲解压的压缩文件,包含完整路径.">
    参数 解压结果 <类型 = 存档解压键值类 注释 = "解压成功后,内容会保存在此参数中.">
    参数 密码 <类型 = 文本型 注释 = "设置解压密码,如果压缩包没有密码则不会有任何效果." @默认值 = "">
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ PivArchiveOperate::Extract(@<压缩文件>, @<解压结果>, @<密码>, piv::Archive::GetInFormat(@<解压格式>))
    }

    方法 解压匹配文件 <公开 静态 类型 = 逻辑型 注释 = "使用通配符筛选文件,然后将匹配的文件解压到指定目录." 返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息."
            折叠 @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 压缩文件 <类型 = 文本型 注释 = "所欲解压的压缩文件,包含完整路径.">
    参数 筛选器 <类型 = 文本型 注释 = "所欲筛选的文件路径,支持通配符,必须完全一致才能匹配成功；" 注释 = "比如文件在子目录里的必须填写带文件夹的相对路径.">
    参数 输出路径 <类型 = 文本型 注释 = "所欲解压到的位置">
    参数 密码 <类型 = 文本型 注释 = "设置解压密码,如果压缩包没有密码则不会有任何效果." @默认值 = "">
    参数 是否排除匹配项 <类型 = 逻辑型 注释 = "默认为假,表示只解压\"筛选器\"成功匹配的文件;" 注释 = "若设置为真,则会解压所有未匹配的文件." @默认值 = 假>
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ PivArchiveOperate::Extract(@<压缩文件>, @<筛选器>, @<输出路径>, @<密码>, @<是否排除匹配项>, piv::Archive::GetInFormat(@<解压格式>))
    }

    方法 解压匹配文件到字节集 <公开 静态 类型 = 逻辑型 注释 = "使用通配符筛选文件,然后将匹配的第一个文件解压到字节集中."
            返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 压缩文件 <类型 = 文本型 注释 = "所欲解压的压缩文件,包含完整路径.">
    参数 筛选器 <类型 = 文本型 注释 = "所欲筛选的文件路径,支持通配符,必须完全一致才能匹配成功；" 注释 = "比如文件在子目录里的必须填写带文件夹的相对路径.">
    参数 输出数据 <类型 = 字节集类 注释 = "解压成功后,内容会保存在此字节集中.">
    参数 密码 <类型 = 文本型 注释 = "设置解压密码,如果压缩包没有密码则不会有任何效果." @默认值 = "">
    参数 输出文件名 <类型 = 文本型 注释 = "返回最终解压的文件名" @默认值 = 空对象>
    参数 是否排除匹配项 <类型 = 逻辑型 注释 = "默认为假,表示只解压\"筛选器\"成功匹配的第一个文件." 注释 = "若设置为真,则会解压未匹配的第一个文件." @默认值 = 假>
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ PivArchiveOperate::Extract(@<压缩文件>.GetText(), @<筛选器>.GetText(), @<输出数据>, @<密码>.GetText(), @<输出文件名>, @<是否排除匹配项>, piv::Archive::GetInFormat(@<解压格式>))
    }

    方法 解压正则匹配文件 <公开 静态 类型 = 逻辑型 注释 = "使用正则表达式筛选文件,然后将匹配的文件解压到指定目录."
            返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 压缩文件 <类型 = 文本型 注释 = "所欲解压的压缩文件,包含完整路径.">
    参数 正则表达式 <类型 = 文本型 注释 = "用于筛选文件路径的正则表达式">
    参数 输出路径 <类型 = 文本型 注释 = "所欲解压到的位置">
    参数 密码 <类型 = 文本型 注释 = "设置解压密码,如果压缩包没有密码则不会有任何效果." @默认值 = "">
    参数 是否排除匹配项 <类型 = 逻辑型 注释 = "默认为假,表示只解压\"正则表达式\"成功匹配的第一个文件." 注释 = "若设置为真,则会解压未匹配的第一个文件." @默认值 = 假>
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ PivArchiveOperate::ExtractRegex(@<压缩文件>, @<正则表达式>, @<输出路径>, @<密码>, @<是否排除匹配项>, piv::Archive::GetInFormat(@<解压格式>))
    }

    方法 解压正则匹配文件到字节集 <公开 静态 类型 = 逻辑型 注释 = "使用正则表达式筛选文件,然后将匹配的第一个文件解压到字节集中."
            返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 压缩文件 <类型 = 文本型 注释 = "所欲解压的压缩文件,包含完整路径.">
    参数 正则表达式 <类型 = 文本型 注释 = "用于筛选文件路径的正则表达式">
    参数 输出数据 <类型 = 字节集类 注释 = "解压成功后,内容会保存在此字节集中.">
    参数 密码 <类型 = 文本型 注释 = "设置解压密码,如果压缩包没有密码则不会有任何效果." @默认值 = "">
    参数 输出文件名 <类型 = 文本型 注释 = "返回最终解压的文件名" @默认值 = 空对象>
    参数 是否排除匹配项 <类型 = 逻辑型 注释 = "默认为假,表示只解压\"正则表达式\"成功匹配的第一个文件." 注释 = "若设置为真,则会解压未匹配的第一个文件." @默认值 = 假>
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ PivArchiveOperate::ExtractRegex(@<压缩文件>.GetText(), @<正则表达式>.GetText(), @<输出数据>, @<密码>.GetText(),
        @                                 @<输出文件名>, @<是否排除匹配项>, piv::Archive::GetInFormat(@<解压格式>))
    }

    # 解压文件资源 ---

    方法 解压资源到 <公开 静态 类型 = 逻辑型 注释 = "将视窗文件资源的压缩包完整解压到指定目录" 返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 压缩包资源 <类型 = 视窗文件资源 注释 = "所欲解压的视窗文件资源">
    参数 输出路径 <类型 = 文本型 注释 = "所欲解压到的位置">
    参数 密码 <类型 = 文本型 注释 = "设置解压密码,如果压缩包没有密码则不会有任何效果." @默认值 = "">
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ PivArchiveOperate::Extract(@<压缩包资源>, @<输出路径>, @<密码>, piv::Archive::GetInFormat(@<解压格式>))
    }

    方法 解压资源到内存 <公开 静态 类型 = 逻辑型 注释 = "将视窗文件资源的压缩包的全部内容解压到内存中." 注释 = "请勿使用本方法解压大文件,以免爆内存."
            返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 压缩包资源 <类型 = 视窗文件资源 注释 = "所欲解压的视窗文件资源">
    参数 解压结果 <类型 = 存档解压键值类 注释 = "解压成功后,内容会保存在此参数中.">
    参数 密码 <类型 = 文本型 注释 = "设置解压密码,如果压缩包没有密码则不会有任何效果." @默认值 = "">
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ PivArchiveOperate::Extract(@<压缩包资源>, @<解压结果>, @<密码>, piv::Archive::GetInFormat(@<解压格式>))
    }

    方法 解压资源匹配文件 <公开 静态 类型 = 逻辑型 注释 = "使用通配符筛选文件,然后将匹配的文件解压到指定目录." 返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息."
            折叠 @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 压缩包资源 <类型 = 视窗文件资源 注释 = "所欲解压的视窗文件资源">
    参数 筛选器 <类型 = 文本型 注释 = "所欲筛选的文件路径,支持通配符,必须完全一致才能匹配成功；" 注释 = "比如文件在子目录里的必须填写带文件夹的相对路径.">
    参数 输出路径 <类型 = 文本型 注释 = "所欲解压到的位置">
    参数 密码 <类型 = 文本型 注释 = "设置解压密码,如果压缩包没有密码则不会有任何效果." @默认值 = "">
    参数 是否排除匹配项 <类型 = 逻辑型 注释 = "默认为假,表示只解压\"筛选器\"成功匹配的文件;" 注释 = "若设置为真,则会解压所有未匹配的文件." @默认值 = 假>
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ PivArchiveOperate::Extract(@<压缩包资源>, @<筛选器>, @<输出路径>, @<密码>, @<是否排除匹配项>, piv::Archive::GetInFormat(@<解压格式>))
    }

    方法 解压资源匹配到字节集 <公开 静态 类型 = 逻辑型 注释 = "使用通配符筛选文件,然后将匹配的第一个文件解压到字节集中."
            返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 压缩包资源 <类型 = 视窗文件资源 注释 = "所欲解压的视窗文件资源">
    参数 筛选器 <类型 = 文本型 注释 = "所欲筛选的文件路径,支持通配符,必须完全一致才能匹配成功；" 注释 = "比如文件在子目录里的必须填写带文件夹的相对路径.">
    参数 输出数据 <类型 = 字节集类 注释 = "解压成功后,内容会保存在此字节集中.">
    参数 密码 <类型 = 文本型 注释 = "设置解压密码,如果压缩包没有密码则不会有任何效果." @默认值 = "">
    参数 输出文件名 <类型 = 文本型 注释 = "返回最终解压的文件名" @默认值 = 空对象>
    参数 是否排除匹配项 <类型 = 逻辑型 注释 = "默认为假,表示只解压\"筛选器\"成功匹配的第一个文件." 注释 = "若设置为真,则会解压未匹配的第一个文件." @默认值 = 假>
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ PivArchiveOperate::Extract(@<压缩包资源>, @<筛选器>.GetText(), @<输出数据>, @<密码>.GetText(), @<输出文件名>, @<是否排除匹配项>, piv::Archive::GetInFormat(@<解压格式>))
    }

    方法 解压资源正则匹配文件 <公开 静态 类型 = 逻辑型 注释 = "使用正则表达式筛选文件,然后将匹配的文件解压到指定目录."
            返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 压缩包资源 <类型 = 视窗文件资源 注释 = "所欲解压的视窗文件资源">
    参数 正则表达式 <类型 = 文本型 注释 = "用于筛选文件路径的正则表达式">
    参数 输出路径 <类型 = 文本型 注释 = "所欲解压到的位置">
    参数 密码 <类型 = 文本型 注释 = "设置解压密码,如果压缩包没有密码则不会有任何效果." @默认值 = "">
    参数 是否排除匹配项 <类型 = 逻辑型 注释 = "默认为假,表示只解压\"正则表达式\"成功匹配的第一个文件." 注释 = "若设置为真,则会解压未匹配的第一个文件." @默认值 = 假>
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ PivArchiveOperate::ExtractRegex(@<压缩包资源>, @<正则表达式>, @<输出路径>, @<密码>, @<是否排除匹配项>, piv::Archive::GetInFormat(@<解压格式>))
    }

    方法 解压资源正则匹配到字节集 <公开 静态 类型 = 逻辑型 注释 = "使用正则表达式筛选文件,然后将匹配的第一个文件解压到字节集中."
            返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 压缩包资源 <类型 = 视窗文件资源 注释 = "所欲解压的视窗文件资源">
    参数 正则表达式 <类型 = 文本型 注释 = "用于筛选文件路径的正则表达式">
    参数 输出数据 <类型 = 字节集类 注释 = "解压成功后,内容会保存在此字节集中.">
    参数 密码 <类型 = 文本型 注释 = "设置解压密码,如果压缩包没有密码则不会有任何效果." @默认值 = "">
    参数 输出文件名 <类型 = 文本型 注释 = "返回最终解压的文件名" @默认值 = 空对象>
    参数 是否排除匹配项 <类型 = 逻辑型 注释 = "默认为假,表示只解压\"正则表达式\"成功匹配的第一个文件." 注释 = "若设置为真,则会解压未匹配的第一个文件." @默认值 = 假>
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ PivArchiveOperate::ExtractRegex(@<压缩包资源>, @<正则表达式>.GetText(), @<输出数据>,
        @                                 @<密码>.GetText(), @<输出文件名>, @<是否排除匹配项>, piv::Archive::GetInFormat(@<解压格式>))
    }

    # 测试 ---

    方法 测试 <公开 静态 类型 = 逻辑型 注释 = "测试提供的压缩文件是否完整有效,本方法会在内存中尝试完整解压数据."
            返回值注释 = "返回是否测试成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 压缩文件 <类型 = 文本型 注释 = "所欲测试的压缩文件,包含完整路径.">
    参数 密码 <类型 = 文本型 注释 = "设置解压密码,如果压缩包没有密码则不会有任何效果." @默认值 = "">
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ PivArchiveOperate::Test(@<压缩文件>, @<密码>, piv::Archive::GetInFormat(@<解压格式>))
    }

    方法 是否已加密文件名 <公开 静态 类型 = 逻辑型 注释 = "判断指定压缩包的文件名是否已加密,即未输入正确密码无法看到项目的文件名." 返回值注释 = "返回真表示至少有一个已加密的项目" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 压缩文件 <类型 = 文本型 注释 = "所欲测试的压缩文件,包含完整路径.">
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ bit7z::BitArchiveReader::isHeaderEncrypted(piv::Archive::Get7zLib(), @<压缩文件>, piv::Archive::GetInFormat(@<解压格式>))
    }

    方法 是否已加密 <公开 静态 类型 = 逻辑型 注释 = "判断指定的压缩包是否已完整加密" 返回值注释 = "返回真表示压缩包的所有项目都是已加密的" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 压缩文件 <类型 = 文本型 注释 = "所欲测试的压缩文件,包含完整路径.">
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ bit7z::BitArchiveReader::isEncrypted(piv::Archive::Get7zLib(), @<压缩文件>, piv::Archive::GetInFormat(@<解压格式>))
    }
}

类 存档解压类 <公开 注释 = "  功能完整的压缩包解压类,支持解压进度反馈," 注释 = "还可以读取压缩包中的元数据." 注释 = "" 折叠 @文档 = "category = \"文件压缩\""
        @强制依赖 = "存档读写类" @视窗.后缀文本 = "public PivArchiveReader">
{
    方法 解压进度改变 <公开 定义事件 类型 = 整数 注释 = "当解压进度发生改变时,本事件将被多次触发直到解压结束." 注释 = " 1. 请勿在此执行耗时操作,否则将拖慢解压进度;"
            注释 = " 2. 通过返回值可以停止解压;" 注释 = " 3. 如果是在主线程调用解压,可以直接在本事件中操作界面;"
            注释 = " 4. 若是在多线程中调用解压,则应该尽量使用\"高级主线程处理器\"" 注释 = "等方式在子线程中操作界面组件;" 返回值注释 = "返回0表示继续解压,返回其他任意值停止解压." 折叠>
    参数 文件路径 <类型 = 文本型 注释 = "当前正在解压的文件路径.">
    参数 解压进度 <类型 = 整数 注释 = "整体的解压百分比进度,范围为[0-100].">
    参数 总解压大小 <类型 = 长整数 注释 = "所有待解压的文件大小(解压后大小).">
    参数 已解压大小 <类型 = 长整数 注释 = "目前已解压的大小.">
    参数 整体压缩比 <类型 = 整数 注释 = "当前已解压数据的压缩比(0-100),该值会随解压进度变化.">

    方法 取最后错误 <公开 类型 = 文本型 注释 = "返回最后一次操作的错误信息,返回\"OK\"表示操作成功无错误." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetError()
    }

    方法 是否为空 <公开 类型 = 逻辑型 注释 = "返回是否打开了压缩包,返回真表示未打开." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.IsNull()
    }

    # 打开 (必须打开成功后才能继续执行后面的方法) ---

    方法 打开文件 <公开 类型 = 逻辑型 注释 = "通过文件路径打开压缩包,必须打开压缩包才能使用本类的其他方法." 返回值注释 = "返回是否打开成功" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 压缩文件 <类型 = 文本型 注释 = "请提供完整的压缩文件路径">
    参数 是否启用进度反馈 <类型 = 逻辑型 注释 = "启用解压过程中的回调函数" @默认值 = 假>
    参数 密码 <类型 = 文本型 注释 = "设置解压密码,如果压缩包没有密码则不会有任何效果." @默认值 = "">
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ @sn<this>.OpenArchive(@<压缩文件>, @<是否启用进度反馈>, @<密码>, piv::Archive::GetInFormat(@<解压格式>))
    }

    方法 打开字节集 <公开 类型 = 逻辑型 注释 = "通过字节集打开压缩包,必须打开压缩包才能使用本类的其他方法."
            注释 = "注意: 所提供的字节集数据会被缓存到本对象中,直到\"关闭\"压缩包才会释放;" 注释 = "建议打开后释放原来的字节集,以减少内存占用." 返回值注释 = "返回是否打开成功" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 压缩包数据 <类型 = 字节集类 注释 = "所欲被打开的压缩包字节集;" 注释 = "数据会缓存到本对象内部,建议打开后释放字节集以减少内存占用.">
    参数 是否启用进度反馈 <类型 = 逻辑型 注释 = "启用解压过程中的回调函数" @默认值 = 假>
    参数 密码 <类型 = 文本型 注释 = "设置解压密码,如果压缩包没有密码则不会有任何效果." @默认值 = "">
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ @sn<this>.OpenArchive(@<压缩包数据>, @<是否启用进度反馈>, @<密码>, piv::Archive::GetInFormat(@<解压格式>))
    }

    方法 打开内存 <公开 类型 = 逻辑型 注释 = "通过内存地址打开压缩包,必须打开压缩包才能使用本类的其他方法."
            注释 = "注意: 所提供的内存数据会被缓存到本对象中,直到\"关闭\"压缩包才会释放;" 注释 = "建议打开后释放原来的内存数据,以减少内存占用." 返回值注释 = "返回是否打开成功." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 压缩包地址 <类型 = 变整数 注释 = "所欲打开的压缩包内存地址">
    参数 压缩包长度 <类型 = 变整数 注释 = "压缩包的字节长度">
    参数 是否启用进度反馈 <类型 = 逻辑型 注释 = "启用解压过程中的回调函数" @默认值 = 假>
    参数 密码 <类型 = 文本型 注释 = "设置解压密码,如果压缩包没有密码则不会有任何效果." @默认值 = "">
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ @sn<this>.OpenArchive(@<压缩包地址>, @<压缩包长度>, @<是否启用进度反馈>, @<密码>, piv::Archive::GetInFormat(@<解压格式>))
    }

    方法 打开文件资源 <公开 类型 = 逻辑型 注释 = "打开视窗文件资源的压缩包,必须打开压缩包才能使用本类的其他方法."
            注释 = "注意: 所提供的文件资源数据会被缓存到本对象中,直到\"关闭\"压缩包才会释放;" 返回值注释 = "返回是否打开成功." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 压缩包资源 <类型 = 视窗文件资源 注释 = "所欲打开的压缩包文件资源ID">
    参数 是否启用进度反馈 <类型 = 逻辑型 注释 = "启用解压过程中的回调函数" @默认值 = 假>
    参数 密码 <类型 = 文本型 注释 = "设置解压密码,如果压缩包没有密码则不会有任何效果." @默认值 = "">
    参数 解压格式 <类型 = 存档输入格式 注释 = "默认自动根据压缩包的文件头和扩展名识别格式;" 注释 = "若压缩包的扩展名和实际格式不符,有可能会识别失败,这时请手动选择格式."
            @默认值 = 存档输入格式.自动>
    {
        @ @sn<this>.OpenArchive(@<压缩包资源>, @<是否启用进度反馈>, @<密码>, piv::Archive::GetInFormat(@<解压格式>))
    }

    方法 关闭 <公开 注释 = "关闭压缩包,关闭后请勿再使用本类的其他方法." 注释 = " 1. 请勿在解压时执行关闭!" 注释 = " 2. 类析构时会自动关闭,打开另一个压缩包也会自动关闭;" 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.CloseArchive()
    }

    方法 启用进度反馈 <公开 属性写 注释 = "设置是否启用解压过程中的回调函数,这可能会降低解压速度." 折叠>
    参数 是否启用 <类型 = 逻辑型>
    {
        @ EnableFeeback(@<是否启用>);
    }

    方法 启用进度反馈 <公开 属性读 类型 = 逻辑型 注释 = "返回是否启用了解压过程中的回调函数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.HasFeeback()
    }

    # 解压 ---

    方法 解压到 <公开 类型 = 逻辑型 注释 = "将压缩包解压到指定目录" 返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 输出路径 <类型 = 文本型 注释 = "所欲解压到的位置">
    {
        @ @sn<this>.Extract(@<输出路径>)
    }

    方法 解压到内存 <公开 类型 = 逻辑型 注释 = "将压缩包的全部内容解压到内存中." 注释 = "请勿使用本方法解压大文件,以免爆内存."
            注释 = "相比\"解压到内存2\",本方法需要做更多的内存复制,但进度反馈较为友好." 返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "">
    参数 解压结果 <类型 = 存档解压键值类 注释 = "解压成功后,内容会以文本到字节集哈希表保存在此参数中;" 注释 = "其中关键字为路径文本,值为数据字节集.">
    {
        @ @sn<this>.Extract(@<解压结果>)
    }

    方法 解压到内存2 <公开 类型 = 逻辑型 注释 = "将压缩包的全部内容解压到内存中." 注释 = "请勿使用本方法解压大文件,以免爆内存."
            注释 = "相比\"解压到内存\",本方每解压一个文件都会从头反馈解压进度,但内存分配次数更低一些." 返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "">
    参数 解压结果 <类型 = 存档解压键值类 注释 = "解压成功后,内容会以文本到字节集哈希表保存在此参数中;" 注释 = "其中关键字为路径文本,值为数据字节集.">
    {
        @ @sn<this>.ExtractEx(@<解压结果>)
    }

    方法 解压项目到字节集 <公开 类型 = 逻辑型 注释 = "将压缩包中指定索引的一个文件解压到字节集中" 返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "">
    参数 索引 <类型 = 整数 注释 = "压缩文件里的文件索引,如果索引是文件夹则无法解压返回假." @默认值 = 0>
    参数 输出数据 <类型 = 字节集类 注释 = "解压成功后,内容会输出到此字节集中.">
    参数 输出文件名 <类型 = 文本型 注释 = "返回索引所对应的文件名" @默认值 = 空对象>
    {
        @ @sn<this>.Extract(@<索引>, @<输出数据>, @<输出文件名>)
    }

    方法 解压多个项目到 <公开 类型 = 逻辑型 注释 = "根据索引数组,将压缩包中对应的多个文件解压到指定目录." 返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 索引数组 <类型 = 整数数组类 注释 = "压缩文件里的文件索引,如果索引是文件夹则无法解压返回假.">
    参数 输出路径 <类型 = 文本型 注释 = "所欲解压到的位置">
    {
        @ @sn<this>.Extract(@<索引数组>, @<输出路径>)
    }

    方法 解压匹配文件 <公开 类型 = 逻辑型 注释 = "使用通配符筛选文件,然后将匹配的文件解压到指定目录." 返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 筛选器 <类型 = 文本型 注释 = "所欲筛选的文件路径,支持通配符,必须完全一致才能匹配成功；" 注释 = "比如文件在子目录里的必须填写带文件夹的相对路径.">
    参数 输出路径 <类型 = 文本型 注释 = "所欲解压到的位置">
    参数 是否排除匹配项 <类型 = 逻辑型 注释 = "默认为假,表示只解压\"筛选器\"成功匹配的文件;" 注释 = "若设置为真,则会解压所有未匹配的文件." @默认值 = 假>
    {
        @ @sn<this>.Extract(@<筛选器>, @<输出路径>, @<是否排除匹配项>)
    }

    方法 解压匹配文件到字节集 <公开 类型 = 逻辑型 注释 = "使用通配符筛选文件,然后将匹配的第一个文件解压到字节集中."
            返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 筛选器 <类型 = 文本型 注释 = "所欲筛选的文件路径,支持通配符,必须完全一致才能匹配成功；" 注释 = "比如文件在子目录里的必须填写带文件夹的相对路径.">
    参数 输出数据 <类型 = 字节集类 注释 = "解压成功后,内容会保存在此字节集中.">
    参数 输出文件名 <类型 = 文本型 注释 = "返回最终解压的文件名" @默认值 = 空对象>
    参数 是否排除匹配项 <类型 = 逻辑型 注释 = "默认为假,表示只解压\"筛选器\"成功匹配的文件;" 注释 = "若设置为真,则会解压所有未匹配的文件." @默认值 = 假>
    {
        @ @sn<this>.Extract(@<筛选器>.GetText(), @<输出数据>, @<输出文件名>, @<是否排除匹配项>)
    }

    方法 解压正则匹配文件 <公开 类型 = 逻辑型 注释 = "使用正则表达式筛选文件,然后将匹配的文件解压到指定目录." 返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息."
            折叠 @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 正则表达式 <类型 = 文本型 注释 = "用于筛选文件路径的正则表达式">
    参数 输出路径 <类型 = 文本型 注释 = "所欲解压到的位置">
    参数 是否排除匹配项 <类型 = 逻辑型 注释 = "默认为假,表示只解压\"筛选器\"成功匹配的文件;" 注释 = "若设置为真,则会解压所有未匹配的文件." @默认值 = 假>
    {
        @ @sn<this>.ExtractRegex(@<正则表达式>, @<输出路径>, @<是否排除匹配项>)
    }

    方法 解压正则匹配文件到字节集 <公开 类型 = 逻辑型 注释 = "使用正则表达式筛选文件,然后将匹配的第一个文件解压到字节集中."
            返回值注释 = "返回是否解压成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 正则表达式 <类型 = 文本型 注释 = "用于筛选文件路径的正则表达式">
    参数 输出数据 <类型 = 字节集类 注释 = "解压成功后,内容会保存在此字节集中.">
    参数 输出文件名 <类型 = 文本型 注释 = "返回最终解压的文件名" @默认值 = 空对象>
    参数 是否排除匹配项 <类型 = 逻辑型 注释 = "默认为假,表示只解压\"正则表达式\"成功匹配的文件;" 注释 = "若设置为真,则会解压所有未匹配的文件." @默认值 = 假>
    {
        @ @sn<this>.ExtractRegex(@<正则表达式>.GetText(), @<输出数据>, @<输出文件名>, @<是否排除匹配项>)
    }

    方法 测试 <公开 类型 = 逻辑型 注释 = "测试打开的压缩包是否完整有效,本方法会在内存中尝试完整解压数据." 返回值注释 = "返回是否测试成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.Test()
    }

    方法 测试项目 <公开 类型 = 逻辑型 注释 = "测试压缩包中指定的项目是否完整有效,本方法会在内存中尝试解压指定的项目."
            返回值注释 = "返回是否测试成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "">
    参数 索引 <类型 = 整数 注释 = "压缩文件里的文件索引,如果索引是文件夹则无法解压返回假.">
    {
        @ @sn<this>.Test(@<索引>)
    }

    # 设置 ---

    方法 压缩密码 <公开 属性写 注释 = "设置密码,密码会在之后的所有解压中生效,直到你执行\"清除密码\"." 注释 = "如果压缩包没有密码,设置密码后不会有任何效果." 折叠 "">
    参数 密码 <类型 = 文本型 注释 = "提供空文本同于\"清除密码\"">
    {
        @ SetPassword(@<密码>.GetText());
    }

    方法 压缩密码 <公开 属性读 类型 = 文本型 注释 = "返回当前设置的压缩密码" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.Password()
    }

    方法 保留目录结构 <公开 属性写 注释 = "设置方法输出时是否保留输入的目录结构" 折叠 "">
    参数 是否保留 <类型 = 逻辑型>
    {
        @ SetRetainDirectories(static_cast<bool>(@<是否保留>));
    }

    方法 保留目录结构 <公开 属性读 类型 = 逻辑型 注释 = "返回真表示在解压和压缩文件时必定保留目录结构" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.RetainDirectories()
    }

    方法 清除密码 <公开 注释 = "清除当前已设置的密码" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ClearPassword()
    }

    方法 是否有密码 <公开 类型 = 逻辑型 注释 = "返回是否已经设置过密码" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.IsPasswordDefined()
    }

    # 属性 ---

    方法 取压缩格式 <公开 类型 = 存档格式类型 注释 = "检测压缩包的压缩格式" 返回值注释 = "返回检测到的压缩格式值,返回自动(0)表示未检测到或未打开压缩文件." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.DetectedFormat()
    }

    方法 取压缩包属性表 <公开 类型 = 存档属性表类 注释 = "获取一部分可用的压缩包属性" 折叠 @嵌入式方法 = "">
    {
        @ @dt<存档属性表类>(@sn<this>.ArchiveProperties())
    }

    方法 取压缩包属性 <公开 类型 = 存档属性变体型 注释 = "获取指定名称的压缩包属性" 折叠 @嵌入式方法 = "">
    参数 属性名 <类型 = 存档属性名>
    {
        @ @dt<存档属性变体型>(@sn<this>.ArchiveProperty(@<属性名>))
    }

    方法 取项目信息表 <公开 类型 = 存档项目信息数组 注释 = "获取所有项目的信息表" 折叠 @嵌入式方法 = "">
    {
        @ @dt<存档项目信息数组>(@sn<this>.Items())
    }

    方法 取项目属性 <公开 类型 = 存档属性变体型 注释 = "获取指定索引和名称的项目属性" 返回值注释 = "失败时返回的空变体型" 折叠 @嵌入式方法 = "">
    参数 项目索引 <类型 = 整数 注释 = "所欲取属性的项目索引,索引从0开始.">
    参数 属性名 <类型 = 存档属性名>
    {
        @ @dt<存档属性变体型>(@sn<this>.ItemProperty(@<项目索引>, @<属性名>))
    }

    方法 取项目数 <公开 类型 = 整数 注释 = "获取压缩包的内容项目数量,1个项目表示1个文件或文件夹." 返回值注释 = "未打开压缩包时返回-1" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ItemsCount()
    }

    方法 是否为目录项目 <公开 类型 = 逻辑型 注释 = "判断指定索引的项目是否为文件夹." 注释 = "请确保项目索引有效,否则会抛出异常." 折叠 @嵌入式方法 = "">
    参数 项目索引 <类型 = 整数 注释 = "所欲判断是否为文件夹的项目索引,索引从0开始.">
    {
        @ @sn<this>.IsItemFolder(项目索引)
    }

    方法 是否为加密项目 <公开 类型 = 逻辑型 注释 = "判断指定索引的项目是否为加密压缩文件." 注释 = "请确保项目索引有效,否则会抛出异常." 返回值注释 = "未打开压缩包时始终返回假" 折叠
            @嵌入式方法 = "">
    参数 项目索引 <类型 = 整数 注释 = "所欲判断是否为加密压缩的项目索引,索引从0开始.">
    {
        @ @sn<this>.IsItemEncrypted(项目索引)
    }

    方法 取压缩文件路径 <公开 类型 = 文本型 注释 = "获取当前已打开的压缩文件路径" 返回值注释 = "未打开压缩文件时返回空文本" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ArchivePath()
    }

    方法 取文件夹数量 <公开 类型 = 整数 注释 = "获取压缩包内的文件夹项目数量" 返回值注释 = "未打开压缩包时返回-1" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.FoldersCount()
    }

    方法 取文件数量 <公开 类型 = 整数 注释 = "获取压缩包内的文件项目数量" 返回值注释 = "未打开压缩包时返回-1" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.FilesCount()
    }

    方法 取总长度 <公开 类型 = 长整数 注释 = "获取压缩包内容的未压缩总字节长度" 返回值注释 = "未打开压缩包时返回-1" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.Size()
    }

    方法 取打包长度 <公开 类型 = 长整数 注释 = "获取压缩包的字节长度(压缩后的长度,等于压缩文件的大小)" 返回值注释 = "未打开压缩包时返回-1" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.PackSize()
    }

    方法 是否有加密项目 <公开 类型 = 逻辑型 注释 = "判断打开的压缩包是否至少有一个加密压缩项目" 返回值注释 = "未打开压缩包时始终返回假" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.HasEncryptedItems()
    }

    方法 是否已加密 <公开 类型 = 逻辑型 注释 = "判断打开的压缩包是否全部为加密压缩项目" 返回值注释 = "未打开压缩包时始终返回假" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.IsEncrypted()
    }

    方法 取分卷数量 <公开 类型 = 整数 注释 = "获取压缩包的分卷数量,如果未分卷返回1." 返回值注释 = "成功返回1以上的分卷数量,未打开压缩包返回-1." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.VolumesCount()
    }

    方法 是否为分卷 <公开 类型 = 逻辑型 注释 = "判断打开的压缩包是否为分卷压缩文件" 返回值注释 = "未打开压缩包时始终返回假" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.IsMultiVolume()
    }

    方法 是否为固实 <公开 类型 = 逻辑型 注释 = "判断打开的压缩包是否为固实压缩文件" 返回值注释 = "未打开压缩包时始终返回假" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.IsSolid()
    }

    # 迭代器

    方法 取尾项目索引 <公开 类型 = 整数 注释 = "获取最后一个项目的索引" 返回值注释 = "成功返回项目索引,如果压缩包为空或未打开压缩包返回-1." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.EndIndex()
    }

    方法 寻找项目索引 <公开 类型 = 整数 注释 = "根据路径获取指定项目的索引位置" 返回值注释 = "成功返回项目索引,找不到或未打开压缩包返回-1." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 项目路径 <类型 = 文本型 注释 = "所欲查找的项目相对路径,如\"path\\file.txt\";" 注释 = "若没有子目录则填文件名即可.">
    {
        @ @sn<this>.FindIndex(@<项目路径>)
    }

    方法 项目是否存在 <公开 类型 = 逻辑型 注释 = "查找压缩包内是否存在指定路径的项目" 返回值注释 = "返回真表示存在,否则为假." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 项目路径 <类型 = 文本型 注释 = "所欲判断的项目相对路径,如\"path\\file.txt\";" 注释 = "若没有子目录则填文件名即可.">
    {
        @ @sn<this>.IsContain(@<项目路径>)
    }

    方法 寻找项目 <公开 注释 = "根据路径获取指定项目的迭代器." 注释 = " 1. 本方法会产生一个子语句体,你可以在子语句体内调用\"取枚举...\"等方法,"
            注释 = "获取所寻找到项目的属性;" 注释 = " 2. 如果寻找的路径不存在,除了\"取枚举索引\"之外的其他方法都会抛出异常;"
            注释 = " 3. 本方法已经做了异常处理,一般不会造成崩溃,但建议用\"项目是否存在\"," 注释 = "判断查找的项目是否存在;" 折叠
            @嵌入式方法 = "name = bit7z_fiter\r\nhas_loop_body = true\r\nbody_header = \"@none\"\r\nbody_tail = \"} catch (...) { }\"">
    参数 项目路径 <类型 = 文本型 注释 = "所欲查找的项目相对路径,如\"path\\file.txt\";" 注释 = "若没有子目录则填文件名即可.">
    {
        @ try {
        @     auto _bit7z_itr = @sn<this>.arc().find(@<项目路径>.GetText());
    }

    方法 枚举循环 <公开 注释 = " 1. 启动一个正向循环来枚举所打开压缩文件中的每一个项目,调用\"取枚举索引\"" 注释 = "可以获取当前所枚举到项目的索引位置;"
            注释 = " 2. 在循环中可以调用\"取枚举...\"等方法来获取当前所枚举到项目的属性;" 注释 = " 3. 必须打开压缩包后才能使用,否则会导致程序崩溃;" 折叠
            @嵌入式方法 = "name = bit7z_iter\r\nhas_loop_body = true">
    {
        @ bit7z::BitArchiveReader* @sn<rand_name0> = @sn<this>.pdata();
        @ for (auto _bit7z_itr = @sn<rand_name0>->begin(); _bit7z_itr != @sn<rand_name0>->end(); _bit7z_itr++)
    }

    方法 逆向枚举循环 <公开 注释 = " 1. 启动一个逆向循环来枚举所打开压缩文件中的每一个项目,调用\"取枚举索引\"" 注释 = "可以获取当前所枚举到项目的索引位置;"
            注释 = " 2. 在循环中可以调用\"取枚举...\"等方法来获取当前所枚举到项目的属性;" 注释 = " 3. 必须打开压缩包后才能使用,否则会导致程序崩溃;" 折叠
            @嵌入式方法 = "name = bit7z_riter\r\nhas_loop_body = true">
    {
        @ bit7z::BitArchiveReader* @sn<rand_name0> = @sn<this>.pdata();
        @ for (auto _bit7z_itr = @sn<rand_name0>->end(); _bit7z_itr != @sn<rand_name0>->begin(); _bit7z_itr--)
    }

    方法 取枚举索引 <公开 类型 = 整数 注释 = "获取当前所枚举到项目的索引." 注释 = "只能在本类的\"枚举循环\"/\"逆向枚举循环\"/\"寻找项目\"的子语句体中使用." 折叠
            @嵌入式方法 = "parent = \"bit7z_iter, bit7z_riter, bit7z_fiter\"">
    {
        @ static_cast<int32_t>(_bit7z_itr->index())
    }

    方法 取枚举属性 <公开 类型 = 存档属性变体型 注释 = "获取当前所枚举到项目的指定属性值." 注释 = "只能在本类的\"枚举循环\"/\"逆向枚举循环\"/\"寻找项目\"的子语句体中使用."
            折叠 @嵌入式方法 = "parent = \"bit7z_iter, bit7z_riter, bit7z_fiter\"">
    参数 属性名 <类型 = 存档属性名>
    {
        @ @dt<存档属性变体型>(_bit7z_itr->itemProperty(static_cast<bit7z::BitProperty>(@<属性名>)))
    }

    方法 取枚举名称 <公开 类型 = 文本型 注释 = "获取当前所枚举到项目的名称(文件名或文件夹名)."
            注释 = "只能在本类的\"枚举循环\"/\"逆向枚举循环\"/\"寻找项目\"的子语句体中使用." 折叠
            @嵌入式方法 = "parent = \"bit7z_iter, bit7z_riter, bit7z_fiter\"">
    {
        @ @an<CVolString>(_bit7z_itr->name().c_str())
    }

    方法 取枚举是否目录 <公开 类型 = 逻辑型 注释 = "判断当前枚举到的项目是否为文件夹." 注释 = "只能在本类的\"枚举循环\"/\"逆向枚举循环\"/\"寻找项目\"的子语句体中使用." 折叠
            @嵌入式方法 = "parent = \"bit7z_iter, bit7z_riter, bit7z_fiter\"">
    {
        @ _bit7z_itr->isDir()
    }

    方法 取枚举是否符号链接 <公开 类型 = 逻辑型 注释 = "判断当前枚举到的项目是否为符号链接." 注释 = "只能在本类的\"枚举循环\"/\"逆向枚举循环\"/\"寻找项目\"的子语句体中使用."
            折叠 @嵌入式方法 = "parent = \"bit7z_iter, bit7z_riter, bit7z_fiter\"">
    {
        @ _bit7z_itr->isSymLink()
    }

    方法 取枚举扩展名 <公开 类型 = 文本型 注释 = "获取当前所枚举到项目的扩展名." 注释 = "只能在本类的\"枚举循环\"/\"逆向枚举循环\"/\"寻找项目\"的子语句体中使用." 折叠
            @嵌入式方法 = "parent = \"bit7z_iter, bit7z_riter, bit7z_fiter\"">
    {
        @ @an<CVolString>(_bit7z_itr->extension().c_str())
    }

    方法 取枚举路径 <公开 类型 = 文本型 注释 = "获取当前所枚举到项目的路径." 注释 = "只能在本类的\"枚举循环\"/\"逆向枚举循环\"/\"寻找项目\"的子语句体中使用." 折叠
            @嵌入式方法 = "parent = \"bit7z_iter, bit7z_riter, bit7z_fiter\"">
    {
        @ @an<CVolString>(_bit7z_itr->path().c_str())
    }

    方法 取枚举项目长度 <公开 类型 = 长整数 注释 = "获取当前所枚举到项目的未压缩长度." 注释 = "只能在本类的\"枚举循环\"/\"逆向枚举循环\"/\"寻找项目\"的子语句体中使用." 折叠
            @嵌入式方法 = "parent = \"bit7z_iter, bit7z_riter, bit7z_fiter\"">
    {
        @ static_cast<int64_t>(_bit7z_itr->size())
    }

    方法 取枚举打包长度 <公开 类型 = 长整数 注释 = "获取当前所枚举到的项目压缩后的长度." 注释 = "只能在本类的\"枚举循环\"/\"逆向枚举循环\"/\"寻找项目\"的子语句体中使用." 折叠
            @嵌入式方法 = "parent = \"bit7z_iter, bit7z_riter, bit7z_fiter\"">
    {
        @ static_cast<int64_t>(_bit7z_itr->packSize())
    }

    方法 取枚举创建时间 <公开 类型 = 标准时间类 注释 = "获取当前所枚举到项目的创建时间." 注释 = "只能在本类的\"枚举循环\"/\"逆向枚举循环\"/\"寻找项目\"的子语句体中使用." 折叠
            @嵌入式方法 = "parent = \"bit7z_iter, bit7z_riter, bit7z_fiter\"">
    {
        @ @dt<标准时间类>(_bit7z_itr->creationTime())
    }

    方法 取枚举访问时间 <公开 类型 = 标准时间类 注释 = "获取当前所枚举到项目的最后访问时间." 注释 = "只能在本类的\"枚举循环\"/\"逆向枚举循环\"/\"寻找项目\"的子语句体中使用."
            折叠 @嵌入式方法 = "parent = \"bit7z_iter, bit7z_riter, bit7z_fiter\"">
    {
        @ @dt<标准时间类>(_bit7z_itr->lastAccessTime())
    }

    方法 取枚举修改时间 <公开 类型 = 标准时间类 注释 = "获取当前所枚举到项目的最后修改时间." 注释 = "只能在本类的\"枚举循环\"/\"逆向枚举循环\"/\"寻找项目\"的子语句体中使用."
            折叠 @嵌入式方法 = "parent = \"bit7z_iter, bit7z_riter, bit7z_fiter\"">
    {
        @ @dt<标准时间类>(_bit7z_itr->lastWriteTime())
    }

    方法 取枚举文件属性 <公开 类型 = 整数 注释 = "获取当前所枚举到项目的文件属性." 注释 = "只能在本类的\"枚举循环\"/\"逆向枚举循环\"/\"寻找项目\"的子语句体中使用."
            返回值注释 = "返回\"文件属性\"中一个或多个常量的位或值." 折叠 @嵌入式方法 = "parent = \"bit7z_iter, bit7z_riter, bit7z_fiter\"">
    {
        @ static_cast<int32_t>(_bit7z_itr->attributes())
    }

    方法 取枚举是否加密 <公开 类型 = 逻辑型 注释 = "判断当前所枚举到的项目是否为加密压缩." 注释 = "只能在本类的\"枚举循环\"/\"逆向枚举循环\"/\"寻找项目\"的子语句体中使用."
            返回值注释 = "返回真表示该项目为加密压缩." 折叠 @嵌入式方法 = "parent = \"bit7z_iter, bit7z_riter, bit7z_fiter\"">
    {
        @ _bit7z_itr->isEncrypted()
    }

    # ----
    # @begin
    # <> <include>
    # int32_t ExtractProgress(const wchar_t *progressFile, int32_t progress, int64_t totalSize, int64_t progress_size, int32_t ratio) override {
    #     return this->@<解压进度改变>(@an<CVolString>(progressFile), progress, totalSize, progress_size, ratio);
    # }
    # <> </include>
    # @end
}

类 存档输出模板 <公开 注释 = "  封装了\"存档压缩类\"和\"存档编辑类\"共用的基本操作," 注释 = "不能直接使用本类." 折叠 @文档 = "category = \"文件压缩\""
        @强制依赖 = "存档读写类" @模板基础类 = 真>
{
    方法 压缩进度改变 <公开 定义事件 类型 = 整数 注释 = "当压缩进度发生改变时,本事件将被多次触发直到压缩结束." 注释 = " 1. 请勿在此执行耗时操作,否则将拖慢压缩进度;"
            注释 = " 2. 通过返回值可以停止压缩;" 注释 = " 3. 如果是在主线程调用压缩,可以直接在本事件中操作界面;"
            注释 = " 4. 若是在多线程中调用压缩,则应该尽量使用\"高级主线程处理器\"" 注释 = "等方式在子线程中操作界面组件;" 返回值注释 = "返回0表示继续压缩,返回其他任意值停止压缩." 折叠>
    参数 文件路径 <类型 = 文本型 注释 = "当前正在压缩的文件路径">
    参数 压缩进度 <类型 = 整数 注释 = "整体的压缩百分比进度,范围为[0-100].">
    参数 总压缩大小 <类型 = 长整数 注释 = "所有待压缩的文件大小(解压后大小).">
    参数 已压缩大小 <类型 = 长整数 注释 = "目前已压缩的大小">
    参数 整体压缩比 <类型 = 整数 注释 = "当前已压缩数据的压缩比(0-100),该值会随压缩进度变化.">

    方法 取最后错误 <公开 类型 = 文本型 注释 = "返回最后一次操作的错误信息,返回\"OK\"表示操作成功无错误." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetError()
    }

    方法 是否为空 <公开 类型 = 逻辑型 注释 = "返回是否创建了压缩包,返回真表示未创建." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.IsNull()
    }

    方法 关闭 <公开 注释 = "关闭压缩包,关闭后请勿再使用本类的其他方法." 注释 = " 1. 请勿在压缩时执行关闭!" 注释 = " 2. 类析构时会自动关闭,打开或创建另一个压缩包也会自动关闭;"
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.CloseArchive()
    }

    方法 启用进度反馈 <公开 属性写 注释 = "设置是否启用压缩过程中的回调函数,启用后会降低压缩速度." 折叠>
    参数 是否启用 <类型 = 逻辑型>
    {
        @ EnableFeeback(@<是否启用>);
    }

    方法 启用进度反馈 <公开 属性读 类型 = 逻辑型 注释 = "返回是否启用了压缩过程中的回调函数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.HasFeeback()
    }

    # 添加文件/目录 (需要调用"压缩到XX"才会实际输出) ---

    方法 添加项目 <公开 类型 = 逻辑型 注释 = "添加多个文件或文件夹到压缩队列中" 返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "">
    参数 路径数组 <类型 = 文本数组类 注释 = "所欲压缩的路径数组;" 注释 = "提供的相对或绝对路径必须指向存在的文件或目录,否则会失败.">
    {
        @ @sn<this>.AddItems(@<路径数组>.data())
    }

    方法 添加别名项目 <公开 类型 = 逻辑型 注释 = "使用哈希表添加多个文件或文件夹到压缩队列中," 注释 = "可以通过哈希表的值自定义项目的名称."
            返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "">
    参数 路径键值对 <类型 = 文本到文本哈希表 注释 = "所欲压缩的路径到别名键值对;" 注释 = "其中键为文件或目录的相对或绝对路径,值为相对路径的别名;"
            注释 = "提供的键必须指向存在的文件或目录,否则会失败.">
    {
        @ @sn<this>.AddItems(@<路径键值对>.m_map)
    }

    方法 添加文件 <公开 类型 = 逻辑型 注释 = "添加单个文件到压缩队列中" 返回值注释 = "返回是否成功,添加了目录和不存在的文件会返回假." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 文件路径 <类型 = 文本型 注释 = "所欲添加到压缩包的文件路径,默认会添加到压缩包的根目录.">
    参数 别名 <类型 = 文本型 注释 = "若不为空,添加的文件会按这个别名重命名;" 注释 = "还可以用来指定文件在压缩包的相对路径." @默认值 = "">
    {
        @ @sn<this>.AddFile(@<文件路径>, @<别名>)
    }

    方法 添加字节集 <公开 类型 = 逻辑型 注释 = "添加字节集数据到压缩队列中;" 注释 = "所提供的字节集数据会被缓存到本对象中,直到\"关闭\"压缩包才会释放;"
            注释 = "建议添加后释放原来的字节集,以减少内存的占用." 返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 缓存数据 <类型 = 字节集类 注释 = "所欲添加到压缩包的字节集数据">
    参数 数据名称 <类型 = 文本型 注释 = "数据在压缩包中的文件名称和相对路径">
    {
        @ @sn<this>.AddFile(@<缓存数据>, @<数据名称>)
    }

    方法 添加内存 <公开 类型 = 逻辑型 注释 = "将内存数据添加到压缩队列中;" 注释 = "所提供的内存数据会被缓存到本对象中,直到\"关闭\"压缩包才会释放;"
            注释 = "建议添加后释放原来的内存数据,以减少内存的占用." 返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 数据地址 <类型 = 变整数 注释 = "所欲添加到压缩包的内存数据地址">
    参数 数据长度 <类型 = 变整数 注释 = "所欲添加到压缩包的内存数据长度">
    参数 数据名称 <类型 = 文本型 注释 = "数据在压缩包中的文件名称和相对路径">
    {
        @ @sn<this>.AddFile(@<数据地址>, @<数据长度>, @<数据名称>)
    }

    方法 添加文件数组 <公开 类型 = 逻辑型 注释 = "添加多个文件到压缩队列中,数组中含有目录将被忽略." 返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "">
    参数 文件数组 <类型 = 文本数组类 注释 = "所欲压缩的文件数组;" 注释 = "提供的相对或绝对路径必须指向存在的文件,否则会失败.">
    {
        @ @sn<this>.AddFiles(@<文件数组>.data())
    }

    方法 添加匹配文件 <公开 类型 = 逻辑型 注释 = "使用通配符筛选指定目录下的文件,然后将匹配的文件添加到压缩队列中." 返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息."
            折叠 @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 输入目录 <类型 = 文本型 注释 = "请提供输入目录的相对或绝对路径;" 注释 = "目录中的文件或子目录将被添加到压缩包中,但不含输入目录本身.">
    参数 筛选器 <类型 = 文本型 注释 = "用通配符筛选要压缩的部分文件" @默认值 = "*.*">
    参数 递归子目录 <类型 = 逻辑型 注释 = "是否递归搜寻\"输入目录\"下所有子目录中的文件." @默认值 = 真>
    参数 是否排除匹配项 <类型 = 逻辑型 注释 = "默认为假,表示只压缩\"筛选器\"成功匹配的文件;" 注释 = "若设置为真,则会压缩所有未匹配的文件." @默认值 = 假>
    {
        @ @sn<this>.AddFiles(@<输入目录>, @<筛选器>, @<是否排除匹配项>, @<递归子目录>)
    }

    方法 添加目录 <公开 类型 = 逻辑型 注释 = "将指定目录的所有文件和文件夹添加到压缩队列中,包括目录自身." 返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 目录路径 <类型 = 文本型 注释 = "所欲压缩的目录路径,包括目录自身会全部添加到压缩包中.">
    {
        @ @sn<this>.AddDirectory(@<目录路径>)
    }

    # 属性 ---

    方法 取压缩格式 <公开 类型 = 存档格式类型 注释 = "返回压缩包的格式" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.CompressionFormat()
    }

    方法 取项目数量 <公开 类型 = 整数 注释 = "获取压缩包当前的项目数量,包括压缩包原有的项目和新添加的队列项目." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ItemsCount()
    }

    # 设置 ---

    方法 压缩密码 <公开 属性写 注释 = "设置密码,密码会在之后的所有压缩中生效,直到你执行\"清除密码\"." 折叠 "">
    参数 新密码 <类型 = 文本型 注释 = "提供空文本同于\"清除密码\"">
    {
        @ SetPassword(@<新密码>.GetText());
    }

    方法 压缩密码 <公开 属性读 类型 = 文本型 注释 = "返回当前的压缩密码" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.Password()
    }

    方法 压缩等级 <公开 属性写 注释 = "设置压缩等级,会影响压缩速度和压缩包大小;" 注释 = "注意: Wim和Tar格式不支持设置压缩等级,会无视该参数." 折叠 "">
    参数 新等级 <类型 = 存档压缩等级>
    {
        @ SetCompressionLevel(@<新等级>);
    }

    方法 压缩等级 <公开 属性读 类型 = 存档压缩等级 注释 = "返回当前的压缩等级" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.CompressionLevel()
    }

    方法 压缩方法 <公开 属性写 注释 = "设置使用的压缩方法,请注意不同压缩格式支持的方法是不同的." 折叠 "">
    参数 新方法 <类型 = 存档压缩方法>
    {
        @ SetCompressionMethod(static_cast<bit7z::BitCompressionMethod>(@<新方法>));
    }

    方法 压缩方法 <公开 属性读 类型 = 存档压缩方法 注释 = "返回当前的压缩方法" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.CompressionMethod()
    }

    方法 字典大小 <公开 属性写 注释 = "设置压缩使用的字典大小" 折叠 "">
    参数 新大小 <类型 = 整数 注释 = "所需的字典大小">
    {
        @ SetDictionarySize(@<新大小>);
    }

    方法 字典大小 <公开 属性读 类型 = 整数 注释 = "返回当前的字典大小" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.DictionarySize()
    }

    方法 单词大小 <公开 属性写 注释 = "设置压缩使用的单词大小" 折叠 "">
    参数 新大小 <类型 = 整数 注释 = "所需的单词大小">
    {
        @ SetWordSize(@<新大小>);
    }

    方法 单词大小 <公开 属性读 类型 = 整数 注释 = "返回当前的单词大小" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.WordSize()
    }

    方法 固实压缩 <公开 属性写 注释 = "设置是否使用固实压缩,只有7z格式支持固实压缩." 折叠 "">
    参数 启用 <类型 = 逻辑型>
    {
        @ SetSolidMode(@<启用>);
    }

    方法 固实压缩 <公开 属性读 类型 = 逻辑型 注释 = "返回是否使用固实压缩" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.SolidMode()
    }

    方法 更新方式 <公开 属性写 注释 = "如果目标压缩包已经存在,设置如何更新目标压缩包的内容;" 注释 = "注意: BZip2、GZip、Xz不支持更新模式,若压缩包存在就会失败." 折叠 "">
    参数 新更新方式 <类型 = 存档更新方式>
    {
        @ SetUpdateMode(@<新更新方式>);
    }

    方法 更新方式 <公开 属性读 类型 = 存档更新方式 注释 = "返回当前使用的更新方式" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.UpdateMode()
    }

    方法 分卷大小 <公开 属性写 注释 = "设置创建分卷压缩文件时的分卷大小(字节),只有压缩为文件时才能分卷." 折叠 "">
    参数 新分卷大小 <类型 = 长整数 注释 = "单位为字节,0表示不分卷.">
    {
        @ SetVolumeSize(@<新分卷大小>);
    }

    方法 分卷大小 <公开 属性读 类型 = 长整数 注释 = "获取创建分卷压缩文件的分卷大小(单位为字节)," 注释 = "返回0表示不分卷." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.VolumeSize()
    }

    方法 线程数 <公开 属性写 注释 = "设置创建压缩时使用的CPU线程数" 折叠 "">
    参数 新线程数 <类型 = 整数>
    {
        @ SetThreadsCount(@<新线程数>);
    }

    方法 线程数 <公开 属性读 类型 = 整数 注释 = "返回创建压缩时使用的CPU线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ThreadsCount()
    }

    方法 存储符号链接 <公开 属性写 注释 = "设置是否将符号链接作为链接存储在压缩文件中" 折叠 "">
    参数 是否存储符号链接 <类型 = 逻辑型 注释 = "设置为真时,符号链接将存储为链接.">
    {
        @ SetStoreSymbolicLinks(static_cast<bool>(@<是否存储符号链接>));
    }

    方法 存储符号链接 <公开 属性读 类型 = 逻辑型 注释 = "返回是否将符号链接作为链接存储在压缩文件中" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.StoreSymbolicLinks()
    }

    方法 保留目录结构 <公开 属性写 注释 = "设置方法输出时是否保留输入的目录结构" 折叠 "">
    参数 是否保留 <类型 = 逻辑型>
    {
        @ SetRetainDirectories(static_cast<bool>(@<是否保留>));
    }

    方法 保留目录结构 <公开 属性读 类型 = 逻辑型 注释 = "返回真表示在解压和压缩文件时必定保留目录结构" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.RetainDirectories()
    }

    方法 设置密码 <公开 注释 = "设置压缩密码和是否加密文件名" 折叠 编辑时信息 = "40D99, 0, 0, 0"
            @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 新密码 <类型 = 文本型 注释 = "提供空文本同于\"清除密码\"." 编辑时信息 = "40D99, 0, 0, 0" @默认值 = "">
    参数 加密文件名 <类型 = 逻辑型 注释 = "是否加密压缩包项目的文件名,仅对SevenZip格式有效." 编辑时信息 = "40D99, 0, 0, 0" @默认值 = 假>
    {
        @ @sn<this>.SetPassword(@<新密码>, @<加密文件名>)
    }

    方法 清除密码 <公开 注释 = "清除当前已设置的密码" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ClearPassword()
    }

    方法 是否有密码 <公开 类型 = 逻辑型 注释 = "返回是否已经设置过密码" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.IsPasswordDefined()
    }

    方法 是否加密文件名 <公开 类型 = 逻辑型 注释 = "返回是否加密文件名,只有SevenZip格式直接加密文件名."
            注释 = "加密文件名后,必须输入密码才能查看压缩包里的项目,可以用\"设置密码\"方法开启." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.CryptHeaders()
    }

    # ----
    # @begin
    # <> <include>
    # int32_t WriterProgress(const wchar_t *progressFile, int32_t progress, int64_t totalSize, int64_t progress_size, int32_t ratio) override {
    #     return this->@<压缩进度改变>(@an<CVolString>(progressFile), progress, totalSize, progress_size, ratio);
    # }
    # <> </include>
    # @end
    # ----
}

类 存档压缩类 <公开 基础类 = 存档输出模板 注释 = "封装了完整功能的压缩类,可以设置所有的压缩选项,支持压缩进度反馈." 注释 = "简单流程: 创建自XX->添加XX->压缩到XX" 折叠
        @文档 = "category = \"文件压缩\"" @模板实现类 = "" @视窗.后缀文本 = "public PivArchiveWirter">
{

    # 打开 (必须打开成功后才能继续执行后面的方法) ---

    方法 创建压缩包 <公开 类型 = 逻辑型 注释 = "创建一个新的空压缩包,不会基于任何现有的压缩包数据进行更新压缩." 注释 = "必须成功创建压缩包才能执行本类的其他方法."
            返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 是否启用进度反馈 <类型 = 逻辑型 注释 = "是否启用压缩过程中的回调函数,启用后可能会降低压缩速度." @默认值 = 假>
    参数 压缩格式 <类型 = 存档输出格式 注释 = "设置压缩格式;" 注释 = "注意BZip2、GZip、Xz格式只能压缩单个文件,提供了多个文件路径或目录就会失败."
            @默认值 = 存档输出格式.SevenZip>
    {
        @ @sn<this>.CreateArchive(@<是否启用进度反馈>, piv::Archive::GetOutFormat(@<压缩格式>))
    }

    方法 创建自文件 <公开 类型 = 逻辑型 注释 = "通过文件路径创建或更新压缩包,必须成功创建压缩包才能执行本类的其他方法."
            返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 压缩文件 <类型 = 文本型 注释 = "提供空文本或不存在的路径,将创建一个新的压缩包;" 注释 = "若提供了现有的压缩文件,将基于此压缩包进行更新压缩." @默认值 = "">
    参数 是否启用进度反馈 <类型 = 逻辑型 注释 = "是否启用压缩过程中的回调函数,启用后可能会降低压缩速度." @默认值 = 假>
    参数 压缩格式 <类型 = 存档输出格式 注释 = "设置压缩格式;" 注释 = "注意BZip2、GZip、Xz格式只能压缩单个文件,提供了多个文件路径或目录就会失败."
            @默认值 = 存档输出格式.SevenZip>
    参数 压缩密码 <类型 = 文本型 注释 = "设置压缩密码;" 注释 = "只有SevenZip和ZIP支持密码,其他格式设置无效." @默认值 = "">
    {
        @ @sn<this>.CreateArchive(@<压缩文件>.GetText(), @<是否启用进度反馈>, piv::Archive::GetOutFormat(@<压缩格式>), @<压缩密码>)
    }

    方法 创建自字节集 <公开 类型 = 逻辑型 注释 = "通过字节集创建或更新压缩包,必须成功创建压缩包才能执行本类的其他方法."
            返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 压缩包数据 <类型 = 字节集类 注释 = "提供空字节集表示将创建一个新的压缩包;" 注释 = "若提供了现有的压缩数据,将基于此压缩包进行更新压缩." @默认值 = 空对象>
    参数 是否启用进度反馈 <类型 = 逻辑型 注释 = "是否启用压缩过程中的回调函数,启用后可能会降低压缩速度." @默认值 = 假>
    参数 压缩格式 <类型 = 存档输出格式 注释 = "设置压缩格式;" 注释 = "注意BZip2、GZip、Xz格式只能压缩单个文件,提供了多个文件路径或目录就会失败."
            @默认值 = 存档输出格式.SevenZip>
    参数 压缩密码 <类型 = 文本型 注释 = "设置压缩密码;" 注释 = "只有SevenZip和ZIP支持密码,其他格式设置无效." @默认值 = "">
    {
        @ @sn<this>.CreateArchive(@<压缩包数据>, @<是否启用进度反馈>, piv::Archive::GetOutFormat(@<压缩格式>), @<压缩密码>)
    }

    # 压缩 ---

    方法 压缩到文件 <公开 类型 = 逻辑型 注释 = "将已添加到队列中的项目压缩,并输出到指定的文件中." 返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 压缩包路径 <类型 = 文本型 注释 = "所欲输出的压缩包文件路径,若文件不存在将自动创建;" 注释 = "若提供的路径跟\"创建自文件\"时相同,会添加并更新原来的压缩包.">
    {
        @ @sn<this>.CompressTo(@<压缩包路径>)
    }

    方法 压缩到字节集 <公开 类型 = 逻辑型 注释 = "  将已添加到队列中的项目压缩,并输出到指定的字节集中." 注释 = "  本方法只有在使用\"创建自字节集\"创建时才会变成更新模"
            注释 = "式,否则为创建模式." 返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "">
    参数 输出字节集 <类型 = 字节集类 注释 = "所欲输出的字节集变量,字节集的内容将被覆盖.">
    {
        @ @sn<this>.CompressTo(@<输出字节集>)
    }
}

类 存档编辑类 <公开 基础类 = 存档输出模板 注释 = "  封装了编辑压缩包的功能(更名/更新/删除项目),同时也支持\"存档压缩类\"的功能,"
        注释 = "可以看作是\"存档压缩类\"的进阶版,但本类只支持打开压缩文件." 注释 = "  简单流程: 打开文件->(操作项目)->应用更改" 折叠
        @文档 = "category = \"文件压缩\"" @模板实现类 = "" @视窗.后缀文本 = "public PivArchiveEditor">
{

    # 打开 (必须打开成功后才能继续执行后面的方法) ---

    方法 打开文件 <公开 类型 = 逻辑型 注释 = "通过文件路径创建或更新压缩包,必须成功创建压缩包才能执行本类的其他方法."
            返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 压缩文件 <类型 = 文本型 注释 = "提供空文本或不存在的路径,将创建一个新的压缩包;" 注释 = "若提供了现有的压缩文件,将基于此压缩包进行更新压缩." @默认值 = "">
    参数 是否启用进度反馈 <类型 = 逻辑型 注释 = "是否启用压缩过程中的回调函数,启用后可能会降低压缩速度." @默认值 = 假>
    参数 压缩格式 <类型 = 存档输出格式 注释 = "设置压缩格式;" 注释 = "注意BZip2、GZip、Xz格式只能压缩单个文件,提供了多个文件路径或目录就会失败."
            @默认值 = 存档输出格式.SevenZip>
    参数 更新方式 <类型 = 存档更新方式 注释 = "本类不支持模式\"无\",建议使用\"添加并替换文件\"或\"添加并更新文件\"." @默认值 = 存档更新方式.添加并替换文件>
    参数 压缩密码 <类型 = 文本型 注释 = "设置压缩密码;" 注释 = "只有SevenZip和ZIP支持密码,其他格式设置无效." @默认值 = "">
    {
        @ @sn<this>.OpenFile(@<压缩文件>, @<是否启用进度反馈>, piv::Archive::GetOutFormat(@<压缩格式>), @<更新方式>, @<压缩密码>)
    }

    方法 应用更改 <公开 类型 = 逻辑型 注释 = "将已请求更改(如\"更名/更新/删除\"操作)应用到打开的压缩文件中." 返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ApplyChanges()
    }

    # 项目操作 (需要执行"应用更改"才会将更改应用到压缩包中) ---

    方法 索引项目更名 <公开 类型 = 逻辑型 注释 = "请求更改指定索引的项目路径" 返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 项目索引 <类型 = 整数 注释 = "所欲更名的项目索引">
    参数 新路径名称 <类型 = 文本型 注释 = "项目在压缩包中的新路径名称">
    {
        @ @sn<this>.RenameItem(@<项目索引>, @<新路径名称>)
    }

    方法 路径项目更名 <公开 类型 = 逻辑型 注释 = "请求更改指定路径的项目路径" 返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 旧路径名称 <类型 = 文本型 注释 = "所欲更名的旧路径">
    参数 新路径名称 <类型 = 文本型 注释 = "项目在压缩包中的新路径名称">
    {
        @ @sn<this>.RenameItem(@<旧路径名称>, @<新路径名称>)
    }

    方法 更新索引项目自文件 <公开 类型 = 逻辑型 注释 = "用文件数据更新指定索引的项目数据" 返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 项目索引 <类型 = 整数 注释 = "所欲更新的项目索引">
    参数 文件路径 <类型 = 文本型 注释 = "用来更新项目数据的文件路径">
    {
        @ @sn<this>.UpdateItem(@<项目索引>, @<文件路径>)
    }

    方法 更新索引项目自字节集 <公开 类型 = 逻辑型 注释 = "用字节集数据更新指定索引的项目数据" 返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "">
    参数 项目索引 <类型 = 整数 注释 = "所欲更新的项目索引">
    参数 数据内容 <类型 = 字节集类 注释 = "用来更新项目数据的字节集;" 注释 = "所提供的数据会被缓存到本对象中,直到执行\"应用更改\"或\"关闭\"才会释放;"
            注释 = "建议执行本方法后释放提供的字节集,以减少内存占用.">
    {
        @ @sn<this>.UpdateItem(@<项目索引>, @<数据内容>)
    }

    方法 更新路径项目自文件 <公开 类型 = 逻辑型 注释 = "用文件数据更新指定路径的项目数据" 返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 项目路径 <类型 = 文本型 注释 = "所欲更新的项目路径">
    参数 文件路径 <类型 = 文本型 注释 = "用来更新项目数据的文件路径">
    {
        @ @sn<this>.UpdateItem(@<项目路径>, @<文件路径>)
    }

    方法 更新路径项目自字节集 <公开 类型 = 逻辑型 注释 = "用字节集数据更新指定路径的项目数据" 返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 项目路径 <类型 = 文本型 注释 = "所欲更新的项目路径">
    参数 数据内容 <类型 = 字节集类 注释 = "用来更新项目数据的字节集;" 注释 = "所提供的数据会被缓存到本对象中,直到执行\"应用更改\"或\"关闭\"才会释放;"
            注释 = "建议执行本方法后释放提供的字节集,以减少内存占用.">
    {
        @ @sn<this>.UpdateItem(@<项目路径>, @<数据内容>)
    }

    方法 删除索引项目 <公开 类型 = 逻辑型 注释 = "请求删除指定索引的项目" 返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠 @嵌入式方法 = "">
    参数 项目索引 <类型 = 整数 注释 = "所欲删除的项目索引">
    {
        @ @sn<this>.DeleteItem(@<项目索引>)
    }

    方法 删除路径项目 <公开 类型 = 逻辑型 注释 = "请求删除指定路径的项目" 返回值注释 = "返回是否成功,失败时可调用\"取最后错误\"获取错误信息." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 项目路径 <类型 = 文本型 注释 = "所欲删除的项目路径">
    {
        @ @sn<this>.DeleteItem(@<项目路径>)
    }
}

# 数据类型 ===

类 存档解压键值类 <公开 基础类 = 通用排序表模板 注释 = "类型为\"文本到字节集排序表\"(std:map)." 注释 = "\"键\"为解压所得的文件路径,\"值\"为对应文件的数据字节集."
        @文档 = "category = \"文件压缩.数据类型\"" @模板实现类 = "文本型, 字节集类">

类 存档属性变体型 <公开 基础类 = 扩展对象类 注释 = "BitPropVariant变体型可以存储压缩包或项目的各种类型属性值."
        注释 = "执行\"取XXX\"方法时,如果获取的类型与变体类型不同,将会抛出异常." 折叠 @文档 = "category = \"文件压缩.数据类型\"" @强制依赖 = "存档读写类">
{
    方法 是否为空 <公开 类型 = 逻辑型 注释 = "返回本变体型是否为空" 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data().isEmpty()
    }

    方法 到文本 <公开 类型 = 文本型 注释 = "将变体型的任意类型属性值转换到文本" 折叠 @嵌入式方法 = "">
    {
        @ @an<CVolString>(@sn<this>.data().toString().c_str())
    }

    方法 取类型 <公开 类型 = 存档变体类型 注释 = "获取变体型的属性值类型" 折叠 @嵌入式方法 = "">
    {
        @ (@dt<存档变体类型>)@sn<this>.data().type()
    }

    方法 清空 <公开 注释 = "清空本变体体中的属性值" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().clear())
    }

    # ---

    方法 取逻辑型 <公开 类型 = 逻辑型 注释 = "bool 获取类型为逻辑型的属性值" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<BOOL>(@sn<this>.data().getBool())
    }

    方法 取文本 <公开 类型 = 文本型 注释 = "tstring 获取类型为文本的属性值" 折叠 @嵌入式方法 = "">
    {
        @ @an<CVolString>(@sn<this>.data().getString().c_str())
    }

    方法 取无符号字节 <公开 类型 = 短整数 注释 = "uint8_t 获取类型为无符号字节的属性值,返回值向上转换为短整数." 折叠 @嵌入式方法 = "">
    {
        @ static_cast<SHORT>(@sn<this>.data().getUInt8())
    }

    方法 取无符号短整数 <公开 类型 = 整数 注释 = "uint16_t 获取类型为无符号短整数的属性值,返回值向上转换为整数." 折叠 编辑时信息 = "FFFF, 0, 0, 0"
            @嵌入式方法 = "">
    {
        @ static_cast<INT>(@sn<this>.data().getUInt16())
    }

    方法 取无符号整数 <公开 类型 = 长整数 注释 = "uint32_t 获取类型为无符号整数的属性值,返回值向上转换为长整数." 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT64>(@sn<this>.data().getUInt32())
    }

    方法 取无符号长整数 <公开 类型 = 长整数 注释 = "uint64_t 获取类型为无符号长整数的属性值,返回值依然为长整数,所以较大的数值会变成负数." 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT64>(@sn<this>.data().getUInt64())
    }

    方法 取字节 <公开 类型 = 字节 注释 = "int8_t 获取类型为字节的属性值" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<S_BYTE>(@sn<this>.data().getInt8())
    }

    方法 取短整数 <公开 类型 = 短整数 注释 = "int16_t 获取类型为短整数的属性值" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<SHORT>(@sn<this>.data().getInt16())
    }

    方法 取整数 <公开 类型 = 长整数 注释 = "int32_t 获取类型为整数的属性值" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(@sn<this>.data().getInt32())
    }

    方法 取长整数 <公开 类型 = 长整数 注释 = "int64_t 获取类型为长整数的属性值" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT64>(@sn<this>.data().getInt64())
    }

    方法 取文件时间 <公开 类型 = 长整数 注释 = "FILETIME 获取类型为FILETIME结构体的属性值" 返回值注释 = "返回自1601年1月1日以来的100纳秒间隔数(UTC)." 折叠
            @禁止流程检查 = 真>
    {
        @ FILETIME ft = data().getFileTime();
        @ return (INT64)(ft.dwLowDateTime | (ft.dwHighDateTime << 32));
    }

    方法 取标准时间 <公开 类型 = 标准时间类 注释 = "FILETIME 将FILETIME结构体的属性值转换为std::time_point(标准时间类),返回输出." 折叠 @嵌入式方法 = "">
    {
        @ @dt<标准时间类>(@sn<this>.data().getTimePoint())
    }

    # ---

    方法 是否为逻辑型 <公开 类型 = 逻辑型 注释 = "bool 返回本变体型是否为逻辑型" 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data().isBool()
    }

    方法 是否为文本 <公开 类型 = 逻辑型 注释 = "tstring 返回本变体型是否为文本型" 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data().isString()
    }

    方法 是否为无符号字节 <公开 类型 = 逻辑型 注释 = "uint8_t 返回本变体型是否为无符号字节" 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data().isUInt8()
    }

    方法 是否为无符号短整数 <公开 类型 = 逻辑型 注释 = "uint16_t 返回本变体型是否为无符号短整数" 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data().isUInt16()
    }

    方法 是否为无符号整数 <公开 类型 = 逻辑型 注释 = "uint32_t 返回本变体型是否为无符号整数" 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data().isUInt32()
    }

    方法 是否为无符号长整数 <公开 类型 = 逻辑型 注释 = "uint64_t 返回本变体型是否为无符号长整数" 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data().isUInt64()
    }

    方法 是否为字节 <公开 类型 = 逻辑型 注释 = "int8_t 返回本变体型是否为字节" 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data().isInt8()
    }

    方法 是否为短整数 <公开 类型 = 逻辑型 注释 = "int16_t 返回本变体型是否为短整数" 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data().isInt16()
    }

    方法 是否为整数 <公开 类型 = 逻辑型 注释 = "int32_t 返回本变体型是否为整数" 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data().isInt32()
    }

    方法 是否为长整数 <公开 类型 = 逻辑型 注释 = "int64_t 返回本变体型是否为长整数" 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data().isInt64()
    }

    方法 是否为时间 <公开 类型 = 逻辑型 注释 = "FILETIME 返回本变体型是否为FILETIME时间." 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data().isFileTime()
    }

    # ---

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        加入格式文本 (展示内容, "<存档属性变体型> 类型: %s; 值: %s", 多项选择 ((整数)本对象.取类型 (), "空", "逻辑值", "文本值", "无符号字节", "无符号短整数", "无符号整数", "无符号长整数", "字节值", "短整数值", "整数值", "长整数值", "时间值"), 本对象.到文本 ())

    }

    # ---
    # @begin
    # <> <include>
    # private:
    #     bit7z::BitPropVariant m_PropVar;
    # public:
    #     inline_ @sn<current_class>(bit7z::BitPropVariant& PropVar) : @sn<current_class>() { m_PropVar = PropVar; }
    #     inline_ BOOL @an<_IsSelfEqualExtra>(const @sn<current_class>& objCompare) const { return m_PropVar == objCompare.m_PropVar; }
    #     inline_ void @an<_CopySelfFromExtra>(const @sn<current_class>& objCopyFrom) { m_PropVar = objCopyFrom.m_PropVar; }
    #     inline @sn<current_class>& operator=(@sn<current_class>&& rhs) { m_PropVar = std::move(rhs.m_PropVar); return *this; }
    #     inline_ bit7z::BitPropVariant& data() { return m_PropVar; }
    # <> </include>
    # @end
}

类 存档属性表类 <公开 注释 = "\"存档解压类.取压缩包属性表\"所返回的排序表(std:map)类型." 注释 = "其中关键字为属性名,值为存档属性的变体型." 折叠
        @文档 = "category = \"文件压缩.数据类型\"" @强制依赖 = "存档读写类">
{
    方法 取属性 <公开 类型 = 存档属性变体型 注释 = "返回所指定属性名在本哈希表中所对应的变体型值" 折叠 @嵌入式方法 = "">
    参数 属性名 <类型 = 存档属性名 注释 = "提供所欲取的属性名">
    {
        @ @dt<存档属性变体型>(@sn<this>.data() [(bit7z::BitProperty)@<属性名>])
    }

    方法 取成员数 <公开 类型 = 整数 注释 = "返回本哈希表中已有键值对成员的数目" 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data().size()
    }

    方法 是否存在 <公开 类型 = 逻辑型 注释 = "返回所指定的属性是否已经存在" 折叠 @禁止流程检查 = 真>
    参数 属性名 <类型 = 存档属性名 注释 = "提供所对应的属性名">
    {
        @ return (data().find((bit7z::BitProperty)@<属性名>) != data().end());
    }

    方法 清空 <公开 注释 = "清除本哈希表中的所有内容" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().clear()
    }

    方法 是否为空 <公开 类型 = 逻辑型 注释 = "返回本哈希表是否为空" 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data().empty()
    }

    方法 枚举循环 <公开 注释 = "  启动一个循环来正向枚举本哈希表中的每一个成员,在循环中可以调用" 注释 = "\"取枚举属性名\"/\"取枚举值\"方法来获取当前所枚举到键值对的关键字及"
            注释 = "其对应值." 折叠 @嵌入式方法 = "name = mIter\r\nhas_loop_body = true">
    {
        @ auto @sn<rand_name0> = &@sn<this>.data();
        @ for (std::map<bit7z::BitProperty, bit7z::BitPropVariant>::iterator _vmapItr = @sn<rand_name0>->begin(); _vmapItr != @sn<rand_name0>->end(); _vmapItr++)
    }

    方法 取枚举属性名 <公开 类型 = 存档属性名 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前所枚举到键值对"
            注释 = "成员的关键字,如果有多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回最近" 注释 = "层\"枚举循环\"所枚举到键值对成员的关键字." 折叠
            @嵌入式方法 = "parent = \"mIter\"">
    {
        @ (@dt<存档属性名>)_vmapItr->first
    }

    方法 取枚举值 <公开 类型 = 存档属性变体型 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前所枚举到键值对"
            注释 = "成员的值,如果有多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回最近层" 注释 = "\"枚举循环\"所枚举到键值对成员的值." 折叠
            @嵌入式方法 = "parent = \"mIter\"">
    {
        @ @dt<存档属性变体型>(_vmapItr->second)
    }

    # @begin
    # <> <include>
    # private:
    #     std::map<bit7z::BitProperty, bit7z::BitPropVariant> m_map;
    # public:
    #     inline_ @sn<current_class>(std::map<bit7z::BitProperty, bit7z::BitPropVariant>& map) : @sn<current_class>() { m_map = map; }
    #     inline_ BOOL @an<_IsSelfEqualExtra>(const @sn<current_class>& objCompare) const { return m_map == objCompare.m_map; }
    #     inline_ void @an<_CopySelfFromExtra>(const @sn<current_class>& objCopyFrom) { m_map = objCopyFrom.m_map; }
    #     inline @sn<current_class>& operator=(@sn<current_class>&& rhs) { m_map = std::move(rhs.m_map); return *this; }
    #     inline_ std::map<bit7z::BitProperty, bit7z::BitPropVariant>& data() { return m_map; }
    # <> </include>
    # @end
}

类 存档项目信息数组 <公开 注释 = "\"存档解压类.取项目信息表\"所返回的信息数组类型." 折叠 @文档 = "category = \"文件压缩.数据类型\"" @强制依赖 = "存档读写类">
{
    方法 是否为空 <公开 类型 = 逻辑型 注释 = "返回本数组是否为空" 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data().empty()
    }

    方法 取成员数 <公开 类型 = 整数 注释 = "返回数组中的成员数目" 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data().size()
    }

    # ---

    方法 取成员属性表 <公开 类型 = 存档属性表类 注释 = "获取指定项目含有各种类型的属性表(不完整)" 折叠 @嵌入式方法 = "">
    参数 索引 <类型 = 整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ @dt<存档属性表类>(@sn<this>.data() [@<索引>].itemProperties())
    }

    方法 取成员属性 <公开 类型 = 存档属性变体型 注释 = "获取指定项目和类型的属性" 返回值注释 = "失败时返回的空变体型." 折叠 @嵌入式方法 = "">
    参数 索引 <类型 = 整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    参数 属性名 <类型 = 存档属性名>
    {
        @ @dt<存档属性变体型>(@sn<this>.data() [@<索引>].itemProperty((bit7z::BitProperty)@<属性名>))
    }

    方法 取成员项目索引 <公开 类型 = 整数 注释 = "获取指定项目的索引" 折叠 @嵌入式方法 = "">
    参数 索引 <类型 = 整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ (INT)@sn<this>.data() [@<索引>].index()
    }

    方法 取成员名称 <公开 类型 = 文本型 注释 = "获取指定项目的名称(文件名或文件夹名)" 折叠 @嵌入式方法 = "">
    参数 索引 <类型 = 整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ @an<CVolString>(@sn<this>.data() [@<索引>].name().c_str())
    }

    方法 成员是否为目录 <公开 类型 = 逻辑型 注释 = "判断指定项目是否为文件夹" 折叠 @嵌入式方法 = "">
    参数 索引 <类型 = 整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ (BOOL)@sn<this>.data() [@<索引>].isDir()
    }

    方法 成员是否为符号链接 <公开 类型 = 逻辑型 注释 = "判断指定项目是否为符号链接" 折叠 @嵌入式方法 = "">
    参数 索引 <类型 = 整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ (BOOL)@sn<this>.data() [@<索引>].isSymLink()
    }

    方法 取成员扩展名 <公开 类型 = 文本型 注释 = "获取指定项目的扩展名" 折叠 @嵌入式方法 = "">
    参数 索引 <类型 = 整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ @an<CVolString>(@sn<this>.data() [@<索引>].extension().c_str())
    }

    方法 取成员路径 <公开 类型 = 文本型 注释 = "获取指定项目的路径" 折叠 @嵌入式方法 = "">
    参数 索引 <类型 = 整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ @an<CVolString>(@sn<this>.data() [@<索引>].path().c_str())
    }

    方法 取成员项目长度 <公开 类型 = 长整数 注释 = "获取指定项目的未压缩长度" 折叠 @嵌入式方法 = "">
    参数 索引 <类型 = 整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ (INT64)@sn<this>.data() [@<索引>].size()
    }

    方法 取成员打包长度 <公开 类型 = 长整数 注释 = "获取指定项目压缩后的长度" 折叠 @嵌入式方法 = "">
    参数 索引 <类型 = 整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ (INT64)@sn<this>.data() [@<索引>].packSize()
    }

    方法 取成员创建时间 <公开 类型 = 标准时间类 注释 = "获取指定项目的创建时间" 折叠 @嵌入式方法 = "">
    参数 索引 <类型 = 整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ @dt<标准时间类>(@sn<this>.data() [@<索引>].creationTime())
    }

    方法 取成员访问时间 <公开 类型 = 标准时间类 注释 = "获取指定项目的最后访问时间" 折叠 @嵌入式方法 = "">
    参数 索引 <类型 = 整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ @dt<标准时间类>(@sn<this>.data() [@<索引>].lastAccessTime())
    }

    方法 取成员修改时间 <公开 类型 = 标准时间类 注释 = "获取指定项目的最后修改时间" 折叠 @嵌入式方法 = "">
    参数 索引 <类型 = 整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ @dt<标准时间类>(@sn<this>.data() [@<索引>].lastWriteTime())
    }

    方法 取成员文件属性 <公开 类型 = 整数 注释 = "获取指定项目的文件属性" 返回值注释 = "返回\"文件属性\"中一个或多个常量的位或值." 折叠 @嵌入式方法 = "">
    参数 索引 <类型 = 整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ (INT)@sn<this>.data() [@<索引>].attributes()
    }

    方法 成员是否为加密项目 <公开 类型 = 逻辑型 注释 = "判断当前所枚举到的项目是否为加密压缩." 注释 = "只能在本类的\"枚举循环\"/\"逆向枚举循环\"/\"寻找项目\"的子语句体中使用."
            返回值注释 = "返回真表示该项目为加密压缩." 折叠 @嵌入式方法 = "">
    参数 索引 <类型 = 整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ (BOOL)@sn<this>.data() [@<索引>].isEncrypted()
    }

    方法 枚举循环 <公开 注释 = "  启动一个循环来枚举本数组中的每一个成员,在循环中可以调用" 注释 = "\"取枚举索引\"方法来获取当前枚举到成员的索引位置." 折叠
            @嵌入式方法 = "name = viter\r\nhas_loop_body = true">
    {
        @ for (std::size_t container_index = 0; container_index < @sn<this>.data().size(); container_index++)
    }

    方法 取枚举索引 <公开 类型 = 整数 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前枚举到成员的索引位置,如果有"
            注释 = "多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回所处最近层\"枚举循环\"枚举到成员的索" 注释 = "引位置." 折叠 @嵌入式方法 = "parent = \"viter\"">
    {
        @ (INT)container_index
    }

    # @begin
    # <> <include>
    # private:
    #     std::vector<bit7z::BitArchiveItemInfo> m_items;
    # public:
    #     inline_ @sn<current_class>(std::vector<bit7z::BitArchiveItemInfo>& items) : @sn<current_class>() { m_items = items; }
    #     inline_ void @an<_CopySelfFromExtra>(const @sn<current_class>& objCopyFrom) { m_items = objCopyFrom.m_items; }
    #     inline @sn<current_class>& operator=(@sn<current_class>&& rhs) { m_items = std::move(rhs.m_items); return *this; }
    #     inline_ std::vector<bit7z::BitArchiveItemInfo>& data() { return m_items; }
    # <> </include>
    # @end
}

# 常量 ===

类 存档属性名 <公开 注释 = "压缩包或项目的属性名(BitProperty)." 注释 = "部分属性在不同的压缩格式里有不一样的值类型." 折叠
        @文档 = "category = \"文件压缩.辅助类\"" @常量类 = 整数>
{
    常量 无属性 <公开 值 = 0 注释 = "NoProperty">
    常量 主子文件 <公开 值 = 1 注释 = "MainSubfile |  |">
    常量 处理项目索引 <公开 值 = 2 注释 = "HandlerItemIndex |  |">
    常量 路径 <公开 值 = 3 注释 = "Path | 文本型 | 项目">
    常量 名称 <公开 值 = 4 注释 = "Name | 文本型 | 项目">
    常量 扩展名 <公开 值 = 5 注释 = "Extension | 文本型 | 项目">
    常量 是否目录 <公开 值 = 6 注释 = "IsDir | 逻辑型 | 项目">
    常量 项目大小 <公开 值 = 7 注释 = "Size | 无符号长整数 | 项目">
    常量 打包大小 <公开 值 = 8 注释 = "PackSize | 无符号长整数 | 项目">
    常量 文件属性 <公开 值 = 9 注释 = "Attrib | 无符号整数 | 项目">
    常量 创建时间 <公开 值 = 10 注释 = "CTime | 时间 | 项目">
    常量 访问时间 <公开 值 = 11 注释 = "ATime | 时间 | 项目">
    常量 修改时间 <公开 值 = 12 注释 = "MTime | 时间 | 项目">
    常量 固实 <公开 值 = 13 注释 = "Solid  | 逻辑型 | 压缩包">
    常量 已注释 <公开 值 = 14 注释 = "Commented |  |">
    常量 已加密 <公开 值 = 15 注释 = "Encrypted | 逻辑型 | 压缩包/项目">
    常量 分割前 <公开 值 = 16 注释 = "SplitBefore | 逻辑型 | 项目">
    常量 分割后 <公开 值 = 17 注释 = "SplitAfter | 逻辑型 | 项目">
    常量 字典大小 <公开 值 = 18 注释 = "DictionarySize |  |">
    常量 CRC <公开 值 = 19 注释 = "CRC | 无符号整数 | 项目">
    常量 类型 <公开 值 = 20 注释 = "Type | 文本型 | 项目">
    常量 是否Anti <公开 值 = 21 注释 = "IsAnti | 逻辑型 | 项目">
    常量 压缩方法 <公开 值 = 22 注释 = "Method 文本型 |  |">
    常量 主机系统 <公开 值 = 23 注释 = "HostOS | 文本型 | 项目">
    常量 文件系统 <公开 值 = 24 注释 = "FileSystem |  |">
    常量 用户 <公开 值 = 25 注释 = "User |  |">
    常量 组 <公开 值 = 26 注释 = "Group |  |">
    常量 字块 <公开 值 = 27 注释 = "Block | 无符号整数 | 项目">
    常量 注释 <公开 值 = 28 注释 = "Comment |  |">
    常量 位置 <公开 值 = 29 注释 = "Position |  |">
    常量 前缀 <公开 值 = 30 注释 = "Prefix |  |">
    常量 子目录数量 <公开 值 = 31 注释 = "NumSubDirs |  |">
    常量 子文件数量 <公开 值 = 32 注释 = "NumSubFiles |  |">
    常量 解包版本 <公开 值 = 33 注释 = "UnpackVer |  |">
    常量 分卷 <公开 值 = 34 注释 = "Volume |  |">
    常量 分卷压缩 <公开 值 = 35 注释 = "IsVolume | 逻辑型 | 压缩包">
    常量 偏移 <公开 值 = 36 注释 = "Offset | 无符号长整数 | 压缩包">
    常量 链接 <公开 值 = 37 注释 = "Links |  |">
    常量 字块数量 <公开 值 = 38 注释 = "NumBlocks | 无符号整数 | 压缩包">
    常量 分卷数量 <公开 值 = 39 注释 = "NumVolumes | 无符号整数 | 压缩包">
    常量 时间类型 <公开 值 = 40 注释 = "TimeType | 无符号整数 | 项目">
    常量 位数64 <公开 值 = 41 注释 = "Bit64 |  |">
    常量 大端 <公开 值 = 42 注释 = "BigEndian |  |">
    常量 CPU <公开 值 = 43 注释 = "Cpu |  |">
    常量 物理大小 <公开 值 = 44 注释 = "PhySize | 无符号长整数 | 压缩包">
    常量 文件头大小 <公开 值 = 45 注释 = "HeadersSize | 无符号长整数 | 压缩包">
    常量 校验和 <公开 值 = 46 注释 = "Checksum |  |">
    常量 字符序列 <公开 值 = 47 注释 = "Characts | 文本型 | 压缩包/项目">
    常量 VA <公开 值 = 48 注释 = "Va |  |">
    常量 ID <公开 值 = 49 注释 = "Id |  |">
    常量 短名称 <公开 值 = 50 注释 = "ShortName |  |">
    常量 创建应用 <公开 值 = 51 注释 = "CreatorApp |  |">
    常量 扇区大小 <公开 值 = 52 注释 = "SectorSize |  |">
    常量 POSIX文件属性 <公开 值 = 53 注释 = "PosixAttrib |  |">
    常量 符号链接 <公开 值 = 54 注释 = "SymLink |  |">
    常量 错误 <公开 值 = 55 注释 = "Error |  |">
    常量 总大小 <公开 值 = 56 注释 = "TotalSize |  |">
    常量 剩余空间 <公开 值 = 57 注释 = "FreeSpace |  |">
    常量 簇大小 <公开 值 = 58 注释 = "ClusterSize |  |">
    常量 卷标名称 <公开 值 = 59 注释 = "VolumeName |  |">
    常量 本地名称 <公开 值 = 60 注释 = "LocalName |  |">
    常量 提供程序 <公开 值 = 61 注释 = "Provider |  |">
    常量 NT安全描述符 <公开 值 = 62 注释 = "NtSecure |  |">
    常量 是否ALT流 <公开 值 = 63 注释 = "IsAltStream | 逻辑型 | 压缩包">
    常量 是否AUX <公开 值 = 64 注释 = "IsAux |  |">
    常量 是否已删除 <公开 值 = 65 注释 = "IsDeleted |  |">
    常量 是否目录树 <公开 值 = 66 注释 = "IsTree |  |">
    常量 SAH1 <公开 值 = 67 注释 = "Sha1 |  |">
    常量 SHA256 <公开 值 = 68 注释 = "Sha256 |  |">
    常量 错误类型 <公开 值 = 69 注释 = "ErrorType |  |">
    常量 错误数量 <公开 值 = 70 注释 = "NumErrors |  |">
    常量 错误标志 <公开 值 = 71 注释 = "ErrorFlags | 无符号整数 | 压缩包">
    常量 警告标志 <公开 值 = 72 注释 = "WarningFlags |  |">
    常量 警告 <公开 值 = 73 注释 = "Warning |  |">
    常量 流数量 <公开 值 = 74 注释 = "NumStreams |  |">
    常量 ALT流数量 <公开 值 = 75 注释 = "NumAltStreams |  |">
    常量 ALT流大小 <公开 值 = 76 注释 = "AltStreamsSize |  |">
    常量 虚拟大小 <公开 值 = 77 注释 = "VirtualSize |  |">
    常量 解包大小 <公开 值 = 78 注释 = "UnpackSize |  |">
    常量 总物理大小 <公开 值 = 79 注释 = "TotalPhySize |  |">
    常量 分卷索引 <公开 值 = 80 注释 = "VolumeIndex | 无符号整数/无符号长整数 | 压缩包/项目">
    常量 子类型 <公开 值 = 81 注释 = "SubType |  |">
    常量 短注释 <公开 值 = 82 注释 = "ShortComment |  |">
    常量 代码页 <公开 值 = 83 注释 = "CodePage |  |">
    常量 是否非存档类型 <公开 值 = 84 注释 = "IsNotArcType |  |">
    常量 无法检测物理大小 <公开 值 = 85 注释 = "PhySizeCantBeDetected |  |">
    常量 是否允许零文件尾 <公开 值 = 86 注释 = "ZerosTailIsAllowed |  |">
    常量 文件尾大小 <公开 值 = 87 注释 = "TailSize |  |">
    常量 嵌入存根大小 <公开 值 = 88 注释 = "EmbeddedStubSize |  |">
    常量 NT重分析 <公开 值 = 89 注释 = "NtReparse |  |">
    常量 硬链接 <公开 值 = 90 注释 = "HardLink |  |">
    常量 索引节点 <公开 值 = 91 注释 = "INode |  |">
    常量 流ID <公开 值 = 92 注释 = "StreamId |  |">
    常量 只读 <公开 值 = 93 注释 = "ReadOnly |  |">
    常量 输出名称 <公开 值 = 94 注释 = "OutName |  |">
    常量 复制链接 <公开 值 = 95 注释 = "CopyLink |  |">
}

类 存档变体类型 <公开 注释 = "\"存档属性变体型\"的属性值类型(BitPropVariantType)." 折叠 @文档 = "category = \"文件压缩.辅助类\"" @常量类 = 整数>
{
    常量 空 <公开 值 = 0 注释 = "Empty">
    常量 逻辑值 <公开 值 = 1 注释 = "Bool">
    常量 文本值 <公开 值 = 2 注释 = "String">
    常量 无符号字节 <公开 值 = 3 注释 = "UInt8">
    常量 无符号短整数 <公开 值 = 4 注释 = "UInt16">
    常量 无符号整数 <公开 值 = 5 注释 = "UInt32">
    常量 无符号长整数 <公开 值 = 6 注释 = "UInt64">
    常量 字节值 <公开 值 = 7 注释 = "Int8">
    常量 短整数值 <公开 值 = 8 注释 = "Int16">
    常量 整数值 <公开 值 = 9 注释 = "Int32">
    常量 长整数值 <公开 值 = 10 注释 = "Int64">
    常量 时间值 <公开 值 = 11 注释 = "FileTime">
}

类 存档格式类型 <公开 注释 = "存档文件使用的压缩格式(BitFormat)." 折叠 @文档 = "category = \"文件压缩.辅助类\"" @常量类 = 字节>
{
    常量 自动 <公开 值 = 0x00 注释 = "自动检测解压格式">
    常量 ZIP <公开 值 = 0x01 注释 = "扩展名: .zip .zipx .jar .xpi .odt .ods .docx .xlsx .epub">
    常量 BZIP2 <公开 值 = 0x02 注释 = "扩展名: .bz2 .bzip2 .tbz2 .tbz">
    常量 RAR <公开 值 = 0x03 注释 = "扩展名: .rar .r00">
    常量 ARJ <公开 值 = 0x04 注释 = "扩展名: .arj">
    常量 Z <公开 值 = 0x05 注释 = "扩展名: .z .taz">
    常量 LZH <公开 值 = 0x06 注释 = "扩展名: .lzh .lha">
    常量 SevenZip <公开 值 = 0x07 注释 = "扩展名: .7z">
    常量 CAB <公开 值 = 0x08 注释 = "扩展名: .cab">
    常量 NSIS <公开 值 = 0x09 注释 = "扩展名: .nsis">
    常量 LZMA <公开 值 = 0x0A 注释 = "扩展名: .lzma">
    常量 LZMA86 <公开 值 = 0x0B 注释 = "扩展名:">
    常量 XZ <公开 值 = 0x0C 注释 = "扩展名: .xz .txz">
    常量 PPMD <公开 值 = 0x0D 注释 = "扩展名: .ppmd">
    常量 VHDX <公开 值 = 0xC4 注释 = "扩展名: .vhdx">
    常量 COFF <公开 值 = 0xC6 注释 = "扩展名:">
    常量 EXT <公开 值 = 0xC7 注释 = "扩展名: .ext .ext2 .ext3 .ext4 .img">
    常量 VMDK <公开 值 = 0xC8 注释 = "扩展名: .vmdk">
    常量 VDI <公开 值 = 0xC9 注释 = "扩展名: .vdi">
    常量 QCOW <公开 值 = 0xCA 注释 = "扩展名: .qcow .qcow2 .qcow2c">
    常量 GPT <公开 值 = 0xCB 注释 = "扩展名:">
    常量 RAR5 <公开 值 = 0xCC 注释 = "扩展名: .rar .r00">
    常量 IHEX <公开 值 = 0xCD 注释 = "扩展名: .ihex">
    常量 HXS <公开 值 = 0xCE 注释 = "扩展名: .hxs .hxi .hxr .hxq .hxw .lit">
    常量 TE <公开 值 = 0xCF 注释 = "扩展名:">
    常量 UEFIc <公开 值 = 0xD0 注释 = "扩展名: .scap">
    常量 UEFIs <公开 值 = 0xD1 注释 = "扩展名: .uefif">
    常量 SquashFS <公开 值 = 0xD2 注释 = "扩展名: .squashfs">
    常量 CramFS <公开 值 = 0xD3 注释 = "扩展名: .cramfs">
    常量 APM <公开 值 = 0xD4 注释 = "扩展名: .apm">
    常量 MSLZ <公开 值 = 0xD5 注释 = "扩展名: .mslz">
    常量 FLV <公开 值 = 0xD6 注释 = "扩展名:">
    常量 SWF <公开 值 = 0xD7 注释 = "扩展名:">
    常量 SWFC <公开 值 = 0xD8 注释 = "扩展名:">
    常量 NTFS <公开 值 = 0xD9 注释 = "扩展名: .ntfs .img">
    常量 FAT <公开 值 = 0xDA 注释 = "扩展名: .fat .img">
    常量 MBR <公开 值 = 0xDB 注释 = "扩展名:">
    常量 VHD <公开 值 = 0xDC 注释 = "扩展名: .vhd">
    常量 PE <公开 值 = 0xDD 注释 = "扩展名:">
    常量 ELF <公开 值 = 0xDE 注释 = "扩展名:">
    常量 MACHO <公开 值 = 0xDF 注释 = "扩展名:">
    常量 UDF <公开 值 = 0xE0 注释 = "扩展名: .udf .iso .img">
    常量 XAR <公开 值 = 0xE1 注释 = "扩展名: .xar .pkg">
    常量 MUB <公开 值 = 0xE2 注释 = "扩展名: .mub">
    常量 HFS <公开 值 = 0xE3 注释 = "扩展名: .hfs .hfsx">
    常量 DMG <公开 值 = 0xE4 注释 = "扩展名: .dmg">
    常量 COMPOUND <公开 值 = 0xE5 注释 = "扩展名: .msi .msp .doc .xls .ppt">
    常量 WIM <公开 值 = 0xE6 注释 = "扩展名: .wim .swm .esd">
    常量 ISO <公开 值 = 0xE7 注释 = "扩展名: .iso .img">
    常量 CHM <公开 值 = 0xE9 注释 = "扩展名: .chm .chw .chi .chq">
    常量 SPLIT <公开 值 = 0xEA 注释 = "扩展名: .001 .002 ...">
    常量 RPM <公开 值 = 0xEB 注释 = "扩展名: .rpm">
    常量 DEB <公开 值 = 0xEC 注释 = "扩展名: .deb">
    常量 CPIO <公开 值 = 0xED 注释 = "扩展名: .cpio">
    常量 TAR <公开 值 = 0xEE 注释 = "扩展名: .tar">
    常量 GZIP <公开 值 = 0xEF 注释 = "扩展名: .gz .gzip .tgz">
}

类 存档输入格式 <公开 注释 = "解压文件时使用的压缩格式(BitInFormat)." 注释 = "一般推荐使用\"自动\",会根据文件头和扩展名识别压缩格式;"
        注释 = "但如果遇到没有文件头的格式且扩展名与格式不符的,\"自动\"会无法正确识别格式." 折叠 @文档 = "category = \"文件压缩.辅助类\"" @常量类 = 字节>
{
    常量 自动 <公开 值 = 0x00 注释 = "自动检测解压格式">
    常量 ZIP <公开 值 = 0x01 注释 = "扩展名: .zip .zipx .jar .xpi .odt .ods .docx .xlsx .epub">
    常量 BZIP2 <公开 值 = 0x02 注释 = "扩展名: .bz2 .bzip2 .tbz2 .tbz">
    常量 RAR <公开 值 = 0x03 注释 = "扩展名: .rar .r00" 注释 = "注意: 如果是rar5的压缩包,请使用RAR5">
    常量 ARJ <公开 值 = 0x04 注释 = "扩展名: .arj">
    常量 Z <公开 值 = 0x05 注释 = "扩展名: .z .taz">
    常量 LZH <公开 值 = 0x06 注释 = "扩展名: .lzh .lha">
    常量 SevenZip <公开 值 = 0x07 注释 = "扩展名: .7z">
    常量 CAB <公开 值 = 0x08 注释 = "扩展名: .cab">
    常量 NSIS <公开 值 = 0x09 注释 = "扩展名: .nsis">
    常量 LZMA <公开 值 = 0x0A 注释 = "扩展名: .lzma">
    常量 LZMA86 <公开 值 = 0x0B 注释 = "扩展名:">
    常量 XZ <公开 值 = 0x0C 注释 = "扩展名: .xz .txz">
    常量 PPMD <公开 值 = 0x0D 注释 = "扩展名: .ppmd">
    常量 VHDX <公开 值 = 0xC4 注释 = "扩展名: .vhdx">
    常量 COFF <公开 值 = 0xC6 注释 = "扩展名:">
    常量 EXT <公开 值 = 0xC7 注释 = "扩展名: .ext .ext2 .ext3 .ext4 .img">
    常量 VMDK <公开 值 = 0xC8 注释 = "扩展名: .vmdk">
    常量 VDI <公开 值 = 0xC9 注释 = "扩展名: .vdi">
    常量 QCOW <公开 值 = 0xCA 注释 = "扩展名: .qcow .qcow2 .qcow2c">
    常量 GPT <公开 值 = 0xCB 注释 = "扩展名:">
    常量 RAR5 <公开 值 = 0xCC 注释 = "扩展名: .rar .r00">
    常量 IHEX <公开 值 = 0xCD 注释 = "扩展名: .ihex">
    常量 HXS <公开 值 = 0xCE 注释 = "扩展名: .hxs .hxi .hxr .hxq .hxw .lit">
    常量 TE <公开 值 = 0xCF 注释 = "扩展名:">
    常量 UEFIc <公开 值 = 0xD0 注释 = "扩展名: .scap">
    常量 UEFIs <公开 值 = 0xD1 注释 = "扩展名: .uefif">
    常量 SquashFS <公开 值 = 0xD2 注释 = "扩展名: .squashfs">
    常量 CramFS <公开 值 = 0xD3 注释 = "扩展名: .cramfs">
    常量 APM <公开 值 = 0xD4 注释 = "扩展名: .apm">
    常量 MSLZ <公开 值 = 0xD5 注释 = "扩展名: .mslz">
    常量 FLV <公开 值 = 0xD6 注释 = "扩展名:">
    常量 SWF <公开 值 = 0xD7 注释 = "扩展名:">
    常量 SWFC <公开 值 = 0xD8 注释 = "扩展名:">
    常量 NTFS <公开 值 = 0xD9 注释 = "扩展名: .ntfs .img">
    常量 FAT <公开 值 = 0xDA 注释 = "扩展名: .fat .img">
    常量 MBR <公开 值 = 0xDB 注释 = "扩展名:">
    常量 VHD <公开 值 = 0xDC 注释 = "扩展名: .vhd">
    常量 PE <公开 值 = 0xDD 注释 = "扩展名:">
    常量 ELF <公开 值 = 0xDE 注释 = "扩展名:">
    常量 MACHO <公开 值 = 0xDF 注释 = "扩展名:">
    常量 UDF <公开 值 = 0xE0 注释 = "扩展名: .udf .iso .img">
    常量 XAR <公开 值 = 0xE1 注释 = "扩展名: .xar .pkg">
    常量 MUB <公开 值 = 0xE2 注释 = "扩展名: .mub">
    常量 HFS <公开 值 = 0xE3 注释 = "扩展名: .hfs .hfsx">
    常量 DMG <公开 值 = 0xE4 注释 = "扩展名: .dmg">
    常量 COMPOUND <公开 值 = 0xE5 注释 = "扩展名: .msi .msp .doc .xls .ppt">
    常量 WIM <公开 值 = 0xE6 注释 = "扩展名: .wim .swm .esd">
    常量 ISO <公开 值 = 0xE7 注释 = "扩展名: .iso .img">
    常量 CHM <公开 值 = 0xE9 注释 = "扩展名: .chm .chw .chi .chq">
    常量 SPLIT <公开 值 = 0xEA 注释 = "扩展名: .001 .002 ...">
    常量 RPM <公开 值 = 0xEB 注释 = "扩展名: .rpm">
    常量 DEB <公开 值 = 0xEC 注释 = "扩展名: .deb">
    常量 CPIO <公开 值 = 0xED 注释 = "扩展名: .cpio">
    常量 TAR <公开 值 = 0xEE 注释 = "扩展名: .tar">
    常量 GZIP <公开 值 = 0xEF 注释 = "扩展名: .gz .gzip .tgz">
}

类 存档输出格式 <公开 注释 = "创建压缩包时使用的压缩格式(BitInOutFormat)." 折叠 @文档 = "category = \"文件压缩.辅助类\"" @常量类 = 字节>
{
    常量 ZIP <公开 值 = 0x01 注释 = "扩展名: .zip .zipx .jar .xpi .odt .ods .docx .xlsx .epub">
    常量 BZIP2 <公开 值 = 0x02 注释 = "扩展名: .bz2 .bzip2 .tbz2 .tbz">
    常量 SevenZip <公开 值 = 0x07 注释 = "扩展名: .7z">
    常量 XZ <公开 值 = 0x0C 注释 = "扩展名: .xz .txz">
    常量 WIM <公开 值 = 0xE6 注释 = "扩展名: .wim .swm .esd">
    常量 TAR <公开 值 = 0xEE 注释 = "扩展名: .tar">
    常量 GZIP <公开 值 = 0xEF 注释 = "扩展名: .gz .gzip .tgz">
}

类 存档压缩等级 <公开 注释 = "创建压缩文件时使用的压缩等级(BitCompressionLevel)." 注释 = "注: Wim、Tar格式不支持设置压缩等级,但只是无效果,不会抛出错误." 折叠
        @文档 = "category = \"文件压缩.辅助类\"" @常量类 = 整数>
{
    常量 仅存储 <公开 值 = 0 注释 = "复制模式(不压缩)" 注释 = "BZip2/GZip/Xz不支持该选项,会抛出异常.">
    常量 极速压缩 <公开 值 = 1 注释 = "GZip不支持该选项,会抛出异常.">
    常量 快速压缩 <公开 值 = 3>
    常量 标准压缩 <公开 值 = 5>
    常量 最大压缩 <公开 值 = 7>
    常量 极限压缩 <公开 值 = 9>
}

类 存档压缩方法 <公开 注释 = "创建压缩包时使用的压缩方法(BitCompressionMethod)." 折叠 @文档 = "category = \"文件压缩.辅助类\"" @常量类 = 整数>
{
    常量 仅存储 <公开 值 = 0 注释 = "不压缩,仅打包文件">
    常量 Deflate <公开 值 = 1>
    常量 Deflate64 <公开 值 = 2>
    常量 BZip2 <公开 值 = 3>
    常量 LZMA <公开 值 = 4>
    常量 LZMA2 <公开 值 = 5>
    常量 PPMd <公开 值 = 6>
}

类 存档更新方式 <公开 注释 = "添加文件到压缩包时,如何处理已经存在的文件(UpdateMode)." 折叠 @文档 = "category = \"文件压缩.辅助类\"" @常量类 = 整数>
{
    常量 无 <公开 值 = 0 注释 = "None 不能添加文件到现有的压缩包中,程序将抛出异常." 编辑时信息 = "0, 67C51, 0, 0">
    常量 添加并更新文件 <公开 值 = 1 注释 = "Append 将新文件添加到目标压缩包中,重复的文件不进行替换." 编辑时信息 = "0, 67C51, 0, 0">
    常量 添加并替换文件 <公开 值 = 2 注释 = "Update 将新文件添加到目标压缩包中,并覆盖替换重复的文件." 编辑时信息 = "0, 67C51, 0, 0">
}
