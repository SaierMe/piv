<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "本库最低要求为C++17标准" @视窗.附加编译参数 = "cpp: /std:c++17" @视窗.需求VS版本 = "15-"
        "@视窗.外部头文件.全局-100" = "<chrono>">

# fmtlong ====

类 格式日志类 <公开 注释 = "  fmtlog 是一个纳秒级精度的高性能异步日志记录库,使用fmtlib进行" 注释 = "文本格式化(std::format标准)."
        注释 = "  本类在项目周期中只能同时打开一个日志文件." 折叠 @文档 = "category = \"日志记录.fmtlog\"" @视窗.外部头文件 = "src\\piv_fmtlog.h"
        @类用途 = 访问静态成员 @别名 = "//fmtlog" @别名类型 = 本地类>
{

    # 源码: https://github.com/MengRao/fmtlog
    # 版本: 2.2.1 (2023/03/26)
    # 作者: Meng Rao
    # 封装: Xelloss
    # 修改版源码: https://github.com/SaierMe/fmtlog
    # ---

    方法 初始化 <公开 静态 类型 = 逻辑型 注释 = "为了简化日志库的使用,而提供的二次封装." 注释 = "提供一系列在启动程序时应该调用的方法,例如:"
            注释 = "打开日志文件、设置各种参数和启动轮询线程..." 返回值注释 = "提供了文件路径时,返回是否打开文件成功,即使返回失败,仍会初始化其他流程." 折叠>
    参数 文件路径 <类型 = 文本型 注释 = "请提供完整的日志文件名;" 注释 = "如果提供空对象,则不创建日志文件;提供空文本时使用\"运行目录\\log.txt\"." @默认值 = "">
    参数 是否每日文件 <类型 = 逻辑型 注释 = "为真时在文件名中添加日期,每到第二天的00:00切换到新日期的日志文件." @默认值 = 假>
    参数 日志级别 <类型 = 字节 注释 = "低于该级别的日志将直接丢弃,不会写入到日志文件:"
            注释 = "0=DBG/调试; 1=INF/信息; 2=WRN/警告; 3=ERR/错误; 4=OFF/关闭" @默认值 = 0>
    参数 刷新延迟 <类型 = 长整数 注释 = "刷新延迟时间(纳秒),默认值为3秒;" 注释 = "最早的日志经过了指定的延迟时间,将立即刷新缓冲区." @默认值 = 3000000000>
    参数 刷新级别 <类型 = 字节 注释 = "默认为\"OFF/关闭\",如果遇到级别大于指定刷新级别的日志,将立即刷新缓冲区."
            注释 = "0=DBG/调试; 1=INF/信息; 2=WRN/警告; 3=ERR/错误; 4=OFF/关闭" @默认值 = 4>
    参数 缓冲区大小 <类型 = 整数 注释 = "默认为8KB,如果缓冲区已满,将立即刷新缓冲区." @默认值 = 8192>
    参数 是否重写 <类型 = 逻辑型 注释 = "如果文件已存在,为真时将清空文件的内容;" 注释 = "为假则在文件尾部添加日志." @默认值 = 假>
    参数 日期格式 <类型 = 文本型 注释 = "\"是否每日文件\"为真时可用,为假时忽略." 注释 = "指定插入到日志文件名的日期时间格式. 默认格式类似\".2022-04-24\"."
            注释 = "下列为常用的格式替换符,完整请看\"标准时间类.取格式时间\":" 注释 = "  %y  年份的后2位              例: 22"
            注释 = "  %Y  完整的4位年份            例: 2022" 注释 = "  %b  缩写的月份名称           例: Apr"
            注释 = "  %B  完整的月份名称           例: April" 注释 = "  %m  十进制的月份             例: 04"
            注释 = "  %d  2位数的某月第N天         例: 01" 注释 = "  %e  2位的某月第N天,前补空格  例:  1"
            注释 = "  %a  缩写的星期名称           例: Fri" 注释 = "  %A  完整的星期名称           例: Friday"
            注释 = "  %u  十进制的星期数(1-7)      例: 5" 注释 = "  %w  星期数(0-6),0为星期天    例: 5"
            注释 = "  %D  等价于 %m/%d/%y          例: 04/01/22" 注释 = "  %F  等价于 %Y-%m-%d          例: 2022-04-01"
            @默认值 = ".%F">
    {
        格式日志类.置日志级别 (日志级别)
        格式日志类.置刷新延迟 (刷新延迟)
        格式日志类.置刷新级别 (刷新级别)
        格式日志类.置缓冲区尺寸 (缓冲区大小)
        格式日志类.启动轮询线程 (1000000)
        如果 (文本是否为空对象 (文件路径) == 假)
        {
            如果 (文本是否为空 (文件路径))
            {
                文件路径 = 取运行目录 () + "log.txt"
            }
            如果 (是否每日文件)
            {
                如果 (格式日志类.打开每日日志 (文件路径, 是否重写, 0, 1, 日期格式) == 假)
                {
                    返回 (假)
                }
            }
            否则
            {
                如果 (格式日志类.打开日志文件 (文件路径, 是否重写) == 假)
                {
                    返回 (假)
                }

            }
        }
        返回 (真)
    }

    方法 销毁 <公开 静态 注释 = "为了简化日志库的使用,而提供的二次封装." 注释 = "提供一系列在退出程序时应该调用的方法,例如:" 注释 = "停止轮询线程、关闭日志文件" 折叠>
    {
        格式日志类.停止轮询线程 ()
        格式日志类.关闭日志文件 ()
    }

    # 日志文件相关

    方法 打开日志文件 <公开 静态 类型 = 逻辑型 注释 = "只有打开日志文件之后,才会将日志输出到文件中." 注释 = "不打开文件仍可以记录日志,但需要通过\"格式日志事件类\"进行处理."
            注释 = "重复执行将切换到新打开的文件." 返回值注释 = "返回是否打开成功" 折叠 @禁止流程检查 = 真>
    参数 文件路径 <类型 = 文本型 注释 = "请提供完整的日志文件名,会自动创建中间目录和文件.">
    参数 是否重写 <类型 = 逻辑型 注释 = "如果文件已存在,为真时将清空文件的内容;为假则在文件尾部添加日志." @默认值 = 假>
    {
        @ @an<CVolString> strPath;
        @ ::CreateDirectoryTree(::GetAbsOSPathOfFileName(@<文件路径>.GetText(), strPath));
        @ return fmtlog::setLogFile(@<文件路径>.GetText(), @<是否重写>);
    }

    方法 打开每日日志 <公开 静态 类型 = 逻辑型 注释 = "打开带日期格式的日志文件,程序运行到第二天会自动切换到新日期的日志文件." 注释 = "只有打开日志文件之后,才会将日志输出到文件中."
            注释 = "不打开文件仍可以记录日志,但需要通过\"格式日志事件类\"进行处理." 注释 = "重复执行将切换到新打开的文件." 返回值注释 = "返回是否打开成功." 折叠 @禁止流程检查 = 真>
    参数 文件路径 <类型 = 文本型 注释 = "请提供完整路径的日志文件名,会自动创建中间目录和文件;"
            注释 = "如提供的路径为\"d:\\\\log.txt\",则默认创建的文件为\"d:\\\\log.2022-04-24.txt\".">
    参数 是否重写 <类型 = 逻辑型 注释 = "如果文件已存在,为真时将清空文件的内容;" 注释 = "为假则在文件尾部添加日志." @默认值 = 假>
    参数 时 <类型 = 整数 注释 = "第二天到达该时间后切换到新日期的日志文件,默认为凌晨0点." @默认值 = 0>
    参数 分 <类型 = 整数 注释 = "默认为0分" @默认值 = 0>
    参数 日期格式 <类型 = 文本型 注释 = "指定插入到日志文件名的日期时间格式. 默认格式类似\".2022-04-24\"."
            注释 = "下列为常用的格式替换符,完整请看\"标准时间类.取格式时间\":" 注释 = "  %y  年份的后2位              例: 22"
            注释 = "  %Y  完整的4位年份            例: 2022" 注释 = "  %b  缩写的月份名称           例: Apr"
            注释 = "  %B  完整的月份名称           例: April" 注释 = "  %m  十进制的月份             例: 04"
            注释 = "  %d  2位数的某月第N天         例: 01" 注释 = "  %e  2位的某月第N天,前补空格  例:  1"
            注释 = "  %a  缩写的星期名称           例: Fri" 注释 = "  %A  完整的星期名称           例: Friday"
            注释 = "  %u  十进制的星期数(1-7)      例: 5" 注释 = "  %w  星期数(0-6),0为星期天    例: 5"
            注释 = "  %D  等价于 %m/%d/%y          例: 04/01/22" 注释 = "  %F  等价于 %Y-%m-%d          例: 2022-04-01"
            @默认值 = ".%F">
    {
        @ @an<CVolString> strPath;
        @ ::CreateDirectoryTree(::GetAbsOSPathOfFileName(@<文件路径>.GetText(), strPath));
        @ return fmtlog::setDailyLogFile(@<文件路径>.GetText(), @<是否重写>, @<时>, @<分>, @<日期格式>);
    }

    方法 关闭日志文件 <公开 静态 注释 = "关闭日志文件,关闭前会将缓冲区的日志写入到文件中." 注释 = "关闭后仍可以记录日志,但需要通过\"格式日志事件类\"进行处理." 折叠
            @嵌入式方法 = "">
    {
        @ fmtlog::closeDailyLogFile()
    }

    # 执行相关

    方法 启动轮询线程 <公开 静态 注释 = "在后台启动一个轮询线程,按指定的间隔周期式执行轮询." 注释 = "启动轮询线程后,用户不应再手动使用\"轮询\"."
            注释 = "建议在启动程序后立即使用本方法." 折叠 @嵌入式方法 = "">
    参数 轮询周期 <类型 = 长整数 注释 = "每次轮询之间的间隔时间(单位为纳秒),默认值为1秒;" 注释 = "注: 1秒=1000*1000*1000纳秒" @默认值 = 1000000000>
    {
        @ fmtlog::startPollingThread(@<轮询周期>)
    }

    方法 停止轮询线程 <公开 静态 注释 = "停止轮询线程,建议在退出程序之前使用本方法." 折叠 @嵌入式方法 = "">
    {
        @ fmtlog::stopPollingThread()
    }

    方法 轮询 <公开 静态 注释 = "收集所有线程的日志信息,然后写入到日志文件中." 注释 = "如果未使用\"启动轮询线程\",用户需要不断重复调用本方法." 折叠 @嵌入式方法 = "">
    参数 强制刷新 <类型 = 逻辑型 注释 = "如果为真,将刷新内部的文件缓存,立即将缓存写出到日志文件." @默认值 = 假>
    {
        @ fmtlog::poll(@<强制刷新>)
    }

    # 加入日志相关

    方法 加入日志 <公开 静态 注释 = "将日志内容推送到日志队列中,可指定日志级别和格式化日志内容." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 日志级别 <类型 = 字节 注释 = "如果提供的日志级别低于当前日志级别,这条日志将被丢弃;"
            注释 = "0=DBG/调试; 1=INF/信息; 2=WRN/警告; 3=ERR/错误; 4=OFF/关闭">
    参数 日志内容 <类型 = 文本型 注释 = "提供日志内容,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注.">
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志内容\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、标准文本类、文本视图类" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ FMTLOG_ONCE_LOC(__FMTLOG_SOURCE(@sn<current_source_file>, @sn<current_source_line>), static_cast<fmtlog::LogLevel>(@<日志级别>), @<日志内容>, @<替换数据>)
    }

    方法 加入调试日志 <公开 静态 注释 = "将调试级别的日志内容推送到日志队列中,可格式化日志内容." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 日志内容 <类型 = 文本型 注释 = "提供日志内容,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注.">
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志内容\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、标准文本类、文本视图类" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ FMTLOG_ONCE_LOC(__FMTLOG_SOURCE(@sn<current_source_file>, @sn<current_source_line>), fmtlog::DBG, @<日志内容>, @<替换数据>)
    }

    方法 加入信息日志 <公开 静态 注释 = "将信息级别的日志内容推送到日志队列中,可格式化日志内容." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 日志内容 <类型 = 文本型 注释 = "提供日志内容,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注.">
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志内容\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、标准文本类、文本视图类" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ FMTLOG_ONCE_LOC(__FMTLOG_SOURCE(@sn<current_source_file>, @sn<current_source_line>), fmtlog::INF, @<日志内容>, @<替换数据>)
    }

    方法 加入警告日志 <公开 静态 注释 = "将警告级别的日志内容推送到日志队列中,可格式化日志内容." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 日志内容 <类型 = 文本型 注释 = "提供日志内容,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注.">
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志内容\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、标准文本类、文本视图类" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ FMTLOG_ONCE_LOC(__FMTLOG_SOURCE(@sn<current_source_file>, @sn<current_source_line>), fmtlog::WRN, @<日志内容>, @<替换数据>)
    }

    方法 加入错误日志 <公开 静态 注释 = "将错误级别的日志内容推送到日志队列中,可格式化日志内容." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 日志内容 <类型 = 文本型 注释 = "提供日志内容,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注.">
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志内容\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、标准文本类、文本视图类" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ FMTLOG_ONCE_LOC(__FMTLOG_SOURCE(@sn<current_source_file>, @sn<current_source_line>), fmtlog::ERR, @<日志内容>, @<替换数据>)
    }

    方法 加入日志_间隔 <公开 静态 注释 = "将日志内容推送到日志队列中,可指定日志级别和格式化日志内容." 注释 = "本方法限制日志的记录频率,低于最小间隔的日志将被丢弃." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 日志级别 <类型 = 字节 注释 = "如果提供的日志级别低于当前日志级别,这条日志将被丢弃;"
            注释 = "0=DBG/调试; 1=INF/信息; 2=WRN/警告; 3=ERR/错误; 4=OFF/关闭">
    参数 最小间隔 <类型 = 长整数 注释 = "提供最小的日志记录间隔,如果上条日志的经过时间低于此间隔,这条日志将被丢弃;" 注释 = "单位为纳秒,1秒=1000*1000*1000纳秒.">
    参数 日志内容 <类型 = 文本型 注释 = "提供日志内容,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注.">
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志内容\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、标准文本类、文本视图类" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ FMTLOG_LIMIT_LOC(__FMTLOG_SOURCE(@sn<current_source_file>, @sn<current_source_line>), @<最小间隔>, static_cast<fmtlog::LogLevel>(@<日志级别>), @<日志内容>, @<替换数据>)
    }

    方法 加入调试日志_间隔 <公开 静态 注释 = "将调试级别的日志内容推送到日志队列中,可格式化日志内容." 注释 = "本方法限制日志的记录频率,低于最小间隔的日志将被丢弃." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 最小间隔 <类型 = 长整数 注释 = "提供最小的日志记录间隔,如果上条日志的经过时间低于此间隔,这条日志将被丢弃." 注释 = "单位为纳秒,1秒=1000*1000*1000纳秒.">
    参数 日志内容 <类型 = 文本型 注释 = "提供日志内容,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注.">
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志内容\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、标准文本类、文本视图类" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ FMTLOG_LIMIT_LOC(__FMTLOG_SOURCE(@sn<current_source_file>, @sn<current_source_line>), @<最小间隔>, fmtlog::DBG, @<日志内容>, @<替换数据>)
    }

    方法 加入信息日志_间隔 <公开 静态 注释 = "将信息级别的日志内容推送到日志队列中,可格式化日志内容." 注释 = "本方法限制日志的记录频率,低于最小间隔的日志将被丢弃." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 最小间隔 <类型 = 长整数 注释 = "提供最小的日志记录间隔,如果上条日志的经过时间低于此间隔,这条日志将被丢弃." 注释 = "单位为纳秒,1秒=1000*1000*1000纳秒.">
    参数 日志内容 <类型 = 文本型 注释 = "提供日志内容,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注.">
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志内容\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、标准文本类、文本视图类" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ FMTLOG_LIMIT_LOC(__FMTLOG_SOURCE(@sn<current_source_file>, @sn<current_source_line>), @<最小间隔>, fmtlog::INF, @<日志内容>, @<替换数据>)
    }

    方法 加入警告日志_间隔 <公开 静态 注释 = "将警告级别的日志内容推送到日志队列中,可格式化日志内容." 注释 = "本方法限制日志的记录频率,低于最小间隔的日志将被丢弃." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 最小间隔 <类型 = 长整数 注释 = "提供最小的日志记录间隔,如果上条日志的经过时间低于此间隔,这条日志将被丢弃." 注释 = "单位为纳秒,1秒=1000*1000*1000纳秒.">
    参数 日志内容 <类型 = 文本型 注释 = "提供日志内容,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注.">
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志内容\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、标准文本类、文本视图类" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ FMTLOG_LIMIT_LOC(__FMTLOG_SOURCE(@sn<current_source_file>, @sn<current_source_line>), @<最小间隔>, fmtlog::WRN, @<日志内容>, @<替换数据>)
    }

    方法 加入错误日志_间隔 <公开 静态 注释 = "将错误级别的日志内容推送到日志队列中,可格式化日志内容." 注释 = "本方法限制日志的记录频率,低于最小间隔的日志将被丢弃." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 最小间隔 <类型 = 长整数 注释 = "提供最小的日志记录间隔,如果上条日志的经过时间低于此间隔,这条日志将被丢弃." 注释 = "单位为纳秒,1秒=1000*1000*1000纳秒.">
    参数 日志内容 <类型 = 文本型 注释 = "提供日志内容,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注.">
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志内容\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、标准文本类、文本视图类" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ FMTLOG_LIMIT_LOC(__FMTLOG_SOURCE(@sn<current_source_file>, @sn<current_source_line>), @<最小间隔>, fmtlog::ERR, @<日志内容>, @<替换数据>)
    }

    方法 加入文本日志 <公开 静态 注释 = "将纯文本的日志内容推送到日志队列中,可指定日志级别." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 日志级别 <类型 = 字节 注释 = "如果提供的日志级别低于当前日志级别,这条日志将被丢弃;"
            注释 = "0=DBG/调试; 1=INF/信息; 2=WRN/警告; 3=ERR/错误; 4=OFF/关闭">
    参数 日志内容 <类型 = 文本型 注释 = "提供日志内容,前面会自动加上日志头.">
    {
        @ FMTLOG_ONCE_PLAIN(__FMTLOG_SOURCE(@sn<current_source_file>, @sn<current_source_line>), static_cast<fmtlog::LogLevel>(@<日志级别>), @<日志内容>)
    }

    方法 加入文本日志_间隔 <公开 静态 注释 = "将纯文本的日志内容推送到日志队列中,可指定日志级别." 注释 = "本方法限制日志的记录频率,低于最小间隔的日志将被丢弃." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 日志级别 <类型 = 字节 注释 = "如果提供的日志级别低于当前日志级别,这条日志将被丢弃;"
            注释 = "0=DBG/调试; 1=INF/信息; 2=WRN/警告; 3=ERR/错误; 4=OFF/关闭">
    参数 最小间隔 <类型 = 长整数 注释 = "提供最小的日志记录间隔,如果上条日志的经过时间低于此间隔,这条日志将被丢弃;" 注释 = "单位为纳秒,1秒=1000*1000*1000纳秒.">
    参数 日志内容 <类型 = 文本型 注释 = "提供日志内容,前面会自动加上日志头.">
    {
        @ FMTLOG_LIMIT_PLAIN(__FMTLOG_SOURCE(@sn<current_source_file>, @sn<current_source_line>), @<最小间隔>, static_cast<fmtlog::LogLevel>(@<日志级别>), @<日志内容>)
    }

    方法 加入来源日志 <公开 静态 注释 = "将日志内容推送到日志队列中,可指定产生日志的来源、日志级别和格式化日志内容." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 日志来源 <类型 = 文本型 注释 = "产生日志的来源,比如\"file.cpp:89, function\".">
    参数 日志级别 <类型 = 字节 注释 = "如果提供的日志级别低于当前日志级别,这条日志将被丢弃;"
            注释 = "0=DBG/调试; 1=INF/信息; 2=WRN/警告; 3=ERR/错误; 4=OFF/关闭">
    参数 日志内容 <类型 = 文本型 注释 = "提供日志内容,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注.">
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志内容\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、标准文本类、文本视图类" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ FMTLOG_ONCE_LOC(@<日志来源>, static_cast<fmtlog::LogLevel>(@<日志级别>), @<日志内容>, @<替换数据>)
    }

    # 设置相关

    方法 置日志头格式 <公开 静态 注释 = "设置自定义的日志头格式" 返回值注释 = "设置了错误的格式会抛出异常错误,如果不想崩溃,请确保格式正确或俘获异常." 折叠 @嵌入式方法 = "">
    参数 格式文本 <类型 = 文本型 注释 = "默认格式为: \"08:42:00.173887 main.v:32 信息[19484] \""
            注释 = "下列为日志头专用的格式替换符,格式替换符需要用\"{}\"包围,若要输入符号" 注释 = "\"{\"和\"}\",需要用\"{{\"和\"}}\"转义."
            注释 = "  l:       日志级别                例: INF" 注释 = "  L:       日志级别(中文)          例: 信息"
            注释 = "  s:       源码文件名和行号        例: main.v:32"
            注释 = "  g:       文件路径和行号          例: D:\\日志测试\\src\\main.v:32"
            注释 = "  t:       线程名称(默认为线程ID)  例: main" 注释 = "  a:       星期几                  例: Fri"
            注释 = "  b:       月份名称                例: Apr" 注释 = "  Y:       年份                    例: 2022"
            注释 = "  C:       年份后两位              例: 22" 注释 = "  m:       月份                    例: 04"
            注释 = "  d:       日                      例: 22" 注释 = "  H:       小时                    例: 16"
            注释 = "  M:       分钟                    例: 08" 注释 = "  S:       秒                      例: 09"
            注释 = "  e:       毫秒                    例: 796" 注释 = "  f:       微秒                    例: 796341"
            注释 = "  F:       纳秒                    例: 796341126"
            注释 = "  Ymd:     年-月-日                例: 2022-04-22"
            注释 = "  HMS:     时:分:秒                例: 16:08:09"
            注释 = "  HMSe:    时:分:毫秒              例: 16:08:09.796"
            注释 = "  HMSf:    时:分:微秒              例: 16:08:09.796341"
            注释 = "  HMSF:    时:分:纳秒              例: 16:08:09.796341126"
            注释 = "  YmdHMS:  年-月-日 时:分:秒       例: 2022-04-22 16:08:09"
            注释 = "  YmdHMSe: 年-月-日 时:分:秒.毫秒  例: 2022-04-22 16:08:09.796"
            注释 = "  YmdHMSf: 年-月-日 时:分:秒.微秒  例: 2022-04-22 16:08:09.796341"
            注释 = "  YmdHMSF: 年-月-日 时:分:秒.纳秒  例: 2022-04-22 16:08:09.796341126"
            @默认值 = "{HMSf} {s:<10} {L}[{t:<5}] ">
    {
        @ fmtlog::setHeaderPattern(@<格式文本>.GetText())
    }

    方法 预先分配 <公开 静态 注释 = "为当前线程预先分配线程队列" 折叠 @嵌入式方法 = "">
    {
        @ fmtlog::preallocate()
    }

    方法 置刷新延迟 <公开 静态 注释 = "设置触发刷新缓冲区的延迟时间(单位为纳秒)." 注释 = "默认值为3秒,如果最早的日志经过了指定的延迟时间,将立即刷新缓冲区." 折叠 @嵌入式方法 = "">
    参数 延迟 <类型 = 长整数 注释 = "延迟时间,单位为纳秒;" 注释 = "默认值为3秒=3*1000*1000*1000">
    {
        @ fmtlog::setFlushDelay(@<延迟>)
    }

    方法 置刷新级别 <公开 静态 注释 = "设置触发刷新缓冲区的日志级别." 注释 = "默认级别为\"OFF/关闭\",如果遇到级别大于指定刷新级别的日志,将立即刷新缓冲区."
            注释 = "例如遇到错误信息时,立即将日志写入到文件中,以免因为程序崩溃或异常退出而丢失日志." 折叠 @嵌入式方法 = "">
    参数 日志级别 <类型 = 字节 注释 = "0=DBG/调试; 1=INF/信息; 2=WRN/警告; 3=ERR/错误; 4=OFF/关闭">
    {
        @ fmtlog::flushOn(static_cast<fmtlog::LogLevel>(@<日志级别>))
    }

    方法 置缓冲区尺寸 <公开 静态 注释 = "设置触发刷新缓冲区的缓冲区尺寸." 注释 = "默认值为大于8KB,如果缓冲区的空间大于指定的字节数,将立即刷新缓冲区." 折叠 @嵌入式方法 = "">
    参数 字节数 <类型 = 整数 注释 = "单位为字节,默认值为大于8KB.">
    {
        @ fmtlog::setFlushBufSize(static_cast<uint32_t>(@<字节数>))
    }

    方法 置线程名称 <公开 静态 注释 = "设置当前线程的名称,该名称会显示在日志中,默认为当前的线程ID." 注释 = "设置的名称只对当前线程有效,可以为不同的线程设置不同的名称." 折叠
            @嵌入式方法 = "">
    参数 线程名称 <类型 = 文本型>
    {
        @ fmtlog::setThreadName(@<线程名称>.GetText())
    }

    方法 置日志级别 <公开 静态 注释 = "设置当前的日志级别,低于此级别的日志将被丢弃." 注释 = "默认值为1,不输出调试日志." 折叠 @嵌入式方法 = "">
    参数 日志级别 <类型 = 字节 注释 = "0=DBG/调试; 1=INF/信息; 2=WRN/警告; 3=ERR/错误; 4=OFF/关闭" @默认值 = 0>
    {
        @ fmtlog::setLogLevel(static_cast<fmtlog::LogLevel>(@<日志级别>))
    }

    方法 取日志级别 <公开 静态 类型 = 字节 注释 = "获取当前的日志级别,低于此级别的日志将被丢弃."
            返回值注释 = "0=DBG/调试; 1=INF/信息; 2=WRN/警告; 3=ERR/错误; 4=OFF/关闭" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<S_BYTE>(fmtlog::getLogLevel())
    }

    方法 检查日志级别 <公开 静态 类型 = 逻辑型 注释 = "检查指定的日志级别是否大于等于当前日志级别." 返回值注释 = "返回真表示测试的级别大于等于当前日志级别,否则返回假." 折叠
            @嵌入式方法 = "">
    参数 日志级别 <类型 = 字节 注释 = "0=DBG/调试; 1=INF/信息; 2=WRN/警告; 3=ERR/错误; 4=OFF/关闭" @默认值 = 0>
    {
        @ fmtlog::checkLogLevel(static_cast<fmtlog::LogLevel>(@<日志级别>))
    }

    方法 取级别颜色 <公开 静态 类型 = 整数 注释 = "获取指定日志级别的颜色" 返回值注释 = "返回颜色值" 折叠>
    参数 日志级别 <类型 = 字节 注释 = "0=DBG/调试; 1=INF/信息; 2=WRN/警告; 3=ERR/错误; 4=OFF/关闭">
    参数 深色背景 <类型 = 逻辑型 注释 = "默认为浅色背景" @默认值 = 假>
    {
        分支判断 ((整数)日志级别)
        {
            分支 (0)
            {
                返回 (选择 (深色背景, 颜色类.蓝灰色, 颜色类.深灰色))
            }
            分支 (1)
            {
                返回 (选择 (深色背景, 颜色类.青绿色, 颜色类.蓝色))
            }
            分支 (2)
            {
                返回 (选择 (深色背景, 颜色类.黄色, 颜色类.黄褐色))
            }
            分支 (3)
            {
                返回 (选择 (深色背景, 颜色类.红色, 颜色类.红色))
            }

        }
        返回 (选择 (深色背景, 颜色类.白色, 颜色类.黑色))
    }

    方法 禁用级别检查 <静态 注释 = "调用本方法以禁用日志级别检查,让低于当前日志级别的日志都能输出." 注释 = "禁用后,\"检查日志级别\"方法将始终返回真."
            @视窗.预定义宏 = "FMTLOG_NO_CHECK_LEVEL">
}

类 格式日志事件类 <公开 注释 = "全局只能有一个实例能生效,以最后定义的为准." 折叠 折叠2 @文档 = "category = \"日志记录.fmtlog\"" @强制依赖 = "格式日志类">
{
    方法 类_初始化 <折叠>
    {
        @ fmtlog::setLogQFullCB(reinterpret_cast<fmtlog::LogQFullCBFn>(&@sn<current_class>::FnLogQFullCb), reinterpret_cast<void*>(this));
        本对象.置最小日志级别 (0)
    }

    方法 置最小日志级别 <公开 注释 = "设置最小日志级别,低于最小日志级别的日志将不出现在事件中." 折叠>
    参数 最小日志级别 <类型 = 字节 注释 = "0=DBG/调试; 1=INF/信息; 2=WRN/警告; 3=ERR/错误; 4=OFF/关闭">
    {
        @ fmtlog::setLogCB(reinterpret_cast<fmtlog::LogCBFn>(&@sn<current_class>::FnLogCb), static_cast<fmtlog::LogLevel>(@<最小日志级别>));
    }

    方法 取级别颜色 <公开 类型 = 整数 注释 = "获取指定日志级别的颜色" 返回值注释 = "返回颜色值" 折叠>
    参数 日志级别 <类型 = 字节 注释 = "0=DBG/调试; 1=INF/信息; 2=WRN/警告; 3=ERR/错误; 4=OFF/关闭">
    参数 深色背景 <类型 = 逻辑型 注释 = "默认为浅色背景" @默认值 = 假>
    {
        分支判断 ((整数)日志级别)
        {
            分支 (0)
            {
                返回 (选择 (深色背景, 颜色类.蓝灰色, 颜色类.深灰色))
            }
            分支 (1)
            {
                返回 (选择 (深色背景, 颜色类.青绿色, 颜色类.蓝色))
            }
            分支 (2)
            {
                返回 (选择 (深色背景, 颜色类.黄色, 颜色类.黄褐色))
            }
            分支 (3)
            {
                返回 (选择 (深色背景, 颜色类.红色, 颜色类.红色))
            }

        }
        返回 (选择 (深色背景, 颜色类.白色, 颜色类.黑色))
    }

    方法 日志队列已满 <公开 定义事件 类型 = 整数 注释 = "当日志队列已满时会响应本事件." 注释 = "这表示轮询线程没有跟上,可能会丢失日志." 返回值注释 = "此返回值无意义">

    方法 日志内容 <公开 定义事件 类型 = 整数 注释 = "每次轮询后,所有线程产生的日志信息都会逐条在这里展示." 注释 = "即使日志文件未打开或已关闭,仍会响应本事件."
            注释 = "警告: 请勿在本事件中执行耗时操作,以免造成阻塞." 返回值注释 = "此返回值无意义" 折叠>
    参数 时间戳 <类型 = 长整数 注释 = "纳秒级精度的19位时间戳">
    参数 日志级别 <类型 = 字节 注释 = "0=DBG/调试; 1=INF/信息; 2=WRN/警告; 3=ERR/错误; 4=OFF/关闭">
    参数 语句位置 <类型 = 文本型 注释 = "日志产生语句所在的源码文件名和行号">
    参数 线程名称 <类型 = 文本型 注释 = "当前的线程ID,或用户通过\"置线程名称\"设置的名称.">
    参数 日志内容 <类型 = 文本型 注释 = "包括日志头和正文的完整日志内容,日志头可以用\"格式日志类.置日志头格式\"自定义.">
    参数 正文内容 <类型 = 文本型 注释 = "当前日志的正文(除去日志头的内容)">
    参数 文件位置 <类型 = 变整数 注释 = "当前日志内容在日志文件中的首位置(字节单位)">

    # @begin
    # <> <include>
    # static void FnLogCb(int64_t ns, fmtlog::LogLevel level, fmt::basic_string_view<FMTLOG_CHAR> location, size_t basePos,
    #                     fmt::basic_string_view<FMTLOG_CHAR> threadName, fmt::basic_string_view<FMTLOG_CHAR> msg, size_t bodyPos, size_t logFilePos, void* userData)
    # {
    #     ((@sn<current_class>*)userData)->@<日志内容>(ns, static_cast<S_BYTE>(level),
    #         @an<CVolString>(location.data(), location.size()), @an<CVolString>(threadName.data(), threadName.size()),
    #         @an<CVolString>(msg.data(), msg.size()), @an<CVolString>(msg.data() + bodyPos), static_cast<INT_P>(logFilePos));
    # }
    # static void FnLogQFullCb(void* userData)
    # {
    #     ((@sn<current_class>*)userData)->@<日志队列已满>();
    # }
    # <> </include>
    # @end
}

# Quill ====

类 Quill日志类 <公开 注释 = "Quill日志记录器 v10.0.0" 注释 = "程序可以存在多个日志记录器,一个文件也可以被多个记录器写入;"
        注释 = "记录器以\"记录器名称\"为唯一标识,如果名称已经存在,则开启现有的记录器." 注释 = "注意: 记录器的开启和关闭非线程安全,请勿在多个线程中同时执行,其他命令是线程安全的." 折叠
        @文档 = "category = \"日志记录.Quill\"" @视窗.外部头文件 = "src\\piv_quill.hpp" @视窗.头文件搜寻目录 = "src">
{
    变量 格式选项 <公开 类型 = Quill格式选项 注释 = "可以设置日志消息和时间戳的格式." 注释 = "必须在开启记录器之前设置,后续修改无效." @属性变量 = 真>

    方法 日志输出 <公开 定义事件 类型 = 整数 注释 = "当Quill后端线程处理了当前事件接收器的日志消息,触发本事件."
            注释 = "注意: 必须在\"开启记录器\"时将\"输出到事件\"设置为真,才能接收到本事件." 折叠>
    参数 元数据 <类型 = Quill元数据 注释 = "日志元数据,含有源文件名、行号、方法名、日志级别等信息.">
    参数 时间戳 <类型 = 长整数 注释 = "纳秒级别的日志记录时间戳">
    参数 记录器名称 <类型 = 文本视图类U 注释 = "输出这条日志的记录器名称">
    参数 日志消息 <类型 = 文本视图类U 注释 = "日志消息的正文">
    参数 日志语句 <类型 = 文本视图类U 注释 = "完整的日志行,包括时间、源语句位置等日志格式和正文,以换行符结尾.">

    方法 打开日志文件 <公开 类型 = 整数 注释 = "创建或获取指定文件路径的接收器,日志记录器将写出日志消息到日志文件中."
            注释 = " 1. 同样文件路径的接收器只能创建一个,但可以关联到多个日志记录器;" 注释 = " 2. 如果同名的接收器已经存在,则直接使用现有的接收器选项;"
            注释 = " 3. 只有已关联的日志记录器都被删除后,文件接收器才会被删除;" 注释 = " 4. 必须在\"开启记录器\"之前打开文件;" 返回值注释 = "返回值:"
            返回值注释 = " 1: 成功打开了新文件;" 返回值注释 = " 0: 指定文件路径的接收器已经存在,\"文件选项\"以之前打开的为准;"
            返回值注释 = "-1: 打开失败,是提供的文件路径有问题;" 折叠 @禁止流程检查 = 真>
    参数 文件路径 <类型 = 文本型 注释 = "请提供包括文件名在内的完整文件路径,如果中间目录不存在会自动创建.">
    参数 文件选项 <类型 = Quill文件选项 注释 = "请提供日志文件的选项,返回值为0时将忽略该选项.">
    参数 文件日志级别 <类型 = Quill日志级别 注释 = "低于该级别的日志会被过滤掉,不会被接收器处理." @默认值 = Quill日志级别.Trace_L3>
    {
        如果 (创建目录 (取文件名路径 (文件路径)) == 假)
        {
            返回 (-1)
        }
        @ INT ret = 0;
        @ PivW2U file_name{@<文件路径>};
        @ std::shared_ptr<quill::Sink> sink = quill::Frontend::get_sink(file_name.str);
        @ if (!sink) {
        @     ret = 1;
        @     sink = quill::Frontend::create_or_get_sink<quill::FileSink>(file_name.str, @<文件选项>, quill::FileEventNotifier{});
        @ }
        @ sink->set_log_level_filter(@<文件日志级别>);
        @ sinks.push_back(sink);
        @ return ret;
    }

    方法 打开轮替文件 <公开 类型 = 整数 注释 = "相比\"打开日志文件\",本方法可以根据指定的时间频率和文件大小,轮替日志文件." 返回值注释 = "返回值:"
            返回值注释 = " 1: 成功打开了新文件;" 返回值注释 = " 0: 指定文件路径的接收器已经存在,\"文件选项\"以之前打开的为准;"
            返回值注释 = "-1: 打开失败,是提供的文件路径有问题;" 折叠 @禁止流程检查 = 真>
    参数 文件路径 <类型 = 文本型 注释 = "请提供包括文件名在内的完整文件路径,如果中间目录不存在会自动创建.">
    参数 文件选项 <类型 = Quill轮替文件选项 注释 = "请提供轮替文件选项,返回值为0时将忽略该选项.">
    参数 文件日志级别 <类型 = Quill日志级别 注释 = "低于该级别的日志会被过滤掉,不会被接收器处理." @默认值 = Quill日志级别.Trace_L3>
    {
        如果 (创建目录 (取文件名路径 (文件路径)) == 假)
        {
            返回 (-1)
        }
        @ INT ret = 0;
        @ PivW2U file_name{@<文件路径>};
        @ std::shared_ptr<quill::Sink> sink = quill::Frontend::get_sink(file_name.str);
        @ if (!sink) {
        @     ret = 1;
        @     sink = quill::Frontend::create_or_get_sink<quill::RotatingSink<quill::FileSink>>(file_name.str, @<文件选项>, quill::FileEventNotifier{});
        @ }
        @ sink->set_log_level_filter(@<文件日志级别>);
        @ sinks.push_back(sink);
        @ return ret;
    }

    方法 开启记录器 <公开 类型 = 逻辑型 注释 = "创建或开启现有的日志记录器,返回是否创建了新的日志记录器." 注释 = " 1. 若要自定义日志格式,请在开启之前设置\"格式选项\"成员变量;"
            注释 = " 2. 请在执行本方法之前使用\"打开xxx\"等方法,否则日志将不会输出到文件;" 注释 = " 3. 如果返回假,则表示开启了同名的记录器,其配置选项以现有记录器的为准,"
            注释 = "而非本方法提供的参数;" 注释 = " 4. 日志记录器的配置选项不可修改,只能先\"关闭\",然后在开启时重新设置;" 返回值注释 = "返回真表示创建了新的日志记录器;"
            返回值注释 = "返回假表示开启了现有的同名记录器;" 折叠 @禁止流程检查 = 真>
    参数 记录器名称 <类型 = 文本型 注释 = "请提供记录器名称,名称是记录器的唯一标识符;" 注释 = "程序允许存在多个日志记录器,但每个名称的记录器只能存在一个.">
    参数 输出到事件 <类型 = 逻辑型 注释 = "是否将日志消息输出到本类的接收事件\"日志输出\"." @默认值 = 假>
    参数 输出到控制台 <类型 = 逻辑型 注释 = "是否将日志消息输出到控制台,应当在编译为控制台程序时才设置为真." @默认值 = 假>
    {
        @ if (logger) return FALSE;
        @ PivW2U logger_name{@<记录器名称>};
        @ if (quill::Frontend::get_logger(logger_name.str) != nullptr)
        @     return FALSE;
        @ if (@<输出到事件>) {
        @     event_sink = quill::Frontend::create_or_get_sink<quill::EventSink>(piv::encoding::value_to_hex(this, std::string{}, true),
        @                  std::bind(&@sn<current_class>::@<日志输出>, this, std::placeholders::_1, std::placeholders::_2,
        @                  std::placeholders::_3, std::placeholders::_4, std::placeholders::_5));
        @     sinks.push_back(event_sink);
        @ }
        @ if (@<输出到控制台>) {
        @     setlocale(LC_ALL, ".UTF-8");
        @     sinks.push_back(quill::Frontend::create_or_get_sink<quill::ConsoleSink>("console"));
        @ }
        @ if (!quill::Backend::is_running()) {
        @     quill::BackendOptions backend_opt;
        @     backend_opt.check_printable_char = {}; // 禁止可打印字符检查(默认会将中文转义)
        @     quill::Backend::start(backend_opt);
        @ }
        @ logger = quill::Frontend::create_or_get_logger(logger_name.str, sinks, @<格式选项>);
        @ sinks.clear();
        @ return TRUE;
    }

    方法 通知关闭 <公开 注释 = "异步删除当前的日志记录器." 注释 = "当与日志接收器关联的记录器都被删除后,该接收器也会被删除."
            注释 = "本方法的作用是关闭对应的日志文件(前提是没有其他记录器关联了同一个文件)." 折叠>
    {
        @ if (logger) {
        @     quill::Frontend::remove_logger(logger);
        @     logger = nullptr;
        @ }
    }

    方法 关闭 <公开 注释 = "异步删除当前的日志记录器,但阻塞当前线程直到删除完成." 注释 = "当与日志接收器关联的记录器都被删除后,该接收器也会被删除."
            注释 = "本方法的作用是关闭对应的日志文件(前提是没有其他记录器关联了同一个文件)." 折叠>
    参数 休眠时间 <类型 = 整数 @默认值 = 100>
    {
        @ if (logger) {
        @     quill::Frontend::remove_logger_blocking(logger, static_cast<uint32_t>(@<休眠时间>));
        @     logger = nullptr;
        @ }
    }

    方法 立即刷新频率 <公开 属性写 注释 = "根据消息计数设置日志记录的刷新间隔." 注释 = "注意: 设置为1可以确保每条日志消息都同步写入到文件,"
            注释 = "但会显著影响程序性能,应该仅在调试时使用." 折叠>
    参数 刷新频率 <类型 = 整数 注释 = "指定每隔多少条消息执行一次立即刷新;" 注释 = "默认为0(禁用立即刷新).">
    {
        @ if (logger)
        @     logger->set_immediate_flush(static_cast<uint32_t>(@<刷新频率>));
    }

    方法 日志级别 <公开 属性写 注释 = "设置当前日志记录器的级别,低于该级别的日志将不会被处理." 注释 = "注意: 需要在\"开启记录器\"之后设置." 折叠>
    参数 日志级别 <类型 = Quill日志级别 注释 = "默认为信息级别(4)">
    {
        @ if (logger)
        @     logger->set_log_level(@<日志级别>);
    }

    方法 日志级别 <公开 属性读 类型 = Quill日志级别 注释 = "返回当前日志记录器的级别,低于该级别的日志将不会被处理."
            返回值注释 = "默认为信息级别(4),如果未开启日志记录器返回无(10)." 折叠 @禁止流程检查 = 真>
    {
        @ return logger != nullptr ? logger->get_log_level() : quill::LogLevel::None;
    }

    方法 刷新日志 <公开 注释 = "阻塞调用线程,直到刷新当前时间戳之前的所有日志消息." 注释 = "后端线程将调用所有记录器和所有接收器上的写入操作,直到当前时间点之前的日志消息被全部写入."
            注释 = "注: 一般不需要调用本方法." 折叠>
    参数 休眠时间 <类型 = 整数 注释 = "阻塞队列已满时,两次重试之间以及检查刷新完成之间的休眠持续时间(以纳秒为单位)." @默认值 = 100>
    {
        @ if (logger)
        @     logger->flush_log(static_cast<uint32_t>(@<休眠时间>));
    }

    # 普通日志 ---

    方法 加入日志 <公开 注释 = "将指定级别的日志内容推送到日志队列中." 注释 = "注: 本方法支持灵活的日志级别和运行期日志格式,但相比其他方法会增加一定的开销." 折叠 @嵌入式方法 = "">
    参数 日志级别 <类型 = Quill日志级别 注释 = "如果提供的日志级别低于当前的日志过滤级别,这条日志将被丢弃;" 注释 = "">
    参数 日志格式 <注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "支持的文本类型: 文本型、标准文本类、文本视图类、文本指针、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_RUNTIME_METADATA_HYBRID(@sn<this>.logger, @<日志级别>, QUILL_U8(@sn<current_source_file>), atoi(@sn<current_source_line>),
        @     QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     nullptr, PivAny2U<true>(@<日志格式>).c_str(), @<替换数据>)
    }

    方法 加入跟踪日志_L3 <公开 注释 = "将L3跟踪级别的日志消息推送到日志队列中" 折叠 @嵌入式方法 = "">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_TRACE_L3(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    方法 加入跟踪日志_L2 <公开 注释 = "将L2跟踪级别的日志消息推送到日志队列中" 折叠 @嵌入式方法 = "">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_TRACE_L2(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    方法 加入跟踪日志_L1 <公开 注释 = "将L1跟踪级别的日志消息推送到日志队列中" 折叠 @嵌入式方法 = "">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_TRACE_L1(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    方法 加入调试日志 <公开 注释 = "将调试级别的日志消息推送到日志队列中" 折叠 @嵌入式方法 = "">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_DEBUG(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    方法 加入信息日志 <公开 注释 = "将信息级别的日志消息推送到日志队列中" 折叠 @嵌入式方法 = "">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_INFO(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    方法 加入通知日志 <公开 注释 = "将通知级别的日志消息推送到日志队列中" 折叠 @嵌入式方法 = "">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_NOTICE(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    方法 加入警告日志 <公开 注释 = "将警告级别的日志消息推送到日志队列中" 折叠 @嵌入式方法 = "">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_WARNING(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    方法 加入错误日志 <公开 注释 = "将错误级别的日志消息推送到日志队列中" 折叠 @嵌入式方法 = "">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_ERROR(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    方法 加入致命日志 <公开 注释 = "将致命错误级别的日志消息推送到日志队列中" 折叠 @嵌入式方法 = "">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_CRITICAL(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    方法 加入来源日志 <公开 注释 = "将指定来源和级别的日志内容推送到日志队列中." 注释 = "注: 本方法用于从其他日志库转发日志,但开销较大." 折叠 @嵌入式方法 = "">
    参数 源文件名 <注释 = "当前日志所处源文件的名称,支持通用文本数据" @匹配类型 = 通用型>
    参数 源行号 <类型 = 整数 注释 = "当前日志在所处源文件中的行号位置" @默认值 = 0>
    参数 源方法名 <注释 = "当前日志所处方法的名称,支持通用文本数据" @匹配类型 = 通用型>
    参数 日志级别 <类型 = Quill日志级别 注释 = "如果提供的日志级别低于当前的日志过滤级别,这条日志将被丢弃;" 注释 = "">
    参数 日志格式 <注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "支持的文本类型: 文本型、标准文本类、文本视图类、文本指针、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_RUNTIME_METADATA_DEEP(@sn<this>.logger, @<日志级别>, PivAny2U<true>(@<源文件名>).c_str(), @<源行号>, PivAny2U<true>(@<源方法名>).c_str(),
        @     nullptr, PivAny2U<true>(@<日志格式>).c_str(), @<替换数据>)
    }

    # 回溯日志 ---

    方法 初始化回溯 <公开 注释 = "在当前记录器初始化启用回溯日志功能." 注释 = "回溯日志会存储在环形缓冲区中,并按需显示."
            注释 = "注意: 重复调用本方法会清空之前的环形缓冲区,并按新的参数重新初始化." 折叠>
    参数 最大容量 <类型 = 整数 注释 = "环形缓冲区的容量,即可存储的回溯日志数量;" 注释 = "超出容量后,最早的回溯日志将被新推送的日志覆盖.">
    参数 刷新级别 <类型 = Quill日志级别 注释 = "当记录器记录了等于或高于该级别的日志后,将刷新显示所有已存储的回溯日志."
            注释 = "默认值\"无\",表示必须用户调用\"刷新回溯\"才能输出回溯日志." @默认值 = Quill日志级别.无>
    {
        @ if (logger)
        @     logger->init_backtrace(static_cast<uint32_t>(@<最大容量>), @<刷新级别>);
    }

    方法 刷新回溯 <公开 注释 = "立即输出已存储的回溯日志" 折叠>
    {
        @ if (logger)
        @     logger->flush_backtrace();
    }

    方法 加入回溯日志 <公开 注释 = "将日志消息推送到后端的环形缓冲区中,回溯日志将按需延后显示." 注释 = "注意: 请先调用\"初始化回溯\",并阅读里面的使用说明." 折叠 @嵌入式方法 = "">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_BACKTRACE(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    # 最小间隔日志 ---

    方法 加入跟踪日志_L3_间隔 <公开 注释 = "将L3跟踪级别的日志消息推送到日志队列中,仅在调试版程序中输出." 注释 = " 1. 用于限制日志的记录频率,低于最小间隔的日志将被丢弃;"
            注释 = " 2. 日志消息后面会标上间隔的日志数量;" 注释 = " 3. 每个前端线程拥有独立的计时器;" 折叠 @嵌入式方法 = "">
    参数 最小间隔 <类型 = 长整数 注释 = "提供最小的日志记录间隔,如果上条日志的经过时间低于此间隔,这条日志将被丢弃;" 注释 = "单位为纳秒,1秒=1000*1000*1000纳秒.">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_TRACE_L3_LIMIT(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @<最小间隔>, @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    方法 加入跟踪日志_L2_间隔 <公开 注释 = "将L2跟踪级别的日志消息推送到日志队列中,仅在调试版程序中输出." 注释 = " 1. 用于限制日志的记录频率,低于最小间隔的日志将被丢弃;"
            注释 = " 2. 日志消息后面会标上间隔的日志数量;" 注释 = " 3. 每个前端线程拥有独立的计时器;" 折叠 @嵌入式方法 = "">
    参数 最小间隔 <类型 = 长整数 注释 = "提供最小的日志记录间隔,如果上条日志的经过时间低于此间隔,这条日志将被丢弃;" 注释 = "单位为纳秒,1秒=1000*1000*1000纳秒.">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_TRACE_L2_LIMIT(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @<最小间隔>, @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    方法 加入跟踪日志_L1_间隔 <公开 注释 = "将L1跟踪级别的日志消息推送到日志队列中,仅在调试版程序中输出." 注释 = " 1. 用于限制日志的记录频率,低于最小间隔的日志将被丢弃;"
            注释 = " 2. 日志消息后面会标上间隔的日志数量;" 注释 = " 3. 每个前端线程拥有独立的计时器;" 折叠 @嵌入式方法 = "">
    参数 最小间隔 <类型 = 长整数 注释 = "提供最小的日志记录间隔,如果上条日志的经过时间低于此间隔,这条日志将被丢弃;" 注释 = "单位为纳秒,1秒=1000*1000*1000纳秒.">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_TRACE_L1_LIMIT(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @<最小间隔>, @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    方法 加入调试日志_间隔 <公开 注释 = "将调试级别的日志消息推送到日志队列中." 注释 = " 1. 用于限制日志的记录频率,低于最小间隔的日志将被丢弃;"
            注释 = " 2. 日志消息后面会标上间隔的日志数量;" 注释 = " 3. 每个前端线程拥有独立的计时器;" 折叠 @嵌入式方法 = "">
    参数 最小间隔 <类型 = 长整数 注释 = "提供最小的日志记录间隔,如果上条日志的经过时间低于此间隔,这条日志将被丢弃;" 注释 = "单位为纳秒,1秒=1000*1000*1000纳秒.">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_DEBUG_LIMIT(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @<最小间隔>, @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    方法 加入信息日志_间隔 <公开 注释 = "将信息级别的日志消息推送到日志队列中." 注释 = " 1. 用于限制日志的记录频率,低于最小间隔的日志将被丢弃;"
            注释 = " 2. 日志消息后面会标上间隔的日志数量;" 注释 = " 3. 每个前端线程拥有独立的计时器;" 折叠 @嵌入式方法 = "">
    参数 最小间隔 <类型 = 长整数 注释 = "提供最小的日志记录间隔,如果上条日志的经过时间低于此间隔,这条日志将被丢弃;" 注释 = "单位为纳秒,1秒=1000*1000*1000纳秒.">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_INFO_LIMIT(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @<最小间隔>, @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    方法 加入通知日志_间隔 <公开 注释 = "将通知级别的日志消息推送到日志队列中." 注释 = " 1. 用于限制日志的记录频率,低于最小间隔的日志将被丢弃;"
            注释 = " 2. 日志消息后面会标上间隔的日志数量;" 注释 = " 3. 每个前端线程拥有独立的计时器;" 折叠 @嵌入式方法 = "">
    参数 最小间隔 <类型 = 长整数 注释 = "提供最小的日志记录间隔,如果上条日志的经过时间低于此间隔,这条日志将被丢弃;" 注释 = "单位为纳秒,1秒=1000*1000*1000纳秒.">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_NOTICE_LIMIT(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @<最小间隔>, @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    方法 加入警告日志_间隔 <公开 注释 = "将警告级别的日志消息推送到日志队列中." 注释 = " 1. 用于限制日志的记录频率,低于最小间隔的日志将被丢弃;"
            注释 = " 2. 日志消息后面会标上间隔的日志数量;" 注释 = " 3. 每个前端线程拥有独立的计时器;" 折叠 @嵌入式方法 = "">
    参数 最小间隔 <类型 = 长整数 注释 = "提供最小的日志记录间隔,如果上条日志的经过时间低于此间隔,这条日志将被丢弃;" 注释 = "单位为纳秒,1秒=1000*1000*1000纳秒.">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_WARNING_LIMIT(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @<最小间隔>, @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    方法 加入错误日志_间隔 <公开 注释 = "将错误级别的日志消息推送到日志队列中." 注释 = " 1. 用于限制日志的记录频率,低于最小间隔的日志将被丢弃;"
            注释 = " 2. 日志消息后面会标上间隔的日志数量;" 注释 = " 3. 每个前端线程拥有独立的计时器;" 折叠 @嵌入式方法 = "">
    参数 最小间隔 <类型 = 长整数 注释 = "提供最小的日志记录间隔,如果上条日志的经过时间低于此间隔,这条日志将被丢弃;" 注释 = "单位为纳秒,1秒=1000*1000*1000纳秒.">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_ERROR_LIMIT(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @<最小间隔>, @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    方法 加入致命日志_间隔 <公开 注释 = "将致命错误级别的日志消息推送到日志队列中." 注释 = " 1. 用于限制日志的记录频率,低于最小间隔的日志将被丢弃;"
            注释 = " 2. 日志消息后面会标上间隔的日志数量;" 注释 = " 3. 每个前端线程拥有独立的计时器;" 折叠 @嵌入式方法 = "">
    参数 最小间隔 <类型 = 长整数 注释 = "提供最小的日志记录间隔,如果上条日志的经过时间低于此间隔,这条日志将被丢弃;" 注释 = "单位为纳秒,1秒=1000*1000*1000纳秒.">
    参数 日志格式 <类型 = 文本型 注释 = "提供日志格式,前面会自动加上日志头,支持std::format的格式化文本;" 注释 = "格式替换符为\"{}\",例如: \"你好，{}。\""
            注释 = "具体的格式要求请参考\"取标准格式文本\"的参数备注." 注释 = "※本参数只能填双引号写的字面量或常量,不能填文本型变量." @需求类型 = 立即数或常量>
    参数 替换数据 <注释 = "本参数可空可扩展;" 注释 = "如果\"日志格式\"为格式文本,本参数用于给格式文本中的格式替换符提供替换数据;"
            注释 = "支持类型: 通用数值型、文本型、STL类型(string/vector等)" @匹配类型 = 通用型 @可扩展 = "" @默认值 = 0>
    {
        @ QUILL_LOG_CRITICAL_LIMIT(QUILL_FILE_U8(@sn<current_source_file>, @sn<current_source_line>), QUILL_FUNC_U8(@sn<current_source_class>, @sn<current_source_method>),
        @     @<最小间隔>, @sn<this>.logger, nullptr, PIV_STR_U8(R@sn<quot>_.(@pvpt<日志格式>)_.@sn<quot>), @<替换数据>)
    }

    # ---
    # @begin
    # <> <include>
    # quill::Logger* logger{nullptr};
    # std::vector<std::shared_ptr<quill::Sink>> sinks;
    # std::shared_ptr<quill::Sink> event_sink{nullptr};
    # void @an<_OnCleanupExtra>() {
    #     if (!event_sink) dynamic_cast<quill::EventSink*>(event_sink.get())->set_event({});
    #     if (logger) quill::Frontend::remove_logger_blocking(logger, 100);
    # }
    # <> </include>
    # @end
}

类 Quill后端 <公开 注释 = "用于管理quill日志的后端线程" 折叠 折叠2 @文档 = "category = \"日志记录.Quill\"" @别名 = "//quill::Backend"
        @别名类型 = 本地类 @类用途 = 访问静态成员 @强制依赖 = "Quill日志类">
{
    方法 启动 <公开 静态 注释 = "用提供的选项启动后端线程,请注意下列事项:" 注释 = "1. 程序只能存在一个后端线程,如果已经正在运行,则调用本方法无效果;"
            注释 = "2. 如果调用本方法手动启动后端线程,在\"Quill日志类\"中开启记录器时会也自动启动;" 注释 = "3. 启动后选项不可更改,只能停止后端线程再重新启动;" 折叠 "">
    参数 选项 <类型 = Quill后端选项 注释 = "提供后端选项">
    参数 禁止字符检查 <类型 = 逻辑型 注释 = "禁止可打印字符检查,因为默认的检查函数会导致中文全部被转义." 注释 = "如果你想自定义检查函数,可以将本参数设置为假." @默认值 = 真>
    {
        如果 (禁止字符检查)
        {
            选项.禁止字符检查 ()
        }
        @ quill::Backend::start(@<选项>);
    }

    方法 停止 <公开 静态 注释 = "停止后端线程(线程安全)" 折叠 @嵌入式方法 = "">
    {
        @ quill::Backend::stop()
    }

    方法 通知 <公开 静态 注释 = "唤醒后端线程(线程安全)." 注释 = "如果后端使用了较长的休眠时间,可以从任意前端线程调用本方法唤醒后端线程." 折叠 @嵌入式方法 = "">
    {
        @ quill::Backend::notify()
    }

    方法 是否正在运行 <公开 静态 类型 = 逻辑型 注释 = "判断后端线程是否正在运行" 折叠 @嵌入式方法 = "">
    {
        @ quill::Backend::is_running()
    }

    方法 取线程ID <公开 静态 类型 = uint32_t 注释 = "返回后端线程的ID" 折叠 @嵌入式方法 = "">
    {
        @ quill::Backend::get_thread_id()
    }
}

类 Quill前端 <公开 注释 = "用于管理quill日志的前端" 折叠 折叠2 @文档 = "category = \"日志记录.Quill\"" @别名 = "//quill::Frontend"
        @别名类型 = 本地类 @类用途 = 访问静态成员 @强制依赖 = "Quill日志类">
{
    方法 预分配 <公开 静态 注释 = "在当前线程预分配所需的本地线程数据." 注释 = "可方法可选使用,推荐在线程加入第一条日志消息之前的线程初始化阶段,调用本方法." 折叠 @嵌入式方法 = "">
    {
        @ quill::Frontend::prealloate()
    }

    方法 收缩线程本地队列 <公开 静态 注释 = "将线程本地的SPSC队列缩减到指定的容量." 注释 = "1. 本方法通过缩小队列大小来帮助控制内存占用;"
            注释 = "2. 比如当前线程突然处理了大量日志消息,将导致队列显著增大,后续可能用不到这么大的队列," 注释 = "就有缩进容量的必要;"
            注释 = "3. 日志记录器可能会维护多个线程本地队列,本方法只会缩减与调用线程相关联的队列;" 折叠 @嵌入式方法 = "">
    参数 容量 <注释 = "单位为字节.队列的初始容量为128KB,只有提供的容量小于当前容量时才会缩小." @匹配类型 = 通用整数型>
    {
        @ quill::Frontend::shrink_thread_local_queue(static_cast<size_t>(@<容量>))
    }

    方法 取线程本地队列容量 <公开 静态 类型 = 变整数 注释 = "返回当前线程本地SPSC队列的容量" 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)quill::Frontend::get_thread_local_queue_capacity()
    }

    方法 取记录器数量 <公开 静态 类型 = 变整数 注释 = "统计现有的记录器数量,包含无效的记录器." 注释 = "本方法可以验证调用异步删除记录器后,后端是否已成功删除记录器." 折叠
            @嵌入式方法 = "">
    {
        @ (INT_P)quill::Frontend::get_number_of_loggers()
    }
}

# Quill辅助类型 ----

类 Quill后端选项 <公开 注释 = "Quill后端线程的启动选项" 折叠 折叠2 @文档 = "category = \"日志记录.Quill.辅助类\""
        @别名 = "quill::BackendOptions" @别名类型 = 本地类 @强制依赖 = "Quill日志类">
{
    变量 线程名称 <公开 类型 = 标准文本类U 注释 = "后端线程的名称,默认为\"QuillBackend\"" 折叠2 @属性变量 = 真 @输出名 = "thread_name">
    变量 空闲时让出线程 <公开 类型 = 逻辑型 注释 = "让后端线程在没有工作时让出线程的调度." 注释 = "默认为假,此选项仅在\"休眠时间\"为0时生效." @属性变量 = 真
            @输出名 = "enable_yield_when_idle">
    变量 中转事件初始缓存容量 <公开 类型 = uint32_t 注释 = "设置的容量必须为2的幂,默认为128(单位为项目,而非字节)."
            注释 = "后端从前端队列中弹出所有日志消息,将其作为中转事件缓存在本地环形缓冲队列中." 注释 = "中转事件不限制缓存的大小,但从本初始容量开始,一直重分配到\"中转事件软上限\"."
            注释 = "后端将为每个前端线程使用单独的中转事件缓存." @属性变量 = 真 @输出名 = "transit_event_buffer_initial_capacity">
    变量 中转事件软上限 <公开 类型 = PIV.类型.size_t 注释 = "表示从所有前端线程接收到的消息上限,默认为4096个项目."
            注释 = "- 后端优先从所有热点线程的前端队列读取消息,并将其临时缓存." 注释 = "- 如果前端线程持续向队列压入消息(例如在循环里进行日志记录),将无法处理任何日志."
            注释 = "- 因此,当达到软上限时,后端工作线程将尝试批量处理一批缓存的中转事件." 注释 = "- 前端队列在每次迭代时都会清空,因此实际弹出的消息可能比当前软上限大得多." @属性变量 = 真
            @输出名 = "transit_events_soft_limit">
    变量 中转事件硬上限 <公开 类型 = PIV.类型.size_t 注释 = "默认为32768." 注释 = "这是后端事件缓冲区的最大上限,到达上限后,后端将停止读取前端队列,直到缓冲区有可用的空间."
            @属性变量 = 真 @输出名 = "transit_events_hard_limit">
    变量 退出前等待队列归零 <公开 类型 = 逻辑型 注释 = "默认为真." 注释 = "启用此选项后,当应用程序正在终止时,后端工作线程将不会立即退出,直到所有前端队列都处理完毕." @属性变量 = 真
            @输出名 = "wait_for_queues_to_empty_before_exit">
    变量 CPU亲和性 <公开 类型 = 无符号短整数 注释 = "可以将后端工作线程绑定到特定的CPU核心上运行." 注释 = "默认为不绑定." @属性变量 = 真
            @输出名 = "cpu_affinity">
    变量 日志级别描述 <公开 类型 = 标准文本定长数组U 注释 = "数组成员数固定为11." @输出名 = "log_level_descriptions">
    变量 日志级别短码 <公开 类型 = 标准文本定长数组U 注释 = "用于标识日志级别的短代号(1到2个字母),数组成员数固定为12." @输出名 = "log_level_short_codes">
    变量 检查后端单例 <公开 类型 = 逻辑型 注释 = "默认为真.启用运行时检查,以检测后端单例类是否存在多个实例."
            注释 = "程序混合在共享库和静态库使用Quill时,可能会存在多个后端单例类的实例," 注释 = "这会导致多个后端工作线程同时运行,从而导致程序异常或崩溃." @属性变量 = 真
            @输出名 = "check_backend_singleton_instance">

    方法 休眠时间 <公开 静态 属性写 注释 = "当队列没有剩余工作要处理时,后端的休眠持续时间." 折叠>
    参数 当前选项 <类型 = Quill后端选项>
    参数 新时间 <类型 = 长整数 注释 = "默认为500纳秒">
    {
        @ @<当前选项>.sleep_duration = std::chrono::nanoseconds{@<新时间>};
    }

    方法 休眠时间 <公开 静态 属性读 类型 = 长整数 注释 = "当队列没有剩余工作要处理时,后端的休眠持续时间." 返回值注释 = "默认为500纳秒" 折叠 @嵌入式方法 = "">
    参数 当前选项 <类型 = Quill后端选项>
    {
        @ @<当前选项>.sleep_duration.count()
    }

    方法 日志时间戳排序宽限期 <公开 静态 属性写 注释 = "宽限期会导致后端从所有前端无锁队列读取消息时出现轻微延迟," 注释 = "但可以确保正确的时间戳排序." 折叠>
    参数 当前选项 <类型 = Quill后端选项>
    参数 宽限期 <类型 = 长整数 注释 = "默认为1微秒,不要设置太大的值;" 注释 = "设置为0将禁用严格的时间戳排序.">
    {
        @ @<当前选项>.log_timestamp_ordering_grace_period = std::chrono::microseconds{@<宽限期>};
    }

    方法 日志时间戳排序宽限期 <公开 静态 属性读 类型 = 长整数 注释 = "宽限期会导致后端从所有前端无锁队列读取消息时出现轻微延迟," 注释 = "但可以确保正确的时间戳排序."
            返回值注释 = "默认为1微秒,为0将禁用严格的时间戳排序." 折叠 @嵌入式方法 = "">
    参数 当前选项 <类型 = Quill后端选项>
    {
        @ @<当前选项>.log_timestamp_ordering_grace_period.count()
    }

    方法 TSC同步间隔 <公开 静态 属性写 注释 = "TSC时钟会慢慢产生偏移,需要定期与系统时钟同步." 注释 = "本参数控制后端与系统时钟同步的频率." 折叠>
    参数 当前选项 <类型 = Quill后端选项>
    参数 间隔 <类型 = 长整数 注释 = "默认值为500毫秒." 注释 = "值越小,同步频率越高,日志时间戳越准确," 注释 = "但会影响后端工作线程的性能.">
    {
        @ @<当前选项>.rdtsc_resync_interval = std::chrono::milliseconds{@<间隔>};
    }

    方法 TSC同步间隔 <公开 静态 属性读 类型 = 长整数 注释 = "TSC时钟会慢慢产生偏移,需要定期与系统时钟同步." 注释 = "本参数控制后端与系统时钟同步的频率."
            返回值注释 = "默认值为500毫秒" 折叠 @嵌入式方法 = "">
    参数 当前选项 <类型 = Quill后端选项>
    {
        @ @<当前选项>.rdtsc_resync_interval.count()
    }

    方法 接收器的最小刷新间隔 <公开 静态 属性写 注释 = "后端线程刷新所有接收器的输出缓冲区的最小间隔" 折叠>
    参数 当前选项 <类型 = Quill后端选项>
    参数 间隔 <类型 = 长整数 注释 = "默认值为200毫秒." 注释 = "设置为0将禁用此功能,只要对接收器进行了写入," 注释 = "后端线程就会忽略是否有未完成的工作,立即刷新接收器.">
    {
        @ @<当前选项>.sink_min_flush_interval = std::chrono::milliseconds{@<间隔>};
    }

    方法 接收器的最小刷新间隔 <公开 静态 属性读 类型 = 长整数 注释 = "后端线程刷新所有接收器的输出缓冲区的最小间隔" 返回值注释 = "默认值为200毫秒" 折叠 @嵌入式方法 = "">
    参数 当前选项 <类型 = Quill后端选项>
    {
        @ @<当前选项>.sink_min_flush_interval.count()
    }

    # ---

    方法 置错误通知回调 <公开 静态 注释 = "后端可能会遇到无法在用户线程中俘获的异常." 注释 = "此时,后端会调用此回调来通知用户." 折叠 @嵌入式方法 = "">
    参数 当前选项 <类型 = Quill后端选项>
    参数 通知函数 <注释 = "默认使用fprintf输出错误消息,但这只能在控制台程序中显示." @匹配方法 = "通知回调模板">
    {
        @ @<当前选项>.error_notifier = std::bind(&@<通知函数>, std::placeholders::_1);
    }

    方法 禁止错误通知 <公开 静态 注释 = "如果不想使用错误通知回调,可以执行本方法关闭." 折叠 @嵌入式方法 = "">
    参数 当前选项 <类型 = Quill后端选项>
    {
        @ @<当前选项>.error_notifier = {}
    }

    方法 通知回调模板 <公开 静态 折叠>
    参数 错误消息 <类型 = 标准文本类U @视窗.前缀文本 = "const ">
    {

    }

    # ---

    方法 置字符检查函数 <公开 静态 注释 = "用于检查日志消息中是否仅包含可打印字符." 注释 = "任何不可打印的字符都会被转义成十六进制值."
            注释 = "注: 默认的检查函数会将所有中文字符转义,因此我默认关闭了此函数." 折叠 @嵌入式方法 = "">
    参数 当前选项 <类型 = Quill后端选项>
    参数 检查函数 <注释 = "默认使用fprintf输出错误消息,但这只能在控制台程序中显示." @匹配方法 = "字符检查函数模板">
    {
        @ @<当前选项>.error_notifier = std::bind(&@<检查函数>, std::placeholders::_1);
    }

    方法 禁止字符检查 <公开 静态 注释 = "如果不想使用字符检查函数,可以执行本方法关闭." 注释 = "注: 默认的检查函数会将所有中文字符转义,因此我默认关闭了此函数." 折叠 @嵌入式方法 = "">
    参数 当前选项 <类型 = Quill后端选项>
    {
        @ @<当前选项>.check_printable_char = {}
    }

    方法 字符检查函数模板 <公开 静态 类型 = 逻辑型 注释 = "返回真表示该字符可以打印,否则将被转义." 折叠>
    参数 待检查字符 <类型 = 字节>
    {
        返回 (真)
    }
}

类 Quill格式选项 <公开 注释 = "Quill的元数据和时间戳的格式化选项" 折叠 折叠2 @文档 = "category = \"日志记录.Quill.辅助类\""
        @别名 = "quill::PatternFormatterOptions" @别名类型 = 本地类 @强制依赖 = "Quill日志类">
{
    变量 日志格式 <公开 类型 = 标准文本类U 注释 = "日志消息的格式,该文本定义了每个日志消息的整体结构." 注释 = "下列为可用的格式替换符:"
            注释 = "  %(time)                   - 表示日志创建时间的可读时间戳" 注释 = "  %(file_name)              - 调用日志的源文件名称"
            注释 = "  %(full_path)              - 调用日志的源文件完整路径" 注释 = "  %(caller_function)        - 调用日志的函数名称"
            注释 = "  %(log_level)              - 表示消息的日志级别的文本"
            注释 = "  %(log_level_short_code)   - 缩写的日志级别名称(1到2个字母)"
            注释 = "  %(line_number)            - 源文件中调用日志的行号" 注释 = "  %(logger)                 - 调用日志的记录器名称"
            注释 = "  %(message)                - 日志消息自身" 注释 = "  %(thread_id)              - 日志记录器所调用线程的ID"
            注释 = "  %(thread_name)            - 线程名称,必须在该线程的第一条日志语句之前设置."
            注释 = "  %(process_id)             - 日志记录器所调用进程的ID"
            注释 = "  %(source_location)        - 包含了完整源文件路径和行号的单行文本"
            注释 = "  %(short_source_location)  - 包含了源文件名称和行号的缩短单行文本"
            注释 = "  %(tags)                   - 附加到消息的自定义标签"
            注释 = "  %(named_args)             - 附加到消息的键值对.仅适用于消息已命名参数的情况,否则为空." @属性变量 = 真 @输出名 = "format_pattern">
    变量 时间戳格式 <公开 类型 = 标准文本类U 注释 = "时间戳的格式(默认:\"%H:%M:%S.%Qns\");" 注释 = "下列为可用的格式替换符(基本与strftime相同):"
            注释 = "  %Qms : 毫秒   |  %Qus : 微秒   |  %Qns : 纳秒" 注释 = "  %Y : 4位年份  |  %y : 2位年份  |  %C : 世纪"
            注释 = "  %m : 2位月份  |  %b : 月份简写 |  %B : 月份全称" 注释 = "  %d : 2位天数  |  %e : 2位天数(前补空格)"
            注释 = "  %A : 星期全称       |  %a : 星期简写" 注释 = "  %u : 星期数(1-7)    |  %w : 星期数(0-6,0为星期天)"
            注释 = "  %j : 每年的第几天   |  %W : 每年的第几周" 注释 = "  %H : 小时(24小时制) |  %I : 小时(12小时制)"
            注释 = "  %M : 分钟           |  %p : 12小时制的AM/PM" 注释 = "  %S : 秒钟           |  %z : 时区" @属性变量 = 真
            @输出名 = "timestamp_pattern">
    变量 源路径剔除前缀 <公开 类型 = 标准文本类U 注释 = "用于删除源文件路径中的指定路径前缀,空文本时显示完整路径." @属性变量 = 真
            @输出名 = "source_location_path_strip_prefix">
    变量 时间戳时区 <公开 类型 = Quill时区 注释 = "时间戳使用的时区,默认是系统本地时区." @属性变量 = 真 @输出名 = "timestamp_timezone">
    变量 添加元数据到多行日志 <公开 类型 = 逻辑型 注释 = "是否在多行日志的每一行前加上元数据,默认为假." @属性变量 = 真
            @输出名 = "add_metadata_to_multi_line_logs">
    变量 删除源文件的相对路径 <公开 类型 = 逻辑型 注释 = "是否删除源文件路径的相对路径部分." 注释 = "如果为真,像\"../\"这样的相对路径部分将会被删除,简化源文件路径显示."
            @属性变量 = 真 @输出名 = "source_location_remove_relative_paths">
}

类 Quill文件选项 <公开 注释 = "Quill文件接收器的选项" 折叠 折叠2 @文档 = "category = \"日志记录.Quill.辅助类\""
        @别名 = "quill::FileSinkConfig" @别名类型 = 本地类 @强制依赖 = "Quill日志类">
{
    方法 文件名附加选项 <公开 静态 属性写 注释 = "附加到日志文件名后面的类型" 折叠>
    参数 当前选项 <类型 = Quill文件选项>
    参数 选项 <类型 = Quill文件名附加选项>
    {
        @ @<当前选项>.set_filename_append_option(@<选项>);
    }

    方法 文件名附加选项 <公开 静态 属性读 类型 = Quill文件名附加选项 注释 = "附加到日志文件名后面的类型" 折叠 @禁止流程检查 = 真>
    参数 当前选项 <类型 = Quill文件选项>
    {
        @ return @<当前选项>.filename_append_option();
    }

    方法 附加日期格式 <公开 静态 属性写 注释 = "自定义附加到日志文件名后面的日期时间格式" 折叠>
    参数 当前选项 <类型 = Quill文件选项>
    参数 日期时间格式 <类型 = 文本型 注释 = "下列为可用的格式替换符:" 注释 = "  %Y : 4位年份  |  %y : 2位年份  |  %C : 世纪"
            注释 = "  %m : 2位月份  |  %b : 月份简写 |  %B : 月份全称" 注释 = "  %d : 2位天数  |  %e : 2位天数(前补空格)"
            注释 = "  %A : 星期全称       |  %a : 星期简写" 注释 = "  %u : 星期数(1-7)    |  %w : 星期数(0-6,0为星期天)"
            注释 = "  %j : 每年的第几天   |  %W : 每年的第几周" 注释 = "  %H : 小时(24小时制) |  %I : 小时(12小时制)"
            注释 = "  %M : 分钟           |  %p : 12小时制的AM/PM" 注释 = "  %S : 秒钟           |  %z : 时区">
    {
        @ @<当前选项>.set_filename_append_option(quill::FilenameAppendOption::StartCustomTimestampFormat, PivW2U{@<日期时间格式>}.str);
    }

    方法 附加日期格式 <公开 静态 属性读 类型 = 文本型 注释 = "返回附加到日志文件名后面的日期时间格式" 折叠 @禁止流程检查 = 真>
    参数 当前选项 <类型 = Quill文件选项>
    {
        @ return @an<CVolString>{@<当前选项>.append_filename_format_pattern().c_str()};
    }

    方法 时区 <公开 静态 属性写 注释 = "日期格式使用的时区,默认是系统本地时区." 折叠>
    参数 当前选项 <类型 = Quill文件选项>
    参数 新时区 <类型 = Quill时区>
    {
        @ @<当前选项>.set_timezone(@<新时区>);
    }

    方法 时区 <公开 静态 属性读 类型 = Quill时区 注释 = "日期格式使用的时区,默认是系统本地时区." 折叠 @禁止流程检查 = 真>
    参数 当前选项 <类型 = Quill文件选项>
    {
        @ return @<当前选项>.timezone();
    }

    方法 刷新到文件 <公开 静态 属性写 注释 = "是否在刷新日志接收器时,将数据写入到磁盘文件." 注释 = "默认写入到磁盘缓冲区,由系统决定何时刷新到文件." 折叠>
    参数 当前选项 <类型 = Quill文件选项>
    参数 是否启用 <类型 = 逻辑型>
    {
        @ @<当前选项>.set_fsync_enabled(@<是否启用>);
    }

    方法 刷新到文件 <公开 静态 属性读 类型 = 逻辑型 注释 = "是否在刷新日志接收器时,将数据写入到磁盘文件." 注释 = "默认写入到磁盘缓冲区,由系统决定何时刷新到文件." 折叠
            @嵌入式方法 = "">
    参数 当前选项 <类型 = Quill文件选项>
    {
        @ @<当前选项>.fsync_enabled();
    }

    方法 重写模式 <公开 静态 属性写 注释 = "设置文件的打开模式(默认为假)." 注释 = "如果日志文件已存在,为真将清空文件原先的内容;" 注释 = "为假则在文件尾部添加日志." 折叠>
    参数 当前选项 <类型 = Quill文件选项>
    参数 是否重写 <类型 = 逻辑型>
    {
        @ @<当前选项>.set_open_mode(@<是否重写> ? 'w' : 'a');
    }

    方法 重写模式 <公开 静态 属性读 类型 = 逻辑型 注释 = "返回文件的打开模式." 注释 = "如果日志文件已存在,为真将清空文件原先的内容;" 注释 = "为假则在文件尾部添加日志." 折叠
            @嵌入式方法 = "">
    参数 当前选项 <类型 = Quill文件选项>
    {
        @ (@<当前选项>.open_mode().c_str() == "w")
    }

    方法 最小刷新间隔 <公开 静态 属性写 注释 = "启用\"刷新到文件\"后,可以设置刷新到文件的最小间隔(单位为毫秒),以避免频繁写入磁盘." 折叠>
    参数 当前选项 <类型 = Quill文件选项>
    参数 间隔 <类型 = 整数 注释 = "单位为毫秒">
    {
        @ @<当前选项>.set_minimum_fsync_interval(std::chrono::milliseconds(@<间隔>));
    }

    方法 最小刷新间隔 <公开 静态 属性读 类型 = 整数 注释 = "启用\"刷新到文件\"后,可以设置刷新到文件的最小间隔(单位为毫秒),以避免频繁写入磁盘." 折叠 @嵌入式方法 = "">
    参数 当前选项 <类型 = Quill文件选项>
    {
        @ static_cast<INT>(@<当前选项>.minimum_fsync_interval().count())
    }

    方法 写入缓冲区大小 <公开 静态 属性写 注释 = "文件流的缓冲区大小,单位为字节,默认为64 × 1024,最小值为4096." 折叠>
    参数 当前选项 <类型 = Quill文件选项>
    参数 大小 <类型 = 整数 注释 = "单位为字节">
    {
        @ @<当前选项>.set_write_buffer_size(static_cast<size_t>(@<大小>));
    }

    方法 写入缓冲区大小 <公开 静态 属性读 类型 = 整数 注释 = "文件流的缓冲区大小,单位为字节,默认为64 × 1024,最小值为4096." 折叠 @嵌入式方法 = "">
    参数 当前选项 <类型 = Quill文件选项>
    {
        @ static_cast<INT>(@<当前选项>.write_buffer_size())
    }

    方法 覆盖日志格式选项 <公开 静态 属性写 注释 = "设置该文件接收器的自定义日志格式,将在该文件内覆盖日志记录器的\"格式选项\"." 折叠>
    参数 当前选项 <类型 = Quill文件选项>
    参数 选项 <类型 = Quill格式选项>
    {
        @ @<当前选项>.set_override_pattern_formatter_options(@<选项>);
    }
}

类 Quill轮替文件选项 <公开 基础类 = Quill文件选项 注释 = "Quill轮替文件接收器的选项" 折叠 折叠2 @文档 = "category = \"日志记录.Quill.辅助类\""
        @别名 = "quill::RotatingFileSinkConfig" @别名类型 = 本地类 @强制依赖 = "Quill日志类">
{
    方法 最大文件尺寸 <公开 静态 属性写 注释 = "每个文件的最大尺寸,达到该尺寸即轮替到下一个文件." 折叠>
    参数 当前选项 <类型 = Quill轮替文件选项>
    参数 文件尺寸 <类型 = 长整数 注释 = "每个文件的最大字节尺寸;" 注释 = "默认为0,表示不按文件尺寸进行轮替;" 注释 = "注: 不能小于512字节,否则会报错.">
    {
        @ @<当前选项>.set_rotation_max_file_size(static_cast<size_t>(@<文件尺寸>));
    }

    方法 最大文件尺寸 <公开 静态 属性读 类型 = 长整数 注释 = "每个文件的最大尺寸,达到该尺寸即轮替到下一个文件." 返回值注释 = "默认为0,表示不按文件尺寸进行轮替." 折叠
            @禁止流程检查 = 真>
    参数 当前选项 <类型 = Quill轮替文件选项>
    {
        @ return static_cast<INT64>(@<当前选项>.rotation_max_file_size());
    }

    方法 最大备份文件数 <公开 静态 属性写 注释 = "轮替后最多保留多少个日志文件" 折叠>
    参数 当前选项 <类型 = Quill轮替文件选项>
    参数 文件数 <类型 = uint32_t 注释 = "默认为无符号整数的最大值(4294967295).">
    {
        @ @<当前选项>.set_max_backup_files(@<文件数>);
    }

    方法 最大备份文件数 <公开 静态 属性读 类型 = uint32_t 注释 = "轮替后最多保留多少个日志文件" 返回值注释 = "默认为无符号整数的最大值(4294967295)." 折叠
            @禁止流程检查 = 真>
    参数 当前选项 <类型 = Quill轮替文件选项>
    {
        @ return @<当前选项>.max_backup_files();
    }

    方法 覆盖滚动文件 <公开 静态 属性写 注释 = "当达到最大备份计数时,是否覆盖最旧的滚动日志." 注释 = "若设置为假,达到最大备份计数将停止日志文件轮替." 折叠>
    参数 当前选项 <类型 = Quill轮替文件选项>
    参数 是否覆盖 <类型 = 逻辑型 注释 = "默认为真">
    {
        @ @<当前选项>.set_overwrite_rolled_files(@<是否覆盖>);
    }

    方法 覆盖滚动文件 <公开 静态 属性读 类型 = 逻辑型 注释 = "当达到最大备份计数时,是否覆盖最旧的滚动日志." 注释 = "若设置为假,达到最大备份计数将停止日志文件轮替."
            返回值注释 = "默认为真" 折叠 @嵌入式方法 = "">
    参数 当前选项 <类型 = Quill轮替文件选项>
    {
        @ @<当前选项>.overwrite_rolled_files()
    }

    方法 删除旧文件 <公开 静态 属性写 注释 = "是否在启动程序时删除上一个轮替日志文件,以避免文件同名冲突." 注释 = "注: 本选项仅在\"重写模式\"为真时有效." 折叠>
    参数 当前选项 <类型 = Quill轮替文件选项>
    参数 是否删除 <类型 = 逻辑型 注释 = "默认为真">
    {
        @ @<当前选项>.set_remove_old_files(@<是否删除>)
    }

    方法 删除旧文件 <公开 静态 属性读 类型 = 逻辑型 注释 = "是否在启动程序时删除上一个轮替日志文件,以避免文件同名冲突." 注释 = "注: 本选项仅在\"重写模式\"为真时有效."
            返回值注释 = "默认为真" 折叠 @嵌入式方法 = "">
    参数 当前选项 <类型 = Quill轮替文件选项>
    {
        @ @<当前选项>.remove_old_files()
    }

    方法 小时轮替间隔 <公开 静态 属性写 注释 = "设置日志文件每隔多少小时进行轮替." 注释 = "注: \"每日/每小时/每分钟\"轮替只能生效其中一个,以最后设置的为准." 折叠>
    参数 当前选项 <类型 = Quill轮替文件选项>
    参数 间隔 <类型 = uint32_t 注释 = "必须提供大于0的值">
    {
        @ @<当前选项>.set_rotation_frequency_and_interval('H', @<间隔>);
    }

    方法 分钟轮替间隔 <公开 静态 属性写 注释 = "设置日志文件每隔多少分钟进行轮替." 注释 = "注: \"每日/每小时/每分钟\"轮替只能生效其中一个,以最后设置的为准." 折叠>
    参数 当前选项 <类型 = Quill轮替文件选项>
    参数 间隔 <类型 = uint32_t 注释 = "必须提供大于0的值">
    {
        @ @<当前选项>.set_rotation_frequency_and_interval('M', @<间隔>);
    }

    方法 每日轮替时间 <公开 静态 属性写 注释 = "设置在每天的指定时间轮替日志文件." 注释 = "注: \"每日/每小时/每分钟\"轮替只能生效其中一个,以最后设置的为准." 折叠>
    参数 当前选项 <类型 = Quill轮替文件选项>
    参数 时间文本 <类型 = 文本型 注释 = "格式必须为\"MM:HH\",如\"00:00\"即在零时轮替日志文件.">
    {
        @ @<当前选项>.set_rotation_time_daily(PivW2U{@<时间文本>}.str);
    }

    方法 每日轮替时间 <公开 静态 属性读 类型 = 文本型 注释 = "返回日志文件的每日轮替时间;"
            注释 = "注: \"2147483647:2147483647\"表示\"轮替频率\"不为\"每日\"." 折叠 @禁止流程检查 = 真>
    参数 当前选项 <类型 = Quill轮替文件选项>
    {
        @ std::pair<std::chrono::hours, std::chrono::minutes> time = @<当前选项>.daily_rotation_time();
        @ return CVolString().Format(L"%d:%d", time.first.count(), time.second.count());
    }

    方法 轮替频率 <公开 静态 属性读 类型 = Quill轮替频率 注释 = "返回日志文件的轮替频率" 返回值注释 = "默认轮替频率为\"禁用\"" 折叠 @禁止流程检查 = 真>
    参数 当前选项 <类型 = Quill轮替文件选项>
    {
        @ return @<当前选项>.rotation_frequency();
    }

    方法 轮替间隔 <公开 静态 属性读 类型 = uint32_t 注释 = "返回日志文件的轮替时间间隔." 注释 = "返回非0值表示当前\"轮替频率\"为每小时或每分钟." 返回值注释 = "默认为0"
            折叠 @禁止流程检查 = 真>
    参数 当前选项 <类型 = Quill轮替文件选项>
    {
        @ return @<当前选项>.rotation_interval();
    }

    方法 轮替命名方案 <公开 静态 属性写 注释 = "设置日志轮替文件的命名方案" 折叠>
    参数 当前选项 <类型 = Quill轮替文件选项>
    参数 命名方案 <类型 = Quill轮替命名方案 注释 = "默认为\"索引\"">
    {
        @ @<当前选项>.set_rotation_naming_scheme(@<命名方案>);
    }

    方法 轮替命名方案 <公开 静态 属性读 类型 = Quill轮替命名方案 注释 = "返回日志轮替文件的命名方案" 返回值注释 = "默认为\"索引\"" 折叠 @禁止流程检查 = 真>
    参数 当前选项 <类型 = Quill轮替文件选项>
    {
        @ return @<当前选项>.rotation_naming_scheme();
    }
}

类 Quill元数据 <公开 注释 = "Quill日志消息的元数据,本数据拥有全局生命周期." 折叠 折叠2 @文档 = "category = \"日志记录.Quill.常量\""
        @别名 = "const quill::MacroMetadata*" @别名类型 = 本地参考类型 @类用途 = 禁止创建对象 @强制依赖 = "Quill日志类">
{
    方法 源语句位置 <公开 静态 属性读 类型 = 文本视图类U 注释 = "返回源文件路径加行号,例: \"D:\\voldev\\src\\main.v:100\"" 折叠 @禁止流程检查 = 真>
    参数 本数据 <类型 = Quill元数据>
    {
        @ return @<本数据>->source_location();
    }

    方法 源方法名 <公开 静态 属性读 类型 = 文本视图类U 注释 = "返回源方法名,例: \"类名::方法名\"" 折叠 @禁止流程检查 = 真>
    参数 本数据 <类型 = Quill元数据>
    {
        @ return @<本数据>->caller_function();
    }

    方法 消息格式 <公开 静态 属性读 类型 = 文本视图类U 注释 = "返回日志消息的格式,与\"加入日志\"的\"日志格式\"参数相同." 折叠 @禁止流程检查 = 真>
    参数 本数据 <类型 = Quill元数据>
    {
        @ return @<本数据>->message_format();
    }

    方法 源行号 <公开 静态 属性读 类型 = 文本视图类U 注释 = "返回源行号,例: \"100\"" 折叠 @禁止流程检查 = 真>
    参数 本数据 <类型 = Quill元数据>
    {
        @ return @<本数据>->line();
    }

    方法 源文件路径 <公开 静态 属性读 类型 = 文本视图类U 注释 = "返回源文件的完整路径,例: \"D:\\voldev\\src\\main.v\"" 折叠 @禁止流程检查 = 真>
    参数 本数据 <类型 = Quill元数据>
    {
        @ return @<本数据>->full_path();
    }

    方法 源文件名 <公开 静态 属性读 类型 = 文本视图类U 注释 = "返回不含路径的源文件名,例: \"main.v\"" 折叠 @禁止流程检查 = 真>
    参数 本数据 <类型 = Quill元数据>
    {
        @ return @<本数据>->file_name();
    }

    方法 源语句位置简写 <公开 静态 属性读 类型 = 文本视图类U 注释 = "返回简写的源语句位置,例: \"main.v:100\"" 折叠 @禁止流程检查 = 真>
    参数 本数据 <类型 = Quill元数据>
    {
        @ return @<本数据>->short_source_location();
    }

    方法 日志级别 <公开 静态 属性读 类型 = Quill日志级别 注释 = "返回这条日志的级别" 折叠 @禁止流程检查 = 真>
    参数 本数据 <类型 = Quill元数据>
    {
        @ return @<本数据>->log_level();
    }

    方法 标签 <公开 静态 属性读 类型 = 文本视图类U 注释 = "返回日志的标签信息,一般为空." 折叠 @禁止流程检查 = 真>
    参数 本数据 <类型 = Quill元数据>
    {
        @ return @<本数据>->tags();
    }

    方法 可跳转源位置 <公开 静态 属性读 类型 = 文本型 注释 = "返回可跳转的源位置,在火山的输出框中双击即可跳转到目标的源文件位置."
            注释 = "例: \"<D:\\voldev\\src\\main.v>, 100: \"" 折叠 @禁止流程检查 = 真>
    参数 本数据 <类型 = Quill元数据>
    {
        变量 语句位置 <类型 = 文本型>
        加入字符 (语句位置, '<')
        加入文本 (语句位置, 本数据.源文件路径.取文本 ())
        加入文本 (语句位置, ">, ")
        加入文本 (语句位置, 本数据.源行号.取文本 ())
        加入文本 (语句位置, ": ")
        返回 (语句位置)
    }

    方法 级别颜色 <公开 静态 属性读 类型 = 整数 注释 = "返回当前日志级别的颜色" 折叠>
    参数 本数据 <类型 = Quill元数据>
    {
        如果 (本数据.日志级别 == Quill日志级别.Trace_L3)
        {
            返回 (颜色类.浅灰色)
        }
        否则 (本数据.日志级别 == Quill日志级别.Trace_L2)
        {
            返回 (颜色类.浅灰色)
        }
        否则 (本数据.日志级别 == Quill日志级别.Trace_L1)
        {
            返回 (颜色类.浅灰色)
        }
        否则 (本数据.日志级别 == Quill日志级别.调试)
        {
            返回 (颜色类.青绿色)
        }
        否则 (本数据.日志级别 == Quill日志级别.信息)
        {
            返回 (颜色类.绿色)
        }
        否则 (本数据.日志级别 == Quill日志级别.通知)
        {
            返回 (颜色类.白色)
        }
        否则 (本数据.日志级别 == Quill日志级别.警告)
        {
            返回 (颜色类.黄色)
        }
        否则 (本数据.日志级别 == Quill日志级别.错误)
        {
            返回 (颜色类.红色)
        }
        否则 (本数据.日志级别 == Quill日志级别.致命)
        {
            返回 (颜色类.红褐色)
        }
        返回 (颜色类.绿色)
    }
}

# Quill枚举和常量 ----

类 Quill日志级别 <公开 注释 = "Quill的日志记录级别" 折叠 折叠2 @文档 = "category = \"日志记录.Quill.常量\"" @别名 = "quill::LogLevel"
        @别名类型 = 本地值类型 @强制依赖 = "Quill日志类">
{
    常量 Trace_L3 <公开 类型 = Quill日志级别 值 = @"@quill::LogLevel::TraceL3" 注释 = "0 (仅调试版)最详细的日志级别,用于跟踪程序每一步的执行过程.">
    常量 Trace_L2 <公开 类型 = Quill日志级别 值 = @"@quill::LogLevel::TraceL2" 注释 = "1 (仅调试版)次详细的日志级别,用于跟踪程序每一步的执行过程.">
    常量 Trace_L1 <公开 类型 = Quill日志级别 值 = @"@quill::LogLevel::TraceL1" 注释 = "2 (仅调试版)详细的日志级别,用于跟踪程序每一步的执行过程.">
    常量 调试 <公开 类型 = Quill日志级别 值 = @"@quill::LogLevel::Debug" 注释 = "3 程序运行的一些详细信息,用于调试程序.">
    常量 信息 <公开 类型 = Quill日志级别 值 = @"@quill::LogLevel::Info" 注释 = "4 程序正常运行过程中产生的一些信息">
    常量 通知 <公开 类型 = Quill日志级别 值 = @"@quill::LogLevel::Notice" 注释 = "5 程序正常运行过程中产生的一些需要提示用户注意的信息">
    常量 警告 <公开 类型 = Quill日志级别 值 = @"@quill::LogLevel::Warning" 注释 = "6 警告用户,虽然程序还在正常工作,但有可能发生了错误.">
    常量 错误 <公开 类型 = Quill日志级别 值 = @"@quill::LogLevel::Error" 注释 = "7 出现严重错误,程序不能执行部分功能.">
    常量 致命 <公开 类型 = Quill日志级别 值 = @"@quill::LogLevel::Critical" 注释 = "8 出现致命错误,程序已经不能继续运行.">
    常量 回溯 <公开 类型 = Quill日志级别 值 = @"@quill::LogLevel::Backtrace" 注释 = "9 仅用于回溯日志,用户不应调用.">
    常量 无 <公开 类型 = Quill日志级别 值 = @"@quill::LogLevel::None" 注释 = "10 用在日志过滤级别中,可以过滤掉日志的输出.">
    常量 动态 <公开 类型 = Quill日志级别 值 = @"@quill::LogLevel::Dynamic" 注释 = "11 仅用于动态日志,用户不应调用.">
}

类 Quill时区 <公开 注释 = "Quill格式化日期时使用的时区" 折叠 折叠2 @文档 = "category = \"日志记录.Quill.常量\""
        @别名 = "quill::Timezone" @别名类型 = 本地值类型 @强制依赖 = "Quill日志类">
{
    常量 本地 <公开 类型 = Quill时区 值 = @"@quill::Timezone::LocalTime" 注释 = "0 系统本地时区">
    常量 GMT <公开 类型 = Quill时区 值 = @"@quill::Timezone::GmtTime" 注释 = "1 格林尼治标准时间">
}

类 Quill文件名附加选项 <公开 注释 = "Quill日志文件的文件名附加选项" 折叠 折叠2 @文档 = "category = \"日志记录.Quill.常量\""
        @别名 = "quill::FilenameAppendOption" @别名类型 = 本地值类型 @强制依赖 = "Quill日志类">
{
    常量 无 <公开 类型 = Quill文件名附加选项 值 = @"@quill::FilenameAppendOption::None" 注释 = "0 不附加内容">
    常量 起始日期 <公开 类型 = Quill文件名附加选项 值 = @"@quill::FilenameAppendOption::StartDate"
            注释 = "1 附加文件名的创建日期,格式:\"_%Y%m%d\"">
    常量 起始日期时间 <公开 类型 = Quill文件名附加选项 值 = @"@quill::FilenameAppendOption::StartDateTime"
            注释 = "2 附加文件名的创建日期和时间,格式:\"_%Y%m%d_%H%M%S\"">
    常量 自定义起始时间格式 <公开 类型 = Quill文件名附加选项 值 = @"@quill::FilenameAppendOption::StartCustomTimestampFormat"
            注释 = "3 附加自定义的文件名创建日期时间格式;" 注释 = "请直接使用\"Quill文件选项.附加日期格式()\"," 注释 = "不能在\"Quill文件选项.文件名附加选项()\"中设置.">
}

类 Quill轮替频率 <公开 注释 = "Quill轮替文件的时间频率" 折叠 折叠2 @文档 = "category = \"日志记录.Quill.常量\""
        @别名 = "quill::RotatingFileSinkConfig::RotationFrequency" @别名类型 = 本地值类型 @强制依赖 = "Quill日志类">
{
    常量 禁用 <公开 类型 = Quill轮替频率 值 = @"@quill::RotatingFileSinkConfig::RotationFrequency::Disabled"
            注释 = "0 不以时间间隔来轮替文件">
    常量 每日 <公开 类型 = Quill轮替频率 值 = @"@quill::RotatingFileSinkConfig::RotationFrequency::Daily"
            注释 = "1 以每天一次的频率轮替文件">
    常量 每小时 <公开 类型 = Quill轮替频率 值 = @"@quill::RotatingFileSinkConfig::RotationFrequency::Hourly"
            注释 = "2 每隔N小时一次进行轮替">
    常量 每分钟 <公开 类型 = Quill轮替频率 值 = @"@quill::RotatingFileSinkConfig::RotationFrequency::Minutely"
            注释 = "3 每隔N分钟一次进行轮替">
}

类 Quill轮替命名方案 <公开 注释 = "Quill轮替文件的旧日志文件命名方案" 折叠 折叠2 @文档 = "category = \"日志记录.Quill.常量\""
        @别名 = "quill::RotatingFileSinkConfig::RotationNamingScheme" @别名类型 = 本地值类型 @强制依赖 = "Quill日志类">
{
    常量 索引 <公开 类型 = Quill轮替命名方案 值 = @"@quill::RotatingFileSinkConfig::RotationNamingScheme::Index"
            注释 = "0 滚动文件的索引从1开始">
    常量 日期 <公开 类型 = Quill轮替命名方案 值 = @"@quill::RotatingFileSinkConfig::RotationNamingScheme::Date"
            注释 = "1 滚动文件的命名格式为\".YYYYMMDD\"">
    常量 日期时间 <公开 类型 = Quill轮替命名方案 值 = @"@quill::RotatingFileSinkConfig::RotationNamingScheme::DateAndTime"
            注释 = "2 滚动文件的命名格式为\".YYYYMMDD_HHMMSS\"">
}

#
