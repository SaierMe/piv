<火山程序 类型 = "通常" 版本 = 1 />

包 火山.BASS音频支持库 <注释 = "https://github.com/SaierMe/piv" @视窗.外部头文件 = "BASS\\include\\piv_bass.hpp">

类 BASS_WASAPI类 <公开 注释 = "BASSWASAPI 2.4.3.1" 注释 = "支持在Windows Vista及更高版本上使用WASAPI输入和输出的扩展,支持独占和共享模式."
        注释 = "\"BASS音频类\"在Vista及更高版本的系统默认就是使用WASAPI,但只支持共享模式,真玩Hifi的,还是得开独占模式."
        注释 = "独占模式可以绕过系统的混合器直接输出,打开后其他应用就不能发声,理论上独占模式的音质更好."
        注释 = "本扩展不能在Windows XP之类的旧系统使用,旧系统默认的是DirectSound." 折叠 "//@视窗.外部头文件" = "BASS\\include\\basswasapi.h"
        "//@视窗.外部库" = "BASS\\$(p)\\basswasapi.lib" @视窗.附属文件 = "BASS\\$(p)\\basswasapi.dll"
        @文档 = "category = \"WASAPI支持\"">
{
    方法 加载动态库 <公开 静态 类型 = 逻辑型 注释 = "程序默认在执行本类的函数时加载与程序文件同位置的DLL文件."
            注释 = "如果你想将DLL放在其他位置,请在执行其他方法前调用本方法手动加载." 注释 = "注意: 请尽量在启动方法中加载,且不应将本对象的实例定义在启动类内." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 动态库路径 <类型 = 文本型 注释 = "basswasapi.dll的路径">
    {
        @ BassWasApi::data().Load(@<动态库路径>)
    }

    方法 卸载动态库 <公开 静态 注释 = "手动卸载动态库,一般不需要执行本方法." 折叠 @嵌入式方法 = "">
    {
        @ BassWasApi::data().Free()
    }

    方法 取版本 <公开 类型 = 整数 注释 = "获取已加载的BASSWASAPI的版本号"
            返回值注释 = "  返回BASSWASAPI版本; 例如, 0x02040103(十六进制)将是版本2.4.1.3" 返回值注释 = "  其中高16位为主版本号,低16位为修订版本号." 折叠
            @嵌入式方法 = "">
    {
        @ static_cast<INT>(BassWasApi::Fn().BASS_WASAPI_GetVersion())
    }

    # ---

    方法 类_清理 <折叠>
    {
        释放 ()
    }

    方法 置通知 <公开 类型 = 逻辑型 注释 = "设置是否开启设备更改通知的回调事件,开启后\"通知\"事件才会生效."
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 是否启用 <类型 = 逻辑型 注释 = "是否启用通知回调事件" @默认值 = 真>
    {
        @ BassWasApi::Fn().BASS_WASAPI_SetNotify((@<是否启用>) ? &@sn<current_class_def>::WasApiNotify : NULL, &@sn<this>)
    }

    方法 通知 <公开 定义事件 类型 = 整数 注释 = "通知回调事件" 返回值注释 = "此返回值无意义" 折叠>
    参数 通知事件 <类型 = 整数 注释 = "通知中包含以下内容之一:" 注释 = " 0=BASS_WASAPI_NOTIFY_ENABLED   此设备已启用."
            注释 = " 1=BASS_WASAPI_NOTIFY_DISABLED  此设备已禁用/断开连接."
            注释 = " 2=BASS_WASAPI_NOTIFY_DEFINPUT  此设备现在是默认输入设备."
            注释 = " 3=BASS_WASAPI_NOTIFY_DEFOUTPUT 此设备现在是默认输出设备."
            注释 = " 256=BASS_WASAPI_NOTIFY_FAIL    此设备出现故障并已停止.如果设备仍处于启用状态且处于共享模式,"
            注释 = " 则可能是设备的采样格式已更改.在此情况下,可以使用\"释放\"和\"初始化\"来恢复设备.">
    参数 设备号 <类型 = 整数 注释 = "发出通知的设备">

    方法 取所有设备信息 <公开 类型 = 整数 注释 = "获取所有可用的设备"
            返回值注释 = "成功返回设备数量,失败返回0,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @禁止流程检查 = 真>
    参数 设备信息 <类型 = BASS_WASAPI_设备信息数组 注释 = "返回的设备信息" "">
    {
        设备信息.删除所有成员 ()
        变量 索引 <类型 = 整数 值 = 0>
        变量 信息 <类型 = BASS_WASAPI_设备信息>
        判断循环 (取设备信息 (索引, 信息))
        {
            设备信息.加入成员 (信息)
            索引 = 索引 + 1
        }
        返回 (设备信息.取成员数 ())
    }

    方法 取设备信息 <公开 类型 = 逻辑型 注释 = "获取一个设备的信息" 返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息."
            折叠 @嵌入式方法 = "">
    参数 设备号 <类型 = 整数 注释 = "0 为第一个设备" @默认值 = 0>
    参数 设备信息 <类型 = BASS_WASAPI_设备信息 注释 = "返回的设备信息" "">
    {
        @ BassWasApi::Fn().BASS_WASAPI_GetDeviceInfo(static_cast<DWORD>(@<设备号>), &@<设备信息>)
    }

    方法 是否可用设备 <公开 类型 = 逻辑型 注释 = "判断设备是否可用,也可以判断设备类型" 折叠>
    参数 设备标志 <类型 = 整数>
    参数 设备类型 <类型 = 整数 注释 = "0=所有设备,1=只有输出设备返回真,2=只有输入设备返回真" @默认值 = 0>
    参数 过滤未连接设备 <类型 = 逻辑型 注释 = "是否过滤未插入或未连接的设备,默认不过滤" @默认值 = 假>
    {
        如果 (位与 (设备标志, 1) != 1)  // 设备是否有效
        {
            返回 (假)
        }
        如果 (设备类型 == 1)
        {
            如果 (位与 (设备标志, 16) == 16)  // 为输入设备
            {
                返回 (假)
            }
        }
        否则 (设备类型 == 2)
        {
            如果 (位与 (设备标志, 16) != 16)  // 为输出设备
            {
                返回 (假)
            }
        }
        如果 (过滤未连接设备 == 真)
        {
            如果 (位与 (设备标志, 32) == 32)  // 是否未插入、未连接
            {
                返回 (假)
            }
            如果 (位与 (设备标志, 64) == 64)  // 是否在音量控制面板中被禁用
            {
                返回 (假)
            }
        }
        返回 (真)
    }

    方法 取设备电平 <公开 类型 = 单精度小数 注释 = "获取设备的电平(峰值振幅)."
            返回值注释 = "成功返回电平级别,失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息" 折叠 @嵌入式方法 = "">
    参数 设备号 <类型 = 整数 注释 = "要获取电平的设备,从0开始">
    参数 通道 <类型 = 整数 注释 = "获取电平的声道,0=第一个通道,-1=所有通道." @默认值 = 0>
    {
        @ BassWasApi::Fn().BASS_WASAPI_GetDeviceLevel(static_cast<DWORD>(@<设备号>), @<通道>)
    }

    方法 置设备 <公开 类型 = 逻辑型 注释 = "设置当前线程后续使用的设备"
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 设备号 <类型 = 整数 注释 = "0 为第一个设备">
    {
        @ BassWasApi::Fn().BASS_WASAPI_SetDevice(static_cast<DWORD>(@<设备号>))
    }

    方法 取设备 <公开 类型 = 整数 注释 = "获取当前线程使用的设备" 返回值注释 = "成功返回设备号,失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息."
            折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(BassWasApi::Fn().BASS_WASAPI_GetDevice())
    }

    方法 取设备类型名 <公开 类型 = 文本型 注释 = "返回输出设备的类型名称(中文名称)" 返回值注释 = "成功返回输出设备的类型名称" 折叠>
    参数 设备类型 <类型 = 整数 注释 = "\"BASS_WASAPI_设备信息\"类中的\"设备类型\"成员">
    {
        分支判断 (设备类型)
        {
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_NETWORKDEVICE)
            {
                返回 ("网络设备")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_SPEAKERS)
            {
                返回 ("扬声器")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_LINELEVEL)
            {
                返回 ("线路输出")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_HEADPHONES)
            {
                返回 ("耳机")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_MICROPHONE)
            {
                返回 ("麦克风")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_HEADSET)
            {
                返回 ("耳机(带麦克风)")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_HANDSET)
            {
                返回 ("手机")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_DIGITAL)
            {
                返回 ("数字接口")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_SPDIF)
            {
                返回 ("S/PDIF")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_HDMI)
            {
                返回 ("HDMI接口")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_UNKNOWN)
            {
                返回 ("未知设备")
            }
        }
        返回 ("未知设备")
    }

    方法 检查格式 <公开 类型 = 整数 注释 = "检查设备是否支持指定的采样格式."
            返回值注释 = "如果是支持的采样格式,则返回支持的最大解析度(BASS_WASAPI_FORMAT),否则返回-1."
            返回值注释 = "可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 设备号 <类型 = 整数 注释 = "所欲使用的设备;" 注释 = "-1=默认输出设备, -2=默认输入设备, -3=默认环回输入设备;" 注释 = "可使用\"取所有设备信息\"枚举可用设备.">
    参数 采样率 <类型 = 整数 注释 = "所欲使用的采样率">
    参数 声道 <类型 = 整数 注释 = "声道数量,1=单声道,2=立体声,以此类推.">
    参数 独占模式 <类型 = 逻辑型 注释 = "真为在独占模式下检查设备,假为在共享模式下检查；"
            注释 = "共享和独占模式可能支持不同的采样格式.共享模式通常只支持\"混合格式\"(可从\"取设备信息\"获取).">
    {
        @ static_cast<INT>(BassWasApi::Fn().BASS_WASAPI_CheckFormat(@<设备号>, static_cast<DWORD>(@<采样率>),
        @    static_cast<DWORD>(@<声道>), (@<独占模式>) ? BASS_WASAPI_EXCLUSIVE : 0))
    }

    方法 输出输入 <公开 定义事件 类型 = 整数 注释 = "用户在本事件中处理输出/输入的回调函数." 注释 = "输出/输入处理的方法应尽可能快,以避免缓冲区不足(输出)或溢出(输入)."
            注释 = "\"取数据\"使用BASS_DATA_AVAILABLE标志时,可用于检查缓冲了多少数据(用于返回值)."
            注释 = "如果输出设备初始化为独占模式,且返回的数据少于请求的数据,则缓冲区的其余部分将以静音填充."
            返回值注释 = "对于输出设备,返回写入缓冲区的字节数.如果该值为负值(高位设置),则该值将被视为0." 返回值注释 = "对于输入设备,0=停止设备,否则继续." 折叠>
    参数 缓冲区 <类型 = 变整数 注释 = "缓冲区的指针,用于存放输出设备的样本数据,或从输入设备获取数据;" 注释 = "样本数据始终为32位浮点数.">
    参数 数据长度 <类型 = 整数 注释 = "缓冲区的数据长度">

    方法 初始化 <公开 类型 = 逻辑型 注释 = "初始化设备,之后在接收事件\"输出输入\"中处理输出/输出数据."
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 设备号 <类型 = 整数 注释 = "所欲使用的设备. -1=默认输出设备, -2=默认输入设备, -3=默认环回输入设备;" 注释 = "可使用\"取所有设备信息\"枚举可用设备."
            @默认值 = -1>
    参数 采样率 <类型 = 整数 注释 = "采样率,0=\"混合格式\"采样率." @默认值 = 0>
    参数 声道 <类型 = 整数 注释 = "声道数量,1=单声道,2=立体声,以此类推." @默认值 = 0>
    参数 标志 <类型 = 整数 注释 = "使用\"BASS_WASAPI_标志\"的组合值" @默认值 = 0>
    参数 缓冲长度 <类型 = 单精度小数 注释 = "设备缓冲区长度(以秒或样本为单位,取决于\"BASS_WASAPI_SAMPLES\"标志);"
            注释 = "这里设置的是最小值,驱动程序可以选择使用更大的缓冲区. 可用\"取信息\"确认缓冲区的大小;"
            注释 = "对于输出设备,缓冲区大小决定了延迟.在事件驱动独占模式下,将有两个此长度的缓冲区,因此总缓冲区长度也是原来的两倍." @默认值 = 0.1>
    参数 周期 <类型 = 单精度小数 注释 = "调用回调函数的间隔(以秒或样本为单位,取决于\"BASS_WASAPI_SAMPLES\"标志).0=使用默认值;"
            注释 = "如果指定的周期低于最小更新周期,将自动升高;" 注释 = "当指定BASS_WASAPI_EVENT标志时,此选项将被忽略,但在Windows 10且\"缓冲长度\"=0的共享模式下除外."
            @默认值 = 0>
    {
        @ BassWasApi::Fn().BASS_WASAPI_Init(@<设备号>, static_cast<DWORD>(@<采样率>), static_cast<DWORD>(@<声道>), static_cast<DWORD>(@<标志>),
        @    @<缓冲长度>, @<周期>, &@sn<current_class_def>::WasApiBuffer, &@sn<this>)
    }

    方法 初始化_通道 <公开 类型 = 逻辑型 注释 = "初始化设备,本方法不启用接收事件\"输出输入\",而是从BASS通道交换数据."
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 设备号 <类型 = 整数 注释 = "要使用的设备. -1=默认输出设备, -2=默认输入设备, -3=默认环回输入设备." 注释 = "可使用\"取所有设备信息\"枚举可用设备."
            @默认值 = -1>
    参数 BASS通道 <类型 = 整数
            注释 = "必须是输出设备的解码通道(使用BASS_STREAM_DECODE),或输入设备的\"push\"或\"dummy\"流(使用STREAMPROC_PUSH或STREAMPROC_DUMMY);"
            注释 = "通道的采样格式必须是浮点(BASS_SAMPLE_FLOAT).">
    参数 标志 <类型 = 整数 注释 = "使用\"BASS_WASAPI_标志\"的组合值" @默认值 = 0>
    参数 缓冲长度 <类型 = 单精度小数 注释 = "设备缓冲区长度(以秒或样本为单位,取决于\"BASS_WASAPI_SAMPLES\"标志);"
            注释 = "这里设置的是最小值,驱动程序可以选择使用更大的缓冲区. 可用\"取信息\"确认缓冲区的大小;"
            注释 = "对于输出设备,缓冲区大小决定了延迟.在事件驱动独占模式下,将有两个此长度的缓冲区,因此总缓冲区长度也是原来的两倍." @默认值 = 0.1>
    参数 周期 <类型 = 单精度小数 注释 = "调用回调函数的间隔(以秒或样本为单位,取决于\"BASS_WASAPI_SAMPLES\"标志).0=使用默认值;"
            注释 = "如果指定的周期低于最小更新周期,将自动升高;" 注释 = "当指定BASS_WASAPI_EVENT标志时,此选项将被忽略,但在Windows 10且\"缓冲长度\"=0的共享模式下除外."
            @默认值 = 0>
    {
        @ BassWasApi::Fn().BASS_WASAPI_Init(@<设备号>, 0, 0, static_cast<DWORD>(@<标志>), @<缓冲长度>, @<周期>, WASAPIPROC_BASS, reinterpret_cast<void*>(@<BASS通道>))
    }

    方法 初始化_推送 <公开 类型 = 逻辑型
            注释 = "初始化设备,本方法不从回调函数和接收事件\"输出输入\"里获取数据,而是通过BASS音频类的\"推送流数据(BASS_StreamPutData)\"获取."
            注释 = "不能用于输入设备或BASS_WASAPI_EVENT标志." 返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息."
            折叠 @嵌入式方法 = "">
    参数 设备号 <类型 = 整数 注释 = "要使用的设备. -1=默认输出设备, -2=默认输入设备, -3=默认环回输入设备;" 注释 = "可使用\"取所有设备信息\"枚举可用设备."
            @默认值 = -1>
    参数 采样率 <类型 = 整数 注释 = "采样率,0=\"混合格式\"采样率." @默认值 = 0>
    参数 声道 <类型 = 整数 注释 = "声道数量,1=单声道,2=立体声,以此类推." @默认值 = 0>
    参数 标志 <类型 = 整数 注释 = "使用\"BASS_WASAPI_标志\"的组合值" @默认值 = 0>
    参数 缓冲长度 <类型 = 单精度小数 注释 = "设备缓冲区长度(以秒或样本为单位,取决于\"BASS_WASAPI_SAMPLES\"标志);"
            注释 = "这里设置的是最小值,驱动程序可以选择使用更大的缓冲区. 可用\"取信息\"确认缓冲区的大小;"
            注释 = "对于输出设备,缓冲区大小决定了延迟.在事件驱动独占模式下,将有两个此长度的缓冲区,因此总缓冲区长度也是原来的两倍." @默认值 = 0.1>
    参数 周期 <类型 = 单精度小数 注释 = "调用回调函数的间隔(以秒或样本为单位,取决于\"BASS_WASAPI_SAMPLES\"标志).0=使用默认值;"
            注释 = "如果指定的周期低于最小更新周期,将自动升高;" 注释 = "当指定BASS_WASAPI_EVENT标志时,此选项将被忽略,但在Windows 10且\"缓冲长度\"=0的共享模式下除外."
            @默认值 = 0>
    {
        @ BassWasApi::Fn().BASS_WASAPI_Init(@<设备号>, static_cast<DWORD>(@<采样率>), static_cast<DWORD>(@<声道>), static_cast<DWORD>(@<标志>),
        @    @<缓冲长度>, @<周期>, (WASAPIPROC*)WASAPIPROC_PUSH, NULL);
    }

    方法 释放 <公开 类型 = 逻辑型 注释 = "释放输出输入设备. 退出程序前应该释放设备,但不需要用户手段调用,类析构的时候会自动调用."
            注释 = "独占模式下,只要初始化后就会一直独占设备,如果想在停止播放的时候转让给其他应用,就应该调用释放."
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    {
        @ BassWasApi::Fn().BASS_WASAPI_Free()
    }

    方法 取信息 <公开 类型 = 逻辑型 注释 = "获取当前所用设备的信息" 返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息."
            折叠 @嵌入式方法 = "">
    参数 信息 <类型 = BASS_WASAPI_信息 注释 = "返回的信息">
    {
        @ BassWasApi::Fn().BASS_WASAPI_GetInfo(&@<信息>)
    }

    方法 取CPU使用率 <公开 类型 = 单精度小数 注释 = "获取BASSWASAPI当前的CPU使用率" 返回值注释 = "返回CPU使用率" 折叠 @嵌入式方法 = "">
    {
        @ BassWasApi::Fn().BASS_WASAPI_GetCPU()
    }

    方法 锁定设备 <公开 类型 = 逻辑型 注释 = "将设备锁定到当前线程. 锁定设备会阻止其他线程访问设备缓冲区,包括WASAPIPROC回调函数."
            注释 = "其他想要访问锁定设备的线程将一直阻塞,直到设备解锁,因此设备应该只被短暂锁定. 设备必须在其锁定的同一线程中解锁."
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 是否锁定 <类型 = 逻辑型 注释 = "真为锁定,假为解锁">
    {
        @ BassWasApi::Fn().BASS_WASAPI_Lock(@<是否锁定>)
    }

    方法 开启设备 <公开 类型 = 逻辑型 注释 = "开启或恢复设备." 返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠
            @嵌入式方法 = "">
    {
        @ BassWasApi::Fn().BASS_WASAPI_Start()
    }

    方法 停止设备 <公开 类型 = 逻辑型 注释 = "停止设备."
            注释 = "如果设备缓冲区未刷新(是否重置=假),之后调用的\"开启设备/BASS_WASAPI_Start\"将恢复之前的缓冲数据,否则将使用新数据恢复."
            注释 = "独占模式输出应在停止时刷新缓冲区,以避免恢复时出现故障." 返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息."
            折叠 @嵌入式方法 = "">
    参数 是否重置 <类型 = 逻辑型 注释 = "是否刷新设备缓冲区" @默认值 = 真>
    {
        @ BassWasApi::Fn().BASS_WASAPI_Stop(@<是否重置>)
    }

    方法 是否已启动 <公开 类型 = 逻辑型 注释 = "检查是否已经开始处理" 返回值注释 = "设备已启动返回真,其他返回假." 折叠 @嵌入式方法 = "">
    {
        @ BassWasApi::Fn().BASS_WASAPI_IsStarted()
    }

    方法 置音量 <公开 类型 = 逻辑型 注释 = "设置输出设备的主音量" 返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息."
            折叠 @嵌入式方法 = "">
    参数 模式 <类型 = 整数 注释 = "获取的音量类型和使用的曲线;" 注释 = " 0=BASS_WASAPI_CURVE_DB 使用对数曲线,如果未指定曲线,此项则为默认值;"
            注释 = " 1=BASS_WASAPI_CURVE_LINEAR 使用线性曲线;"
            注释 = " 2=BASS_WASAPI_CURVE_WINDOWS 使用WINDOWS的Hybrid曲线,跟WINDOWS的音量控制一样;"
            注释 = " 8=BASS_WASAPI_VOL_SESSION 获取会话的音量,其他为设备音量;" @默认值 = 0>
    参数 音量 <类型 = 单精度小数 注释 = "使用线性或Windows曲线时音量范围为0(静音)到1(最大值). 其他为dB级别;"
            注释 = "设备的有效dB级别范围请用\"取输出信息/BASS_WASAPI_GetInfo\"获取.">
    {
        @ BassWasApi::Fn().BASS_WASAPI_SetVolume(static_cast<DWORD>(@<模式>), @<音量>)
    }

    方法 取音量 <公开 类型 = 单精度小数 注释 = "获取当前的主音量级别"
            返回值注释 = "成功返回音量值,失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 模式 <类型 = 整数 注释 = "获取的音量类型和使用的曲线;" 注释 = " 0=BASS_WASAPI_CURVE_DB 使用对数曲线,如果未指定曲线,此项则为默认值;"
            注释 = " 1=BASS_WASAPI_CURVE_LINEAR 使用线性曲线;"
            注释 = " 2=BASS_WASAPI_CURVE_WINDOWS 使用WINDOWS的Hybrid曲线,跟WINDOWS的音量控制一样;"
            注释 = " 8=BASS_WASAPI_VOL_SESSION 获取会话的音量,其他为设备音量;" @默认值 = 2>
    {
        @ BassWasApi::Fn().BASS_WASAPI_GetVolume(static_cast<DWORD>(@<模式>))
    }

    方法 置静音 <公开 类型 = 逻辑型 注释 = "使设备静音或取消静音" 返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息."
            折叠 @嵌入式方法 = "">
    参数 模式 <类型 = 整数 注释 = "设置的音量类型;" 注释 = " 0=BASS_WASAPI_CURVE_DB 使用对数曲线,如果未指定曲线,此项则为默认值;"
            注释 = " 1=BASS_WASAPI_CURVE_LINEAR 使用线性曲线;"
            注释 = " 2=BASS_WASAPI_CURVE_WINDOWS 使用WINDOWS的Hybrid曲线,跟WINDOWS的音量控制一样;"
            注释 = " 8=BASS_WASAPI_VOL_SESSION 获取会话的音量,其他为设备音量;" @默认值 = 0>
    参数 是否静音 <类型 = 逻辑型 注释 = "是否将设备静音,真为静音,假为取消静音.">
    {
        @ BassWasApi::Fn().BASS_WASAPI_SetMute(static_cast<DWORD>(@<模式>), @<是否静音>)
    }

    方法 取静音 <公开 类型 = 逻辑型 注释 = "获取设备的静音状态" 返回值注释 = "成功返回静音的状态(真为静音)." 折叠 @嵌入式方法 = "">
    参数 模式 <类型 = 整数 注释 = "设置的音量类型." 注释 = " 0=BASS_WASAPI_CURVE_DB 使用对数曲线,如果未指定曲线,此项则为默认值;"
            注释 = " 1=BASS_WASAPI_CURVE_LINEAR 使用线性曲线;"
            注释 = " 2=BASS_WASAPI_CURVE_WINDOWS 使用WINDOWS的Hybrid曲线,跟WINDOWS的音量控制一样;"
            注释 = " 8=BASS_WASAPI_VOL_SESSION 获取会话的音量,其他为设备音量;" @默认值 = 0>
    {
        @ BassWasApi::Fn().BASS_WASAPI_GetMute(static_cast<DWORD>(@<模式>))
    }

    方法 置数据 <公开 类型 = 整数 注释 = "将样本数据添加到输出设备缓冲区."
            返回值注释 = "成功返回使用的数据量,否则返回-1.可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 缓冲区 <类型 = 变整数 注释 = "样本数据的指针">
    参数 长度 <类型 = 整数 注释 = "数据的字节大小">
    {
        @ static_cast<INT>(BassWasApi::Fn().BASS_WASAPI_PutData(reinterpret_cast<void*>(@<缓冲区>), static_cast<DWORD>(@<长度>)))
    }

    方法 取数据 <公开 类型 = 整数 注释 = "获取即时的样本数据或其FFT信号." 返回值注释 = "失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息.."
            返回值注释 = "请求FFT数据时,返回从通道读取的字节数(用于执行FFT)." 返回值注释 = "请求样本数据时,将返回写入缓冲区的字节数."
            返回值注释 = "使用BASS_DATA_AVAILABLE标志时,将返回通道缓冲区中的字节数." 折叠 @嵌入式方法 = "">
    参数 缓冲区 <类型 = 变整数 注释 = "用来接收数据的缓冲区指针.">
    参数 长度 <类型 = 整数 注释 = "你想要获取的数据字节数,也可以使用\"BASS_通道数据类型\"中常量的组合值.">
    {
        @ static_cast<INT>(BassWasApi::Fn().BASS_WASAPI_GetData(reinterpret_cast<void*>(@<缓冲区>), static_cast<DWORD>(@<长度>)))
    }

    方法 置数据2 <公开 类型 = 整数 注释 = "将样本数据添加到输出设备缓冲区." 注释 = "\"置数据\"的二次封装版本,缓冲区改成字节集类,而原始版本更适合在回调事件中使用."
            返回值注释 = "成功返回使用的数据量,否则返回-1.可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @禁止流程检查 = 真>
    参数 缓冲区 <类型 = 字节集类 注释 = "样本数据">
    {
        @ return static_cast<INT>(BassWasApi::Fn().BASS_WASAPI_PutData(reinterpret_cast<void*>(@<缓冲区>.GetPtr()), static_cast<DWORD>(@<缓冲区>.GetSize())));
    }

    方法 取数据2 <公开 类型 = 整数 注释 = "获取即时的样本数据或其FFT信号." 注释 = "\"取数据\"的二次封装版本,缓冲区改成字节集类,而原始版本更适合在回调事件中使用."
            返回值注释 = "失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息.." 返回值注释 = "请求FFT数据时,返回从通道读取的字节数(用于执行FFT)."
            返回值注释 = "请求样本数据时,将返回写入缓冲区的字节数." 返回值注释 = "使用BASS_DATA_AVAILABLE标志时,将返回通道缓冲区中的字节数." 折叠 @禁止流程检查 = 真>
    参数 缓冲区 <类型 = 字节集类 注释 = "用来接收数据的缓冲区字节集;" 注释 = "当句柄是录制句柄(HRECORD)时,可以为\"空对象\",以丢弃从录制缓冲区请求的数据." @默认值 = 空对象>
    参数 长度 <类型 = 整数 注释 = "你想要获取的数据字节数,也可以使用\"BASS_通道数据类型\"中常量的组合值." @默认值 = 0>
    {
        变量 缓冲区长度 <类型 = 整数>
        变量 FFT倍数 <类型 = 整数>
        变量 信息 <类型 = BASS_WASAPI_信息>
        取信息 (信息)
        如果 (信息.声道数 > 2)
        {
            FFT倍数 = 2 * 信息.声道数
        }
        否则
        {
            FFT倍数 = 4
        }
        如果 (位与 (长度, 0x80000007) == 0x80000007)  // 判断是否FFT,以及获取样本量
        {
            缓冲区长度 = 32768 * FFT倍数
        }
        否则 (位与 (长度, 0x80000006) == 0x80000006)
        {
            缓冲区长度 = 16384 * FFT倍数
        }
        否则 (位与 (长度, 0x80000005) == 0x80000005)
        {
            缓冲区长度 = 8192 * FFT倍数
        }
        否则 (位与 (长度, 0x80000004) == 0x80000004)
        {
            缓冲区长度 = 4096 * FFT倍数
        }
        否则 (位与 (长度, 0x80000003) == 0x80000003)
        {
            缓冲区长度 = 2048 * FFT倍数
        }
        否则 (位与 (长度, 0x80000002) == 0x80000002)
        {
            缓冲区长度 = 1024 * FFT倍数
        }
        否则 (位与 (长度, 0x80000001) == 0x80000001)
        {
            缓冲区长度 = 512 * FFT倍数
        }
        否则 (位与 (长度, 0x80000000) == 0x80000000)
        {
            缓冲区长度 = 256 * FFT倍数
        }
        否则
        {
            缓冲区长度 = 长度  // 不是FFT,则使用长度参数中的数值
        }
        缓冲区.分配字节集 (缓冲区长度)
        @ return static_cast<INT>(BassWasApi::Fn().BASS_WASAPI_GetData(reinterpret_cast<void*>(@<缓冲区>.GetPtr()), static_cast<DWORD>(@<长度>)));
    }

    方法 取电平 <公开 类型 = 整数 注释 = "获取电平(峰值振幅)" 返回值注释 = "失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息."
            返回值注释 = "如果成功,左声道的电平在低位(低16位),右声道在高位(高16位)返回,若通道为单声道,则低位与高位重复."
            返回值注释 = "该级别的线性范围为0(无声)到32768(最大).通道暂停时将返回0." 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(BassWasApi::Fn().BASS_WASAPI_GetLevel())
    }

    方法 取电平EX <公开 类型 = 逻辑型 注释 = "获取电平(峰值振幅)" 返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息."
            折叠 @禁止流程检查 = 真>
    参数 电平数据 <类型 = 单精度小数数组类 注释 = "用于接收电平级别的数组">
    参数 数据长度 <类型 = 单精度小数 注释 = "计算电平的观察数据量,单位为秒,除解码通道外,最大值为1秒.">
    参数 声道 <类型 = 整数 注释 = "0=全部声道, 1=单声道, 2=立体声" @默认值 = 2>
    参数 是否RMS级别 <类型 = 逻辑型 注释 = "假为获取电平级别,真为获取RMS(均方根值)级别." @默认值 = 假>
    参数 应用属性 <类型 = 逻辑型 注释 = "为真时将当前的BASS_ATTRIB_VOL和BASS_ATTRIB_PAN值应用于电平级别中." @默认值 = 假>
    {
        @ BOOL ret;
        @ DWORD flags = @<声道>;
        @ if (@<是否RMS级别>) flags |= BASS_LEVEL_RMS;
        @ if (@<应用属性>) flags |= BASS_LEVEL_VOLPAN;
        @ if (@<声道> == 1) {
        @     @<电平数据>.data().InitCount(1, TRUE);
        @     ret = BassWasApi::Fn().BASS_WASAPI_GetLevelEx(@<电平数据>.data().GetData(), @<数据长度>, flags);
        @ } else if (@<声道> == 2) {
        @     @<电平数据>.data().InitCount(2, TRUE);
        @     ret = BassWasApi::Fn().BASS_WASAPI_GetLevelEx(@<电平数据>.data().GetData(), @<数据长度>, flags);
        @ } else {
        @     BASS_WASAPI_INFO ci;
        @     BassWasApi::Fn().BASS_WASAPI_GetInfo(&ci);
        @     @<电平数据>.data().InitCount(ci.chans, TRUE);
        @     ret = BassWasApi::Fn().BASS_WASAPI_GetLevelEx(@<电平数据>.data().GetData(), @<数据长度>, flags);
        @ }
        @ return ret;
    }

    # @begin
    # <> <include>
    # static void CALLBACK WasApiNotify(DWORD notify, DWORD device, void *user) {
    #     reinterpret_cast<@sn<current_class>*>(user)->@<通知>(static_cast<INT>(notify), static_cast<INT>(device));
    # }
    # static DWORD CALLBACK WasApiBuffer(void *buffer, DWORD length, void *user) {
    #     return static_cast<DWORD>(reinterpret_cast<@sn<current_class>*>(user)->@<输出输入>(reinterpret_cast<INT_P>(buffer), static_cast<INT>(length)));
    # }
    # <> </include>
    # @end
}

类 "// BASS_ASIO类" <公开 注释 = "BASSASIO 1.4.2" 注释 = "支持在Windows Vista及更高版本上使用WASAPI输入和输出的扩展,支持独占和共享模式."
        注释 = "\"BASS音频类\"在Vista及更高版本的系统默认就是使用WASAPI,但只支持共享模式,真玩Hifi的,还是得开独占模式."
        注释 = "独占模式可以绕过系统的混合器直接输出,打开后其他应用就不能发声,理论上独占模式的音质更好."
        注释 = "本扩展不能在Windows XP之类的旧系统使用,旧系统默认的是DirectSound." 折叠 @视窗.附属文件 = "BASS\\$(p)\\bassasio.dll"
        @文档 = "category = \"WASAPI支持\"">
{
    方法 加载动态库 <公开 静态 类型 = 逻辑型 注释 = "程序默认在执行本类的函数时加载与程序文件同位置的DLL文件."
            注释 = "如果你想将DLL放在其他位置,请在执行其他方法前调用本方法手动加载." 注释 = "注意: 请尽量在启动方法中加载,且不应将本对象的实例定义在启动类内." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 动态库路径 <类型 = 文本型 注释 = "bassasio.dll的路径">
    {
        @ BassAsio::data().Load(@<动态库路径>)
    }

    方法 卸载动态库 <公开 静态 注释 = "手动卸载动态库,一般不需要执行本方法." 折叠 @嵌入式方法 = "">
    {
        @ BassAsio::data().Free()
    }

    方法 取版本 <公开 类型 = 整数 注释 = "获取已加载的BASSASIO的版本号,其中高16位为主版本号,低16位为修订版本号." 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(BassAsio::Fn().BASS_ASIO_GetVersion())
    }

    # ---

    方法 类_清理 <折叠>
    {
        释放 ()
    }

    方法 取错误代码 <公开 类型 = 整数 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(BassAsio::Fn().BASS_ASIO_ErrorGetCode())
    }

    方法 取设备信息 <公开 类型 = 逻辑型 注释 = "获取一个设备的信息" 返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息."
            折叠 @嵌入式方法 = "">
    参数 设备号 <类型 = 整数 注释 = "0 为第一个设备" @默认值 = 0>
    参数 设备信息 <类型 = BASS_ASIO_设备信息 注释 = "返回的设备信息" "">
    {
        @ BassAsio::Fn().BASS_ASIO_GetDeviceInfo(static_cast<DWORD>(@<设备号>), &@<设备信息>)
    }

    方法 取所有设备信息 <公开 类型 = 整数 注释 = "获取所有可用的设备"
            返回值注释 = "成功返回设备数量,失败返回0,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @禁止流程检查 = 真>
    参数 设备信息 <类型 = BASS_ASIO_设备信息数组 注释 = "返回的设备信息" "">
    {
        设备信息.删除所有成员 ()
        变量 索引 <类型 = 整数 值 = 0>
        变量 信息 <类型 = BASS_ASIO_设备信息>
        判断循环 (取设备信息 (索引, 信息))
        {
            设备信息.加入成员 (信息)
            索引 = 索引 + 1
        }
        返回 (设备信息.取成员数 ())
    }

    方法 添加设备 <公开 类型 = 整数 注释 = "添加一个驱动到驱动列表中,并返回设备号." 注释 = "失败将返回-1,可以用\"取错误代码\"获取错误代码." 折叠 @嵌入式方法 = "">
    参数 驱动类标识符 <类型 = GUID类 注释 = "驱动程序的类标识符(GUID)">
    参数 驱动文件名 <类型 = 文本型 注释 = "驱动程序的文件名">
    参数 设备名称 <类型 = 文本型 注释 = "设置的描述名称">
    {
        @ static_cast<INT>(BassAsio::Fn().BASS_ASIO_AddDevice(&@<驱动类标识符>.m_guid, @<驱动文件名>.GetText(), @<设备名称>.GetText()))
    }

    方法 置设备 <公开 类型 = 逻辑型 注释 = "设置当前线程后续使用的设备." 注释 = "注意: 允许不同线程使用不同的设备" 折叠 @嵌入式方法 = "">
    参数 设备号 <类型 = 整数 注释 = "所欲使用的驱动">
    {
        @ BassAsio::Fn().BASS_ASIO_SetDevice(static_cast<DWORD>(@<设备号>))
    }

    方法 取设备 <公开 类型 = 整数 注释 = "获取当前线程使用的设备号,失败返回-1." 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(BassAsio::Fn().BASS_ASIO_GetDevice())
    }

    方法 初始化 <公开 类型 = 逻辑型 注释 = "初始化ASIO设备或驱动,返回是否成功." 返回值注释 = "如果失败,可以用\"取错误代码\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 设备号 <类型 = 整数 注释 = "所欲使用的设备,-1为第一个可用设备, 1为第一个设备..." 注释 = "可使用\"取所有设备信息\"枚举可用设备." @默认值 = -1>
    参数 标志 <类型 = 整数 注释 = "使用\"BASS_ASIO_标志\"的组合值" @默认值 = 0>
    {
        @ BassAsio::Fn().BASS_ASIO_Init(@<设备号>, static_cast<DWORD>(@<标志>))
    }

    方法 释放 <公开 类型 = 逻辑型 注释 = "释放ASION设备或驱动,返回是否成功." 折叠 @嵌入式方法 = "">
    {
        @ BassAsio::Fn().BASS_ASIO_Free()
    }

    方法 锁定设备 <公开 类型 = 逻辑型 注释 = "将设备锁定到当前线程,返回是否成功." 注释 = "锁定设备会阻止其他线程在设备上执行大多数操作,包括通道处理."
            注释 = "其他想要访问锁定设备的线程将一直阻塞,直到设备解锁,因此设备应该只被短暂锁定. 设备必须在其锁定的同一线程中解锁." 折叠 @嵌入式方法 = "">
    参数 是否锁定 <类型 = 逻辑型>
    {
        @ BassAsio::Fn().BASS_ASIO_Lock(@<是否锁定>)
    }

    方法 置通知 <公开 类型 = 逻辑型 注释 = "在ASIO驱动上设置一个通知回调函数,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 通知回调 <注释 = "提供用户自定义的通知函数" @匹配方法 = "通知回调模板">
    参数 用户参数 <类型 = 变整数>
    {
        @ BassAsio::Fn().BASS_ASIO_SetNotify((ASIONOTIFYPROC)@<通知回调>, (void*)@<用户参数>)
    }

    方法 通知回调模板 <公开 静态 折叠>
    参数 通知 <类型 = 整数>
    参数 用户参数 <类型 = 变整数>

    方法 驱动面板 <公开 类型 = 逻辑型 注释 = "显示ASIO驱动程序的控制面板,返回是否成功." 折叠 @嵌入式方法 = "">
    {
        @ BassAsio::Fn().BASS_ASIO_ControlPanel()
    }

    方法 取信息 <公开 类型 = 逻辑型 注释 = "获取当前所用设备的信息,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 信息 <类型 = BASS_ASIO_信息 注释 = "返回的信息">
    {
        @ BassAsio::Fn().BASS_ASIO_GetInfo(&@<信息>)
    }

    方法 检查采样率 <公开 类型 = 逻辑型 注释 = "检查设备是否支持指定的采样率" 折叠 @嵌入式方法 = "">
    参数 采样率 <类型 = 小数 注释 = "所欲检查的采样率">
    {
        @ BassAsio::Fn().BASS_ASIO_CheckRate(@<采样率>)
    }

    方法 置采样率 <公开 类型 = 逻辑型 注释 = "设置设备的采样率,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 采样率 <类型 = 小数 注释 = "所欲设置的采样率">
    {
        @ BassAsio::Fn().BASS_ASIO_SetRate(@<采样率>)
    }

    方法 取采样率 <公开 类型 = 小数 注释 = "获取设备的采样率,失败返回-1." 折叠 @嵌入式方法 = "">
    {
        @ BassAsio::Fn().BASS_ASIO_GetRate()
    }

    方法 开启设备 <公开 类型 = 逻辑型 注释 = "开启或恢复设备,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 缓冲区长度 <类型 = 整数 注释 = "缓冲区长度,以采样为单位,0为使用当前长度." @默认值 = 0>
    参数 最大线程数 <类型 = 整数 注释 = "最大的处理线程数,0为使用当前线程数." @默认值 = 0>
    {
        @ BassAsio::Fn().BASS_ASIO_Start(static_cast<DWORD>(@<缓冲区长度>), static_cast<DWORD>(@<缓冲区长度>))
    }

    方法 停止设备 <公开 类型 = 逻辑型 注释 = "停止设备,返回是否成功."
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    {
        @ BassAsio::Fn().BASS_ASIO_Stop()
    }

    方法 是否已启动 <公开 类型 = 逻辑型 注释 = "检查是否已经开始处理" 返回值注释 = "设备已启动返回真,其他返回假." 折叠 @嵌入式方法 = "">
    {
        @ BassAsio::Fn().BASS_ASIO_IsStarted()
    }

    方法 取延迟值 <公开 类型 = 整数 注释 = "获取输入或输出通道的延迟" 折叠 @嵌入式方法 = "">
    参数 为输入通道 <类型 = 逻辑型 注释 = "真=获取输入通道的延迟;" 注释 = "假=获取输出通道的延迟;">
    {
        @ static_cast<INT>(BassAsio::Fn().BASS_ASIO_GetLatency(@<为输入通道>))
    }

    方法 取CPU使用率 <公开 类型 = 单精度小数 注释 = "获取BASSASIO当前的CPU使用率" 折叠 @嵌入式方法 = "">
    {
        @ BassAsio::Fn().BASS_ASIO_GetCPU()
    }

    方法 监听 <公开 类型 = 逻辑型 注释 = "设置直接输入监听状态,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 输入通道 <类型 = 整数 注释 = "设置为监听状态的输入通道,-1为全部输入通道." @默认值 = -1>
    参数 输出通道 <类型 = 整数 注释 = "建议的监听输出通道">
    参数 增益 <类型 = 整数 注释 = "建议的输出增益,0(无声) - 0x7FFFFFFF (+12 dB), 0x20000000 = 0 dB.">
    参数 状态 <类型 = 整数 注释 = "0为关闭监听,1为开启监听." 注释 = "根据驱动程序的不同,也可以进行其他设置.">
    参数 声场定位 <类型 = 整数 注释 = "建议的输出声场定位. 0 = 左, 0x7FFFFFFF = 右.">
    {
        @ BassAsio::Fn().BASS_ASIO_Monitor(@<输入通道>, static_cast<DWORD>(@<输出通道>), static_cast<DWORD>(@<增益>), static_cast<DWORD>(@<状态>), static_cast<DWORD>(@<声场定位>))
    }

    方法 置DSD <公开 类型 = 逻辑型 注释 = "设置设备的采样格式为DSD或PCM,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 开启DSD <类型 = 逻辑型 注释 = "真为DSD格式,假为PCM">
    {
        @ BassAsio::Fn().BASS_ASIO_SetDSD(@<开启DSD>)
    }

    方法 未来功能 <公开 类型 = 逻辑型 注释 = "提供对驱动\"未来\"功能的访问." 折叠 @嵌入式方法 = "">
    参数 选择器 <类型 = 逻辑型 注释 = "操作代码">
    参数 参数 <类型 = 变整数 注释 = "指向操作参数的指针(如果可用)">
    {
        @ BassAsio::Fn().BASS_ASIO_Future(static_cast<DWORD>(@<选择器>), (void*)@<参数>)
    }

    # 通道 ---

    方法 取通道信息 <公开 类型 = 逻辑型 注释 = "获取某条通道的信息,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 为输入通道 <类型 = 逻辑型 注释 = "提供的通道是否为输入通道;" 注释 = "为真表示输入通道,为假表示输出通道.">
    参数 通道号 <类型 = 整数 注释 = "输入输出通道的序号,0为第一条通道">
    参数 通道信息 <类型 = BASS_ASIO_通道信息 注释 = "成功在此返回通道信息">
    {
        @ BassAsio::Fn().BASS_ASIO_ChannelGetInfo(@<为输入通道>, static_cast<DWORD>(@<通道号>), &@<通道信息>)
    }

    方法 重置通道 <公开 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 为输入通道 <类型 = 逻辑型 注释 = "提供的通道是否为输入通道;" 注释 = "为真表示输入通道,为假表示输出通道.">
    参数 通道号 <类型 = 整数 注释 = "输入输出通道的序号,0为第一条通道">
    参数 标志 <类型 = 整数>
    {
        @ BassAsio::Fn().BASS_ASIO_ChannelReset(@<为输入通道>, @<通道号>, static_cast<DWORD>(@<标志>))
    }

    方法 启用通道 <公开 类型 = 逻辑型 @嵌入式方法 = "">
    参数 为输入通道 <类型 = 逻辑型 注释 = "提供的通道是否为输入通道;" 注释 = "为真表示输入通道,为假表示输出通道.">
    参数 通道号 <类型 = 整数 注释 = "输入输出通道的序号,0为第一条通道">
    参数 回调函数 <@匹配方法 = "通道回调模板">
    参数 用户参数 <类型 = 变整数>
    {
        @ BassAsio::Fn().BASS_ASIO_ChannelEnable(@<为输入通道>, static_cast<DWORD>(@<通道号>), (ASIOPROC)@<回调函数>, (void*)@<用户参数>)
    }

    方法 通道回调模板 <公开 静态 类型 = 整数 折叠>
    参数 为输入通道 <类型 = 逻辑型 注释 = "提供的通道是否为输入通道;" 注释 = "为真表示输入通道,为假表示输出通道.">
    参数 通道号 <类型 = 整数 注释 = "输入输出通道的序号,0为第一条通道">
    参数 缓冲区 <类型 = 变整数>
    参数 长度 <类型 = 整数>
    参数 用户参数 <类型 = 变整数>
    {
        返回 (0)
    }

    方法 ChannelEnableMirror <公开 类型 = 逻辑型 @嵌入式方法 = "">
    参数 通道号 <类型 = 整数 注释 = "输入输出通道的序号,0为第一条通道">
    参数 为输入通道 <类型 = 逻辑型 注释 = "提供的通道是否为输入通道;" 注释 = "为真表示输入通道,为假表示输出通道.">
    参数 通道号2 <类型 = 整数 注释 = "输入输出通道的序号,0为第一条通道">
    {
        @ BassAsio::Fn().BASS_ASIO_ChannelEnableMirror(static_cast<DWORD>(@<通道号>), @<为输入通道>, static_cast<DWORD>(@<通道号2>))
    }

    方法 ChannelEnableBASS <公开 类型 = 逻辑型 @嵌入式方法 = "">
    参数 为输入通道 <类型 = 逻辑型 注释 = "提供的通道是否为输入通道;" 注释 = "为真表示输入通道,为假表示输出通道.">
    参数 通道号 <类型 = 整数 注释 = "输入输出通道的序号,0为第一条通道">
    参数 句柄 <类型 = 整数>
    参数 join <类型 = 逻辑型>
    {
        @ BassAsio::Fn().BASS_ASIO_ChannelEnableBASS(@<为输入通道>, static_cast<DWORD>(@<通道号>), static_cast<DWORD>(@<句柄>), @<join>)
    }

    方法 "//取设备电平" <公开 类型 = 单精度小数 注释 = "获取设备的电平(峰值振幅)."
            返回值注释 = "成功返回电平级别,失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息" 折叠 @嵌入式方法 = "">
    参数 设备号 <类型 = 整数 注释 = "要获取电平的设备,从0开始">
    参数 通道 <类型 = 整数 注释 = "获取电平的声道,0=第一个通道,-1=所有通道." @默认值 = 0>
    {
        @ BassWasApi::Fn().BASS_WASAPI_GetDeviceLevel(static_cast<DWORD>(@<设备号>), @<通道>)
    }

    方法 "//取设备类型名" <公开 类型 = 文本型 注释 = "返回输出设备的类型名称(中文名称)" 返回值注释 = "成功返回输出设备的类型名称" 折叠>
    参数 设备类型 <类型 = 整数 注释 = "\"BASS_WASAPI_设备信息\"类中的\"设备类型\"成员">
    {
        分支判断 (设备类型)
        {
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_NETWORKDEVICE)
            {
                返回 ("网络设备")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_SPEAKERS)
            {
                返回 ("扬声器")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_LINELEVEL)
            {
                返回 ("线路输出")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_HEADPHONES)
            {
                返回 ("耳机")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_MICROPHONE)
            {
                返回 ("麦克风")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_HEADSET)
            {
                返回 ("耳机(带麦克风)")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_HANDSET)
            {
                返回 ("手机")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_DIGITAL)
            {
                返回 ("数字接口")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_SPDIF)
            {
                返回 ("S/PDIF")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_HDMI)
            {
                返回 ("HDMI接口")
            }
            分支 (BASS_WASAPI_设备类型.BASS_WASAPI_TYPE_UNKNOWN)
            {
                返回 ("未知设备")
            }
        }
        返回 ("未知设备")
    }

    方法 "//置音量" <公开 类型 = 逻辑型 注释 = "设置输出设备的主音量"
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 模式 <类型 = 整数 注释 = "获取的音量类型和使用的曲线;" 注释 = " 0=BASS_WASAPI_CURVE_DB 使用对数曲线,如果未指定曲线,此项则为默认值;"
            注释 = " 1=BASS_WASAPI_CURVE_LINEAR 使用线性曲线;"
            注释 = " 2=BASS_WASAPI_CURVE_WINDOWS 使用WINDOWS的Hybrid曲线,跟WINDOWS的音量控制一样;"
            注释 = " 8=BASS_WASAPI_VOL_SESSION 获取会话的音量,其他为设备音量;" @默认值 = 0>
    参数 音量 <类型 = 单精度小数 注释 = "使用线性或Windows曲线时音量范围为0(静音)到1(最大值). 其他为dB级别;"
            注释 = "设备的有效dB级别范围请用\"取输出信息/BASS_WASAPI_GetInfo\"获取.">
    {
        @ BassWasApi::Fn().BASS_WASAPI_SetVolume(static_cast<DWORD>(@<模式>), @<音量>)
    }

    方法 "//取音量" <公开 类型 = 单精度小数 注释 = "获取当前的主音量级别"
            返回值注释 = "成功返回音量值,失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 模式 <类型 = 整数 注释 = "获取的音量类型和使用的曲线;" 注释 = " 0=BASS_WASAPI_CURVE_DB 使用对数曲线,如果未指定曲线,此项则为默认值;"
            注释 = " 1=BASS_WASAPI_CURVE_LINEAR 使用线性曲线;"
            注释 = " 2=BASS_WASAPI_CURVE_WINDOWS 使用WINDOWS的Hybrid曲线,跟WINDOWS的音量控制一样;"
            注释 = " 8=BASS_WASAPI_VOL_SESSION 获取会话的音量,其他为设备音量;" @默认值 = 2>
    {
        @ BassWasApi::Fn().BASS_WASAPI_GetVolume(static_cast<DWORD>(@<模式>))
    }

    方法 "//置静音" <公开 类型 = 逻辑型 注释 = "使设备静音或取消静音"
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 模式 <类型 = 整数 注释 = "设置的音量类型;" 注释 = " 0=BASS_WASAPI_CURVE_DB 使用对数曲线,如果未指定曲线,此项则为默认值;"
            注释 = " 1=BASS_WASAPI_CURVE_LINEAR 使用线性曲线;"
            注释 = " 2=BASS_WASAPI_CURVE_WINDOWS 使用WINDOWS的Hybrid曲线,跟WINDOWS的音量控制一样;"
            注释 = " 8=BASS_WASAPI_VOL_SESSION 获取会话的音量,其他为设备音量;" @默认值 = 0>
    参数 是否静音 <类型 = 逻辑型 注释 = "是否将设备静音,真为静音,假为取消静音.">
    {
        @ BassWasApi::Fn().BASS_WASAPI_SetMute(static_cast<DWORD>(@<模式>), @<是否静音>)
    }

    方法 "//取静音" <公开 类型 = 逻辑型 注释 = "获取设备的静音状态" 返回值注释 = "成功返回静音的状态(真为静音)." 折叠 @嵌入式方法 = "">
    参数 模式 <类型 = 整数 注释 = "设置的音量类型." 注释 = " 0=BASS_WASAPI_CURVE_DB 使用对数曲线,如果未指定曲线,此项则为默认值;"
            注释 = " 1=BASS_WASAPI_CURVE_LINEAR 使用线性曲线;"
            注释 = " 2=BASS_WASAPI_CURVE_WINDOWS 使用WINDOWS的Hybrid曲线,跟WINDOWS的音量控制一样;"
            注释 = " 8=BASS_WASAPI_VOL_SESSION 获取会话的音量,其他为设备音量;" @默认值 = 0>
    {
        @ BassWasApi::Fn().BASS_WASAPI_GetMute(static_cast<DWORD>(@<模式>))
    }

    方法 "//置数据" <公开 类型 = 整数 注释 = "将样本数据添加到输出设备缓冲区."
            返回值注释 = "成功返回使用的数据量,否则返回-1.可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 缓冲区 <类型 = 变整数 注释 = "样本数据的指针">
    参数 长度 <类型 = 整数 注释 = "数据的字节大小">
    {
        @ static_cast<INT>(BassWasApi::Fn().BASS_WASAPI_PutData(reinterpret_cast<void*>(@<缓冲区>), static_cast<DWORD>(@<长度>)))
    }

    方法 "//取数据" <公开 类型 = 整数 注释 = "获取即时的样本数据或其FFT信号."
            返回值注释 = "失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息.." 返回值注释 = "请求FFT数据时,返回从通道读取的字节数(用于执行FFT)."
            返回值注释 = "请求样本数据时,将返回写入缓冲区的字节数." 返回值注释 = "使用BASS_DATA_AVAILABLE标志时,将返回通道缓冲区中的字节数." 折叠 @嵌入式方法 = "">
    参数 缓冲区 <类型 = 变整数 注释 = "用来接收数据的缓冲区指针.">
    参数 长度 <类型 = 整数 注释 = "你想要获取的数据字节数,也可以使用\"BASS_通道数据类型\"中常量的组合值.">
    {
        @ static_cast<INT>(BassWasApi::Fn().BASS_WASAPI_GetData(reinterpret_cast<void*>(@<缓冲区>), static_cast<DWORD>(@<长度>)))
    }

    方法 "//置数据2" <公开 类型 = 整数 注释 = "将样本数据添加到输出设备缓冲区." 注释 = "\"置数据\"的二次封装版本,缓冲区改成字节集类,而原始版本更适合在回调事件中使用."
            返回值注释 = "成功返回使用的数据量,否则返回-1.可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @禁止流程检查 = 真>
    参数 缓冲区 <类型 = 字节集类 注释 = "样本数据">
    {
        @ return static_cast<INT>(BassWasApi::Fn().BASS_WASAPI_PutData(reinterpret_cast<void*>(@<缓冲区>.GetPtr()), static_cast<DWORD>(@<缓冲区>.GetSize())));
    }

    方法 "//取数据2" <公开 类型 = 整数 注释 = "获取即时的样本数据或其FFT信号." 注释 = "\"取数据\"的二次封装版本,缓冲区改成字节集类,而原始版本更适合在回调事件中使用."
            返回值注释 = "失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息.." 返回值注释 = "请求FFT数据时,返回从通道读取的字节数(用于执行FFT)."
            返回值注释 = "请求样本数据时,将返回写入缓冲区的字节数." 返回值注释 = "使用BASS_DATA_AVAILABLE标志时,将返回通道缓冲区中的字节数." 折叠 @禁止流程检查 = 真>
    参数 缓冲区 <类型 = 字节集类 注释 = "用来接收数据的缓冲区字节集;" 注释 = "当句柄是录制句柄(HRECORD)时,可以为\"空对象\",以丢弃从录制缓冲区请求的数据." @默认值 = 空对象>
    参数 长度 <类型 = 整数 注释 = "你想要获取的数据字节数,也可以使用\"BASS_通道数据类型\"中常量的组合值." @默认值 = 0>
    {
        变量 缓冲区长度 <类型 = 整数>
        变量 FFT倍数 <类型 = 整数>
        变量 信息 <类型 = BASS_WASAPI_信息>
        取信息 (信息)
        如果 (信息.声道数 > 2)
        {
            FFT倍数 = 2 * 信息.声道数
        }
        否则
        {
            FFT倍数 = 4
        }
        如果 (位与 (长度, 0x80000007) == 0x80000007)  // 判断是否FFT,以及获取样本量
        {
            缓冲区长度 = 32768 * FFT倍数
        }
        否则 (位与 (长度, 0x80000006) == 0x80000006)
        {
            缓冲区长度 = 16384 * FFT倍数
        }
        否则 (位与 (长度, 0x80000005) == 0x80000005)
        {
            缓冲区长度 = 8192 * FFT倍数
        }
        否则 (位与 (长度, 0x80000004) == 0x80000004)
        {
            缓冲区长度 = 4096 * FFT倍数
        }
        否则 (位与 (长度, 0x80000003) == 0x80000003)
        {
            缓冲区长度 = 2048 * FFT倍数
        }
        否则 (位与 (长度, 0x80000002) == 0x80000002)
        {
            缓冲区长度 = 1024 * FFT倍数
        }
        否则 (位与 (长度, 0x80000001) == 0x80000001)
        {
            缓冲区长度 = 512 * FFT倍数
        }
        否则 (位与 (长度, 0x80000000) == 0x80000000)
        {
            缓冲区长度 = 256 * FFT倍数
        }
        否则
        {
            缓冲区长度 = 长度  // 不是FFT,则使用长度参数中的数值
        }
        缓冲区.分配字节集 (缓冲区长度)
        @ return static_cast<INT>(BassWasApi::Fn().BASS_WASAPI_GetData(reinterpret_cast<void*>(@<缓冲区>.GetPtr()), static_cast<DWORD>(@<长度>)));
    }

    方法 "//取电平" <公开 类型 = 整数 注释 = "获取电平(峰值振幅)" 返回值注释 = "失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息."
            返回值注释 = "如果成功,左声道的电平在低位(低16位),右声道在高位(高16位)返回,若通道为单声道,则低位与高位重复."
            返回值注释 = "该级别的线性范围为0(无声)到32768(最大).通道暂停时将返回0." 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(BassWasApi::Fn().BASS_WASAPI_GetLevel())
    }

    方法 "//取电平EX" <公开 类型 = 逻辑型 注释 = "获取电平(峰值振幅)"
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @禁止流程检查 = 真>
    参数 电平数据 <类型 = 单精度小数数组类 注释 = "用于接收电平级别的数组">
    参数 数据长度 <类型 = 单精度小数 注释 = "计算电平的观察数据量,单位为秒,除解码通道外,最大值为1秒.">
    参数 声道 <类型 = 整数 注释 = "0=全部声道, 1=单声道, 2=立体声" @默认值 = 2>
    参数 是否RMS级别 <类型 = 逻辑型 注释 = "假为获取电平级别,真为获取RMS(均方根值)级别." @默认值 = 假>
    参数 应用属性 <类型 = 逻辑型 注释 = "为真时将当前的BASS_ATTRIB_VOL和BASS_ATTRIB_PAN值应用于电平级别中." @默认值 = 假>
    {
        @ BOOL ret;
        @ DWORD flags = @<声道>;
        @ if (@<是否RMS级别>) flags |= BASS_LEVEL_RMS;
        @ if (@<应用属性>) flags |= BASS_LEVEL_VOLPAN;
        @ if (@<声道> == 1) {
        @     @<电平数据>.data().InitCount(1, TRUE);
        @     ret = BassWasApi::Fn().BASS_WASAPI_GetLevelEx(@<电平数据>.data().GetData(), @<数据长度>, flags);
        @ } else if (@<声道> == 2) {
        @     @<电平数据>.data().InitCount(2, TRUE);
        @     ret = BassWasApi::Fn().BASS_WASAPI_GetLevelEx(@<电平数据>.data().GetData(), @<数据长度>, flags);
        @ } else {
        @     BASS_WASAPI_INFO ci;
        @     BassWasApi::Fn().BASS_WASAPI_GetInfo(&ci);
        @     @<电平数据>.data().InitCount(ci.chans, TRUE);
        @     ret = BassWasApi::Fn().BASS_WASAPI_GetLevelEx(@<电平数据>.data().GetData(), @<数据长度>, flags);
        @ }
        @ return ret;
    }
}

类 BASS混合器类 <公开 注释 = "BASSmix 2.4.11.2" 注释 = "提供合并或分离BASS通道、重采样和矩阵混音功能."
        注释 = "注: 本类新增了几个配置选项,需要使用BASS音频类的\"置配置选项\"进行设置." 注释 = "本类新增了两个属性,需要使用BASS音频类的\"置通道属性\"使用." 折叠
        "//@视窗.外部头文件" = "BASS\\include\\bassmix.h" "//@视窗.外部库" = "BASS\\$(p)\\bassmix.lib"
        @视窗.附属文件 = "BASS\\$(p)\\bassmix.dll" @文档 = "category = \"BASS混合器\"">
{
    方法 加载动态库 <公开 静态 类型 = 逻辑型 注释 = "程序默认在执行本类的函数时加载与程序文件同位置的DLL文件."
            注释 = "如果你想将DLL放在其他位置,请在执行其他方法前调用本方法手动加载." 注释 = "注意: 请尽量在启动方法中加载,且不应将本对象的实例定义在启动类内." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 动态库路径 <类型 = 文本型 注释 = "bassBassMix::Fn().dll的路径">
    {
        @ BassMix::data().Load(@<动态库路径>)
    }

    方法 卸载动态库 <公开 静态 注释 = "手动卸载动态库,一般不需要执行本方法." 折叠 @嵌入式方法 = "">
    {
        @ BassMix::data().Free()
    }

    方法 取版本 <公开 类型 = 整数 注释 = "获取已加载的BASSmix的版本号" 返回值注释 = "返回BASSmix版本,其中高16位为主版本号,低16位为修订版本号;"
            返回值注释 = "例: 0x02040103(十六进制) = 2.4.1.3" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(BassMix::Fn().BASS_Mixer_GetVersion())
    }

    # 混合器流

    方法 创建混合流 <公开 类型 = 整数 注释 = "创建一条混合器流." 注释 = "此源通道可以随时插入或移除其他流,因此没有预定长度,不能\"取通道长度\",除了位置0之外,不能移动到其他位置."
            返回值注释 = "成功返回流句柄,失败返回0,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 采样率 <类型 = 整数 注释 = "混合器输出的采样率" "">
    参数 声道 <类型 = 整数 注释 = "声道数量: 1=单声道, 2=立体声, 4=四声道, 6=5.1, 8=7.1">
    参数 标志 <类型 = 整数 注释 = "使用\"BASS_音频标志\"类和\"BASS_混合器标志\"类中的以下部分常量的组合值:"
            注释 = " BASS_音频标志: BASS_SAMPLE_8BITS、BASS_SAMPLE_FLOAT、BASS_SAMPLE_SOFTWARE、BASS_SAMPLE_3D"
            注释 = " BASS_SAMPLE_FX、BASS_STREAM_AUTOFREE、BASS_STREAM_DECODE、BASS_SPEAKER_xxx"
            注释 = " BASS_混合器标志: BASS_MIXER_END、BASS_MIXER_NONSTOP、BASS_MIXER_POSEX、BASS_MIXER_RESUME" @默认值 = 0>
    {
        @ static_cast<INT>(BassMix::Fn().BASS_Mixer_StreamCreate(static_cast<DWORD>(@<采样率>), static_cast<DWORD>(@<声道>), static_cast<DWORD>(@<标志>)))
    }

    方法 加入通道 <公开 类型 = 逻辑型 注释 = "将一条通道插入到混合器" 返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息."
            折叠 @嵌入式方法 = "">
    参数 混合器句柄 <类型 = 整数 注释 = "混合器的句柄" "">
    参数 通道句柄 <类型 = 整数 注释 = "想插入到混合器的通道,可以是HMUSIC、HSTREAM或HRECORD句柄.">
    参数 标志 <类型 = 整数 注释 = "使用\"BASS_音频标志\"类和\"BASS_混合器标志\"类中的以下部分常量的组合值:"
            注释 = " BASS_音频标志: BASS_STREAM_AUTOFREE、BASS_SPEAKER_xxx"
            注释 = " BASS_混合器标志: BASS_MIXER_CHAN_BUFFER、BASS_MIXER_CHAN_DOWNMIX、BASS_MIXER_CHAN_LIMIT、"
            注释 = " BASS_MIXER_CHAN_MATRIX、BASS_MIXER_CHAN_NORAMPIN、BASS_MIXER_CHAN_PAUSE" @默认值 = 0>
    {
        @ BassMix::Fn().BASS_Mixer_StreamAddChannel(static_cast<HSTREAM>(@<混合器句柄>), static_cast<DWORD>(@<通道句柄>), static_cast<DWORD>(@<标志>))
    }

    方法 加入通道EX <公开 类型 = 逻辑型 注释 = "将一条通道插入到混合器,可以选择延迟开始和限制长度."
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 混合器句柄 <类型 = 整数 注释 = "混合器的句柄" "">
    参数 通道句柄 <类型 = 整数 注释 = "想插入到混合器的通道,可以是HMUSIC、HSTREAM或HRECORD句柄.">
    参数 标志 <类型 = 整数 注释 = "使用\"BASS_音频标志\"类和\"BASS_混合器标志\"类中的以下部分常量的组合值:"
            注释 = " BASS_音频标志: BASS_STREAM_AUTOFREE、BASS_SPEAKER_xxx"
            注释 = " BASS_混合器标志: BASS_MIXER_CHAN_ABSOLUTE、BASS_MIXER_CHAN_BUFFER、BASS_MIXER_CHAN_DOWNMIX"
            注释 = " BASS_MIXER_CHAN_LIMIT、BASS_MIXER_CHAN_MATRIX、BASS_MIXER_CHAN_NORAMPIN、BASS_MIXER_CHAN_PAUSE"
            @默认值 = 0>
    参数 延迟开始 <类型 = 长整数 注释 = "进入混合器之前的延迟(单位为字节)" @默认值 = 0>
    参数 长度 <类型 = 长整数 注释 = "混合的最大数据量(单位为字节),0=无限制;" 注释 = "一旦到达该值,通道将从混合器中移除." @默认值 = 0>
    {
        @ BassMix::Fn().BASS_Mixer_StreamAddChannelEx(static_cast<HSTREAM>(@<混合器句柄>), static_cast<DWORD>(@<通道句柄>),
        @     static_cast<DWORD>(@<标志>), static_cast<QWORD>(@<延迟开始>), static_cast<QWORD>(@<长度>))
    }

    方法 取混合器源通道 <公开 类型 = 整数 注释 = "获取混合器的源通道"
            返回值注释 = "成功返回通道数组中的源通道数量,失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @禁止流程检查 = 真>
    参数 混合器句柄 <类型 = 整数 注释 = "混合器的句柄" "">
    参数 通道数组 <类型 = 整数数组类 注释 = "接收混合器源通道句柄的数组">
    {
        @ INT count = static_cast<INT>(BassMix::Fn().BASS_Mixer_StreamGetChannels(static_cast<HSTREAM>(@<混合器句柄>), NULL, 0));
        @ @<通道数组>.data().InitCount(count, TRUE);
        @ BassMix::Fn().BASS_Mixer_StreamGetChannels(static_cast<HSTREAM>(@<混合器句柄>), reinterpret_cast<DWORD*>(@<通道数组>.data().GetData()), static_cast<DWORD>(count));
        @ return count;
    }

    方法 取混合器 <公开 类型 = 整数 注释 = "获取通道所插入的混合器"
            返回值注释 = "成功返回混合器流的句柄,失败返回0,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "通道的句柄">
    {
        @ static_cast<INT>(BassMix::Fn().BASS_Mixer_ChannelGetMixer(static_cast<DWORD>(@<通道句柄>)))
    }

    方法 取混合器通道状态 <公开 类型 = 整数 注释 = "获取混合器源通道的状态,返回值请参考\"BASS_通道状态\"中的常量." 折叠 @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "通道的句柄">
    {
        @ static_cast<INT>(BassMix::Fn().BASS_Mixer_ChannelIsActive(static_cast<DWORD>(@<通道句柄>)))
    }

    方法 置取通道标志 <公开 类型 = 整数 注释 = "修改和获取通道的标志" 返回值注释 = "成功返回通道的新标志,失败返回-1,可以用\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠
            @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "通道句柄,可以是HCHANNEL、HMUSIC或HSTREAM句柄.">
    参数 标志 <类型 = 整数 注释 = "使用\"BASS_音频标志\"类和\"BASS_混合器标志\"类中的以下部分常量的组合值:"
            注释 = " BASS_音频标志: BASS_STREAM_AUTOFREE、BASS_SPEAKER_xxx"
            注释 = " BASS_混合器标志: BASS_MIXER_CHAN_BUFFER、BASS_MIXER_CHAN_LIMIT、BASS_MIXER_CHAN_NORAMPIN"
            注释 = " BASS_MIXER_CHAN_PAUSE">
    参数 掩码 <类型 = 整数 注释 = "要修改的标志(如上一参数所述),未包含在此参数的标志会保持原样;" 注释 = "如果将本参数设置为0,则可以用来获取通道的当前标志;"
            注释 = "如果要添加标志,则需要在\"标志\"和\"掩码\"参数里都有一样的标志;" 注释 = "如果要移除标志,则在此参数填写要移除的标志,且确保这个标志不在\"标志参数\"中;"
            注释 = "要修改扬声器标志,可以在本参数中使用任意的\"BASS_SPEAKER_xxx\"标志(无需包括其所有标志).">
    {
        @ static_cast<INT>(BassMix::Fn().BASS_Mixer_ChannelFlags(static_cast<DWORD>(@<通道句柄>), static_cast<DWORD>(@<标志>), static_cast<DWORD>(@<掩码>)))
    }

    方法 删除通道 <公开 类型 = 逻辑型 注释 = "从混合器中移除一条通道" 返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息."
            折叠 @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "要从混合器中移除的通道">
    {
        @ BassMix::Fn().BASS_Mixer_ChannelRemove(static_cast<DWORD>(@<通道句柄>))
    }

    # 混合器源通道(部分方法跟BASS音频类的一样)

    方法 置播放位置 <公开 类型 = 逻辑型 注释 = "设置混合器源通道的播放位置."
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "源通道的句柄">
    参数 播放位置 <类型 = 长整数 注释 = "播放位置,单位由参数\"长度模式\"确定.">
    参数 位置模式 <类型 = 整数 注释 = "位置模式,默认为字节长度,可使用\"BASS_位置类型\"中的选项之一;"
            注释 = "可选位或\"BASS_位置类型\"的所有标志,再额外加上\"BASS_音频标志\"的BASS_MUSIC_POSRESET、BASS_MUSIC_POSRESETEX标志,"
            注释 = "以及混合器的以下两个标志:" 注释 = " BASS_MIXER_CHAN_NORAMPIN (0x800000) 开始播放时不淡入"
            注释 = " BASS_POS_MIXER_RESET (0x10000) 清空播放缓冲区" @默认值 = BASS_位置类型.BASS_POS_BYTE>
    {
        @ BassMix::Fn().BASS_Mixer_ChannelSetPosition(static_cast<DWORD>(@<通道句柄>), static_cast<QWORD>(@<播放位置>), static_cast<DWORD>(@<位置模式>))
    }

    方法 取播放位置 <公开 类型 = 长整数 注释 = "获取混合器源通道的播放位置"
            返回值注释 = "成功返回播放位置,失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "源通道的句柄">
    参数 位置模式 <类型 = 整数 注释 = "仅支持以下两种模式:" 注释 = " 0 = BASS_POS_BYTE,获取字节长度"
            注释 = " 1 = BASS_POS_MUSIC_ORDER,获取顺序长度(仅限MOD音乐)" 注释 = " 可选位或标志 BASS_POS_DECODE"
            @默认值 = BASS_位置类型.BASS_POS_BYTE>
    {
        @ static_cast<INT64>(BassMix::Fn().BASS_Mixer_ChannelGetPosition(static_cast<DWORD>(@<通道句柄>), static_cast<DWORD>(@<位置模式>)))
    }

    方法 取播放位置EX <公开 类型 = 长整数 注释 = "获取混合器源通道的播放位置,可选加上延迟的影响."
            返回值注释 = "成功返回播放位置,失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "源通道的句柄">
    参数 位置模式 <类型 = 整数 注释 = "仅支持以下两种模式" 注释 = " 0 = BASS_POS_BYTE,获取字节长度"
            注释 = " 1 = BASS_POS_MUSIC_ORDER,获取顺序长度(仅限MOD音乐)" 注释 = " 可选位或标志 BASS_POS_DECODE"
            @默认值 = BASS_位置类型.BASS_POS_BYTE>
    参数 延迟 <类型 = 整数 注释 = "从混合器输出到取得源通道位置的距离(单位为字节)" @默认值 = 0>
    {
        @ static_cast<INT64>(BassMix::Fn().BASS_Mixer_ChannelGetPositionEx(static_cast<DWORD>(@<通道句柄>), static_cast<DWORD>(@<位置模式>), static_cast<DWORD>(@<延迟>)))
    }

    方法 取通道电平 <公开 类型 = 整数 注释 = "获取混合器源通道的电平级别(峰值振幅)."
            返回值注释 = "失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息."
            返回值注释 = "如果成功,左声道的电平在低位(低16位),右声道在高位(高16位)返回,若通道为单声道,则低位与高位重复."
            返回值注释 = "该级别的线性范围为0(无声)到32768(最大).通道暂停时将返回0." 折叠 @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "源通道的句柄">
    {
        @ static_cast<INT>(BassMix::Fn().BASS_Mixer_ChannelGetLevel(static_cast<DWORD>(@<通道句柄>)))
    }

    方法 取立体声电平 <公开 类型 = 逻辑型 注释 = "获取混合器源通道的通道级别(峰值振幅),本方法用于返回立体声的左右声道电平." 返回值注释 = "返回是否成功" 折叠 "">
    参数 通道句柄 <类型 = 整数 注释 = "源通道的句柄">
    参数 左声道 <类型 = 整数类 注释 = "返回左声道的电平" @默认值 = 空对象>
    参数 右声道 <类型 = 整数类 注释 = "返回右声道的电平" @默认值 = 空对象>
    {
        变量 电平 <类型 = 整数>
        电平 = 取通道电平 (通道句柄)
        如果 (电平 <= 0)
        {
            返回 (假)
        }
        左声道.值 = 位与 (电平, 0xFFFF)
        右声道.值 = 位右移 (电平, 16)
        返回 (真)
    }

    方法 取通道电平EX <公开 类型 = 逻辑型 注释 = "获取混合器源通道的电平级别(峰值振幅)."
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @禁止流程检查 = 真>
    参数 通道句柄 <类型 = 整数 注释 = "通道句柄,可以是HCHANNEL、HMUSIC、HSTREAM或HRECORD句柄.">
    参数 电平数据 <类型 = 单精度小数数组类 注释 = "用于接收电平级别的数组">
    参数 数据长度 <类型 = 单精度小数 注释 = "计算电平的观察数据量,单位为秒,除解码通道外,最大值为1秒.">
    参数 声道 <类型 = 整数 注释 = "0=全部声道, 1=单声道, 2=立体声" @默认值 = 2>
    参数 是否RMS级别 <类型 = 逻辑型 注释 = "假为获取电平级别,真为获取RMS(均方根值)级别." @默认值 = 假>
    参数 应用属性 <类型 = 逻辑型 注释 = "为真时将当前的BASS_ATTRIB_VOL和BASS_ATTRIB_PAN值应用于电平级别中." @默认值 = 假>
    {
        @ DWORD flags = @<声道>;
        @ if (@<是否RMS级别>) flags |= BASS_LEVEL_RMS;
        @ if (@<应用属性>) flags |= BASS_LEVEL_VOLPAN;
        @ if (@<声道> == 1) {
        @     @<电平数据>.data().InitCount(1, TRUE);
        @ } else if (@<声道> == 2) {
        @     @<电平数据>.data().InitCount(2, TRUE);
        @ } else {
        @     BASS_CHANNELINFO ci;
        @     BassMix::Fn().BASS_ChannelGetInfo(@<通道句柄>, &ci);
        @     @<电平数据>.data().InitCount(ci.chans, TRUE);
        @ }
        @ return BassMix::Fn().BASS_Mixer_ChannelGetLevelEx(static_cast<DWORD>(@<通道句柄>), @<电平数据>.data().GetData(), @<数据长度>, flags);
    }

    方法 取通道数据 <公开 类型 = 整数 注释 = "获取混合器源通道的即时样本数据(或其FFT信号)"
            返回值注释 = "失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 返回值注释 = "请求FFT数据时,返回从通道读取的字节数(用于执行FFT)."
            返回值注释 = "请求样本数据时,将返回写入缓冲区的字节数(不一定与使用BASS_DATA_FLOAT或BBASS_DATA_FIXED标志时读取的字节数相同)."
            返回值注释 = "使用BASS_DATA_AVAILABLE标志时,将返回通道缓冲区中的字节数." 折叠 @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "源通道的句柄">
    参数 缓冲区 <类型 = 变整数 注释 = "用来接收数据的缓冲区指针;" 注释 = "当句柄是录制句柄(HRECORD)时,可以为0,以丢弃从录制缓冲区请求的数据." "">
    参数 长度 <类型 = 整数 注释 = "填写要获取的数据字节数(最多268435455或0xFFFFFFF),也可以使用\"BASS_通道数据类型\"中常量的组合值." "">
    {
        @ static_cast<INT>(BassMix::Fn().BASS_Mixer_ChannelGetData(static_cast<DWORD>(@<通道句柄>), reinterpret_cast<void*>(@<缓冲区>), static_cast<DWORD>(@<长度>)))
    }

    方法 同步回调 <公开 定义事件 类型 = 整数 注释 = "执行\"置通道同步器\",可以在本事件中处理同步回调." 返回值注释 = "返回值无意义" 折叠>
    参数 同步句柄 <类型 = 整数 注释 = "同步器的句柄">
    参数 通道句柄 <类型 = 整数 注释 = "进行同步的通道">
    参数 数据 <类型 = 整数 注释 = "与同步类型关联的其他数据">

    方法 置通道同步器 <公开 类型 = 整数 注释 = "在混合器源通道上设置同步器,可以在接收事件\"同步回调\"中处理同步操作."
            返回值注释 = "成功返回同步句柄,失败返回0,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "源通道的句柄">
    参数 同步类型 <类型 = 整数 注释 = "同步的类型,为\"BASS_同步类型\"中常量的组合值.">
    参数 同步参数 <类型 = 长整数 注释 = "设置同步参数. 参数值取决于同步类型,详细请看\"BASS_同步类型\"的常量备注.">
    {
        @ static_cast<INT>(BassMix::Fn().BASS_Mixer_ChannelSetSync(static_cast<DWORD>(@<通道句柄>), static_cast<DWORD>(@<同步类型>),
        @    static_cast<QWORD>(@<同步参数>), &@sn<current_class_def>::MixSync, &@sn<this>))
    }

    方法 移除通道同步器 <公开 类型 = 逻辑型 注释 = "从混合器源通道上移除同步器"
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "源通道的句柄">
    参数 同步句柄 <类型 = 整数 注释 = "欲移除的同步句柄">
    {
        @ BassMix::Fn().BASS_Mixer_ChannelRemoveSync(static_cast<DWORD>(@<通道句柄>), static_cast<HSYNC>(@<同步句柄>))
    }

    方法 置通道矩阵 <公开 类型 = 逻辑型 注释 = "设置通道的混合矩阵" 返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息."
            折叠 @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "通道的句柄">
    参数 矩阵 <类型 = "单精度小数 [][]" 注释 = "矩阵,为二维单精度小数数组.">
    {
        @ BassMix::Fn().BASS_Mixer_ChannelSetMatrix(static_cast<DWORD>(@<通道句柄>), @<矩阵>)
    }

    方法 置通道矩阵EX <公开 类型 = 逻辑型 注释 = "设置通道的混合矩阵,从当前矩阵转换."
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "通道的句柄">
    参数 矩阵 <类型 = "单精度小数 [][]" 注释 = "矩阵,为二维单精度小数数组.">
    参数 时间 <类型 = 单精度小数 注释 = "从当前矩阵转换到指定矩阵所需的时间(秒)">
    {
        @ BassMix::Fn().BASS_Mixer_ChannelSetMatrixEx(static_cast<DWORD>(@<通道句柄>), @<矩阵>, @<时间>)
    }

    方法 取通道矩阵 <公开 类型 = 逻辑型 注释 = "获取存在的通道的混合矩阵"
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "通道的句柄">
    参数 矩阵 <类型 = "单精度小数 [][]" 注释 = "返回的矩阵,为二维单精度小数数组.">
    {
        @ BassMix::Fn().BASS_Mixer_ChannelGetMatrix(static_cast<DWORD>(@<通道句柄>), @<矩阵>)
    }

    方法 置通道包络线 <公开 类型 = 逻辑型 注释 = "设置包络线以在一个周期时间内修改通道的采样率、音量或声像."
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "通道的句柄">
    参数 类型 <类型 = 整数 注释 = "要使用包络线修改的属性(请直接填左边的数值),为下列选项之一:" 注释 = " 1 BASS_MIXER_ENV_FREQ  采样率"
            注释 = " 2 BASS_MIXER_ENV_VOL   音量" 注释 = " 3 BASS_MIXER_ENV_PAN   声像" 注释 = " 可选标志(请与选项位或):"
            注释 = " 0x10000 BASS_MIXER_ENV_LOOP   循环包络线" 注释 = " 0x20000 BASS_MIXER_ENV_REMOVE 到达包络线的结尾时从混合器移除源通道">
    参数 节点数组 <类型 = BASS_MIXER_节点数组 注释 = "包络线节点的数组,应具有序列位置.">
    {
        @ BassMix::Fn().BASS_Mixer_ChannelSetEnvelope(static_cast<DWORD>(@<通道句柄>), static_cast<DWORD>(@<类型>),
        @     reinterpret_cast<BASS_MIXER_NODE*>(@<节点数组>.data()), static_cast<DWORD>(@<节点数组>.size()))
    }

    方法 置通道包络线位置 <公开 类型 = 逻辑型 注释 = "设置通道包络线的当前位置"
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "通道的句柄">
    参数 类型 <类型 = 整数 注释 = "要设置位置的包络线属性(请直接填左边的数值),为下列选项之一:" 注释 = " 1 BASS_MIXER_ENV_FREQ  采样率"
            注释 = " 2 BASS_MIXER_ENV_VOL   音量" 注释 = " 3 BASS_MIXER_ENV_PAN   声像">
    参数 位置 <类型 = 长整数 注释 = "新包络线位置,单位为字节;" 注释 = "如果超出包络线末端,则包络线将被封顶或循环,具体取决于包络线是否启用了循环.">
    {
        @ BassMix::Fn().BASS_Mixer_ChannelSetEnvelopePos(static_cast<DWORD>(@<通道句柄>), static_cast<DWORD>(@<类型>), static_cast<DWORD>(@<位置>))
    }

    方法 取通道包络线位置 <公开 类型 = 长整数 注释 = "获取通道包络线的当前位置和值"
            返回值注释 = "成功返回包络线的位置,失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "通道的句柄">
    参数 类型 <类型 = 整数 注释 = "要设置位置的包络线属性(请直接填左边的数值),为下列选项之一:" 注释 = " 1 BASS_MIXER_ENV_FREQ  采样率"
            注释 = " 2 BASS_MIXER_ENV_VOL   音量" 注释 = " 3 BASS_MIXER_ENV_PAN   声像">
    参数 值 <类型 = 单精度小数类 注释 = "返回包络线当前位置的值" @默认值 = 空对象>
    {
        @ static_cast<INT64>(BassMix::Fn().BASS_Mixer_ChannelGetEnvelopePos(static_cast<DWORD>(@<通道句柄>), static_cast<DWORD>(@<类型>), &@<值.值>))
    }

    # 分割流

    方法 创建分离流 <公开 类型 = 整数 注释 = "创建一条分离流." 注释 = "此源通道可以随时插入或移除其他流,因此没有预定长度,不能\"取通道长度\",除了位置0之外,不能移动到其他位置."
            返回值注释 = "成功返回流句柄,失败返回0,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 通道句柄 <类型 = 整数 注释 = "要分离的通道句柄,可以是HMUSIC、HSTREAM或HRECORD句柄." "">
    参数 标志 <类型 = 整数 注释 = "使用\"BASS_音频标志\"类中的以下部分常量和\"BASS_分离标志\"类的所有标志的组合值;"
            注释 = " BASS_音频标志: BASS_SAMPLE_SOFTWARE、BASS_SAMPLE_3D、BASS_SAMPLE_FX、BASS_STREAM_AUTOFREE"
            注释 = " BASS_STREAM_DECODE、BASS_SPEAKER_xxx" @默认值 = 0>
    参数 通道映射 <类型 = 整数数组类 注释 = "通道映射,指向通道索引数组(0=第一个,-1=数组末尾)的指针,空对象=一比一映射整个源" @默认值 = 空对象>
    {
        @ return static_cast<INT>(BassMix::Fn().BASS_Split_StreamCreate(static_cast<DWORD>(@<通道句柄>), static_cast<DWORD>(@<标志>),
        @    static_cast<DWORD>(@<标志>), @<通道映射>.data().IsEmpty() ? NULL : @<通道映射>.data().GetData()));
    }

    方法 取分离流源通道 <公开 类型 = 整数 注释 = "获取分离流的源通道"
            返回值注释 = "成功返回源通道的句柄,失败返回0,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 分离流句柄 <类型 = 整数 注释 = "分离流的句柄" "">
    {
        @ static_cast<INT>(BassMix::Fn().BASS_Split_StreamGetSource(static_cast<HSTREAM>(@<分离流句柄>)))
    }

    方法 取分离流 <公开 类型 = 整数 注释 = "获取通道所有的分离流"
            返回值注释 = "成功返回分离流数组的成员数,失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @禁止流程检查 = 真>
    参数 通道句柄 <类型 = 整数 注释 = "通道句柄,可以是HMUSIC、HSTREAM或HRECORD句柄." "">
    参数 分离流数组 <类型 = 整数数组类 注释 = "返回分离流的句柄数组" @默认值 = 空对象>
    {
        @ INT count = static_cast<INT>(BassMix::Fn().BASS_Split_StreamGetSplits(static_cast<HSTREAM>(@<通道句柄>), NULL, 0));
        @ @<分离流数组>.data().InitCount(count, TRUE);
        @ BassMix::Fn().BASS_Split_StreamGetSplits(static_cast<DWORD>(@<通道句柄>), reinterpret_cast<HSTREAM *>(@<分离流数组>.data().GetData()), static_cast<DWORD>(count));
        @ return count;
    }

    方法 重置分离流 <公开 类型 = 逻辑型 注释 = "重置源通道的一个分离流或所有分离流"
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 流句柄 <类型 = 整数 注释 = "分离流或源通道的句柄" "">
    {
        @ BassMix::Fn().BASS_Split_StreamReset(static_cast<DWORD>(@<流句柄>))
    }

    方法 重置分离流EX <公开 类型 = 逻辑型 注释 = "重置分离流,并设置它在源缓冲区的位置."
            返回值注释 = "返回是否成功. 如果失败,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 分离流句柄 <类型 = 整数 注释 = "分离流的句柄" "">
    参数 偏移 <类型 = 整数 注释 = "在源缓冲区中放置分离器的距离(单位为字节).">
    {
        @ BassMix::Fn().BASS_Split_StreamResetEx(static_cast<DWORD>(@<分离流句柄>), static_cast<DWORD>(@<偏移>))
    }

    方法 取分离流可用缓冲区 <公开 类型 = 整数 注释 = "获取分流器可用的缓冲大小,或分流器源缓冲区中的数据量."
            返回值注释 = "返回数据量(单位为字节),失败返回-1,可以用BASS音频库的\"取错误代码\"或\"取错误描述\"获取具体的错误信息." 折叠 @嵌入式方法 = "">
    参数 流句柄 <类型 = 整数 注释 = "分离流或源通道的句柄" "">
    {
        @ static_cast<INT>(BassMix::Fn().BASS_Split_StreamGetAvailable(static_cast<DWORD>(@<流句柄>)))
    }

    # @begin
    # <> <include>
    # static void CALLBACK MixSync(HSYNC handle, DWORD channel, DWORD data, void *user) {
    #     reinterpret_cast<@sn<current_class>*>(user)->@<同步回调>(static_cast<INT>(handle), static_cast<INT>(channel), static_cast<INT>(data));
    # }
    # <> </include>
    # @end
}

类 音频标签类 <公开 注释 = "TAGS Version 19" 注释 = "发布日期: 2023-09-15"
        注释 = "BASS音频库对读取流标签的支持有限.本库扩展了该功能,允许开发人员/用户从BASS的流句柄中提取指定的歌曲信息，"
        注释 = "并根据的格式文本(包括条件处理),将提取的标签值输出为格式化为文本. 本类非线程安全." 注释 = "支持的标签格式:" 注释 = "  MP3 ID3v1 and ID3v2.2/3/4"
        注释 = "  OGG/FLAC comments" 注释 = "  WMA" 注释 = "  APE, OFR, MPC, AAC - all use APE tags" 注释 = "  MP4"
        注释 = "  WAV/etc RIFF INFO" 注释 = "  MOD/etc titles" 折叠 "//@视窗.外部头文件" = "BASS\\include\\tags.h"
        "//@视窗.外部库" = "BASS\\$(p)\\tags.lib" @视窗.附属文件 = "BASS\\$(p)\\tags.dll" @文档 = "category = \"BASS扩展\""
        @强制依赖 = "BASS音频类">
{
    方法 加载动态库 <公开 静态 类型 = 逻辑型 注释 = "程序默认在执行本类的函数时加载与程序文件同位置的DLL文件."
            注释 = "如果你想将DLL放在其他位置,请在执行其他方法前调用本方法手动加载." 注释 = "注意: 请尽量在启动方法中加载." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 动态库路径 <类型 = 文本型 注释 = "tags.dll的路径">
    {
        @ BassTags::data().Load(@<动态库路径>)
    }

    方法 卸载动态库 <公开 静态 注释 = "手动卸载动态库,一般不需要执行本方法." 折叠 @嵌入式方法 = "">
    {
        @ BassTags::data().Free()
    }

    # ---

    方法 取版本 <公开 静态 类型 = 整数 注释 = "获取TAGS的版本值" 返回值注释 = "返回值的高8位是当前版本,低8位是编译版本" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(BassTags::Fn().TAGS_GetVersion())
    }

    方法 取标签 <公开 静态 类型 = 文本型 注释 = "获取BASS通道句柄中的标签值" 返回值注释 = "成功返回格式化的标签文本."
            返回值注释 = "无法正确读取标签或遇到不支持的标签时,返回空文本." 折叠 编辑时信息 = "55F10, 0, 0, 0"
            @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 通道句柄 <类型 = 整数 注释 = "BASS的通道句柄" 编辑时信息 = "55F10, 0, 0, 0">
    参数 格式文本 <类型 = 文本型 注释 = "格式文本(支持条件判断):" 注释 = " - 纯文本,如\"一些歌曲\". 此类文本仅复制到输出."
            注释 = " - 特殊标识符,以\"%\"开头以替换标签值:" 注释 = "   \"%TITL\" - 标题;" 注释 = "   \"%ARTI\" - 艺术家;"
            注释 = "   \"%ALBM\" - 专辑;" 注释 = "   \"%GNRE\" - 流派;" 注释 = "   \"%YEAR\" - 日期;"
            注释 = "   \"%CMNT\" - 注释;" 注释 = "   \"%TRCK\" - 音轨号(可能包含合计音轨,如\"track/total\");"
            注释 = "   \"%COMP\" - 作曲家;" 注释 = "   \"%COPY\" - 版权;" 注释 = "   \"%SUBT\" - 副标题;"
            注释 = "   \"%AART\" - 专辑歌手;" 注释 = "   \"%DISC\" - 碟片编号(可能包含合计碟片,\"disc/total\");"
            注释 = "   \"%PUBL\" - 出版商;" 注释 = "" 注释 = " - 表达式:" 注释 = "   \"%IFV1(x,a)\" - 如果x不为空,则等于a,否则为空文本;"
            注释 = "   \"%IFV2(x,a,b)\" - 如果x不为空,则等于a,否则为b;"
            注释 = "   \"%IUPC(x)\" - 使x大写,例如\"%IUPC(foO)\"为\"FOO\";"
            注释 = "   \"%ILWC(x)\" - 使x小写,例如\"%ILWC(fOO)\"为\"foo\";"
            注释 = "   \"%ICAP(x)\" - 将x每个单词的首字母大写,例如\"%ICAP(FoO bAR)\"为\"Foo Bar\";"
            注释 = "   \"%ITRM(x)\" - 删除x的首尾空格;" 注释 = "" 注释 = " - 转义符号:" 注释 = "   \"%%\" - \"%\""
            注释 = "   \"%(\" - \"(\"" 注释 = "   \"%,\" - \",\"" 注释 = "   \"%)\" - \")\"" 编辑时信息 = "55F10, 0, 0, 0"
            @默认值 = "%IFV1(%TRCK,%TRCK. )%IFV2(%ARTI,%ARTI,无艺术家) - %IFV2(%TITL,%TITL -,无标题 -) %IFV1(%ALBM,%ALBM)">
    {
        @ @an<CVolString>{BassTags::Fn().TAGS_Read(@<通道句柄>, @<格式文本>)}
    }

    方法 取标签信息 <公开 静态 类型 = 逻辑型 注释 = "获取BASS通道句柄中的标签值,为\"取标签\"的二次封装" 返回值注释 = "返回是否成功" 折叠 @禁止流程检查 = 真>
    参数 通道句柄 <类型 = 整数 注释 = "BASS的通道句柄">
    参数 标签信息 <类型 = 音频标签信息类 注释 = "返回标签信息" @默认值 = 空对象>
    {
        变量 标签 <类型 = 文本型>
        变量 格式文本 <类型 = 文本型
                值 = "%IFV1(%TITL,%TITL)丨罓%IFV1(%ARTI,%ARTI)丨罓%IFV1(%ALBM,%ALBM)丨罓%IFV1(%GNRE,%GNRE)丨罓%IFV1(%YEAR,%YEAR)丨罓%IFV1(%CMNT,%CMNT)丨罓%IFV1(%TRCK,%TRCK)丨罓%IFV1(%COMP,%COMP)丨罓%IFV1(%COPY,%COPY)丨罓%IFV1(%SUBT,%SUBT)丨罓%IFV1(%AART,%AART)丨罓%IFV1(%DISC,%DISC)丨罓%IFV1(%PUBL,%PUBL)">
        标签 = 取标签 (通道句柄, 格式文本)
        如果 (文本是否为空 (标签) == 真)
        {
            返回 (假)
        }
        变量 标签数组 <类型 = 文本数组类>
        如果 (分割子文本 (标签, "丨罓", 标签数组, 假, 假) != 13)
        {
            返回 (假)
        }
        标签信息.标题 = 标签数组.取成员 (0)
        标签信息.艺术家 = 标签数组.取成员 (1)
        标签信息.专辑 = 标签数组.取成员 (2)
        标签信息.流派 = 标签数组.取成员 (3)
        标签信息.日期 = 标签数组.取成员 (4)
        标签信息.注释 = 标签数组.取成员 (5)
        标签信息.音轨号 = 标签数组.取成员 (6)
        标签信息.作曲家 = 标签数组.取成员 (7)
        标签信息.版权 = 标签数组.取成员 (8)
        标签信息.副标题 = 标签数组.取成员 (9)
        标签信息.专辑歌手 = 标签数组.取成员 (10)
        标签信息.碟片编号 = 标签数组.取成员 (11)
        标签信息.出版商 = 标签数组.取成员 (12)
        返回 (真)
    }

    方法 取标签EX <公开 静态 类型 = 文本型 注释 = "获取BASS通道句柄中的标签值" 返回值注释 = "成功返回格式化的标签文本."
            返回值注释 = "无法正确读取标签或遇到不支持的标签时,返回空文本." 折叠 编辑时信息 = "53A7E, 0, 0, 0"
            @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 通道句柄 <类型 = 整数 注释 = "BASS的通道句柄" 编辑时信息 = "53A7E, 0, 0, 0">
    参数 格式文本 <类型 = 文本型 注释 = "格式文本(支持条件判断):" 注释 = " - 纯文本,如\"一些歌曲\". 此类文本仅复制到输出."
            注释 = " - 特殊标识符,以\"%\"开头以替换标签值:" 注释 = "   \"%TITL\" - 标题;" 注释 = "   \"%ARTI\" - 艺术家;"
            注释 = "   \"%ALBM\" - 专辑;" 注释 = "   \"%GNRE\" - 流派;" 注释 = "   \"%YEAR\" - 日期;"
            注释 = "   \"%CMNT\" - 注释;" 注释 = "   \"%TRCK\" - 音轨号(可能包含合计音轨,如\"track/total\");"
            注释 = "   \"%COMP\" - 作曲家;" 注释 = "   \"%COPY\" - 版权;" 注释 = "   \"%SUBT\" - 副标题;"
            注释 = "   \"%AART\" - 专辑歌手;" 注释 = "   \"%DISC\" - 碟片编号(可能包含合计碟片,\"disc/total\");"
            注释 = "   \"%PUBL\" - 出版商;" 注释 = "" 注释 = " - 表达式:" 注释 = "   \"%IFV1(x,a)\" - 如果x不为空,则等于a,否则为空文本;"
            注释 = "   \"%IFV2(x,a,b)\" - 如果x不为空,则等于a,否则为b;"
            注释 = "   \"%IUPC(x)\" - 使x大写,例如\"%IUPC(foO)\"为\"FOO\";"
            注释 = "   \"%ILWC(x)\" - 使x小写,例如\"%ILWC(fOO)\"为\"foo\";"
            注释 = "   \"%ICAP(x)\" - 将x每个单词的首字母大写,例如\"%ICAP(FoO bAR)\"为\"Foo Bar\";"
            注释 = "   \"%ITRM(x)\" - 删除x的首尾空格;" 注释 = "" 注释 = " - 转义符号:" 注释 = "   \"%%\" - \"%\""
            注释 = "   \"%(\" - \"(\"" 注释 = "   \"%,\" - \",\"" 注释 = "   \"%)\" - \")\"" 编辑时信息 = "53A7E, 0, 0, 0"
            @默认值 = "%IFV1(%TRCK,%TRCK. )%IFV2(%ARTI,%ARTI,无艺术家) - %IFV2(%TITL,%TITL -,无标题 -) %IFV1(%ALBM,%ALBM)">
    参数 标签类型 <类型 = 整数 注释 = "获取指定的标签类型,为\"BASS_标签类型\"类的选项之一,-1=所有标签类型." 编辑时信息 = "53A7E, 0, 0, 0" @默认值 = -1>
    参数 代码页 <类型 = 整数 注释 = "0为使用系统默认代码页,如果提供的代码页无效,将自动设置为 1252 (Latin 1)." 注释 = "ANSI代码页标识符请参阅:"
            注释 = "https://docs.microsoft.com/zh-cn/windows/win32/intl/code-page-identifiers?redirectedfrom=MSDN"
            编辑时信息 = "53A7E, 0, 0, 0" @默认值 = 0>
    {
        @ @an<CVolString>{BassTags::Fn().TAGS_ReadEx(static_cast<DWORD>(@<通道句柄>), @<格式文本>, static_cast<DWORD>(@<标签类型>), @<代码页>)}
    }

    方法 取错误描述 <公开 静态 类型 = 文本型 注释 = "获取最近一次错误的描述" 返回值注释 = "返回错误的描述文本" 折叠 @嵌入式方法 = "">
    {
        @ @an<CVolString>{BassTags::Fn().TAGS_GetLastErrorDesc()}
    }
}

# 音频标签类.辅助类

类 音频标签信息类 <公开 基础类 = 扩展对象类 注释 = "\"音频标签类.取标签信息\"返回的数据类型" 折叠 @文档 = "category = \"BASS扩展.辅助类\"">
{
    变量 标题 <公开 类型 = 文本型>
    变量 艺术家 <公开 类型 = 文本型>
    变量 专辑 <公开 类型 = 文本型>
    变量 流派 <公开 类型 = 文本型>
    变量 日期 <公开 类型 = 文本型>
    变量 注释 <公开 类型 = 文本型>
    变量 音轨号 <公开 类型 = 文本型>
    变量 作曲家 <公开 类型 = 文本型>
    变量 版权 <公开 类型 = 文本型>
    变量 副标题 <公开 类型 = 文本型>
    变量 专辑歌手 <公开 类型 = 文本型>
    变量 碟片编号 <公开 类型 = 文本型>
    变量 出版商 <公开 类型 = 文本型>

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<音频标签信息类> 总共 13 个成员:\r\n"
        加入文本 (展示内容, "1. 标题: " + 取调试文本2 (最大展示数据尺寸, 标题) + "\r\n")
        加入文本 (展示内容, "2. 艺术家: " + 取调试文本2 (最大展示数据尺寸, 艺术家) + "\r\n")
        加入文本 (展示内容, "3. 专辑: " + 取调试文本2 (最大展示数据尺寸, 专辑) + "\r\n")
        加入文本 (展示内容, "4. 流派: " + 取调试文本2 (最大展示数据尺寸, 流派) + "\r\n")
        加入文本 (展示内容, "5. 日期: " + 取调试文本2 (最大展示数据尺寸, 日期) + "\r\n")
        加入文本 (展示内容, "6. 注释: " + 取调试文本2 (最大展示数据尺寸, 注释) + "\r\n")
        加入文本 (展示内容, "7. 音轨号: " + 取调试文本2 (最大展示数据尺寸, 音轨号) + "\r\n")
        加入文本 (展示内容, "8. 作曲家: " + 取调试文本2 (最大展示数据尺寸, 作曲家) + "\r\n")
        加入文本 (展示内容, "9. 版权: " + 取调试文本2 (最大展示数据尺寸, 版权) + "\r\n")
        加入文本 (展示内容, "10. 副标题: " + 取调试文本2 (最大展示数据尺寸, 副标题) + "\r\n")
        加入文本 (展示内容, "11. 专辑歌手: " + 取调试文本2 (最大展示数据尺寸, 专辑歌手) + "\r\n")
        加入文本 (展示内容, "12. 碟片编号: " + 取调试文本2 (最大展示数据尺寸, 碟片编号) + "\r\n")
        加入文本 (展示内容, "13. 出版商: " + 取调试文本2 (最大展示数据尺寸, 出版商))
    }
}

# BASS_WASAPI类.辅助类

类 BASS_WASAPI_信息 <公开 基础类 = PIV结构模板 注释 = "\"BASS_WASAPI类::取信息/BASS_WASAPI_GetInfo\"返回的信息" 折叠 折叠2
        @文档 = "category = \"WASAPI支持.辅助类\"" @别名 = "BASS_WASAPI_INFO" @别名类型 = 本地结构 @模板实现类 = "BASS_WASAPI_信息">
{
    变量 初始化标志 <公开 类型 = 整数 注释 = "设备初始化时设置的标志" @输出名 = "initflags">
    变量 采样率 <公开 类型 = 整数 注释 = "采样率" @输出名 = "freq">
    变量 声道数 <公开 类型 = 整数 注释 = "声道数量,1=单声道,2=立体声,以此类推." @输出名 = "chans">
    变量 格式 <公开 类型 = 整数 注释 = "设备的采样格式,为以下的选项之一:" 注释 = "1 BASS_WASAPI_FORMAT_8BIT  8位整数."
            注释 = "2 BASS_WASAPI_FORMAT_16BIT 16位整数." 注释 = "3 BASS_WASAPI_FORMAT_24BIT 24位整数."
            注释 = "4 BASS_WASAPI_FORMAT_32BIT 32位整数." 注释 = "5 BASS_WASAPI_FORMAT_FLOAT 32位浮点数." @输出名 = "format">
    变量 缓存长度 <公开 类型 = 整数 注释 = "缓冲区的字节大小" @输出名 = "buflen">
    变量 最大音量 <公开 类型 = 单精度小数 注释 = "音量的最大值(单位为dB)" @输出名 = "volmax">
    变量 最小音量 <公开 类型 = 单精度小数 注释 = "音量的最小值(单位为dB)" @输出名 = "volmin">
    变量 音量步进 <公开 类型 = 单精度小数 注释 = "音量的步进值(单位为dB)" @输出名 = "volstep">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = BASS_WASAPI_信息 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 格式文本 <类型 = 文本型
                值 = "<BASS_WASAPI_信息> 总共 8 个成员:\r\n1. 初始化标志: %u\r\n2. 采样率: %u\r\n3. 声道数: %u\r\n4. 格式: %u\r\n5. 缓存长度: %u\r\n6. 最大音量: %f\r\n7. 最小音量: %f\r\n8. 音量步进: %f">
        返回 (取格式文本 (格式文本, 欲操作本对象.初始化标志, 欲操作本对象.采样率, 欲操作本对象.声道数, 欲操作本对象.格式, 欲操作本对象.缓存长度, 欲操作本对象.最大音量, 欲操作本对象.最小音量, 欲操作本对象.音量步进))
    }
}

类 BASS_WASAPI_设备信息 <公开 基础类 = PIV结构模板 注释 = "\"BASS_WASAPI类::取设备信息/BASS_WASAPI_GetDeviceInfo\"返回的信息" 折叠
        折叠2 @文档 = "category = \"WASAPI支持.辅助类\"" @别名 = "BASS_WASAPI_DEVICEINFO" @别名类型 = 本地结构
        @模板实现类 = "BASS_WASAPI_设备信息">
{
    变量 "//名称" <公开 类型 = 文本型 注释 = "设备描述" @输出名 = "name">
    变量 "//驱动ID" <公开 类型 = 文本型 注释 = "驱动程序的识别ID" @输出名 = "id">
    变量 设备类型 <公开 类型 = 整数 注释 = "为\"BASS_WASAPI_设备类型\"的选项之一" @输出名 = "type">
    变量 标志 <公开 类型 = 整数 注释 = "设备的当前和输入/输出状态,为以下标志的组合值:"
            注释 = " 1 BASS_DEVICE_ENABLED   此设备已启用并准备好,若不存在此标志,则无法初始化设备."
            注释 = " 2 BASS_DEVICE_DEFAULT   此设备为系统默认设备" 注释 = " 4 BASS_DEVICE_INIT      此设备已经被初始化,即已调用\"初始化\"方法."
            注释 = " 8 BASS_DEVICE_LOOPBACK  此设备为环回输入设备;它从输出设备捕获声音."
            注释 = "16 BASS_DEVICE_INPUT     此设备为录制设备,否则为输出设备."
            注释 = "32 BASS_DEVICE_UNPLUGGED 此设备未插入音频线. 仅适用于具有插孔存在检测的设备."
            注释 = "64 BASS_DEVICE_DISABLED  此设备已经在声音控制面板中被禁用." @输出名 = "flags">
    变量 最小周期 <公开 类型 = 小数 注释 = "最短更新周期(单位为秒)" @输出名 = "minperiod">
    变量 默认周期 <公开 类型 = 小数 注释 = "默认更新周期(单位为秒)" @输出名 = "defperiod">
    变量 最低采样率 <公开 类型 = 整数 注释 = "共享模式下的采样率" @输出名 = "mixfreq">
    变量 最低声道 <公开 类型 = 整数 注释 = "共享模式下的声道数" @输出名 = "mixchans">

    方法 名称 <公开 静态 属性读 类型 = 文本型 注释 = "设备描述" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = BASS_WASAPI_设备信息>
    {
        @ @an<CVolString>(reinterpret_cast<const wchar_t*>(@<欲操作本对象>.name))
    }

    方法 驱动ID <公开 静态 属性读 类型 = 文本型 注释 = "驱动程序的识别ID" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = BASS_WASAPI_设备信息>
    {
        @ @an<CVolString>(reinterpret_cast<const wchar_t*>(@<欲操作本对象>.id))
    }

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = BASS_WASAPI_设备信息 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 格式文本 <类型 = 文本型
                值 = "<BASS_WASAPI_设备信息> 总共 8 个成员:\r\n1. 名称: %s\r\n2. 驱动ID: %s\r\n3. 设备类型: %u\r\n4. 标志: %u\r\n5. 最小周期: %f\r\n6. 默认周期: %f\r\n7. 最低采样率: %u\r\n8. 最低声道: %u">
        返回 (取格式文本 (格式文本, 欲操作本对象.名称, 欲操作本对象.驱动ID, 欲操作本对象.设备类型, 欲操作本对象.标志, 欲操作本对象.最小周期, 欲操作本对象.默认周期, 欲操作本对象.最低采样率, 欲操作本对象.最低声道))
    }
}

类 BASS_WASAPI_设备信息数组 <公开 基础类 = PIV数组模板 注释 = "\"BASS_WASAPI类::取所有设备信息\"返回的信息数组"
        @文档 = "category = \"BASS扩展.辅助类\"" @模板实现类 = "BASS_WASAPI_设备信息">

类 BASS_WASAPI_标志 <公开 注释 = "BASS_WASAPI类" 折叠 @文档 = "category = \"WASAPI支持.常量\"">
{
    常量 BASS_WASAPI_EXCLUSIVE <公开 类型 = 整数 值 = @BASS_WASAPI_EXCLUSIVE 注释 = "在独占模式下初始化设备,否则在共享模式下初始化."
            注释 = "其高16位值——使用MAKELONG(标志,格式),可用于限制在独占模式下使用的采样格式." 注释 = "默认情况下,将按顺序尝试32位浮点、32位整数、24位整数、16位整数、8位整数."
            注释 = "BASS_WASAPI_FORMAT(请参阅\"BASS_WASAPI_信息\")可用于绕过该顺序中其前面的格式. 独占模式在环回设备上不可用.">
    常量 BASS_WASAPI_AUTOFORMAT <公开 类型 = 整数 值 = @BASS_WASAPI_AUTOFORMAT 注释 = "如果不支持指定的格式,则自动选择其他采样格式."
            注释 = "如果可能,将使用比\"采样率\"参数更高的采样率,而不是更低的.">
    常量 BASS_WASAPI_BUFFER <公开 类型 = 整数 值 = @BASS_WASAPI_BUFFER
            注释 = "启用双缓冲,供BASS_WASAPI_GetData和BASS_WASAPI_GetLevel和BASS_WASAPI_GetLevelEx使用."
            注释 = "这需要初始化\"BASS音频库\".">
    常量 BASS_WASAPI_EVENT <公开 类型 = 整数 值 = @BASS_WASAPI_EVENT 注释 = "启用事件驱动缓冲."
            注释 = "BASSWASAPI通常会根据\"周期\"参数定期在设备的缓冲区写入或读取数据,但在事件驱动系统中,当缓冲区有更多应该写入或读取的数据时,WASAPI会向BASSWASAPI发出信号."
            注释 = "因此周期参数被忽略,缓冲区也处于共享模式,因为系统将选择适当的缓冲区长度." 注释 = "在独占模式下,有两个缓冲区长度的缓冲区交替处理. 事件驱动缓冲在环回设备上不可用.">
    常量 BASS_WASAPI_SAMPLES <公开 类型 = 整数 值 = @BASS_WASAPI_SAMPLES 注释 = "缓冲区和周期以样本而不是秒为单位.">
    常量 BASS_WASAPI_DITHER <公开 类型 = 整数 值 = @BASS_WASAPI_DITHER
            注释 = "将浮点采样数据转换为设备格式时应用抖动(TPDF).此标志仅用于独占模式输出.">
    常量 BASS_WASAPI_RAW <公开 类型 = 整数 值 = @BASS_WASAPI_RAW
            注释 = "请求原生模式,绕过设备上启用的任何声音增强功能. 仅在Windows 8.1及更高版本上可用.">
    常量 BASS_WASAPI_ASYNC <公开 类型 = 整数 值 = @BASS_WASAPI_ASYNC 注释 = "异步调用回调函数. 仅适用于事件驱动的独占模式输出,否则将被忽略."
            注释 = "启用时,将提前异步填充缓冲区,以降低了欠载的几率,但也会将延迟增加一个缓冲区长度."
            注释 = "如果确实发生欠载,仍会向设备发送静默缓冲区(而不是无缓冲区),这可以防止某些设备在欠载后出现声音故障.">
    常量 ""
    常量 BASS_WASAPI_CATEGORY_MASK <公开 类型 = 整数 值 = @BASS_WASAPI_CATEGORY_MASK
            注释 = "掩码. 用来检查WASAPI的类别,将标志的组合值与\"BASS_WASAPI_CATEGORY_MASK\"位与,即可得到WASAPI的类别的标志.">
    常量 BASS_WASAPI_CATEGORY_OTHER <公开 类型 = 整数 值 = @BASS_WASAPI_CATEGORY_OTHER 注释 = "其他的音频流.">
    常量 BASS_WASAPI_CATEGORY_FOREGROUNDONLYMEDIA <公开 类型 = 整数 值 = @BASS_WASAPI_CATEGORY_FOREGROUNDONLYMEDIA
            注释 = "仅前景音频">
    常量 BASS_WASAPI_CATEGORY_BACKGROUNDCAPABLEMEDIA <公开 类型 = 整数
            值 = @BASS_WASAPI_CATEGORY_BACKGROUNDCAPABLEMEDIA 注释 = "仅背景音频">
    常量 BASS_WASAPI_CATEGORY_COMMUNICATIONS <公开 类型 = 整数 值 = @BASS_WASAPI_CATEGORY_COMMUNICATIONS
            注释 = "实时通信,如VOIP或语音聊天.">
    常量 BASS_WASAPI_CATEGORY_ALERTS <公开 类型 = 整数 值 = @BASS_WASAPI_CATEGORY_ALERTS 注释 = "报警声. 仅用于输出设备.">
    常量 BASS_WASAPI_CATEGORY_SOUNDEFFECTS <公开 类型 = 整数 值 = @BASS_WASAPI_CATEGORY_SOUNDEFFECTS
            注释 = "声音效果. 仅用于输出设备.">
    常量 BASS_WASAPI_CATEGORY_GAMEEFFECTS <公开 类型 = 整数 值 = @BASS_WASAPI_CATEGORY_GAMEEFFECTS
            注释 = "游戏音效. 仅用于输出设备.">
    常量 BASS_WASAPI_CATEGORY_GAMEMEDIA <公开 类型 = 整数 值 = @BASS_WASAPI_CATEGORY_GAMEMEDIA
            注释 = "游戏背景音频. 仅用于输出设备.">
    常量 BASS_WASAPI_CATEGORY_GAMECHAT <公开 类型 = 整数 值 = @BASS_WASAPI_CATEGORY_GAMECHAT
            注释 = "游戏语音聊天. 与实时通信类似,但这个不会减弱其他流的音量. 仅用于输出设备.">
    常量 BASS_WASAPI_CATEGORY_SPEECH <公开 类型 = 整数 值 = @BASS_WASAPI_CATEGORY_SPEECH 注释 = "说话.">
    常量 BASS_WASAPI_CATEGORY_MOVIE <公开 类型 = 整数 值 = @BASS_WASAPI_CATEGORY_MOVIE 注释 = "包含音频和对话的流. 仅用于输出设备.">
    常量 BASS_WASAPI_CATEGORY_MEDIA <公开 类型 = 整数 值 = @BASS_WASAPI_CATEGORY_MEDIA 注释 = "包含音频而不包含对话的流. 仅用于输出设备.">
}

类 BASS_WASAPI_设备类型 <公开 注释 = "BASS_WASAPI类" 折叠 @文档 = "category = \"WASAPI支持.常量\"">
{
    常量 BASS_WASAPI_TYPE_NETWORKDEVICE <公开 类型 = 整数 值 = @BASS_WASAPI_TYPE_NETWORKDEVICE
            注释 = "通过网络远程访问的音频终端设备">
    常量 BASS_WASAPI_TYPE_SPEAKERS <公开 类型 = 整数 值 = @BASS_WASAPI_TYPE_SPEAKERS 注释 = "扬声器">
    常量 BASS_WASAPI_TYPE_LINELEVEL <公开 类型 = 整数 值 = @BASS_WASAPI_TYPE_LINELEVEL
            注释 = "线路输出. 向音频解码器上的线路输入插孔发送线路电平模拟信号,或从解码器上的线路输出插孔接收线路电平模拟信号">
    常量 BASS_WASAPI_TYPE_HEADPHONES <公开 类型 = 整数 值 = @BASS_WASAPI_TYPE_HEADPHONES 注释 = "耳机">
    常量 BASS_WASAPI_TYPE_MICROPHONE <公开 类型 = 整数 值 = @BASS_WASAPI_TYPE_MICROPHONE 注释 = "麦克风">
    常量 BASS_WASAPI_TYPE_HEADSET <公开 类型 = 整数 值 = @BASS_WASAPI_TYPE_HEADSET 注释 = "一个头戴式耳机或一对耳机，带有用于双向通信的话筒">
    常量 BASS_WASAPI_TYPE_HANDSET <公开 类型 = 整数 值 = @BASS_WASAPI_TYPE_HANDSET
            注释 = "电话听筒,手机的一部分,包括一个扬声器和一个用于双向通信的麦克风">
    常量 BASS_WASAPI_TYPE_DIGITAL <公开 类型 = 整数 值 = @BASS_WASAPI_TYPE_DIGITAL
            注释 = "数字接口. 通过未知类型的数字线缆连接到其他音频解码器">
    常量 BASS_WASAPI_TYPE_SPDIF <公开 类型 = 整数 值 = @BASS_WASAPI_TYPE_SPDIF
            注释 = "通过Sony/Philips数字接口(S/PDIF)线缆连接到音频解码器的音频终端设备">
    常量 BASS_WASAPI_TYPE_HDMI <公开 类型 = 整数 值 = @BASS_WASAPI_TYPE_HDMI
            注释 = "HDMI接口. 通过HDMI线缆连接到其他音频解码器的音频终端设备">
    常量 BASS_WASAPI_TYPE_UNKNOWN <公开 类型 = 整数 值 = @BASS_WASAPI_TYPE_UNKNOWN 注释 = "未知类型">
}

# BASS_ASIO类.辅助类

类 BASS_ASIO_信息 <公开 基础类 = PIV结构模板 注释 = "\"BASS_ASIO类::取信息/BASS_ASIO_GetInfo\"返回的信息" 折叠 折叠2
        @文档 = "category = \"WASAPI支持.辅助类\"" @别名 = "BASS_ASIO_INFO" @别名类型 = 本地结构 @模板实现类 = "BASS_ASIO_信息">
{
    方法 名称 <公开 静态 属性读 类型 = 文本型 注释 = "设备或驱动程序的名称" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = BASS_ASIO_信息>
    {
        @ @an<CVolString>(reinterpret_cast<const wchar_t*>(@<欲操作本对象>.name))
    }

    变量 版本 <公开 类型 = 整数 注释 = "设备的版本" @输出名 = "version">
    变量 输入通道数 <公开 类型 = 整数 注释 = "可用的输入通道数" @输出名 = "inputs">
    变量 输出通道数 <公开 类型 = 整数 注释 = "可用的输出通道数" @输出名 = "outputs">
    变量 最小缓存 <公开 类型 = 整数 注释 = "最小缓冲区长度,以采样为单位." @输出名 = "bufmin">
    变量 最大缓存 <公开 类型 = 整数 注释 = "最大缓冲区长度,以采样为单位." @输出名 = "bufmax">
    变量 默认缓存 <公开 类型 = 整数 注释 = "首选/默认缓冲区长度,以采样为单位." @输出名 = "bufpref">
    变量 缓存粒度 <公开 类型 = 整数 注释 = "缓冲区长度的例子,-1等于以两倍的粒度增加缓冲区长度." @输出名 = "bufgran">
    变量 初始标志 <公开 类型 = 整数 注释 = "调用\"初始化\"时提供的标志" @输出名 = "initflags">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = BASS_ASIO_信息 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 格式文本 <类型 = 文本型
                值 = "<BASS_ASIO_信息> 总共 9 个成员:\r\n1. 名称: %s\r\n2. 版本: %u\r\n3. 输入通道数: %u\r\n4. 输出通道数: %u\r\n5. 最小缓存: %u\r\n6. 最大缓存: %u\r\n7. 默认缓存: %u\r\n8. 缓存粒度: %d\r\n9. 初始标志: %u">
        返回 (取格式文本 (格式文本, 欲操作本对象.名称, 欲操作本对象.版本, 欲操作本对象.输入通道数, 欲操作本对象.输出通道数, 欲操作本对象.最小缓存, 欲操作本对象.最大缓存, 欲操作本对象.默认缓存, 欲操作本对象.缓存粒度, 欲操作本对象.初始标志))
    }
}

类 BASS_ASIO_设备信息 <公开 基础类 = PIV结构模板 注释 = "\"BASS_ASIO类::取设备信息/BASS_ASIO_GetDeviceInfo\"返回的信息" 折叠 折叠2
        @文档 = "category = \"ASIO支持.辅助类\"" @别名 = "BASS_ASIO_DEVICEINFO" @别名类型 = 本地结构 @模板实现类 = "BASS_ASIO_设备信息">
{
    方法 名称 <公开 静态 属性读 类型 = 文本型 注释 = "设备描述" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = BASS_ASIO_设备信息>
    {
        @ @an<CVolString>(reinterpret_cast<const wchar_t*>(@<欲操作本对象>.name))
    }

    方法 驱动文件名 <公开 静态 属性读 类型 = 文本型 注释 = "驱动程序的文件名" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = BASS_ASIO_设备信息>
    {
        @ @an<CVolString>(reinterpret_cast<const wchar_t*>(@<欲操作本对象>.driver))
    }

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = BASS_ASIO_设备信息 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 格式文本 <类型 = 文本型 值 = "<BASS_ASIO_设备信息> 总共 2 个成员:\r\n1. 名称: %s\r\n2. 驱动文件名: %s">
        返回 (取格式文本 (格式文本, 欲操作本对象.名称, 欲操作本对象.驱动文件名))
    }
}

类 BASS_ASIO_设备信息数组 <公开 基础类 = PIV数组模板 注释 = "\"BASS_ASIO类::取所有设备信息\"返回的信息数组"
        @文档 = "category = \"ASIO支持.辅助类\"" @模板实现类 = "BASS_ASIO_设备信息">

类 BASS_ASIO_通道信息 <公开 基础类 = PIV结构模板 注释 = "\"BASS_ASIO类::取通道信息/BASS_ASIO_ChannelGetInfo\"返回的信息" 折叠 折叠2
        @文档 = "category = \"ASIO支持.辅助类\"" @别名 = "BASS_ASIO_CHANNELINFO" @别名类型 = 本地结构
        @模板实现类 = "BASS_ASIO_通道信息">
{
    变量 群组 <公开 类型 = 整数 注释 = "通道的群组" @输出名 = "group">
    变量 采样格式 <公开 类型 = 整数 注释 = "通道的采样格式,为下列常量之一:" 注释 = "16 BASS_ASIO_FORMAT_16BIT 16位整数."
            注释 = "17 BASS_ASIO_FORMAT_24BIT 24位整数." 注释 = "18 BASS_ASIO_FORMAT_32BIT 32位整数."
            注释 = "19 BASS_ASIO_FORMAT_32BIT16 16位对齐的32位整数." 注释 = "24 BASS_ASIO_FORMAT_32BIT18 18位对齐的32位整数."
            注释 = "25 BASS_ASIO_FORMAT_32BIT20 20位对齐的32位整数." 注释 = "26 BASS_ASIO_FORMAT_32BIT24 24位对齐的32位整数."
            注释 = "27BASS_ASIO_FORMAT_FLOAT 32位单精度浮点数." 注释 = "32 BASS_ASIO_FORMAT_DSD_LSB DSD with LSB first."
            注释 = "33 BASS_ASIO_FORMAT_DSD_MSB DSD with MSB first." @输出名 = "format">

    方法 名称 <公开 静态 属性读 类型 = 文本型 注释 = "通道的名称" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = BASS_ASIO_通道信息>
    {
        @ @an<CVolString>(reinterpret_cast<const wchar_t*>(@<欲操作本对象>.name))
    }

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = BASS_ASIO_通道信息 注释 = "用作填入本对象中所有数据的展示文本">
    {
        变量 格式文本 <类型 = 文本型 值 = "<BASS_ASIO_通道信息> 总共 3 个成员:\r\n1. 群组: %u\r\n2. 采样格式: %u\r\n3. 名称: %s">
        返回 (取格式文本 (格式文本, 欲操作本对象.群组, 欲操作本对象.采样格式, 欲操作本对象.名称))
    }
}

类 BASS_ASIO_标志 <公开 折叠 @文档 = "category = \"ASIO支持.常量\"">
{
    常量 "" <公开 类型 = 整数 值 = @BASS_ASIO_THREAD
            注释 = "Host the driver in a dedicated thread, else the current thread.">
    常量 "" <公开 类型 = 整数 值 = @BASS_ASIO_JOINORDER
            注释 = "Place joined channels in the order in which BASS_ASIO_ChannelJoin was called to join them, else place them in numerically ascending order.">

    #
}

#
# BASS混合器类.辅助类

类 BASS_分离标志 <公开 注释 = "BASS混合器类::创建分离流" 折叠 @文档 = "category = \"BASS混合器.常量\"">
{
    常量 BASS_SPLIT_SLAVE <公开 类型 = 整数 值 = @BASS_SPLIT_SLAVE 注释 = "分离器的长度和位置基于分离器,而不是源的通道计数.">
    常量 BASS_SPLIT_POS <公开 类型 = 整数 值 = @BASS_SPLIT_POS 注释 = "仅从分离器缓冲区获取数据,而不直接从源获取数据.">
}

类 BASS_混合器标志 <公开 注释 = "BASS混合器类::创建混合流" 折叠 @文档 = "category = \"BASS混合器.常量\"">
{
    常量 BASS_MIXER_RESUME <公开 类型 = 整数 值 = @BASS_MIXER_RESUME>
    常量 BASS_MIXER_POSEX <公开 类型 = 整数 值 = @BASS_MIXER_POSEX>
    常量 BASS_MIXER_NOSPEAKER <公开 类型 = 整数 值 = @BASS_MIXER_NOSPEAKER>
    常量 BASS_MIXER_QUEUE <公开 类型 = 整数 值 = @BASS_MIXER_QUEUE>
    常量 BASS_MIXER_END <公开 类型 = 整数 值 = @BASS_MIXER_END>
    常量 BASS_MIXER_NONSTOP <公开 类型 = 整数 值 = @BASS_MIXER_NONSTOP>
    常量 ""
    常量 ""
    常量 BASS_MIXER_CHAN_ABSOLUTE <公开 类型 = 整数 值 = @BASS_MIXER_CHAN_ABSOLUTE
            注释 = "开始点是混合器输出中的绝对位置,而不是混合器当前位置的相对位置." 注释 = "如果位置已过,将立即启动源.">
    常量 BASS_MIXER_CHAN_BUFFER <公开 类型 = 整数 值 = @BASS_MIXER_CHAN_BUFFER
            注释 = "缓冲样本数据，供\"取通道数据\"和\"取通道电平\"和\"取通道电平EX\"使用."
            注释 = "这会增加内存需求,因此不应非必要地启用. 缓冲区的大小可以通过BASS_CONFIG_MIXER_BUFFER配置选项进行控制.">
    常量 BASS_MIXER_CHAN_LIMIT <公开 类型 = 整数 值 = @BASS_MIXER_CHAN_LIMIT
            注释 = "在源处于活动状态(未结束)时,将混合器处理限制在此源中可用的数据量." 注释 = "如果源暂停,那么混合器也将停止,而不是像通常那样继续混合其他源."
            注释 = "只能在每个混合器的其中一个源中应用此标志,因此它将自动从同一混合器的任何其他源中删除.">
    常量 BASS_MIXER_CHAN_MATRIX <公开 类型 = 整数 值 = @BASS_MIXER_CHAN_MATRIX
            注释 = "创建通道矩阵,允许将源通道发送到任何级别的任何混合器输出通道." 注释 = "可通过\"取通道矩阵\"和\"置通道矩阵\"方法获取和修改矩阵."
            注释 = "矩阵最初将包含一对一的映射,例如left out=left in, right out=right in,等等.">
    常量 BASS_MIXER_CHAN_PAUSE <公开 类型 = 整数 值 = @BASS_MIXER_CHAN_PAUSE 注释 = "暂停源的处理. 可使用\"置取通道标志\"恢复处理.">
    常量 BASS_MIXER_CHAN_DOWNMIX <公开 类型 = 整数 值 = @BASS_MIXER_CHAN_DOWNMIX
            注释 = "如果源具有比混合器更多的输出通道(混合器为立体声或单声道),则会创建通道矩阵,并使用适当的向下混音矩阵进行初始化(最多8个通道)."
            注释 = "注意,假设源数据遵循标准通道顺序,如STREAMPROC文档中所述.">
    常量 BASS_MIXER_CHAN_NORAMPIN <公开 类型 = 整数 值 = @BASS_MIXER_CHAN_NORAMPIN
            注释 = "不要在开始时淡入,包括在移动位置后(\"置播放位置\")." 注释 = "这对于无间隙播放非常有用,使其中的源通道无缝地跟随另一个通道."
            注释 = "这不会影响音量和声像变化,因为音量和声像变化总是平滑的.">
    常量 BASS_MIXER_BUFFER <公开 类型 = 整数 值 = @BASS_MIXER_BUFFER>
    常量 BASS_MIXER_LIMIT <公开 类型 = 整数 值 = @BASS_MIXER_LIMIT>
    常量 BASS_MIXER_MATRIX <公开 类型 = 整数 值 = @BASS_MIXER_MATRIX>
    常量 BASS_MIXER_PAUSE <公开 类型 = 整数 值 = @BASS_MIXER_PAUSE>
    常量 BASS_MIXER_DOWNMIX <公开 类型 = 整数 值 = @BASS_MIXER_DOWNMIX>
    常量 BASS_MIXER_NORAMPIN <公开 类型 = 整数 值 = @BASS_MIXER_NORAMPIN>
}

类 BASS_MIXER_节点 <公开 基础类 = PIV结构模板 注释 = "BASS混合器类::置通道包络线" 折叠 折叠2 @文档 = "category = \"BASS混合器.辅助类\""
        @别名 = "BASS_MIXER_NODE" @别名类型 = 本地结构 @模板实现类 = "BASS_MIXER_节点">
{
    变量 位置 <公开 类型 = 长整数 @输出名 = "pos">
    变量 值 <公开 类型 = 单精度小数 @输出名 = "val">

    方法 取展示内容 <公开 静态 类型 = 文本型 注释 = "将本对象中的所有数据用文本方式返回,用作调试或其它场合展示时使用." 折叠>
    参数 欲操作本对象 <类型 = BASS_MIXER_节点 注释 = "用作填入本对象中所有数据的展示文本">
    {
        返回 (取格式文本 ("<BASS_MIXER_节点> {位置(pos): %I64u, 值(val): %f}", 欲操作本对象.位置, 欲操作本对象.值))
    }
}

类 BASS_MIXER_节点数组 <公开 基础类 = PIV数组模板 注释 = "BASS混合器类::置通道包络线" @文档 = "category = \"BASS混合器.辅助类\""
        @模板实现类 = "BASS_MIXER_节点">
