<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "文本操作" 注释 = "https://github.com/SaierMe/piv" "">

# 正则表达式 ====

类 正则匹配类 <公开 注释 = "提供文本的正则匹配和替换操作." 注释 = "本类无需实例化,请以\"类名.方法名()\"调用."
        注释 = "本类仅实现了大部分JavaScript RegExp语法." 注释 = "源码: https://gitee.com/scu319hy/simple_regex" 折叠
        @文档 = "category = \"正则表达式\"" @视窗.外部头文件 = "src\\piv_regex.h">
{
    方法 匹配 <公开 静态 类型 = 逻辑型 注释 = "判断提供的UTF-16LE编码内容是否部分匹配指定的正则表达式的规则." 注释 = "只要匹配到内容的首部即可返回真,中间匹配会返回假."
            返回值注释 = "匹配首部返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 欲匹配内容 <注释 = "提供所欲进行匹配的文本内容,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE编码)" @匹配类型 = 通用型>
    参数 正则表达式 <注释 = "提供所欲使用的正则表达式文本,支持类型:" 注释 = " 文本型、标准文本类W、字节集类(UTF-16LE编码)" @匹配类型 = 通用型>
    参数 匹配模式 <类型 = 整数 注释 = "提供正则的匹配模式,为\"正则匹配标志\"中一个常量或多个常量的位或值." @默认值 = 正则匹配标志.无>
    {
        @ piv::regex::Match<wchar_t>(@<正则表达式>, @<欲匹配内容>, @<匹配模式>)
    }

    方法 完全匹配 <公开 静态 类型 = 逻辑型 注释 = "判断提供的UTF-16LE编码内容是否完全匹配指定正则表达式的规则" 返回值注释 = "完全匹配返回真,否则返回假." 折叠
            @嵌入式方法 = "">
    参数 欲匹配内容 <注释 = "提供所欲进行匹配的文本内容,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE编码)" @匹配类型 = 通用型>
    参数 正则表达式 <注释 = "提供所欲使用的正则表达式文本,支持类型:" 注释 = " 文本型、标准文本类W、字节集类(UTF-16LE编码)" @匹配类型 = 通用型>
    参数 匹配模式 <类型 = 整数 注释 = "提供正则的匹配模式,为\"正则匹配标志\"中一个常量或多个常量的位或值." @默认值 = 正则匹配标志.无>
    {
        @ piv::regex::FullMatch<wchar_t>(@<正则表达式>, @<欲匹配内容>, @<匹配模式>)
    }

    方法 匹配U <公开 静态 类型 = 逻辑型 注释 = "判断提供的UTF-8编码内容是否部分匹配指定的正则表达式的规则." 注释 = "只要匹配到内容的首部即可返回真,中间匹配会返回假."
            返回值注释 = "匹配首部返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 欲匹配内容 <注释 = "提供所欲进行匹配的文本内容,支持类型:" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8编码)" @匹配类型 = 通用型>
    参数 正则表达式 <注释 = "提供所欲使用的正则表达式文本,支持类型:" 注释 = " *文本型、标准文本类U、字节集类(UTF-8编码)" @匹配类型 = 通用型>
    参数 匹配模式 <类型 = 整数 注释 = "提供正则的匹配模式,为\"正则匹配标志\"中一个常量或多个常量的位或值." @默认值 = 正则匹配标志.无>
    {
        @ piv::regex::Match<char>(@<正则表达式>, @<欲匹配内容>, @<匹配模式>)
    }

    方法 完全匹配U <公开 静态 类型 = 逻辑型 注释 = "判断提供的UTF-8编码内容是否完全匹配指定正则表达式的规则" 返回值注释 = "完全匹配返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 欲匹配内容 <注释 = "提供所欲进行匹配的文本内容,支持类型:" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8编码)" @匹配类型 = 通用型>
    参数 正则表达式 <注释 = "提供所欲使用的正则表达式文本,支持类型:" 注释 = " *文本型、标准文本类U、字节集类(UTF-8编码)" @匹配类型 = 通用型>
    参数 匹配模式 <类型 = 整数 注释 = "提供正则的匹配模式,为\"正则匹配标志\"中一个常量或多个常量的位或值." @默认值 = 正则匹配标志.无>
    {
        @ piv::regex::FullMatch<char>(@<正则表达式>, @<欲匹配内容>, @<匹配模式>)
    }

    方法 正则替换 <公开 静态 类型 = 整数 注释 = "以正则匹配方式查找并替换欲匹配内容中的子内容." 注释 = "结果返回到UTF-16LE编码的火山文本型." 返回值注释 = "返回成功替换的次数"
            折叠 @嵌入式方法 = "">
    参数 欲替换内容 <注释 = "提供所欲进行替换的文本内容,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE编码)" @匹配类型 = 通用型>
    参数 正则表达式 <注释 = "提供所欲使用的正则表达式文本,支持类型:" 注释 = " 文本型、标准文本类W、字节集类(UTF-16LE编码)" @匹配类型 = 通用型>
    参数 正则替换格式 <注释 = "提供所欲使用的替换格式内容;" 注释 = "支持使用\"\\0\"～\"\\9\"引用子匹配文本,注意反斜杠需要用\'\\\\\'转义;"
            注释 = "支持类型: 文本型、标准文本类W、字节集类(UTF-16LE编码);" @匹配类型 = 通用型>
    参数 替换结果 <类型 = 文本型 注释 = "替换后的结果将保存在此参数;" 注释 = "即使未进行任何替换也会赋值为所欲替换的内容.">
    参数 开始位置 <类型 = 变整数 注释 = "进行查找替换的开始位置" @默认值 = 0>
    参数 替换次数 <类型 = 变整数 注释 = "-1表示全部替换" @默认值 = -1>
    参数 匹配模式 <类型 = 整数 注释 = "提供正则的匹配模式,为\"正则匹配标志\"中一个常量或多个常量的位或值." @默认值 = 正则匹配标志.无>
    {
        @ piv::regex::Replace<wchar_t>(@<欲替换内容>, @<正则表达式>, @<正则替换格式>, @<替换结果>, (size_t)@<开始位置>, (size_t)@<替换次数>, @<匹配模式>)
    }

    方法 正则替换W <公开 静态 类型 = 整数 注释 = "以正则匹配方式查找并替换欲匹配内容中的子内容." 注释 = "结果返回到UTF-16LE编码的标准文本类."
            返回值注释 = "返回成功替换的次数" 折叠 @嵌入式方法 = "">
    参数 欲替换内容 <注释 = "提供所欲进行替换的文本内容,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE编码)" @匹配类型 = 通用型>
    参数 正则表达式 <注释 = "提供所欲使用的正则表达式文本,支持类型:" 注释 = " 文本型、标准文本类W、字节集类(UTF-16LE编码)" @匹配类型 = 通用型>
    参数 正则替换格式 <注释 = "提供所欲使用的替换格式内容;" 注释 = "支持使用\"\\0\"～\"\\9\"引用子匹配文本,注意反斜杠需要用\'\\\\\'转义;"
            注释 = "支持类型: 文本型、标准文本类W、字节集类(UTF-16LE编码);" @匹配类型 = 通用型>
    参数 替换结果 <类型 = 标准文本类W 注释 = "替换后的结果将保存在此参数;" 注释 = "即使未进行任何替换也会赋值为所欲替换的内容.">
    参数 开始位置 <类型 = 变整数 注释 = "进行查找替换的开始位置" @默认值 = 0>
    参数 替换次数 <类型 = 变整数 注释 = "-1表示全部替换" @默认值 = -1>
    参数 匹配模式 <类型 = 整数 注释 = "提供正则的匹配模式,为\"正则匹配标志\"中一个常量或多个常量的位或值." @默认值 = 正则匹配标志.无>
    {
        @ piv::regex::Replace<wchar_t>(@<欲替换内容>, @<正则表达式>, @<正则替换格式>, @<替换结果>, (size_t)@<开始位置>, (size_t)@<替换次数>, @<匹配模式>)
    }

    方法 正则替换U <公开 静态 类型 = 整数 注释 = "以正则匹配方式查找并替换欲匹配内容中的子内容." 注释 = "结果返回到UTF-8编码的标准文本类U." 返回值注释 = "返回成功替换的次数"
            折叠 @嵌入式方法 = "">
    参数 欲替换内容 <注释 = "提供所欲进行替换的文本内容,支持类型:" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8编码)" @匹配类型 = 通用型>
    参数 正则表达式 <注释 = "提供所欲使用的正则表达式文本,支持类型:" 注释 = " *文本型、标准文本类U、字节集类(UTF-8编码)" @匹配类型 = 通用型>
    参数 正则替换格式 <注释 = "提供所欲使用的替换格式内容;" 注释 = "支持使用\"\\0\"～\"\\9\"引用子匹配文本,注意反斜杠需要用\'\\\\\'转义;"
            注释 = "支持类型: *文本型、标准文本类U、字节集类(UTF-8编码);" @匹配类型 = 通用型>
    参数 替换结果 <类型 = 标准文本类U 注释 = "替换后的结果将保存在此参数;" 注释 = "即使未进行任何替换也会赋值为所欲替换的内容.">
    参数 开始位置 <类型 = 变整数 注释 = "进行查找替换的开始位置" @默认值 = 0>
    参数 替换次数 <类型 = 变整数 注释 = "-1表示全部替换" @默认值 = -1>
    参数 匹配模式 <类型 = 整数 注释 = "提供正则的匹配模式,为\"正则匹配标志\"中一个常量或多个常量的位或值." @默认值 = 正则匹配标志.无>
    {
        @ piv::regex::Replace<char>(@<欲替换内容>, @<正则表达式>, @<正则替换格式>, @<替换结果>, (size_t)@<开始位置>, (size_t)@<替换次数>, @<匹配模式>)
    }

    方法 正则替换到字节集 <公开 静态 类型 = 整数 注释 = "以正则匹配方式查找并替换欲匹配内容中的子内容." 注释 = "结果返回到UTF-16LE编码的字节集类."
            返回值注释 = "返回成功替换的次数" 折叠 @嵌入式方法 = "">
    参数 欲替换内容 <注释 = "提供所欲进行替换的文本内容,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE编码)" @匹配类型 = 通用型>
    参数 正则表达式 <注释 = "提供所欲使用的正则表达式文本,支持类型:" 注释 = " 文本型、标准文本类W、字节集类(UTF-16LE编码)" @匹配类型 = 通用型>
    参数 正则替换格式 <注释 = "提供所欲使用的替换格式内容;" 注释 = "支持使用\"\\0\"～\"\\9\"引用子匹配文本,注意反斜杠需要用\'\\\\\'转义;"
            注释 = "支持类型: 文本型、标准文本类W、字节集类(UTF-16LE编码);" @匹配类型 = 通用型>
    参数 替换结果 <类型 = 字节集类 注释 = "替换后的结果将保存在此参数;" 注释 = "即使未进行任何替换也会赋值为所欲替换的内容.">
    参数 开始位置 <类型 = 变整数 注释 = "进行查找替换的开始位置" @默认值 = 0>
    参数 替换次数 <类型 = 变整数 注释 = "-1表示全部替换" @默认值 = -1>
    参数 匹配模式 <类型 = 整数 注释 = "提供正则的匹配模式,为\"正则匹配标志\"中一个常量或多个常量的位或值." @默认值 = 正则匹配标志.无>
    {
        @ piv::regex::Replace<wchar_t>(@<欲替换内容>, @<正则表达式>, @<正则替换格式>, @<替换结果>, (size_t)@<开始位置>, (size_t)@<替换次数>, @<匹配模式>)
    }

    方法 正则替换到字节集U <公开 静态 类型 = 整数 注释 = "以正则匹配方式查找并替换欲匹配内容中的子内容." 注释 = "结果返回到UTF-8编码的字节集类."
            返回值注释 = "返回成功替换的次数" 折叠 @嵌入式方法 = "">
    参数 欲替换内容 <注释 = "提供所欲进行替换的文本内容,支持类型:" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8编码)" @匹配类型 = 通用型>
    参数 正则表达式 <注释 = "提供所欲使用的正则表达式文本,支持类型:" 注释 = " *文本型、标准文本类U、字节集类(UTF-8编码)" @匹配类型 = 通用型>
    参数 正则替换格式 <注释 = "提供所欲使用的替换格式内容;" 注释 = "支持使用\"\\0\"～\"\\9\"引用子匹配文本,注意反斜杠需要用\'\\\\\'转义;"
            注释 = "支持类型: *文本型、标准文本类U、字节集类(UTF-8编码);" @匹配类型 = 通用型>
    参数 替换结果 <类型 = 字节集类 注释 = "替换后的结果将保存在此参数;" 注释 = "即使未进行任何替换也会赋值为所欲替换的内容.">
    参数 开始位置 <类型 = 变整数 注释 = "进行查找替换的开始位置" @默认值 = 0>
    参数 替换次数 <类型 = 变整数 注释 = "-1表示全部替换" @默认值 = -1>
    参数 匹配模式 <类型 = 整数 注释 = "提供正则的匹配模式,为\"正则匹配标志\"中一个常量或多个常量的位或值." @默认值 = 正则匹配标志.无>
    {
        @ piv::regex::Replace<char>(@<欲替换内容>, @<正则表达式>, @<正则替换格式>, @<替换结果>, (size_t)@<开始位置>, (size_t)@<替换次数>, @<匹配模式>)
    }

    方法 正则匹配到数组 <公开 静态 类型 = 整数 注释 = "如果有子匹配文本就把子匹配文本取出来,否则就把匹配的文本取出来." 返回值注释 = "返回匹配数量" 折叠 "">
    参数 要匹配的内容 <类型 = 文本型 注释 = "提供要匹配的内容">
    参数 正则表达式 <类型 = 文本型 注释 = "提供正则表达式文本">
    参数 匹配结果 <类型 = 二维文本数组类 注释 = "匹配结果放到此参数中">
    参数 匹配模式 <类型 = 整数 注释 = "提供正则的匹配模式,为\"正则匹配标志\"中一个常量或多个常量的位或值." @默认值 = 正则匹配标志.无>
    {
        变量 正则 <类型 = 正则查找类>
        匹配结果.删除所有成员 ()
        如果 (正则.查找 (要匹配的内容, 正则表达式, 匹配模式) == 真)
        {
            循环判断首 ()
            {
                变量 子匹配结果 <类型 = 文本数组类>
                变量 子匹配数量 <类型 = 整数>
                子匹配数量 = 正则.取子匹配数量 ()
                如果 (子匹配数量 == 0)
                {
                    子匹配结果.加入成员 (正则.取匹配文本 ())
                }
                否则
                {
                    计次循环 (正则.取子匹配数量 ())
                    {
                        子匹配结果.加入成员 (正则.取子匹配文本 (取循环索引 () + 1))
                    }
                }
                匹配结果.加入成员 (子匹配结果)
            }
            循环判断尾 (正则.查找下一个 () == 真)
        }
        返回 (匹配结果.取成员数 ())
    }

    方法 正则匹配到JSON数组 <公开 静态 类型 = 整数 注释 = "本方法可以将正则匹配结果,存储在JSON数组中." 返回值注释 = "返回匹配数量" 折叠>
    参数 要匹配的内容 <类型 = 文本型 注释 = "提供要匹配的内容">
    参数 正则表达式 <类型 = 文本型 注释 = "提供正则表达式文本">
    参数 匹配结果 <类型 = PivJSON 注释 = "存储匹配结果到本参数中">
    参数 匹配模式 <类型 = 整数 注释 = "提供正则的匹配模式,为\"正则匹配标志\"中一个常量或多个常量的位或值." @默认值 = 正则匹配标志.无>
    {
        变量 正则 <类型 = 正则查找类>
        匹配结果.清空 ()
        如果 (正则.查找 (要匹配的内容, 正则表达式, 匹配模式) == 真)
        {
            循环判断首 ()
            {
                变量 子匹配结果 <类型 = PivJSON>
                变量 子匹配数量 <类型 = 整数>
                子匹配数量 = 正则.取子匹配数量 ()
                如果 (子匹配数量 == 0)
                {
                    子匹配结果.加入成员 (正则.取匹配视图 ())
                }
                否则
                {
                    计次循环 (子匹配数量)
                    {
                        子匹配结果.加入成员 (正则.取子匹配视图 (取循环索引 () + 1))
                    }
                }
                匹配结果.加入成员 (子匹配结果)
            }
            循环判断尾 (正则.查找下一个 () == 真)
        }
        返回 (匹配结果.取成员数 ())
    }
}

类 正则查找类 <公开 基础类 = PIV本地类模板 注释 = "提供UTF-16LE编码文本的正则查找和替换操作." 注释 = "本类仅实现了大部分JavaScript RegExp语法." 折叠
        @文档 = "category = \"正则表达式\"" @别名 = "PivRegex<wchar_t>" @别名类型 = 本地类 @模板实现类 = "正则查找类" @强制依赖 = "正则匹配类">
{
    方法 查找 <公开 静态 类型 = 逻辑型 注释 = "以正则匹配方式查找指定的内容,如查找成功可通过\"取子匹配文本\"获取各个子匹配组的内容." 返回值注释 = "查找到匹配内容返回真,否则返回假."
            折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类>
    参数 欲匹配内容 <注释 = "提供所欲进行匹配的文本内容,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE编码)" @匹配类型 = 通用型
            @需求类型 = 可写入变量>
    参数 正则表达式 <注释 = "提供所欲使用的正则表达式文本,支持类型:" 注释 = " 文本型、标准文本类W、字节集类(UTF-16LE编码)" @匹配类型 = 通用型>
    参数 匹配模式 <类型 = 整数 注释 = "提供正则的匹配模式,为\"正则匹配标志\"中一个常量或多个常量的位或值." @默认值 = 正则匹配标志.无>
    {
        @ @<欲操作本对象>.Search(@<欲匹配内容>, @<正则表达式>, @<匹配模式>)
    }

    方法 查找下一个 <公开 静态 类型 = 逻辑型 注释 = "查找下一个匹配文本段." 注释 = "如果当前处于匹配状态(即调用过\"查找\"方法并返回真),则从当前匹配文本段的"
            注释 = "下一个字符处开始查找下一个匹配文本段." 返回值注释 = "存在下一个匹配文本段将返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类>
    {
        @ @<欲操作本对象>.SearchNext()
    }

    方法 替换 <公开 静态 类型 = 逻辑型 注释 = "用指定的格式文本替换当前正则查找到的文本段." 注释 = " 1. 需要在每次调用\"查找/查找下一个\"方法后执行,只能替换当前的匹配文本段;"
            注释 = " 2. 若不想替换当前的匹配文本段,只需要继续\"查找下一个\";" 注释 = " 3. 如果在单次\"查找/查找下一个\"后多次执行替换,相当于在上次替换的位置后面继续插入文本;"
            注释 = " 4. 本方法不会立即返回文本,需要在完成所有操作后,调用\"取替换文本/取替换视图\"来获取替换后的文本;" 返回值注释 = "返回是否替换成功" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类>
    参数 正则替换格式 <注释 = "提供所欲使用的替换格式内容;" 注释 = "支持使用\"\\0\"～\"\\9\"引用子匹配文本,注意反斜杠需要用\'\\\\\'转义;"
            注释 = "支持类型: 文本型、标准文本类W、字节集类(UTF-16LE编码);" @匹配类型 = 通用型>
    {
        @ @<欲操作本对象>.Replace(@<正则替换格式>)
    }

    方法 是否存在匹配 <公开 静态 类型 = 逻辑型 注释 = "检查上次执行\"查找/查找下一个\"是否查找到内容." 返回值注释 = "查找到内容返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类>
    {
        @ @<欲操作本对象>.IsMatch()
    }

    方法 取匹配文本 <公开 静态 类型 = 文本型 注释 = "调用\"查找/查找下一个\"方法后,获取与整个正则表达式匹配的文本." 注释 = "注: 等同于\"取子匹配文本 (0)\"."
            返回值注释 = "没有匹配内容将返回空文本" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类>
    {
        @ @<欲操作本对象>.GetMatchText<@an<CVolString>>()
    }

    方法 取匹配视图 <公开 静态 类型 = 文本视图类W 注释 = "调用\"查找/查找下一个\"方法后,获取与整个正则表达式匹配的文本视图."
            注释 = "注: 返回的文本视图直接引用\"查找\"的\"欲匹配内容\"数据." 返回值注释 = "没有匹配内容将返回空文本" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类>
    {
        @ @<欲操作本对象>.GetMatchText<@dt<文本视图类W>>()
    }

    方法 取子匹配数量 <公开 静态 类型 = 整数 注释 = "调用\"查找/查找下一个\"方法后,获取子匹配数量." 注释 = "注: 正则表达式里每一对括号表示一个子匹配组." 折叠
            @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类>
    {
        @ (INT)@<欲操作本对象>.GetGroupCount()
    }

    方法 取子匹配文本 <公开 静态 类型 = 文本型 注释 = "调用\"查找/查找下一个\"方法后获取所查找到的子匹配文本." 返回值注释 = "没有匹配内容,或索引超出范围将返回空文本." 折叠
            @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类>
    参数 索引 <类型 = 整数 注释 = "提供所欲获取子匹配内容的索引位置;" 注释 = "0表示获取整个匹配组内容,从1开始获取子匹配组内容.">
    {
        @ @<欲操作本对象>.GetGrounpText<@an<CVolString>>(static_cast<size_t>(@<索引>))
    }

    方法 取子匹配视图 <公开 静态 类型 = 文本视图类W 注释 = "调用\"查找/查找下一个\"方法后获取所查找到的子匹配文本视图."
            注释 = "注: 返回的文本视图直接引用\"查找\"的\"欲匹配内容\"数据." 返回值注释 = "没有匹配内容,或索引超出范围将返回空文本." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类>
    参数 索引 <类型 = 整数 注释 = "提供所欲获取子匹配内容的索引位置;" 注释 = "0表示获取整个匹配组内容,从1开始获取子匹配组内容.">
    {
        @ @<欲操作本对象>.GetGrounpText<@dt<文本视图类W>>(static_cast<size_t>(@<索引>))
    }

    方法 取替换文本 <公开 静态 类型 = 文本型 注释 = "获取正则替换后的文本." 注释 = " 1. 执行本方法后,将结束本次正则查找,直到重新执行\"查找\";"
            注释 = " 2. 未执行过\"替换\"的情况下,将返回所欲查找替换的原文;" 注释 = " 3. 未执行过\"查找\"将返回空文本;" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类>
    {
        @ @an<CVolString>(@<欲操作本对象>.GetReplacedText().c_str())
    }

    方法 取替换视图 <公开 静态 类型 = 文本视图类W 注释 = "获取正则替换后的文本视图." 注释 = " 1. 执行本方法后,将结束本次正则查找,直到重新执行\"查找\";"
            注释 = " 2. 未执行过\"替换\"的情况下,将返回所欲查找替换的原文;" 注释 = " 3. 未执行过\"查找\"将返回空文本;"
            注释 = " 4. 重新\"查找\"或本类被销毁后,请勿再使用返回的文本视图;" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类>
    {
        @ @dt<文本视图类W>(@<欲操作本对象>.GetReplacedText())
    }

    方法 清空 <公开 静态 注释 = "结束正则查找和替换,并释放本类占用的资源." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类>
    {
        @ @<欲操作本对象>.Clear()
    }
}

类 正则查找类U <公开 基础类 = PIV本地类模板 注释 = "提供UTF-8编码文本的正则查找和替换操作." 注释 = "本类仅实现了大部分JavaScript RegExp语法." 折叠
        @文档 = "category = \"正则表达式\"" @别名 = "PivRegex<char>" @别名类型 = 本地类 @模板实现类 = "正则查找类U" @强制依赖 = "正则匹配类">
{
    方法 查找 <公开 静态 类型 = 逻辑型 注释 = "以正则匹配方式查找指定的内容,如查找成功可通过\"取子匹配文本\"获取各个子匹配组的内容." 返回值注释 = "查找到匹配内容返回真,否则返回假."
            折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类U>
    参数 欲匹配内容 <注释 = "提供所欲进行匹配的文本内容,支持类型:" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8编码)" @匹配类型 = 通用型 @需求类型 = 可写入变量>
    参数 正则表达式 <注释 = "提供所欲使用的正则表达式文本,支持类型:" 注释 = " *文本型、标准文本类U、字节集类(UTF-8编码)" @匹配类型 = 通用型>
    参数 匹配模式 <类型 = 整数 注释 = "提供正则的匹配模式,为\"正则匹配标志\"中一个常量或多个常量的位或值." @默认值 = 正则匹配标志.无>
    {
        @ @<欲操作本对象>.Search(@<欲匹配内容>, @<正则表达式>, @<匹配模式>)
    }

    方法 查找下一个 <公开 静态 类型 = 逻辑型 注释 = "查找下一个匹配文本段." 注释 = "如果当前处于匹配状态(即调用过\"查找\"方法并返回真),则从当前匹配文本段的"
            注释 = "下一个字符处开始查找下一个匹配文本段." 返回值注释 = "存在下一个匹配文本段将返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类U>
    {
        @ @<欲操作本对象>.SearchNext()
    }

    方法 替换 <公开 静态 类型 = 逻辑型 注释 = "用指定的格式文本替换当前正则查找到的文本段." 注释 = " 1. 需要在每次调用\"查找/查找下一个\"方法后执行,只能替换当前的匹配文本段;"
            注释 = " 2. 若不想替换当前的匹配文本段,只需要继续\"查找下一个\";" 注释 = " 3. 如果在单次\"查找/查找下一个\"后多次执行替换,相当于在上次替换的位置后面继续插入文本;"
            注释 = " 4. 本方法不会立即返回文本,需要在完成所有操作后,调用\"取替换文本/取替换视图\"来获取替换后的文本;" 返回值注释 = "返回是否替换成功" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类U>
    参数 正则替换格式 <注释 = "提供所欲使用的替换格式内容;" 注释 = "支持使用\"\\0\"～\"\\9\"引用子匹配文本,注意反斜杠需要用\'\\\\\'转义;"
            注释 = "支持类型: *文本型、标准文本类U、字节集类(UTF-8编码);" @匹配类型 = 通用型>
    {
        @ @<欲操作本对象>.Replace(@<正则替换格式>)
    }

    方法 是否存在匹配 <公开 静态 类型 = 逻辑型 注释 = "检查上次执行\"查找/查找下一个\"是否查找到内容." 返回值注释 = "查找到内容返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类U>
    {
        @ @<欲操作本对象>.IsMatch()
    }

    方法 取匹配文本 <公开 静态 类型 = 标准文本类U 注释 = "调用\"查找/查找下一个\"方法后,获取与整个正则表达式匹配的文本." 注释 = "注: 等同于\"取子匹配文本 (0)\"."
            返回值注释 = "没有匹配内容将返回空文本" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类U>
    {
        @ @<欲操作本对象>.GetMatchText<std::string>()
    }

    方法 取匹配字节集 <公开 静态 类型 = 字节集类 注释 = "调用\"查找/查找下一个\"方法后,获取与整个正则表达式匹配的文本字节集." 注释 = "注: 等同于\"取子匹配字节集 (0)\"."
            返回值注释 = "没有匹配内容将返回空文本" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类U>
    {
        @ @<欲操作本对象>.GetMatchText<@an<CVolMem>>()
    }

    方法 取匹配视图 <公开 静态 类型 = 文本视图类U 注释 = "调用\"查找/查找下一个\"方法后,获取与整个正则表达式匹配的文本视图."
            注释 = "注: 返回的文本视图直接引用\"查找\"的\"欲匹配内容\"数据." 返回值注释 = "没有匹配内容将返回空文本" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类U>
    {
        @ @<欲操作本对象>.GetMatchText<@dt<文本视图类U>>()
    }

    方法 取子匹配数量 <公开 静态 类型 = 整数 注释 = "调用\"查找/查找下一个\"方法后,获取子匹配数量." 注释 = "注: 正则表达式里每一对括号表示一个子匹配组." 折叠
            @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类U>
    {
        @ (INT)@<欲操作本对象>.GetGroupCount()
    }

    方法 取子匹配文本 <公开 静态 类型 = 标准文本类U 注释 = "调用\"查找/查找下一个\"方法后获取所查找到的子匹配文本." 返回值注释 = "没有匹配内容,或索引超出范围将返回空文本." 折叠
            @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类U>
    参数 索引 <类型 = 整数 注释 = "提供所欲获取子匹配内容的索引位置;" 注释 = "0表示获取整个匹配组内容,从1开始获取子匹配组内容.">
    {
        @ @<欲操作本对象>.GetGrounpText<std::string>(static_cast<size_t>(@<索引>))
    }

    方法 取子匹配字节集 <公开 静态 类型 = 字节集类 注释 = "调用\"查找/查找下一个\"方法后获取所查找到的子匹配文本字节集." 返回值注释 = "没有匹配内容,或索引超出范围将返回空文本." 折叠
            @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类U>
    参数 索引 <类型 = 整数 注释 = "提供所欲获取子匹配内容的索引位置;" 注释 = "0表示获取整个匹配组内容,从1开始获取子匹配组内容.">
    {
        @ @<欲操作本对象>.GetGrounpText<@an<CVolMem>>(static_cast<size_t>(@<索引>))
    }

    方法 取子匹配视图 <公开 静态 类型 = 文本视图类U 注释 = "调用\"查找/查找下一个\"方法后获取所查找到的子匹配文本视图."
            注释 = "注: 返回的文本视图直接引用\"查找\"的\"欲匹配内容\"数据." 返回值注释 = "没有匹配内容,或索引超出范围将返回空文本." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类U>
    参数 索引 <类型 = 整数 注释 = "提供所欲获取子匹配内容的索引位置;" 注释 = "0表示获取整个匹配组内容,从1开始获取子匹配组内容.">
    {
        @ @<欲操作本对象>.GetGrounpText<@dt<文本视图类U>>(static_cast<size_t>(@<索引>))
    }

    方法 取替换文本 <公开 静态 类型 = 标准文本类U 注释 = "获取正则替换后的文本." 注释 = " 1. 执行本方法后,将结束本次正则查找,直到重新执行\"查找\";"
            注释 = " 2. 未执行过\"替换\"的情况下,将返回所欲查找替换的原文;" 注释 = " 3. 未执行过\"查找\"将返回空文本;" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类U>
    {
        @ @<欲操作本对象>.GetReplacedText()
    }

    方法 取替换视图 <公开 静态 类型 = 文本视图类U 注释 = "获取正则替换后的文本视图." 注释 = " 1. 执行本方法后,将结束本次正则查找,直到重新执行\"查找\";"
            注释 = " 2. 未执行过\"替换\"的情况下,将返回所欲查找替换的原文;" 注释 = " 3. 未执行过\"查找\"将返回空文本;"
            注释 = " 4. 重新\"查找\"或本类被销毁后,请勿再使用返回的文本视图;" 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类U>
    {
        @ @dt<文本视图类U>(@<欲操作本对象>.GetReplacedText())
    }

    方法 清空 <公开 静态 注释 = "结束正则查找和替换,并释放本类占用的资源." 折叠 @嵌入式方法 = "">
    参数 欲操作本对象 <类型 = 正则查找类U>
    {
        @ @<欲操作本对象>.Clear()
    }
}

类 正则匹配标志 <公开 注释 = "提供了常用的正则匹配模式" 折叠 @文档 = "category = \"正则表达式.辅助类\"">
{
    常量 无 <公开 类型 = 整数 值 = 0 注释 = "不使用任何匹配标志">
    常量 单行模式 <公开 类型 = 整数 值 = 0x1 注释 = "使小数点\'.\'可以匹配包含换行符\'\\n\'在内的任意字符;"
            注释 = "默认情况下,小数点只匹配换行符以外的任意字符,不匹配换行符.">
    常量 忽略大小写 <公开 类型 = 整数 值 = 0x2 注释 = "匹配时忽略大小写,默认情况下,正则表达式是区分大小写." 注释 = "注意: 本正则库的忽略大小写对[A-Z]和[a-z]也会生效.">
    常量 禁止缓存文本 <公开 类型 = 整数 值 = 0x4 注释 = "  默认情况下,执行\"查找\"方法会将\"欲匹配内容\"的文本数据缓存到\"正则查找类\"的内部," 注释 = "" 注释 = ""
            注释 = ",因此性能更高," 注释 = "但如果在查找后修改了\"欲匹配内容\"的文本变量,将无法继续获取匹配内容."
            注释 = "  使用本标志后,\"正则查找类\"将缓存所欲匹配的文本内容,你无需在意提交的文本数据" 注释 = "是否会被修改,但这会带来一定的性能损失.">
}

# 文本处理 ====

类 文本P <公开 注释 = "一些文本操作相关的辅助方法(通过类名调用)" 折叠 @禁止创建对象 = 真 @文档 = "category = \"文本操作\""
        "@视窗.外部头文件.全局-111" = "src\\piv_encoding.hpp">
{
    方法 文本逻辑比较 <公开 静态 类型 = 整数 注释 = "比较两个文本,返回逻辑比较结果." 返回值注释 = "如果返回值小于0,表示本文本小于所比较文本;"
            返回值注释 = "如果等于0,表示本文本等于所比较文本;" 返回值注释 = "如果大于0,表示本文本大于所比较文本." 折叠 @嵌入式方法 = "" @视窗.外部头文件 = "shlwapi.h"
            @视窗.外部库 = "Shlwapi.lib">
    参数 所欲操作的文本 <类型 = 文本型>
    参数 所欲比较的文本 <类型 = 文本型 注释 = "提供所欲比较的文本">
    {
        @ StrCmpLogicalW (@<所欲操作的文本>.GetText (), @<所欲比较的文本>.GetText ())
    }

    方法 多字节数组到文本 <公开 静态 类型 = 文本型 注释 = "将ANSI编码的字节数组转换为火山的文本型." 折叠 @嵌入式方法 = "">
    参数 多字节数组 <类型 = "字节 []" 注释 = "必须是带结束零字符的字节数组">
    参数 代码页 <类型 = 整数 注释 = "默认值0表示使用本地编码,常用代码页:" 注释 = "  932 日文(Shift-JIS)" 注释 = "  936 中文简体(GB2312)"
            注释 = "  949 韩文" 注释 = "  950 中文繁体(Big5)" @默认值 = 0>
    {
        @ PivA2Ws{reinterpret_cast<const char *>(@<多字节数组>), static_cast<size_t>(-1), static_cast<uint32_t>(@<代码页>)}.str
        // @ @an<CVolString> (GetWideText ((const CHAR*)@<多字节数组>, CVolMem (), NULL))
    }

    方法 UTF8指针到文本 <公开 静态 类型 = 文本型 注释 = "将UTF-8的文本指针转换为火山的文本型." 折叠 @嵌入式方法 = "">
    参数 UTF8文本指针 <类型 = 变整数 注释 = "必须是带结束零字符的UTF8文本指针">
    {
        @ PivU2Ws{reinterpret_cast<const char *>(@<UTF8文本指针>)}.str
        // @ @an<CVolString> (Utf8ToWStr ((const U8CHAR*)@<UTF8文本指针>, -1, CVolMem ()))
    }

    方法 UTF8字节数组到文本 <公开 静态 类型 = 文本型 注释 = "将UTF-8编码的字节数组转换为火山的文本型." 折叠 @嵌入式方法 = "">
    参数 UTF8字节数组 <类型 = "字节 []" 注释 = "必须是带结束零字符的字节数组">
    {
        @ PivU2Ws{reinterpret_cast<const char *>(@<UTF8字节数组>)}.str
        // @ @an<CVolString> (Utf8ToWStr ((const U8CHAR*)@<UTF8字节数组>, -1, CVolMem ()))
    }

    方法 取所有中间文本 <公开 静态 类型 = 文本数组类 注释 = "(过时)获取所有两段文本中间的内容" 返回值注释 = "返回所获取的文本数组" 折叠>
    参数 文本数据 <类型 = 文本型 注释 = "所欲取中间文本的数据">
    参数 开始文本 <类型 = 文本型 注释 = "中间文本前面的内容,不会出现在结果中.">
    参数 结束文本 <类型 = 文本型 注释 = "中间文本后面的内容,不会出现在结果中.">
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    {
        变量 结果数组 <类型 = 文本数组类>
        变量 开始文本长度 <类型 = 整数>
        变量 结束文本长度 <类型 = 整数>
        变量 开始位置 <类型 = 整数 值 = 0>
        变量 结束位置 <类型 = 整数 值 = 0>
        开始文本长度 = 取文本长度 (开始文本)
        结束文本长度 = 取文本长度 (结束文本)
        判断循环 (真)
        {
            开始位置 = 寻找文本 (文本数据, 开始文本, 结束位置, 是否不区分大小写)
            如果 (开始位置 == -1)
            {
                跳出循环
            }
            开始位置 = 开始位置 + 开始文本长度
            结束位置 = 寻找文本 (文本数据, 结束文本, 开始位置, 是否不区分大小写)
            如果 (结束位置 == -1)
            {
                跳出循环
            }
            结果数组.加入成员 (取文本中间 (文本数据, 开始位置, 结束位置 - 开始位置))
            开始位置 = 结束位置 + 结束文本长度

        }
        返回 (结果数组)
    }

    方法 取所有中间文本Ex <公开 静态 类型 = 整数 注释 = "获取所有两段文本中间的内容" 返回值注释 = "中间文本的数量" 折叠>
    参数 文本数据 <类型 = 文本型 注释 = "所欲取中间文本的数据">
    参数 结果数组 <类型 = 文本数组类 注释 = "返回所获取的文本数组">
    参数 开始文本 <类型 = 文本型 注释 = "中间文本前面的内容,不会出现在结果中.">
    参数 结束文本 <类型 = 文本型 注释 = "中间文本后面的内容,不会出现在结果中.">
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    参数 忽略空白结果 <类型 = 逻辑型 注释 = "是否忽略空白的中间文本,不加入到结果数组." @默认值 = 真>
    {
        变量 开始文本长度 <类型 = 整数>
        变量 结束文本长度 <类型 = 整数>
        变量 开始位置 <类型 = 整数 值 = 0>
        变量 结束位置 <类型 = 整数 值 = 0>
        变量 中间文本 <类型 = 文本型>
        结果数组.删除所有成员 ()
        开始文本长度 = 取文本长度 (开始文本)
        结束文本长度 = 取文本长度 (结束文本)
        判断循环 (真)
        {
            开始位置 = 寻找文本 (文本数据, 开始文本, 结束位置, 是否不区分大小写)
            如果 (开始位置 == -1)
            {
                跳出循环
            }
            开始位置 = 开始位置 + 开始文本长度
            结束位置 = 寻找文本 (文本数据, 结束文本, 开始位置, 是否不区分大小写)
            如果 (结束位置 == -1)
            {
                跳出循环
            }
            中间文本 = 取文本中间 (文本数据, 开始位置, 结束位置 - 开始位置)
            如果 (文本是否为空 (中间文本) == 假 || 忽略空白结果 == 假)
            {
                结果数组.加入成员 (中间文本)
            }
            开始位置 = 结束位置 + 结束文本长度
        }
        返回 (结果数组.取成员数 ())
    }

    方法 取子文本中间 <公开 静态 类型 = 文本型 注释 = "取出两段文本中间的内容" 折叠 "">
    参数 文本内容 <类型 = 文本型 注释 = "所欲取文本中间的原始文本">
    参数 开始文本 <类型 = 文本型 注释 = "提供所欲查找的开始文本内容">
    参数 结束文本 <类型 = 文本型 注释 = "提供所欲查找的结束文本内容">
    参数 起始搜寻位置 <类型 = 整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本." @默认值 = 假>
    {
        变量 开始位置 <类型 = 整数>
        开始位置 = 寻找文本 (文本内容, 开始文本, 起始搜寻位置, 是否不区分大小写)
        如果 (开始位置 == -1)
        {
            返回 (选择 (失败返回原文本, 文本内容, ""))
        }
        起始搜寻位置 = 开始位置 + 取文本长度 (开始文本)
        变量 结束位置 <类型 = 整数>
        结束位置 = 寻找文本 (文本内容, 结束文本, 起始搜寻位置, 是否不区分大小写)
        如果 (结束位置 == -1)
        {
            返回 (选择 (失败返回原文本, 文本内容, ""))
        }
        如果 (是否包含开始文本 == 假)
        {
            开始位置 = 起始搜寻位置
        }
        返回 (取文本中间 (文本内容, 开始位置, 结束位置 - 开始位置 + 选择 (是否包含结束文本, 取文本长度 (结束文本), 0)))
    }

    方法 取子文本左边 <公开 静态 类型 = 文本型 注释 = "寻找文本,然后取出找到的文本左边的内容." 折叠 "">
    参数 被查找的文本 <类型 = 文本型>
    参数 要查找的文本 <类型 = 文本型>
    参数 起始搜寻位置 <类型 = 整数 @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "默认为从左到右找,真为从右往左找." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到就返回原文本,默认为返回空文本." @默认值 = 假>
    {
        变量 找到的位置 <类型 = 整数>
        如果 (是否反向查找 == 真)
        {
            找到的位置 = 倒找文本 (被查找的文本, 要查找的文本, 选择 (起始搜寻位置 == 0, -1, 起始搜寻位置), 是否不区分大小写)
        }
        否则
        {
            找到的位置 = 寻找文本 (被查找的文本, 要查找的文本, 起始搜寻位置, 是否不区分大小写)
        }
        如果 (找到的位置 != -1)
        {
            返回 (取文本左边 (被查找的文本, 找到的位置))
        }
        否则
        {
            返回 (选择 (失败返回原文本, 被查找的文本, ""))

        }
    }

    方法 取子文本右边 <公开 静态 类型 = 文本型 注释 = "寻找文本,然后取出找到的文本右边的内容." 折叠 "">
    参数 被查找的文本 <类型 = 文本型 "">
    参数 要查找的文本 <类型 = 文本型>
    参数 起始搜寻位置 <类型 = 整数 @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "默认为从左到右找,真为从右往左找." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到就返回原文本,默认为返回空文本." @默认值 = 假>
    {
        变量 找到的位置 <类型 = 整数>
        如果 (是否反向查找 == 真)
        {
            找到的位置 = 倒找文本 (被查找的文本, 要查找的文本, 选择 (起始搜寻位置 == 0, -1, 起始搜寻位置), 是否不区分大小写)
        }
        否则
        {
            找到的位置 = 寻找文本 (被查找的文本, 要查找的文本, 起始搜寻位置, 是否不区分大小写)
        }
        如果 (找到的位置 != -1)
        {
            返回 (取文本右边 (被查找的文本, 取文本长度 (被查找的文本) - 找到的位置 - 取文本长度 (要查找的文本)))
        }
        否则
        {
            返回 (选择 (失败返回原文本, 被查找的文本, ""))

        }
    }

    方法 取随机文本 <公开 静态 类型 = 文本型 注释 = "获取指定类型的随机文本" 返回值注释 = "成功返回指定字符数的随机文本,失败返回空文本." 折叠 @禁止流程检查 = 真>
    参数 欲取字符数 <类型 = 整数 注释 = "要取的字符个数">
    参数 字符类型 <类型 = 整数 注释 = "为以下数值相加值或位或值,默认为1+2+4;" 注释 = "  1、数字;" 注释 = "  2、小写字母;" 注释 = "  4、大写字母;"
            注释 = "  8、特殊符号;" @默认值 = 7>
    {
        @ TCHAR Buffer[96] { 0 };
        @ if ((@<字符类型> & 1) == 1) wcscat (Buffer, L"0123456789");
        @ if ((@<字符类型> & 2) == 2) wcscat (Buffer, L"abcdefghijklmnopqrstuvwxyz");
        @ if ((@<字符类型> & 4) == 4) wcscat (Buffer, L"ABCDEFGHIJKLMNOPQRSTUVWXYZ");
        @ if ((@<字符类型> & 8) == 8) wcscat (Buffer, L" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~");
        @ size_t Offset = wcslen (Buffer) - 1;
        @ if (Offset <= 0) return @an<CVolString>(L"");
        @ CVolString szStr;
        @ wchar_t* pStr = szStr.InitWithChars (@<欲取字符数>, ' ');
        @ for (INT i = 0; i < @<欲取字符数>; i++) {
        @     pStr[i] = Buffer[randint (0, Offset)];
        @ }
        @ return szStr;
    }
}

类 文本处理类 <公开 注释 = "一些文本操作相关的全局辅助方法" 注释 = "" 折叠 @文档 = "category = \"文本操作\"" @全局类 = 真 @禁止创建对象 = 真>
{

    # 简写版(UTF-8) ---

    方法 _sv <公开 静态 类型 = 文本视图类U 注释 = "创建一个UTF-8编码的文本视图,并将它指向填入的字符串字面量." 注释 = "注: 等同于\"创建文本视图U\""
            返回值注释 = "返回所创建的文本视图(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @dt<文本视图类U>{reinterpret_cast<const char *>(u8@sn<quot>@pvpt<文本字面量>@sn<quot>)}
    }

    方法 _u8 <公开 静态 类型 = 常量字符串指针 注释 = "通过字符串字面量创建一个UTF-8编码文本指针." 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ reinterpret_cast<const char *>(u8@sn<quot>@pvpt<文本字面量>@sn<quot>)
    }

    # ---

    方法 创建文本对象W <公开 静态 类型 = 标准文本类W 注释 = "通过字符串字面量创建一个UTF-16LE编码文本对象." 注释 = "本方法不会产生文本编码转换."
            返回值注释 = "返回所创建的标准文本类(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @dt<标准文本类W>{L@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    方法 创建文本对象U <公开 静态 类型 = 标准文本类U 注释 = "通过字符串字面量创建一个UTF-8编码文本对象." 注释 = "本方法不会产生文本编码转换."
            返回值注释 = "返回所创建的标准文本类(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @dt<标准文本类U>{reinterpret_cast<const char*>(u8@sn<quot>@pvpt<文本字面量>@sn<quot>)}
    }

    方法 创建文本对象A <公开 静态 类型 = 标准文本类A 注释 = "通过字符串字面量创建一个ANSI多字节编码文本对象." 注释 = "本方法不会产生文本编码转换."
            返回值注释 = "返回所创建的标准文本类(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @dt<标准文本类A>{@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    方法 创建文本视图W <公开 静态 类型 = 文本视图类W 注释 = "创建一个UTF-16LE编码的文本视图,并将它指向填入的字符串字面量." 注释 = "本方法不会产生文本复制和文本编码转换."
            返回值注释 = "返回所创建的文本视图(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @dt<文本视图类W>{L@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    方法 创建文本视图U <公开 静态 类型 = 文本视图类U 注释 = "创建一个UTF-8编码的文本视图,并将它指向填入的字符串字面量." 注释 = "本方法不会产生文本复制和文本编码转换."
            返回值注释 = "返回所创建的文本视图(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @dt<文本视图类U>{reinterpret_cast<const char *>(u8@sn<quot>@pvpt<文本字面量>@sn<quot>)}
    }

    方法 创建文本视图A <公开 静态 类型 = 文本视图类A 注释 = "创建一个ANSI多字节编码的文本视图,并将它指向填入的字符串字面量." 注释 = "本方法不会产生文本复制和文本编码转换."
            返回值注释 = "返回所创建的文本视图(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @dt<文本视图类A>{@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    # ====
    # 如需使用以下的过时功能,请在项目属性的编译时预定义宏中添加 PIV_ENABLE_OBSOLETE
    # ====

    方法 版本号比较 <公开 静态 类型 = 整数 注释 = "请改用\"文本P.文本逻辑比较\"." 注释 = "比较两个软件版本号,能正确返回12>2(默认的文本比较是12<2)."
            返回值注释 = "版本一大于版本二返回1,版本一等于版本二返回0,版本一小于版本二返回-1." 折叠 @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 版本一 <类型 = 文本型 注释 = "可以是任意形式的版本号,请填写正确的分隔符.">
    参数 版本二 <类型 = 文本型 注释 = "比较的两个版本号格式应当一致">
    参数 分隔符 <类型 = 文本型 注释 = "可以是多个字符的集合,提供空文本表示不分隔." @默认值 = ".-">
    {
        如果 (版本一 == 版本二)
        {
            返回 (0)
        }
        如果 (文本是否为空 (版本一) == 真)
        {
            返回 (-1)
        }
        如果 (文本是否为空 (版本二) == 真)
        {
            返回 (1)
        }
        变量 子版本一 <类型 = 文本数组类>
        变量 子版本二 <类型 = 文本数组类>
        变量 子数量一 <类型 = 整数>
        变量 子数量二 <类型 = 整数>
        子数量一 = 分割文本 (版本一, 分隔符, 子版本一)
        子数量二 = 分割文本 (版本二, 分隔符, 子版本二)
        变量 较大值 <类型 = 整数>
        变量 较小值 <类型 = 整数>
        变量 版本文本一 <类型 = 文本型>
        变量 版本文本二 <类型 = 文本型>
        变量 分隔符二 <类型 = 文本型>
        置文本预分配字符数 (版本文本一, 取文本长度 (版本一) * 2)
        置文本预分配字符数 (版本文本二, 取文本长度 (版本一) * 2)
        如果 (取文本长度 (分隔符) > 1)
        {
            分隔符二 = 取文本左边 (分隔符, 1)
        }
        否则
        {
            分隔符二 = 分隔符
        }
        较大值 = 取较大值 (子数量一, 子数量二)
        较小值 = 取较小值 (子数量一, 子数量二)
        // 第一组
        版本文本一 = 子版本一.取成员 (0)
        版本文本二 = 子版本二.取成员 (0)
        如果 (取文本长度 (版本文本一) > 取文本长度 (版本文本二))
        {
            版本文本二 = 取重复文本 ("0", 取文本长度 (版本文本一) - 取文本长度 (版本文本二)) + 版本文本二
        }
        否则 (取文本长度 (版本文本一) < 取文本长度 (版本文本二))
        {
            版本文本一 = 取重复文本 ("0", 取文本长度 (版本文本二) - 取文本长度 (版本文本一)) + 版本文本一
        }
        // 第二至N组
        变量 索引 <类型 = 整数>
        循环 (1, 较大值, 索引, 1)
        {
            变量 文本一 <类型 = 文本型>
            变量 文本二 <类型 = 文本型>
            如果 (索引 < 较小值)
            {
                变量 长度一 <类型 = 整数>
                变量 长度二 <类型 = 整数>
                文本一 = 子版本一.取成员 (索引)
                文本二 = 子版本二.取成员 (索引)
                长度一 = 取文本长度 (文本一)
                长度二 = 取文本长度 (文本二)
                如果 (长度一 == 长度二)
                {
                    加入文本 (版本文本一, 分隔符二 + 文本一)
                    加入文本 (版本文本二, 分隔符二 + 文本二)
                }
                否则 (长度一 > 长度二)
                {
                    加入文本 (版本文本一, 分隔符二 + 文本一)
                    加入文本 (版本文本二, 分隔符二 + 取重复文本 ("0", 长度一 - 长度二) + 文本二)
                }
                否则 (长度一 < 长度二)
                {
                    加入文本 (版本文本一, 分隔符二 + 取重复文本 ("0", 长度二 - 长度一) + 文本一)
                    加入文本 (版本文本二, 分隔符二 + 文本二)
                }
            }
            否则
            {
                如果 (较大值 == 子数量一)
                {
                    文本一 = 子版本一.取成员 (索引)
                    加入文本 (版本文本一, 分隔符二 + 文本一)
                    加入文本 (版本文本二, 分隔符二 + 取重复文本 ("0", 取文本长度 (文本一)))
                }
                否则
                {
                    文本二 = 子版本二.取成员 (索引)
                    加入文本 (版本文本一, 分隔符二 + 取重复文本 ("0", 取文本长度 (文本二)))
                    加入文本 (版本文本二, 分隔符二 + 文本二)

                }
            }
        }
        返回 (文本比较 (版本文本一, 版本文本二))
    }

    方法 文本_多字节指针到文本 <公开 静态 类型 = 文本型 注释 = "官方已有一样的方法\"多字节指针到文本\"." 注释 = "将ANSI的文本指针转换为火山的文本型." 折叠 @嵌入式方法 = ""
            @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 多字节文本指针 <类型 = 变整数 注释 = "必须是带结束零字符的多字节文本指针">
    {
        @ @an<CVolString> (GetWideText ((const CHAR*)@<多字节文本指针>, CVolMem (), NULL))
    }

    方法 文本_UTF8指针到文本 <公开 静态 类型 = 文本型 注释 = "请改用\"文本P.UTF8指针到文本\"." 注释 = "将UTF-8的文本指针转换为火山的文本型." 折叠
            @嵌入式方法 = "" @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 UTF8文本指针 <类型 = 变整数 注释 = "必须是带结束零字符的UTF8文本指针">
    {
        @ @an<CVolString> (Utf8ToWStr ((const U8CHAR*)@<UTF8文本指针>, -1, CVolMem ()))
    }

    方法 文本_取文本中间_批量 <公开 静态 类型 = 文本数组类 注释 = "请改用\"文本P.取所有中间文本\"." 折叠 @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 文本数据 <类型 = 文本型>
    参数 开始文本 <类型 = 文本型>
    参数 结束文本 <类型 = 文本型>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    {
        变量 结果数组 <类型 = 文本数组类>
        变量 开始文本长度 <类型 = 整数>
        变量 结束文本长度 <类型 = 整数>
        变量 开始位置 <类型 = 整数 值 = 0>
        变量 结束位置 <类型 = 整数 值 = 0>
        开始文本长度 = 取文本长度 (开始文本)
        结束文本长度 = 取文本长度 (结束文本)
        判断循环 (真)
        {
            开始位置 = 寻找文本 (文本数据, 开始文本, 结束位置, 是否不区分大小写)
            如果 (开始位置 == -1)
            {
                跳出循环
            }
            开始位置 = 开始位置 + 开始文本长度
            结束位置 = 寻找文本 (文本数据, 结束文本, 开始位置, 是否不区分大小写)
            如果 (结束位置 == -1)
            {
                跳出循环
            }
            结果数组.加入成员 (取文本中间 (文本数据, 开始位置, 结束位置 - 开始位置))
            开始位置 = 结束位置 + 结束文本长度

        }
        返回 (结果数组)
    }

    方法 文本_取文本中间 <公开 静态 类型 = 文本型 注释 = "请改用\"文本P.取子文本中间\"." 注释 = "取出两段文本中间的内容" 折叠
            @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 文本内容 <类型 = 文本型 注释 = "所欲取文本中间的原始文本">
    参数 开始文本 <类型 = 文本型 注释 = "提供所欲查找的开始文本内容">
    参数 结束文本 <类型 = 文本型 注释 = "提供所欲查找的结束文本内容">
    参数 起始搜寻位置 <类型 = 整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        变量 开始位置 <类型 = 整数>
        开始位置 = 寻找文本 (文本内容, 开始文本, 起始搜寻位置, 是否不区分大小写)
        如果 (开始位置 == -1)
        {
            返回 (选择 (失败返回原文本, 文本内容, ""))
        }
        起始搜寻位置 = 开始位置 + 取文本长度 (开始文本)
        变量 结束位置 <类型 = 整数>
        结束位置 = 寻找文本 (文本内容, 结束文本, 起始搜寻位置, 是否不区分大小写)
        如果 (结束位置 == -1)
        {
            返回 (选择 (失败返回原文本, 文本内容, ""))
        }
        如果 (是否包含开始文本 == 假)
        {
            开始位置 = 起始搜寻位置
        }
        返回 (取文本中间 (文本内容, 开始位置, 结束位置 - 开始位置 + 选择 (是否包含结束文本, 取文本长度 (结束文本), 0)))
    }

    方法 文本_取文本左边 <公开 静态 类型 = 文本型 注释 = "请改用\"文本P.取子文本左边\"." 注释 = "寻找文本,然后取出找到的文本左边的内容." 折叠
            @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 被查找的文本 <类型 = 文本型>
    参数 要查找的文本 <类型 = 文本型>
    参数 起始搜寻位置 <类型 = 整数 @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "默认为从左到右找；真为从右往左找" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        变量 找到的位置 <类型 = 整数>
        如果 (是否反向查找 == 真)
        {
            找到的位置 = 倒找文本 (被查找的文本, 要查找的文本, 选择 (起始搜寻位置 == 0, -1, 起始搜寻位置), 是否不区分大小写)
        }
        否则
        {
            找到的位置 = 寻找文本 (被查找的文本, 要查找的文本, 起始搜寻位置, 是否不区分大小写)
        }
        如果 (找到的位置 != -1)
        {
            返回 (取文本左边 (被查找的文本, 找到的位置))
        }
        否则
        {
            返回 (选择 (失败返回原文本, 被查找的文本, ""))

        }
    }

    方法 文本_取文本右边 <公开 静态 类型 = 文本型 注释 = "请改用\"文本P.取子文本右边\"." 注释 = "寻找文本,然后取出找到的文本右边的内容." 折叠
            @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 被查找的文本 <类型 = 文本型 "">
    参数 要查找的文本 <类型 = 文本型>
    参数 起始搜寻位置 <类型 = 整数 @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "默认为从左到右找；真为从右往左找" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        变量 找到的位置 <类型 = 整数>
        如果 (是否反向查找 == 真)
        {
            找到的位置 = 倒找文本 (被查找的文本, 要查找的文本, 选择 (起始搜寻位置 == 0, -1, 起始搜寻位置), 是否不区分大小写)
        }
        否则
        {
            找到的位置 = 寻找文本 (被查找的文本, 要查找的文本, 起始搜寻位置, 是否不区分大小写)
        }
        如果 (找到的位置 != -1)
        {
            返回 (取文本右边 (被查找的文本, 取文本长度 (被查找的文本) - 找到的位置 - 取文本长度 (要查找的文本)))
        }
        否则
        {
            返回 (选择 (失败返回原文本, 被查找的文本, ""))

        }
    }

    方法 文本_取随机文本 <公开 静态 类型 = 文本型 注释 = "请改用\"文本P.取随机文本\"." 注释 = "获取指定类型的随机文本."
            返回值注释 = "成功返回指定字符数的随机文本,失败返回空文本." 折叠 @禁止流程检查 = 真 @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 欲取字符数 <类型 = 整数 注释 = "要取的字符个数">
    参数 字符类型 <类型 = 整数 注释 = "为以下数值相加值或位或值,默认为1+2+4;" 注释 = "  1、数字" 注释 = "  2、小写字母" 注释 = "  4、大写字母"
            注释 = "  8、特殊符号" @默认值 = 7>
    {
        @ TCHAR Buffer[96] { 0 };
        @ if ((@<字符类型> & 1) == 1) wcscat (Buffer, L"0123456789");
        @ if ((@<字符类型> & 2) == 2) wcscat (Buffer, L"abcdefghijklmnopqrstuvwxyz");
        @ if ((@<字符类型> & 4) == 4) wcscat (Buffer, L"ABCDEFGHIJKLMNOPQRSTUVWXYZ");
        @ if ((@<字符类型> & 8) == 8) wcscat (Buffer, L" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~");
        @ size_t Offset = wcslen (Buffer) - 1;
        @ if (Offset <= 0) return @an<CVolString>(L"");
        @ CVolString szStr;
        @ szStr.SetLength (@<欲取字符数>);
        @ SetRandSeed (0);
        @ for (INT i = 0; i < @<欲取字符数>; i++) {
        @     wcsncpy ((wchar_t*)szStr.GetText () + i, Buffer + randint (0, Offset), 1);
        @ }
        @ return szStr;
    }
}

# 文本格式(std::format) ====

类 标准格式化类 <公开 注释 = "  {fmt}是一个文本格式化库,已经进入了C++20标准(std::format)," 注释 = "因为火山暂时不兼容C++20,所以这里封装了原型的{fmt}."
        注释 = "  {fmt}的执行效率比核心库的\"取格式文本\"高,格式也更自由多变." 注释 = "  版本: 9.1.0" 注释 = "  格式文本的语法请参考:"
        注释 = "  https://fmt.dev/latest/syntax.html"
        注释 = "  https://www.apiref.com/cpp-zh/cpp/utility/format/formatter.html" 折叠
        @文档 = "category = \"文本操作\"" @视窗.外部头文件 = "src\\piv_fmt.h" @视窗.附加编译参数 = "cpp: /std:c++17" @全局类 = 真>
{
    方法 取标准格式文本 <公开 静态 类型 = 文本型 注释 = "使用{fmt}格式化文本,然后返回结果文本."
            注释 = "例如: 取标准格式文本 (\"{1:>06}的{0}: {1:#06X}\", \"十六进制\", 2022)" 注释 = "结果: \"002022的十六进制: 0X07E6\"" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 格式文本 <类型 = 文本型 注释 = "  \"{[参数ID][:][填充字符][对齐][符号][#][0][宽度][.精度][L][类型]}\""
            注释 = "  一个标准的替换字段如上,只有首尾的\"{\"和\"}\"字符是必须,其他均可空,全部留" 注释 = "空则是按顺序把替换参数填进去."
            注释 = "  [参数ID]的范围是0-9,表示替换参数的顺序,同一个\"参数ID\"可以在\"格式文本\"" 注释 = "中多次出现."
            注释 = "  [:]选项可空,但如果要使用后面的选项则必须填写." 注释 = "  [填充字符]默认为空格,可填写除了\"{\"和\"}\"以外的任意单个字符;"
            注释 = "  [对齐]选项可用[<][>][^]之一,分别为靠左、靠右和居中对齐.数值参数默认靠" 注释 = "右对齐,其余参数默认靠左对齐."
            注释 = "  [符号]选项可用[+][-][ ],[+]表示在所有数值前插入加号或负号; [-]为默" 注释 = "认值,表示仅在负数前插入负号; [ ]表示在正数前插入空格,负数前插入负号."
            注释 = "  [#]选项只能用于数值参数,在输出2进制、8进制或16进制数值时加上前缀,比如" 注释 = "2进制的\"0b\"、8进制的\"0\"、16进制的\"0x\"."
            注释 = "  [0]只能用于数值参数,填充数字0来对齐,[填充字符]的优先级会高于此选项." 注释 = "  [宽度]选项指定填充对齐的最小宽度,可以使用\"{}\"实现动态宽度."
            注释 = "  [.精度]选项仅用于小数值,其中[精度]为十进制值,用来指定显示小数点后多少" 注释 = "位数字,如\"{:.2f}\"为显示小数点后两位.[精度]可以使用\"{}\"实现动态精度."
            注释 = "  [L]使用本地区域设置插入适当的数字分隔符,此选项仅对数字类型有效." 注释 = "  [类型]选项如下:" 注释 = "    s : 文本型(可省略)"
            注释 = "    c : 字符(可省略)" 注释 = "    b ：整数(以二进制替换,前缀为\"0b\")" 注释 = "    B ：整数(以二进制替换,前缀为\"0B\")"
            注释 = "    c : 整数(将数值转换为字符替换)" 注释 = "    d ：整数(以十进制格式替换,可省略)" 注释 = "    o ：整数(以八进制格式替换)"
            注释 = "    x ：整数(以小写的十六进制替换,前缀为\"0x\")" 注释 = "    X ：整数(以大写的十六进制替换,前缀为\"0X\")"
            注释 = "    a : 小数(以小写的十六进制格式替换,小数点9之后使用指数表示)" 注释 = "    A : 小数(以大写的十六进制格式替换,小数点9之后使用指数表示)"
            注释 = "    e : 小数(以指数格式替换,小写符号)" 注释 = "    E : 小数(以指数格式替换,大写符号)" 注释 = "    f : 小数(以非指数格式替换,小写符号)"
            注释 = "    F : 小数(以非指数格式替换,大写符号)" 注释 = "    g : 小数(根据值大小自动选择是否以指数格式替换,小写符号)"
            注释 = "    G : 小数(根据值大小自动选择是否以指数格式替换,大写符号)">
    参数 替换数据 <注释 = "  用作给格式文本中的替换字段提供替换参数,替换参数和替换字段的数量可以不" 注释 = "一致. 如果替换字段中用了\"参数ID\",需要注意替换参数的顺序."
            注释 = "  支持类型: 通用数值型、文本型、标准文本类W、文本视图类" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @an<CVolString>{fmt::format(fmt::runtime(PivS2WV{@<格式文本>}.sv), @<替换数据>).c_str()}
    }

    方法 标准格式化输出 <公开 静态 注释 = "使用{fmt}格式化文本,然后输出到控制台,默认不带换行符."
            注释 = "例如: 标准格式化输出 (\"{:#^20}\", \"Hello World!\")" 注释 = "结果: \"####Hello World!####\"" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 格式文本 <类型 = 文本型 注释 = "  \"{[参数ID][:][填充字符][对齐][符号][#][0][宽度][.精度][L][类型]}\""
            注释 = "  一个标准的替换字段如上,只有首尾的\"{\"和\"}\"字符是必须,其他均可空,全部留" 注释 = "空则是按顺序把替换参数填进去."
            注释 = "  [参数ID]的范围是0-9,表示替换参数的顺序,同一个\"参数ID\"可以在\"格式文本\"" 注释 = "中多次出现."
            注释 = "  [:]选项可空,但如果要使用后面的选项则必须填写." 注释 = "  [填充字符]默认为空格,可填写除了\"{\"和\"}\"以外的任意单个字符;"
            注释 = "  [对齐]选项可用[<][>][^]之一,分别为靠左、靠右和居中对齐.数值参数默认靠" 注释 = "右对齐,其余参数默认靠左对齐."
            注释 = "  [符号]选项可用[+][-][ ],[+]表示在所有数值前插入加号或负号; [-]为默" 注释 = "认值,表示仅在负数前插入负号; [ ]表示在正数前插入空格,负数前插入负号."
            注释 = "  [#]选项只能用于数值参数,在输出2进制、8进制或16进制数值时加上前缀,比如" 注释 = "2进制的\"0b\"、8进制的\"0\"、16进制的\"0x\"."
            注释 = "  [0]只能用于数值参数,填充数字0来对齐,[填充字符]的优先级会高于此选项." 注释 = "  [宽度]选项指定填充对齐的最小宽度,可以使用\"{}\"实现动态宽度."
            注释 = "  [.精度]选项仅用于小数值,其中[精度]为十进制值,用来指定显示小数点后多少" 注释 = "位数字,如\"{:.2f}\"为显示小数点后两位.[精度]可以使用\"{}\"实现动态精度."
            注释 = "  [L]使用本地区域设置插入适当的数字分隔符,此选项仅对数字类型有效." 注释 = "  [类型]选项如下:" 注释 = "    s : 文本型(可省略)"
            注释 = "    c : 字符(可省略)" 注释 = "    b ：整数(以二进制替换,前缀为\"0b\")" 注释 = "    B ：整数(以二进制替换,前缀为\"0B\")"
            注释 = "    c : 整数(将数值转换为字符替换)" 注释 = "    d ：整数(以十进制格式替换,可省略)" 注释 = "    o ：整数(以八进制格式替换)"
            注释 = "    x ：整数(以小写的十六进制替换,前缀为\"0x\")" 注释 = "    X ：整数(以大写的十六进制替换,前缀为\"0X\")"
            注释 = "    a : 小数(以小写的十六进制格式替换,小数点9之后使用指数表示)" 注释 = "    A : 小数(以大写的十六进制格式替换,小数点9之后使用指数表示)"
            注释 = "    e : 小数(以指数格式替换,小写符号)" 注释 = "    E : 小数(以指数格式替换,大写符号)" 注释 = "    f : 小数(以非指数格式替换,小写符号)"
            注释 = "    F : 小数(以非指数格式替换,大写符号)" 注释 = "    g : 小数(根据值大小自动选择是否以指数格式替换,小写符号)"
            注释 = "    G : 小数(根据值大小自动选择是否以指数格式替换,大写符号)">
    参数 替换数据 <注释 = "  用作给格式文本中的替换字段提供替换参数,替换参数和替换字段的数量可以不" 注释 = "一致. 如果替换字段中用了\"参数ID\",需要注意替换参数的顺序."
            注释 = "  支持类型: 通用数值型、文本型、标准文本类W、文本视图类" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ fmt::print(fmt::runtime(PivS2WV{@<格式文本>}.sv), @<替换数据>)
    }

    方法 加入标准格式文本 <公开 静态 注释 = "使用{fmt}格式化文本,然后将结果文本添加到当前文本尾部." 注释 = "参数支持文本类型: 文本型、标准文本类W、文本视图类" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 所欲操作的文本 <类型 = 文本型>
    参数 格式文本 <类型 = 文本型 注释 = "  \"{[参数ID][:][填充字符][对齐][符号][#][0][宽度][.精度][L][类型]}\""
            注释 = "  一个标准的替换字段如上,只有首尾的\"{\"和\"}\"字符是必须,其他均可空,全部留" 注释 = "空则是按顺序把替换参数填进去."
            注释 = "  [参数ID]的范围是0-9,表示替换参数的顺序,同一个\"参数ID\"可以在\"格式文本\"" 注释 = "中多次出现."
            注释 = "  [:]选项可空,但如果要使用后面的选项则必须填写." 注释 = "  [填充字符]默认为空格,可填写除了\"{\"和\"}\"以外的任意单个字符;"
            注释 = "  [对齐]选项可用[<][>][^]之一,分别为靠左、靠右和居中对齐.数值参数默认靠" 注释 = "右对齐,其余参数默认靠左对齐."
            注释 = "  [符号]选项可用[+][-][ ],[+]表示在所有数值前插入加号或负号; [-]为默" 注释 = "认值,表示仅在负数前插入负号; [ ]表示在正数前插入空格,负数前插入负号."
            注释 = "  [#]选项只能用于数值参数,在输出2进制、8进制或16进制数值时加上前缀,比如" 注释 = "2进制的\"0b\"、8进制的\"0\"、16进制的\"0x\"."
            注释 = "  [0]只能用于数值参数,填充数字0来对齐,[填充字符]的优先级会高于此选项." 注释 = "  [宽度]选项指定填充对齐的最小宽度,可以使用\"{}\"实现动态宽度."
            注释 = "  [.精度]选项仅用于小数值,其中[精度]为十进制值,用来指定显示小数点后多少" 注释 = "位数字,如\"{:.2f}\"为显示小数点后两位.[精度]可以使用\"{}\"实现动态精度."
            注释 = "  [L]使用本地区域设置插入适当的数字分隔符,此选项仅对数字类型有效." 注释 = "  [类型]选项如下:" 注释 = "    s : 文本型(可省略)"
            注释 = "    c : 字符(可省略)" 注释 = "    b ：整数(以二进制替换,前缀为\"0b\")" 注释 = "    B ：整数(以二进制替换,前缀为\"0B\")"
            注释 = "    c : 整数(将数值转换为字符替换)" 注释 = "    d ：整数(以十进制格式替换,可省略)" 注释 = "    o ：整数(以八进制格式替换)"
            注释 = "    x ：整数(以小写的十六进制替换,前缀为\"0x\")" 注释 = "    X ：整数(以大写的十六进制替换,前缀为\"0X\")"
            注释 = "    a : 小数(以小写的十六进制格式替换,小数点9之后使用指数表示)" 注释 = "    A : 小数(以大写的十六进制格式替换,小数点9之后使用指数表示)"
            注释 = "    e : 小数(以指数格式替换,小写符号)" 注释 = "    E : 小数(以指数格式替换,大写符号)" 注释 = "    f : 小数(以非指数格式替换,小写符号)"
            注释 = "    F : 小数(以非指数格式替换,大写符号)" 注释 = "    g : 小数(根据值大小自动选择是否以指数格式替换,小写符号)"
            注释 = "    G : 小数(根据值大小自动选择是否以指数格式替换,大写符号)">
    参数 替换数据 <注释 = "  用作给格式文本中的替换字段提供替换参数,替换参数和替换字段的数量可以不" 注释 = "一致. 如果替换字段中用了\"参数ID\",需要注意替换参数的顺序."
            注释 = "  支持类型: 通用数值型、文本型、标准文本类W、文本视图类" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @<所欲操作的文本>.AddText(fmt::format(fmt::runtime(PivS2WV{@<格式文本>}.sv), @<替换数据>).c_str())
    }

    # UTF8 ---

    方法 取标准格式文本U8 <公开 静态 类型 = 文本型 注释 = "跟\"取标准格式文本\"的不同之处是内部使用UTF8处理."
            注释 = "因为{fmt}处理Unicode汉字的对齐不准确,使用本方法能正确对齐." 注释 = "因为增加了多余的编码转换,本方法会慢一点."
            注释 = "参数支持文本类型: 文本型、标准文本类U、文本视图类U" 折叠 @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 格式文本 <注释 = "  \"{[参数ID][:][填充字符][对齐][符号][#][0][宽度][.精度][L][类型]}\""
            注释 = "  一个标准的替换字段如上,只有首尾的\"{\"和\"}\"字符是必须,其他均可空,全部留" 注释 = "空则是按顺序把替换参数填进去."
            注释 = "  [参数ID]的范围是0-9,表示替换参数的顺序,同一个\"参数ID\"可以在\"格式文本\"" 注释 = "中多次出现."
            注释 = "  [:]选项可空,但如果要使用后面的选项则必须填写." 注释 = "  [填充字符]默认为空格,可填写除了\"{\"和\"}\"以外的任意单个字符;"
            注释 = "  [对齐]选项可用[<][>][^]之一,分别为靠左、靠右和居中对齐.数值参数默认靠" 注释 = "右对齐,其余参数默认靠左对齐."
            注释 = "  [符号]选项可用[+][-][ ],[+]表示在所有数值前插入加号或负号; [-]为默" 注释 = "认值,表示仅在负数前插入负号; [ ]表示在正数前插入空格,负数前插入负号."
            注释 = "  [#]选项只能用于数值参数,在输出2进制、8进制或16进制数值时加上前缀,比如" 注释 = "2进制的\"0b\"、8进制的\"0\"、16进制的\"0x\"."
            注释 = "  [0]只能用于数值参数,填充数字0来对齐,[填充字符]的优先级会高于此选项." 注释 = "  [宽度]选项指定填充对齐的最小宽度,可以使用\"{}\"实现动态宽度."
            注释 = "  [.精度]选项仅用于小数值,其中[精度]为十进制值,用来指定显示小数点后多少" 注释 = "位数字,如\"{:.2f}\"为显示小数点后两位.[精度]可以使用\"{}\"实现动态精度."
            注释 = "  [L]使用本地区域设置插入适当的数字分隔符,此选项仅对数字类型有效." 注释 = "  [类型]选项如下:" 注释 = "    s : 文本型(可省略)"
            注释 = "    c : 字符(可省略)" 注释 = "    b ：整数(以二进制替换,前缀为\"0b\")" 注释 = "    B ：整数(以二进制替换,前缀为\"0B\")"
            注释 = "    c : 整数(将数值转换为字符替换)" 注释 = "    d ：整数(以十进制格式替换,可省略)" 注释 = "    o ：整数(以八进制格式替换)"
            注释 = "    x ：整数(以小写的十六进制替换,前缀为\"0x\")" 注释 = "    X ：整数(以大写的十六进制替换,前缀为\"0X\")"
            注释 = "    a : 小数(以小写的十六进制格式替换,小数点9之后使用指数表示)" 注释 = "    A : 小数(以大写的十六进制格式替换,小数点9之后使用指数表示)"
            注释 = "    e : 小数(以指数格式替换,小写符号)" 注释 = "    E : 小数(以指数格式替换,大写符号)" 注释 = "    f : 小数(以非指数格式替换,小写符号)"
            注释 = "    F : 小数(以非指数格式替换,大写符号)" 注释 = "    g : 小数(根据值大小自动选择是否以指数格式替换,小写符号)"
            注释 = "    G : 小数(根据值大小自动选择是否以指数格式替换,大写符号)" @匹配类型 = 通用型>
    参数 替换数据 <注释 = "  用作给格式文本中的替换字段提供替换参数,替换参数和替换字段的数量可以不" 注释 = "一致. 如果替换字段中用了\"参数ID\",需要注意替换参数的顺序."
            @匹配类型 = 通用型 @可扩展 = "">
    {
        @ PivU2Ws{fmt::format(fmt::runtime(PivS2V{@<格式文本>}.sv), @<替换数据>)}.str
    }
}

# 标准文本(std::basic_string) ====

类 标准文本模板 <公开 注释 = "标准文本(std::basic_string)的模板基础类." 注释 = "\"模板类型1\"为模板实现类的类型(用于返回值)."
        注释 = "\"模板类型2\"为字符类型." 折叠 @文档 = "category = \"文本操作\"" "@视窗.外部头文件.全局-111" = "src\\piv_string.hpp"
        @模板基础类 = 真 @别名类型 = 本地类>
{

    # 文本属性 ---

    方法 预分配字符数 <公开 静态 属性读 类型 = 变整数 注释 = "  返回当前文本对象已分配的内存空间大小(单位为字符)," 注释 = "为了快速添加文本,该尺寸一般比实际的文本长度稍大." 折叠
            @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ static_cast<INT_P>(@<本文本>.capacity())
    }

    方法 预分配字符数 <公开 静态 属性写 注释 = "  设置本文本对象为了快速进行内容的添加/删除处理使用的空间分配尺寸,"
            注释 = "每次文本需要调整其空间大小时,都使用本属性值乘于单个字符尺寸作为空" 注释 = "间调整基准尺寸.值越大,批量加入/删除文本内容时所实际需要重分配空间"
            注释 = "的次数就越少,操作速度越快,但是多余内存占用就越大." 注释 = "  一般情况下无需更改本属性值." 折叠>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲分配字符数 <类型 = 变整数>
    {
        @ @<本文本>.reserve(static_cast<size_t>(@<所欲分配字符数>));
    }

    方法 是否为空 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否为空" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<本文本>.empty()
    }

    方法 取文本指针 <公开 静态 类型 = 变整数 注释 = "返回当前文本的指针,尾部带结束零字符." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ reinterpret_cast<INT_P>(@<本文本>.c_str())
    }

    方法 取文本长度 <公开 静态 类型 = 整数 注释 = "返回当前文本的字符长度" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ static_cast<INT>(@<本文本>.size())
    }

    方法 取字节长度 <公开 静态 类型 = 整数 注释 = "返回当前文本的字节长度" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ static_cast<INT>(@<本文本>.size() * sizeof(@m<CharT>))
    }

    方法 取文字长度 <公开 静态 类型 = 整数 注释 = "  返回当前文本的文字长度,对于UTF-8和多字节,一个文字往往会占用一或多个字符,"
            注释 = "即便Unicode也不是所有文字都占一个字符,比如Emoji表情就占两个字符." 注释 = "  本方法可以准确返回文本中所有文字的数量." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ static_cast<INT>(piv::edit::count_with_word<@m<EncodeT>>(@<本文本>))
    }

    方法 取文本哈希值 <公开 静态 类型 = 变整数 注释 = "  计算并返回当前文本的哈希值,区分英文字母的大小写." 注释 = "  文本哈希值可以在比较两个文本是否相同时使用(即如果两个文本"
            注释 = "的哈希值不同,则两个文本必定不相同)." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ static_cast<INT_P>(std::hash<@dt<模板类型1>>{}(@<本文本>))
    }

    方法 取文本大小写无关哈希值 <公开 静态 类型 = 变整数 注释 = "  计算并返回当前文本的哈希值,不区分英文字母的大小写."
            注释 = "  文本哈希值可以在比较两个文本是否相同时使用(即如果两个文本" 注释 = "的哈希值不同,则两个文本必定不相同)." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ static_cast<INT_P>(piv::ci_hash<@dt<模板类型1>>{}(@<本文本>))
    }

    方法 取对象自身指针 <公开 静态 类型 = 变整数 注释 = "返回本文本对象(std::basic_string)的指针" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ reinterpret_cast<INT_P>(&@<本文本>)
    }

    # 文本赋值 ---

    方法 置文本指针 <公开 静态 类型 = 模板类型1 注释 = "从文本指针置入文本数据,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本指针 <类型 = 变整数 注释 = "所欲置入的文本指针,文本编码必须跟文本对象一致.">
    参数 文本长度 <类型 = 变整数 注释 = "提供文本的字符长度;" 注释 = "参数为-1时会自动识别长度,但指向的文本必须带结束零字符;"
            注释 = "如果文本不含结束零字符或者要置入部分文本,则必须提供正确的字符长度." @默认值 = -1>
    {
        @ @<本文本>.assign(reinterpret_cast<const @m<CharT> *>(@<文本指针>), static_cast<size_t>(@<文本长度>))
    }

    方法 置文本长度 <公开 静态 类型 = 模板类型1 注释 = "设置当前文本对象的长度,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @禁止流程检查 = 真
            @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲设置的长度 <类型 = 变整数 注释 = "如果小于原有文本长度,则将原有文本剪切到所指定长度;" 注释 = "如果大于原有文本长度,则在尾部补充对应数目的空格字符.">
    {
        @ @<本文本>.resize(static_cast<size_t>(@<所欲设置的长度>));
        @ return @<本文本>;
    }

    方法 置十六进制文本 <公开 静态 类型 = 模板类型1 注释 = "将提供的十六进制文本还原为文本并置入到本对象中,返回文本对象自身."
            注释 = "注: 当前的文本内容会被覆盖,十六进制文本还原后的文本编码必须跟当前文本对象一致,否则会乱码." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲置入十六进制文本 <注释 = "提供所欲置入的十六进制文本,支持类型:" 注释 = "  文本型、标准文本类(W/U/A)、文本视图类(W/U/A)、字节集类" @匹配类型 = 通用型>
    参数 欲置入长度 <类型 = 变整数 注释 = "是否仅置入部分长度的十六进制文本,-1为置入整个文本." @默认值 = -1>
    {
        @ piv::str::assign_hex(@<本文本>, @<欲置入十六进制文本>, static_cast<size_t>(@<欲置入长度>))
    }

    方法 置文件资源 <公开 静态 类型 = 逻辑型 注释 = "将所指定的文件资源复制到当前的文本对象中,返回是否载入成功." 返回值注释 = "无论是否成功,文本对象都会先被清空." 折叠
            @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲载入的数据资源 <类型 = 视窗文件资源 注释 = "所欲指向的文本数据资源,文本编码必须跟文本对象一致.">
    {
        @ piv::str::assign_resdata(@<本文本>, @<所欲载入的数据资源>)
    }

    方法 填充文本 <公开 静态 类型 = 模板类型1 注释 = "使用所指定长度的指定字符重新填写本标准文本类对象,返回文本对象自身" 注释 = "注意文本对象原本的内容会被覆盖."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 填充长度 <类型 = 变整数 注释 = "提供所欲填写文本的长度(即重复填充所指定字符的次数),必须大于等于0.">
    参数 填充字符 <类型 = 模板类型2 注释 = "提供所欲使用的填充用字符,默认为空格,注意不能为零字符(\'\\0\')."
            注释 = "\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节);" @默认值 = 32>
    {
        @ @<本文本>.assign(static_cast<size_t>(@<填充长度>), @<填充字符>)
    }

    # 文件读写 ---

    方法 读入文本文件 <公开 静态 类型 = 逻辑型 注释 = "从所指定路径文件中读入指定尺寸的文本内容到本文本内,返回是否读取成功."
            注释 = "如果文本文件的编码与当前的文本对象不一致,将进行编码转换." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲读取文件名 <类型 = 文本型 注释 = "提供所欲读取文件的路径名称,请勿读入大于2GB的文件.">
    参数 所欲读取数据尺寸 <类型 = 整数 注释 = "提供所欲读取数据的尺寸(单位字节),为-1表示全部读取." @默认值 = -1>
    参数 文件文本编码 <类型 = 文本编码类型 注释 = "提供文件中文本内容的编码格式;" 注释 = "如果为\"文本编码类型.未知\",则首先检查是否为\"文本编码类型.UTF16\"格式;"
            注释 = "如果不是,则认为其为\"文本编码类型.多字节\"格式." @默认值 = 文本编码类型.UTF16>
    参数 代码页 <类型 = 整数 注释 = "仅在读入文件的文本编码为\"多字节\"时有效,0表示使用本地编码,常用代码页:" 注释 = "  932 日文(Shift-JIS)"
            注释 = "  936 中文简体(GB2312)" 注释 = "  949 韩文" 注释 = "  950 中文繁体(Big5)" @默认值 = 0>
    {
        @ piv::str::read_from_file<@m<EncodeT>>(@<本文本>, @<所欲读取文件名>.GetText(), @<所欲读取数据尺寸>, (VOL_STRING_ENCODE_TYPE)@<文件文本编码>, @<代码页>)
    }

    方法 写出文本文件 <公开 静态 类型 = 逻辑型 注释 = "将本文本对象的内容写入到所指定路径的文件中,返回是否写出成功." 注释 = "如果指定的写出文本编码与当前的文本对象不一致,将进行编码转换."
            折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲写到文件名 <类型 = 文本型 注释 = "提供所欲写到文件的路径名称">
    参数 所欲写出文本长度 <类型 = 整数 注释 = "提供所欲写出到文本文件的字符数目,为-1表示全部写出." @默认值 = -1>
    参数 所欲写出文本编码 <类型 = 文本编码类型 注释 = "提供欲将所写出文本文件的编码类型,不能为\"文本编码类型.未知\"." @默认值 = 文本编码类型.UTF16>
    参数 是否添加BOM签名 <类型 = 逻辑型 注释 = "是否给写出的文本文件加上BOM签名,本参数对多字节编码无效." @默认值 = 真>
    参数 代码页 <类型 = 整数 注释 = "仅在写出文本编码为\"多字节\"时有效,0表示使用本地编码,常用代码页:" 注释 = "  932 日文(Shift-JIS)"
            注释 = "  936 中文简体(GB2312)" 注释 = "  949 韩文" 注释 = "  950 中文繁体(Big5)" @默认值 = 0>
    {
        @ piv::str::write_into_file<@m<EncodeT>>(@<本文本>, @<所欲写到文件名>.GetText(), @<所欲写出文本长度>, (VOL_STRING_ENCODE_TYPE)@<所欲写出文本编码>, @<是否添加BOM签名>, @<代码页>)
    }

    # 加入文本 ---

    方法 加入文本指针 <公开 静态 类型 = 模板类型1 注释 = "将所指定指针处的文本数据添加到本文本对象的尾部," 注释 = "所添加指针的文本编码必须与文本对象一致."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本指针 <类型 = 变整数 注释 = "所欲置入的文本指针,文本编码必须跟文本对象一致.">
    参数 文本长度 <类型 = 变整数 注释 = "提供文本的字符长度;" 注释 = "参数为-1时会自动识别长度,但指向的文本必须带结束零字符."
            注释 = "如果文本不含结束零字符或者只加入部分文本,则必须提供正确的字符长度." @默认值 = -1>
    {
        @ if (@<文本长度> == -1)
        @     return @<本文本>.append(reinterpret_cast<const @m<CharT> *>(@<文本指针>));
        @ else
        @     return @<本文本>.append(reinterpret_cast<const @m<CharT> *>(@<文本指针>), static_cast<size_t>(@<文本长度>));
    }

    方法 加入字符 <公开 静态 类型 = 模板类型1 注释 = "将单个或多个字符添加到当前文本的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲添加的字符 <类型 = 模板类型2 注释 = "提供所欲添加到文本中的字符(可扩展参数,支持一次加入多个字符);"
            注释 = "\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节)." @可扩展 = "">
    {
        @ piv::str::push_back(@<本文本>, @<欲添加的字符>)
    }

    方法 加入重复字符 <公开 静态 类型 = 模板类型1 注释 = "将所指定的字符添加多个到当前文本的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的字符 <类型 = 模板类型2 注释 = "提供所欲添加到文本中的字符;" 注释 = "\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节).">
    参数 所欲重复添加的次数 <类型 = 变整数 注释 = "提供将所指定字符重复添加的次数" @默认值 = 1>
    {
        @ @<本文本>.append(static_cast<size_t>(@<所欲重复添加的次数>), @<所欲添加的字符>)
    }

    方法 添加字符数组 <公开 静态 类型 = 模板类型1 注释 = "将所指定字符数组中的文本内容添加到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的字符数组 <类型 = "模板类型2 []" 注释 = "提供所欲添加其文本内容的字符数组;" 注释 = "\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节).">
    参数 所欲添加的字符数目 <类型 = 变整数 注释 = "提供该字符数组中所欲加入到本文本中的字符数目;" 注释 = "必须大于等于0且小于等于指定字符数组定义时所分配的成员字符数目.">
    {
        @ @<本文本>.append(@<所欲添加的字符数组>, static_cast<size_t>(@<所欲添加的字符数目>))
    }

    方法 加入换行符 <公开 静态 类型 = 模板类型1 注释 = "将回车及换行字符(\"\\r\\n\")添加到当前文本尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<本文本>.push_back('\r');
        @ @<本文本>.push_back('\n');
        @ return @<本文本>;
    }

    方法 检查加入换行符 <公开 静态 类型 = 模板类型1 注释 = "如果当前文本不以换行字符(\'\\n\')结束,则将回车及换行字符(\"\\r\\n\")"
            注释 = "添加到当前文本尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ if (@<本文本>.empty()) {
        @     @<本文本>.push_back('\r');
        @     @<本文本>.push_back('\n');
        @     return @<本文本>;
        @ }
        @ if (@<本文本>.back() != '\n') {
        @     if (@<本文本>.back() != '\r')
        @         @<本文本>.push_back('\r');
        @     @<本文本>.push_back('\n');
        @ }
        @ return @<本文本>;
    }

    方法 检查加入路径字符 <公开 静态 类型 = 模板类型1 注释 = "如果当前文本不以路径字符\'\\\'结束,则添加该字符到尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ if (@<本文本>.empty()) {
        @     @<本文本>.push_back('\\');
        @     return @<本文本>;
        @ }
        @ if (@<本文本>.back() != '\\')
        @     @<本文本>.push_back('\\');
        @ return @<本文本>;
    }

    方法 加入无符号值 <公开 静态 类型 = 模板类型1 注释 = "将指定的整数型转换到无符号,加入到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 无符号值 <注释 = "所欲加入的数值(支持字节、短整数、整数、长整数),会自动转换到无符号类型." @匹配类型 = 通用整数型>
    {
        @ piv::str::append_unsigned(@<本文本>, @<无符号值>)
    }

    方法 加入十六进制文本 <公开 静态 类型 = 模板类型1 注释 = "将提供的十六进制文本还原为文本并添加到当前文本尾部,返回文本对象自身."
            注释 = "十六进制文本还原后的文本编码必须跟当前文本对象一致,否则会乱码." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲加入十六进制文本 <注释 = "提供所欲加入的十六进制文本,支持类型:" 注释 = " 文本型、标准文本类(W/U/A)、文本视图类(W/U/A)、字节集类" @匹配类型 = 通用型>
    参数 欲加入长度 <类型 = 变整数 注释 = "是否仅加入部分长度的十六进制文本,-1为加入整个文本." @默认值 = -1>
    {
        @ piv::str::append_hex(@<本文本>, @<欲加入十六进制文本>, @<欲加入长度>)
    }

    # 插入文本 ---

    方法 插入字符 <公开 静态 类型 = 模板类型1 注释 = "将所指定字符插入到文本的所指定索引位置,返回文本对象自身." 注释 = "异常类型: std::out_of_range"
            返回值注释 = "返回自身(支持链式语法)" 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的索引位置,必须大于等于0且小于等于文本当前长度.">
    参数 所欲插入的字符 <类型 = 模板类型2 注释 = "提供所欲插入到文本中的字符;" 注释 = "\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节).">
    {
        @ PIV_ASSERT(@<插入索引位置> >= 0 && static_cast<size_t>(@<插入索引位置>) <= @<本文本>.size(),
        @     L"索引位置必须大于等于0且小于等于文本长度", @sn<current_source_class>"::"@sn<current_source_method>);
        @ return @<本文本>.insert(static_cast<size_t>(@<插入索引位置>), 1, @<所欲插入的字符>);
    }

    方法 插入行首空格 <公开 静态 类型 = 模板类型1 注释 = "在文本的每行(基于换行符分隔)行首插入指定数目的空格字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲插入的空格数 <类型 = 整数 注释 = "指定在文本每行行首插入的空格字符数目,不能小于0.">
    {
        @ PIV_ASSERT(@<所欲插入的空格数> >= 0,
        @     L"所欲插入的空格数不能小于0", @sn<current_source_class>"::"@sn<current_source_method>);
        @ if (@<本文本>.empty())
        @     return @<本文本>;
        @ size_t fpos = 0, pos = 0;
        @ @<本文本>.insert(0, static_cast<size_t>(@<所欲插入的空格数>), ' ');
        @ while (fpos < @<本文本>.size()) {
        @     fpos = @<本文本>.find_first_of('\n', pos);
        @     if (fpos == -1)
        @         break;
        @     @<本文本>.insert(fpos + 1, static_cast<size_t>(@<所欲插入的空格数>), ' ');
        @     pos = fpos + static_cast<size_t>(@<所欲插入的空格数>);
        @ }
        @ return @<本文本>;
    }

    # 删除字符 ---

    方法 清空文本 <公开 静态 类型 = 模板类型1 注释 = "清空文本,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<本文本>.clear();
        @ return @<本文本>;
    }

    方法 删除部分文本 <公开 静态 类型 = 整数 注释 = "删除当前文本对象中的指定区域内的字符,返回所实际删除的字符数." 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始字符索引 <类型 = 变整数 注释 = "提供所欲删除首字符的索引位置,必须大于等于0且小于等于文本当前长度.">
    参数 欲删除字符数 <类型 = 变整数 注释 = "提供所欲删除字符的数目;" 注释 = "如果加上\"起始字符索引\"后大于文本当前长度,则删除\"起始字符索引\"后的所有字符.">
    {
        @ PIV_ASSERT(@<起始字符索引> >= 0 && @<起始字符索引> < @<本文本>.size() && @<欲删除字符数> >= 0,
        @     L"索引位置必须大于等于0且小于文本长度,并且删除字符数应大于等于0.", @sn<current_source_class>"::"@sn<current_source_method>);
        @ size_t ret = @<本文本>.size();
        @ @<本文本>.erase(static_cast<size_t>(@<起始字符索引>), static_cast<size_t>(@<欲删除字符数>));
        @ return ret - @<本文本>.size();
    }

    方法 删除字符 <公开 静态 类型 = 模板类型1 注释 = "删除当前文本对象中的所指定区域的字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @禁止流程检查 = 真
            @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始字符索引 <类型 = 变整数 注释 = "提供所欲删除首字符的索引位置,必须大于等于0且小于等于文本当前长度.">
    参数 欲删除字符数 <类型 = 变整数 注释 = "提供所欲删除字符的数目;" 注释 = "如果加上\"起始字符索引\"后大于文本当前长度,则删除\"起始字符索引\"后的所有字符.">
    {
        @ PIV_ASSERT(@<起始字符索引> >= 0 && (size_t)@<起始字符索引> < @<本文本>.size() && @<欲删除字符数> >= 0,
        @     L"索引位置必须大于等于0且小于文本长度,并且删除字符数应大于等于0.", @sn<current_source_class>"::"@sn<current_source_method>);
        @ return @<本文本>.erase(static_cast<size_t>(@<起始字符索引>), static_cast<size_t>(@<欲删除字符数>));
    }

    方法 删除文字 <公开 静态 类型 = 模板类型1 注释 = "删除当前文本对象中的所指定区域的文字,返回文本对象自身."
            注释 = "注: 跟\"删除字符\"不同,本方法以实际显示的文字为单位(一个文字可能对应" 注释 = "单个或多个字符)." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始文字索引 <类型 = 变整数 注释 = "提供所欲删除首文字的索引位置,必须大于等于0;" 注释 = "如果大于文本的文字长度,则表示删除整个文本.">
    参数 欲删除文字数 <类型 = 变整数 注释 = "提供所欲删除文字的数目;" 注释 = "如果加上\"起始文字索引\"后大于文本的文字长度,则删除\"起始文字索引\"后的所有字符.">
    {
        @ piv::edit::remove_words<@m<EncodeT>>(@<本文本>, static_cast<size_t>(@<起始文字索引>), static_cast<size_t>(@<欲删除文字数>))
    }

    方法 删除空白行 <公开 静态 类型 = 模板类型1 注释 = "删除当前文本中的所有空行(基于换行符分隔,包括行中全为空白字符的文本行)," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ if (@<本文本>.empty())
        @     return @<本文本>;
        @ @dt<模板类型1> ret;
        @ size_t spos = 0, fpos = 0, len = @<本文本>.size();
        @ ret.reserve(len);
        @ piv::basic_string_view<@m<CharT>> sv = @<本文本>;
        @ piv::basic_string_view<@m<CharT>> tmp;
        @ while (fpos < len) {
        @     fpos = sv.find('\n', spos);
        @     if (fpos != piv::basic_string_view<@m<CharT>>::npos) {
        @         tmp = sv.substr(spos, fpos - spos + 1);
        @         spos = fpos + 1;
        @     } else {
        @         tmp = sv.substr(spos, len - spos);
        @         fpos = len;
        @     }
        @     if (tmp.empty()) continue;
        @     bool isSpace = true;
        @     for (auto it = tmp.begin(); it != tmp.end(); it++) {
        @         if (*it > ' ') {
        @             isSpace = false;
        @             break;
        @         }
        @     }
        @     if (!isSpace)
        @         ret.append(tmp.data(), tmp.size());
        @ }
        @ @<本文本>.swap(ret);
        @ return @<本文本>;
    }

    方法 删首字符 <公开 静态 类型 = 模板类型1 注释 = "删除首部一个字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ if (@<本文本>.empty())
        @     return @<本文本>;
        @ return @<本文本>.erase(0, 1);
    }

    方法 删尾字符 <公开 静态 类型 = 模板类型1 注释 = "删除尾部一个字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ if (!@<本文本>.empty())
        @     @<本文本>.pop_back();
        @ return @<本文本>;
    }

    方法 删首空 <公开 静态 类型 = 模板类型1 注释 = "删除当前文本首部的所有空白字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ piv::edit::trim_left(@<本文本>)
    }

    方法 删尾空 <公开 静态 类型 = 模板类型1 注释 = "删除当前文本尾部的所有空白字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ piv::edit::trim_right(@<本文本>)
    }

    方法 删首尾空 <公开 静态 类型 = 模板类型1 注释 = "删除文本首部和尾部的所有空白字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ piv::edit::trim_right(piv::edit::trim_left(@<本文本>))
    }

    方法 删全部空 <公开 静态 类型 = 模板类型1 注释 = "删除文本中的所有空白字符(包括控制符、通信专用字符和制表符)," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 保留换行符 <类型 = 逻辑型 注释 = "是否保留文本中的换行符" @默认值 = 真>
    {
        @ @<本文本>.erase(std::remove_if(@<本文本>.begin(), @<本文本>.end(),
        @                 [@<保留换行符>](int32_t ch) {
        @                    return ((ch >= 0 && ch <= 0x09) || ch == 0x0B || ch == 0x0C || (!@<保留换行符> && (ch == '\r' || ch == '\n')) || (ch >= 0x0E && ch <= ' '));
        @                 }), @<本文本>.end());
        @ return @<本文本>;
    }

    方法 检查删除路径字符 <公开 静态 类型 = 模板类型1 注释 = "如果当前文本以一个可以被删除的路径字符\'\\\'结束(即不为类似\"c:\\\"这样的文本),则将其删除."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ if (@<本文本>.empty())
        @     return @<本文本>;
        @ while (@<本文本>.back() == '\\')
        @ {
        @     if (@<本文本>.size() == 3 && str[1] == ':')
        @         break;
        @     @<本文本>.pop_back();
        @ }
        @ return @<本文本>;
    }

    # 寻找文本 ---

    方法 寻找字符 <公开 静态 类型 = 变整数 注释 = "在文本中查找所指定字符的索引位置,未找到则返回-1." 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲查找的字符 <类型 = 模板类型2 注释 = "提供所欲查找的字符;" 注释 = "\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节).">
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,应大于等于0且小于等于文本长度." @默认值 = 0>
    {
        @ if (@<起始搜寻位置> >= @<本文本>.size())
        @     return -1;
        @ return (INT_P)@<本文本>.find(@<所欲查找的字符>, static_cast<size_t>(@<起始搜寻位置>));
    }

    方法 倒找字符 <公开 静态 类型 = 变整数 注释 = "在文本中逆向查找所指定字符的索引位置,未找到则返回-1." 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲查找的字符 <类型 = 模板类型2 注释 = "提供所欲查找的字符;" 注释 = "\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节).">
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,应小于等于文本长度,小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ if (@<起始搜寻位置> != -1 && @<起始搜寻位置> >= @<本文本>.size())
        @     return -1;
        @ return (INT_P)@<本文本>.rfind(@<所欲查找的字符>, static_cast<size_t>(@<起始搜寻位置>));
    }

    # 替换文本 ---

    方法 替换字符 <公开 静态 类型 = 逻辑型 注释 = "将文本中所有指定字符均替换为另一个." 注释 = "\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节)."
            返回值注释 = "返回是否产生了实际替换" 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲被替换的字符 <类型 = 模板类型2 注释 = "提供文本中所欲被替换的字符">
    参数 所欲替换到的字符 <类型 = 模板类型2 注释 = "提供用作替换的字符">
    参数 起始替换索引位置 <类型 = 变整数 注释 = "提供起始替换索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    {
        @ bool replaced = false;
        @ std::for_each(@<本文本>.begin() + @<起始替换索引位置>, @<本文本>.end(), [&](@m<CharT>& ch) {
        @                   if (ch == @<所欲被替换的字符>) { ch = @<所欲替换到的字符>; replaced = true; }
        @               });
        @ return replaced;
    }

    方法 替换控制符 <公开 静态 类型 = 模板类型1 注释 = "将文本中的所有控制类字符替换为空格,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @禁止流程检查 = 真
            @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ std::for_each(@<本文本>.begin(), @<本文本>.end(), [](@m<CharT>& ch) {
        @                   if (std::iswcntrl(static_cast<uint16_t>(ch))) { ch = ' '; }
        @               });
        @ return @<本文本>;
    }

    方法 交换文本 <公开 静态 注释 = "将两个标准文本类的内容交换" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲交换的文本 <类型 = 标准文本模板 注释 = "所欲交换内容的另一个文本对象">
    {
        @ @<本文本>.swap(@<所欲交换的文本>)
    }

    # 提取文本 ---

    方法 取字符 <公开 静态 类型 = 模板类型2 注释 = "返回文本中所指定索引位置处的字符,文本为空时将报错." 注释 = "注: 本方法不做索引越界检查."
            返回值注释 = "返回\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节)" 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 字符索引位置 <类型 = 整数 注释 = "提供所欲获取字符的索引位置,必须大于等于0小于文本的长度.">
    {
        @ PIV_ASSERT(@<本文本>.empty() == false && @<字符索引位置> >= 0 && (size_t)@<字符索引位置> < @<本文本>.size(),
        @     L"索引位置必须大于等于0且小于文本长度", @sn<current_source_class>"::"@sn<current_source_method>);
        @ return @<本文本>[static_cast<size_t>(@<字符索引位置>)];
    }

    方法 取字符2 <公开 静态 类型 = 模板类型2 注释 = "返回文本中所指定索引位置处的字符,文本为空时将报错."
            返回值注释 = "返回\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 字符索引位置 <类型 = 整数 注释 = "提供所欲获取字符的索引位置,必须大于等于0小于文本的长度.">
    {
        @ @<本文本>.at(static_cast<size_t>(@<字符索引位置>))
    }

    方法 取首字符 <公开 静态 类型 = 模板类型2 注释 = "返回文本的首字符,文本为空时返回0." 返回值注释 = "返回\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节)" 折叠
            @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ PIV_ASSERT(@<本文本>.empty() == false, L"文本不能为空", @sn<current_source_class>"::"@sn<current_source_method>);
        @ return @<本文本>.front();
    }

    方法 取尾字符 <公开 静态 类型 = 模板类型2 注释 = "返回文本的尾字符,文本为空时返回0." 返回值注释 = "返回\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节)" 折叠
            @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ PIV_ASSERT(@<本文本>.empty() == false, L"文本不能为空", @sn<current_source_class>"::"@sn<current_source_method>);
        @ return @<本文本>.back();
    }

    方法 取文本中间 <公开 静态 类型 = 模板类型1 注释 = "返回一个标准文本类,其中包含当前文本中从指定位置算起指定数量的字符." 注释 = "异常类型: std::out_of_range" 折叠
            @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始取出索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于文本长度,否则报错.">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置)," 注释 = "将返回索引位置后面的全部剩余字符.">
    {
        @ PIV_ASSERT(static_cast<size_t>(@<起始取出索引位置>) <= @<本文本>.size(),
        @            L"索引位置不能大于文本长度", @sn<current_source_class>"::"@sn<current_source_method>);
        @ return @<本文本>.substr(static_cast<size_t>(@<起始取出索引位置>), static_cast<size_t>(@<欲取出字符的数目>));
    }

    方法 取文本左边 <公开 静态 类型 = 模板类型1 注释 = "返回一个标准文本类,其中包含当前文本中从左边算起指定数量的字符." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本长度,将返回完整的文本.">
    {
        @ @<本文本>.substr(0, static_cast<size_t>(@<欲取出字符的数目>))
    }

    方法 取文本右边 <公开 静态 类型 = 模板类型1 注释 = "返回一个标准文本类,其中包含当前文本中从右边算起指定数量的字符." 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本长度,将返回完整的文本.">
    {
        @ size_t pos = (static_cast<size_t>(@<欲取出字符的数目>) > @<本文本>.size()) ? 0 : @<本文本>.size() - static_cast<size_t>(@<欲取出字符的数目>);
        @ return @<本文本>.substr(pos, static_cast<size_t>(@<欲取出字符的数目>));
    }

    方法 取中间文字 <公开 静态 类型 = 模板类型1 注释 = "返回一个标准文本类,其中包含当前文本中从指定位置算起指定数量的文字."
            注释 = "注: 跟\"取文本中间\"不同,本方法以实际显示的文字为单位(一个文字可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始取出索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首文字位置,如果大于文本的文字数量会返回空文本.">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于等于(文字数目-索引位置),将返回索引位置后面" 注释 = "的全部剩余文字.">
    {
        @ piv::edit::substr_with_word<@m<EncodeT>>(@<本文本>, static_cast<size_t>(@<起始取出索引位置>), static_cast<size_t>(@<欲取出文字的数目>))
    }

    方法 取左边文字 <公开 静态 类型 = 模板类型1 注释 = "返回一个标准文本类,其中包含当前文本中从左边算起指定数量的文字."
            注释 = "注: 跟\"取文本左边\"不同,本方法以实际显示的文字为单位(一个文字可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本的文字长度,将返回完整的文本.">
    {
        @ piv::edit::substr_with_word<@m<EncodeT>>(@<本文本>, 0, static_cast<size_t>(@<欲取出文字的数目>))
    }

    方法 取右边文字 <公开 静态 类型 = 模板类型1 注释 = "返回一个标准文本类,其中包含当前文本中从右边算起指定数量的文字."
            注释 = "注: 跟\"取文本右边\"不同,本方法以实际显示的文字为单位(一个文字可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本的文字长度,将返回完整的文本.">
    {
        @ size_t length = piv::edit::count_with_word<@m<EncodeT>, @dt<模板类型1>>(@<本文本>);
        @ size_t pos = (static_cast<size_t>(@<欲取出文字的数目>) >= length) ? 0 : (length - static_cast<size_t>(@<欲取出文字的数目>));
        @ return piv::edit::substr_with_word<@m<EncodeT>>(@<本文本>, pos, static_cast<size_t>(@<欲取出文字的数目>));
    }

    # 比较文本 ---

    方法 是否以字符开头 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否以所指定字符开头" 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲检查的字符 <类型 = 模板类型2 注释 = "提供用来检查是否以其开头的字符," 注释 = "\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节).">
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ if (@<本文本>.empty())
        @     return FALSE;
        @ if (@<是否区分大小写>)
        @     return (@<本文本>.front() == @<所欲检查的字符>);
        @ else
        @     return (piv::edit::tolower(static_cast<uint16_t>(@<本文本>.front())) == piv::edit::tolower(static_cast<uint16_t>(@<所欲检查的字符>)));
    }

    方法 是否以字符结束 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否以所指定字符结束" 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲检查的字符 <类型 = 模板类型2 注释 = "提供用来检查是否以其结束的字符," 注释 = "\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节).">
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ if (@<本文本>.empty())
        @     return FALSE;
        @ if (@<是否区分大小写>)
        @     return (@<本文本>.back() == @<所欲检查的字符>);
        @ else
        @     return (piv::edit::tolower(static_cast<uint16_t>(@<本文本>.back())) == piv::edit::tolower(static_cast<uint16_t>(@<所欲检查的字符>)));
    }

    方法 取文本MD5 <公开 静态 类型 = 模板类型1 注释 = "计算并返回文本的MD5数据摘要(32个字符)." 注释 = "返回类型与当前文本对象一致." 折叠 @嵌入式方法 = ""
            @强制依赖 = "MD5校验类">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否大写 <类型 = 逻辑型 注释 = "默认返回大写字符,为假时返回小写字符." @默认值 = 真>
    {
        @ piv::GetStringMd5(@<本文本>, static_cast<bool>(@<是否大写>))
    }

    # 输出文本 ---

    方法 复制到字符数组 <公开 静态 类型 = 变整数 注释 = "将本文本的内容复制到所指定的字符数组中,返回复制的字符数." 注释 = "注: 出错将抛出异常" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲复制到的字符数组 <类型 = "模板类型2 []" 注释 = "提供所欲复制到的字符数组,成员\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节).">
    参数 欲复制的起始索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错.">
    参数 欲复制的字符数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置);" 注释 = "将复制索引位置后面的全部剩余字符.">
    {
        @ (INT_P>)@<本文本>.copy(@<所欲复制到的字符数组>, static_cast<size_t>(@<欲复制的起始索引位置>), static_cast<size_t>(@<欲复制的字符数目>))
    }

    方法 到字节集 <公开 静态 类型 = 字节集类 注释 = "返回一个包含当前文本数据的字节集" 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否添加结束零字符 <类型 = 逻辑型 注释 = "指定返回的文本字节集中是否包括结束零字符" @默认值 = 假>
    {
        @ return @an<CVolMem>{@<本文本>.data(), static_cast<INT_P>((@<本文本>.size() + (@<是否添加结束零字符> ? 1 : 0)) * sizeof(@m<CharT>))};
    }

    方法 到整数 <公开 静态 类型 = 整数 注释 = "将当前文本的整数值文本转换到整数并返回" 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 进制 <类型 = 整数 注释 = "提供整数文本的进制类型,范围为2到36进制." 注释 = "默认值0表示根据数值前缀自动识别进制,如\"0x\"为16进制,"
            注释 = "\'0\'开头为8进制,1-9开头为10进制." @默认值 = 0>
    {
        @ PIV_IF (sizeof(@m<CharT>) == 2)
        @     return static_cast<int32_t>(wcstoul((const wchar_t *)@<本文本>.c_str(), nullptr, @<进制>));
        @ else
        @     return static_cast<int32_t>(strtoul((const char *)@<本文本>.c_str(), nullptr, @<进制>));
    }

    方法 到长整数 <公开 静态 类型 = 长整数 注释 = "将当前文本的长整数值文本转换到长整数并返回" 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 进制 <类型 = 整数 注释 = "提供整数文本的进制类型,范围为2到36进制." 注释 = "默认值0表示根据数值前缀自动识别进制,如\"0x\"为16进制,"
            注释 = "\'0\'开头为8进制,1-9开头为10进制." @默认值 = 0>
    {
        @ PIV_IF (sizeof(@m<CharT>) == 2)
        @     return static_cast<int64_t>(wcstoull((const wchar_t *)@<本文本>.c_str(), nullptr, @<进制>));
        @ else
        @     return static_cast<int64_t>(strtoull((const char *)@<本文本>.c_str(), nullptr, @<进制>));
    }

    方法 到小数 <公开 静态 类型 = 小数 注释 = "将当前文本的双精度浮点数文本转换到小数并返回" 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ PIV_IF (sizeof(@m<CharT>) == 2)
        @     return _wtof(reinterpret_cast<const wchar_t *>(@<本文本>.c_str()));
        @ else
        @     return atof(reinterpret_cast<const char *>(@<本文本>.c_str()));
    }

    方法 到十六进制 <公开 静态 类型 = 模板类型1 注释 = "将本文本的内容转换为十六进制格式的连续文本" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否分隔字符 <类型 = 逻辑型 注释 = "是否用空格分隔十六进制字符" @默认值 = 假>
    {
        @ piv::encoding::str_to_hex<@m<CharT>>(@<本文本>, @<是否分隔字符>, @dt<模板类型1>{})
    }

    方法 到十六进制文本 <公开 静态 类型 = 文本型 注释 = "将本文本的内容转换为十六进制格式的连续文本,返回火山的文本型." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否分隔字符 <类型 = 逻辑型 注释 = "是否用空格分隔十六进制字符" @默认值 = 假>
    {
        @ piv::encoding::str_to_hex(@<本文本>, @<是否分隔字符>, @an<CVolString>{})
    }

    方法 到USC2 <公开 静态 类型 = 模板类型1 注释 = "将本文本的内容转换为以\"\\u\"开头的Unicode编码文本."
            注释 = "例: \"你好,火山!\"编码为\"\\u4f60\\u597d,\\u706b\\u5c71!\"" 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "是否编码ASCII字符" @默认值 = 假>
    {
        @ PIV_IF(sizeof(@m<EncodeT>) == 2)
        @     return piv::encoding::to_usc2(@<本文本>, @<编码ASCII字符>, @dt<模板类型1>{});
        @ PIV_ELSE_IF(sizeof(@m<EncodeT>) == 3)
        @     return piv::encoding::to_usc2(PivU2W{reinterpret_cast<const char *>(@<本文本>.c_str())}.str, @<编码ASCII字符>, @dt<模板类型1>{});
        @ else
        @     return piv::encoding::to_usc2(PivA2W{reinterpret_cast<const char *>(@<本文本>.c_str())}.str, @<编码ASCII字符>, @dt<模板类型1>{});
    }

    方法 到USC2文本 <公开 静态 类型 = 文本型 注释 = "将本文本的内容转换为以\"\\u\"开头的Unicode编码文本,返回火山的文本型."
            注释 = "例: \"你好,火山!\"编码为\"\\u4f60\\u597d,\\u706b\\u5c71!\"" 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "是否编码ASCII字符" @默认值 = 假>
    {
        @ PIV_IF(sizeof(@m<EncodeT>) == 2)
        @     return piv::encoding::to_usc2(@<本文本>, @<编码ASCII字符>, @an<CVolString>{});
        @ PIV_ELSE_IF(sizeof(@m<EncodeT>) == 3)
        @     return piv::encoding::to_usc2(PivU2W{reinterpret_cast<const char *>(@<本文本>.c_str())}.str, @<编码ASCII字符>, @an<CVolString>{});
        @ else
        @     return piv::encoding::to_usc2(PivA2W{reinterpret_cast<const char *>(@<本文本>.c_str())}.str, @<编码ASCII字符>, @an<CVolString>{});
    }

    # 转换文本 ---

    方法 到小写 <公开 静态 类型 = 模板类型1 注释 = "将当前文本中的所有英文字母转换为小写,返回转换后的结果文本." 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写." @视窗.前缀文本 = "const ">
    {
        @ @dt<模板类型1> lower;
        @ lower.resize(@<本文本>.size());
        @ std::transform(@<本文本>.begin(), @<本文本>.end(), lower.begin(),
        @                [](@m<CharT> c) -> @m<CharT>
        @                { return (@m<CharT>)piv::edit::tolower(static_cast<uint16_t>(c)); });
        @ return lower;
    }

    方法 到大写 <公开 静态 类型 = 模板类型1 注释 = "将当前文本中的所有英文字母转换为大写,返回转换后的结果文本." 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写." @视窗.前缀文本 = "const ">
    {
        @ @dt<模板类型1> upper;
        @ upper.resize(@<本文本>.size());
        @ std::transform(@<本文本>.begin(), @<本文本>.end(), upper.begin(),
        @                [](@m<CharT> c) -> @m<CharT>
        @                { return (@m<CharT>)piv::edit::toupper(static_cast<uint16_t>(c)); });
        @ return upper;
    }

    方法 自身到小写 <公开 静态 类型 = 模板类型1 注释 = "将当前文本中的所有英文字母转换为小写,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @禁止流程检查 = 真
            @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ std::for_each(@<本文本>.begin(), @<本文本>.end(), [](@m<CharT>& ch) {
        @                   ch = (@m<CharT>)piv::edit::tolower(static_cast<uint16_t>(ch));
        @               });
        @ return @<本文本>;
    }

    方法 自身到大写 <公开 静态 类型 = 模板类型1 注释 = "将当前文本中的所有英文字母转换为大写,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @禁止流程检查 = 真
            @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ std::for_each(@<本文本>.begin(), @<本文本>.end(), [](@m<CharT>& ch) {
        @                    ch = (@m<CharT>)piv::edit::toupper(static_cast<uint16_t>(ch));
        @                });
        @ return @<本文本>;
    }

    方法 到半角 <公开 静态 类型 = 模板类型1 注释 = "将文本中所有的全角ASCII字符转换为对应的半角字符,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 转换选项 <类型 = 整数 注释 = "选择要转换全角字符,默认转换全部全角ASCII字符,可选参数如下:" 注释 = "  1 = 标点符号;" 注释 = "  2 = 数字(0-9);"
            注释 = "  4 = 英文字母(a-z/A-Z);" 注释 = "可以使用\"位或\"组合多种选项." @默认值 = 7>
    {
        @ piv::edit::to_halfwidth<@m<EncodeT>>(@<本文本>, @<转换选项>)
    }

    方法 到全角 <公开 静态 类型 = 模板类型1 注释 = "将文本中所有的半角ASCII字符转换为对应的全角字符,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 转换选项 <类型 = 整数 注释 = "选择要转换半角字符,默认转换全部半角字符,可选参数如下:" 注释 = "  1 = 标点符号;" 注释 = "  2 = 数字(0-9);"
            注释 = "  4 = 英文字母(a-z/A-Z);" 注释 = "可以使用\"位或\"组合多种选项." @默认值 = 7>
    {
        @ piv::edit::to_fullwidth<@m<EncodeT>>(@<本文本>, @<转换选项>)
    }

    方法 逆序置文本 <公开 静态 类型 = 模板类型1 注释 = "将当前文本的内容逆序翻转,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @禁止流程检查 = 真
            @视窗.返回参考 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<本文本> = piv::edit::reverse_text<@m<EncodeT>>(@<本文本>);
        @ return @<本文本>;
    }

    方法 取逆序文本 <公开 静态 类型 = 模板类型1 注释 = "将当前文本的内容逆序翻转,然后将其返回." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ piv::edit::reverse_text<@m<EncodeT>>(@<本文本>)
    }

    # BASE编码 ---

    方法 BASE64编码 <公开 静态 类型 = 模板类型1 注释 = "返回当前文本数据所对应的BASE64编码格式文本内容" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 每行最大字符数 <类型 = 整数 注释 = "指定每行编码文本的最大字符数,小于0表示无限制,等于0表示使用默认每行字符数(76)." @默认值 = 0>
    {
        @ piv::base64<@m<CharT>>{}.encode(@<本文本>, @dt<模板类型1>{}, @<每行最大字符数>)
    }

    方法 BASE64解码 <公开 静态 类型 = 模板类型1 注释 = "  将当前的BASE64编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE64到字节集\"." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ piv::base64<@m<CharT>>{}.decode(@<本文本>)
    }

    方法 BASE85编码 <公开 静态 类型 = 模板类型1 注释 = "返回当前文本数据所对应的BASE85编码格式文本内容" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 自动填充 <类型 = 逻辑型 注释 = "为真时将自动在临时文本后填充0字符,以满足字节对齐为4的倍数." 注释 = "如果为假,文本长度必须为4的倍数,否则将失败返回空文本." @默认值 = 真>
    {
        @ piv::base85<@m<CharT>>{}.encode(@<本文本>, @<自动填充>)
    }

    方法 BASE85解码 <公开 静态 类型 = 模板类型1 注释 = "  将当前的BASE85编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE85到字节集\"." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ piv::base85<@m<CharT>>{}.decode(@<本文本>)
    }

    方法 BASE91编码 <公开 静态 类型 = 模板类型1 注释 = "返回当前文本数据所对应的BASE91编码格式文本内容." 注释 = "保留ASCII字符为{<>\"}." 折叠
            @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ piv::base91<@m<CharT>>{}.encode(@<本文本>)
    }

    方法 BASE91解码 <公开 静态 类型 = 模板类型1 注释 = "  将当前的BASE91编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE91到字节集\"." 注释 = "  保留ASCII字符为{<>\"}." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ piv::base91<@m<CharT>>{}.decode(@<本文本>)
    }

    方法 BASE64到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE64编码格式文本,解码为对应的字节集后返回." 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @an<CVolMem> buffer;
        @ piv::base64<@m<CharT>>{}.decode(@<本文本>, buffer);
        @ return buffer;
    }

    方法 BASE85到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE85编码格式文本,解码为对应的字节集后返回." 折叠 @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @an<CVolMem> buffer;
        @ piv::base85<@m<CharT>>{}.decode(@<本文本>, buffer);
        @ return buffer;
    }

    方法 BASE91到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE91编码格式文本,解码为对应的字节集后返回." 注释 = "保留ASCII字符为{<>\"}." 折叠
            @禁止流程检查 = 真>
    参数 本文本 <类型 = 标准文本模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @an<CVolMem> buffer;
        @ piv::base91<@m<CharT>>{}.decode(@<本文本>, buffer);
        @ return buffer;
    }
}

类 标准文本类W <公开 基础类 = 标准文本模板 注释 = "UTF-16LE编码(与\"文本型\"相同编码)的标准文本类(std::wstring)." 折叠
        @文档 = "category = \"文本操作\"" @模板实现类 = "标准文本类W, 字符" @别名 = "std::wstring">
{

    # @ @def_macro CharT wchar_t
    # @ @def_macro EncodeT piv::utf16_le
    # 静态函数 ---

    方法 创建文本 <公开 静态 类型 = 标准文本类W 注释 = "通过字符串字面量创建一个UTF-16LE编码的文本对象."
            注释 = "注意本方法需要以类名调用(而不是类变量),本方法不会产生文本编码转换." 注释 = "另外有作用相同的全局方法\"创建文本对象W\"."
            返回值注释 = "返回所创建的标准文本类(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量 @默认值 = "">
    {
        @ @dt<标准文本类W>{L@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    # 文本赋值 ---

    方法 值 <公开 静态 属性写 注释 = "将所指定的文本数据置入到文本对象中" 注释 = "" 折叠 "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <类型 = 文本型 注释 = "所欲赋值的文本型数据">
    {
        @ @<本文本>.assign(@<本文本>, @<文本数据>.GetText());
    }

    方法 值 <公开 静态 属性读 类型 = 文本型 注释 = "以文本型返回文本对象的内容" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @an<CVolString>(@<本文本>.c_str())
    }

    方法 置字面量 <公开 静态 类型 = 标准文本类W 注释 = "将填入的一段字符串字面量置入到文本对象中." 注释 = "注意文本对象原本的内容会被覆盖,本方法不会产生文本编码转换." 折叠
            @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @<本文本>.assign(L@sn<quot>@pvpt<文本字面量>@sn<quot>)
    }

    方法 置文本 <公开 静态 类型 = 标准文本类W 注释 = "将所指定的文本数据置入到文本对象中,返回文本对象自身." 注释 = "注意文本对象原本的内容会被覆盖."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲置入的UTF-16LE文本数据,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类W、字节集类(UTF-16LE)" 注释 = " 小数、通用整数型"
            @匹配类型 = 通用型>
    {
        @ piv::str::assign(@<本文本>, @<文本数据>)
    }

    方法 置部分文本 <公开 静态 类型 = 标准文本类W 注释 = "将所指定文本数据的一部分置入到文本对象中,返回文本对象自身." 注释 = "注意文本对象原本的内容会被覆盖."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲置入的UTF-16LE文本数据,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类W、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 所欲添加的长度 <类型 = 变整数 注释 = "提供欲将所指定文本的多少字符添加到当前文本尾部">
    {
        @ piv::str::assign(@<本文本>, @<文本数据>, static_cast<size_t>(@<所欲添加的长度>))
    }

    方法 置USC2文本 <公开 静态 类型 = 标准文本类W 注释 = "将以\"\\u\"开头的Unicode编码文本转换为文本并置入到本对象中,返回文本对象自身."
            注释 = "例: \"\\u4f60\\u597d,\\u706b\\u5c71!\"转换为\"你好,火山!\"" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲置入USC2文本 <注释 = "提供所欲置入的USC2文本,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类W、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    {
        @ piv::encoding::usc2_to_str(PivS2WV{@<欲置入USC2文本>}.sv, @<本文本>)
    }

    # 加入文本 ---

    方法 加入文本 <公开 静态 类型 = 标准文本类W 注释 = "将一个或多个文本数据加入到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "所欲加入的UTF-16LE文本数据,支持连续加入,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类W、字节集类(UTF-16LE)"
            注释 = " 小数、通用整数型" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ piv::str::appends(@<本文本>, @<文本数据>)
    }

    方法 加入文本行 <公开 静态 类型 = 标准文本类W 注释 = "将一个或多个文本数据加入到当前文本对象的尾部,并在最后加入一个换行符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)"
            折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "所欲加入的UTF-16LE文本数据,支持连续加入,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类W、字节集类(UTF-16LE)"
            注释 = " 小数、通用整数型" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ piv::str::append_line(@<本文本>, @<文本数据>)
    }

    方法 加入字面量 <公开 静态 类型 = 标准文本类W 注释 = "将一个文本字面量加入到当前文本对象的尾部,返回文本对象自身."
            注释 = "相比\"加入文本\",本方法不会产生编码转换,但只能填写文本常量." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @<本文本>.append(L@sn<quot>@pvpt<文本字面量>@sn<quot>)
    }

    方法 加入部分文本 <公开 静态 类型 = 标准文本类W 注释 = "将所指定文本数据的一部分加入到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲加入的UTF-16LE文本数据,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类W、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 所欲添加的长度 <类型 = 变整数 注释 = "提供欲将所指定文本的多少字符添加到当前文本尾部">
    {
        @ piv::str::append(@<本文本>, @<文本数据>, static_cast<size_t>(@<所欲添加的长度>))
    }

    方法 加入重复文本 <公开 静态 类型 = 标准文本类W 注释 = "将所指定的文本重复多次加入当前文本的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的UTF-16LE文本数据,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类W、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 所欲添加的次数 <类型 = 变整数>
    {
        @ piv::str::append_repeat(@<本文本>, @<所欲添加的文本>, static_cast<size_t>(@<所欲添加的次数>))
    }

    方法 加入格式文本 <公开 静态 类型 = 标准文本类W 注释 = "将所指定的格式文本添加到当前文本尾部,返回文本对象自身." 注释 = "注意: 本方法填写文本参数时只能使用文本型."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 格式文本 <注释 = "本参数支持类型: 文本型、标准文本类W、文本视图类W、字节集类(UTF-16LE)" 注释 = "提供其中可以包含格式替换符的文本,其中的格式替换符将被后续对应参数所替换."
            注释 = "以下为常用的格式替换符,详细信息请参阅C++文档中关于sprintf函数的说明." 注释 = "    %c: 字符" 注释 = "    %d: 整数(以有符号十进制格式替换)"
            注释 = "    %o: 整数(以无符号八进制格式替换)" 注释 = "    %u: 整数(以无符号十进制格式替换)" 注释 = "    %x: 整数(以无符号小写十六进制格式替换)"
            注释 = "    %X: 整数(以无符号大写十六进制格式替换)" 注释 = "    %I64d: 长整数(以有符号十进制格式替换)"
            注释 = "    %I64o: 长整数(以无符号八进制格式替换)" 注释 = "    %I64u: 长整数(以无符号十进制格式替换)"
            注释 = "    %I64x: 长整数(以无符号小写十六进制格式替换)" 注释 = "    %I64X: 长整数(以无符号大写十六进制格式替换)"
            注释 = "    %e, %E: 小数(以指数形式替换)" 注释 = "    %f: 小数(以非指数形式替换)" 注释 = "    %.8f: 小数(用来表达小数的带宽度限制的常用格式替换符)"
            注释 = "    %g, %G: 小数(根据值大小自动选择是否以指数形式替换)" 注释 = "    %s: 文本型" 注释 = "    %%: 百分号字符本身"
            注释 = "注意: 如果欲格式化\"变整数\"值,请务必将其先强制转换为整数或者长整数,再使用对应的格式替换符." @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." 注释 = "注意: 本参数填写文本数据时只能使用文本型."
            @匹配类型 = 通用基本型 @可扩展 = "">
    {
        @ @<本文本>.append(piv::edit::format<@m<CharT>>(PivS2WV{@<格式文本>}.c_str(), @<替换数据>))
    }

    方法 加入格式化文本 <公开 静态 类型 = 标准文本类W 注释 = "使用{fmt}将指定的格式化文本添加到当前文本尾部,返回文本对象自身."
            注释 = "支持的文本类型: 文本型、标准文本类W、文本视图类W" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @强制依赖 = "标准格式化类">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 格式文本 <注释 = "  \"{[参数ID][:][填充字符][对齐][符号][#][0][宽度][.精度][L][类型]}\""
            注释 = "  一个标准的替换字段如上,只有首尾的\"{\"和\"}\"字符是必须,其他均可空,全部留" 注释 = "空则是按顺序把替换参数填进去."
            注释 = "  [参数ID]的范围是0-9,表示替换参数的顺序,同一个\"参数ID\"可以在\"格式文本\"" 注释 = "中多次出现."
            注释 = "  [:]选项可空,但如果要使用后面的选项则必须填写." 注释 = "  [填充字符]默认为空格,可填写除了\"{\"和\"}\"以外的任意单个字符;"
            注释 = "  [对齐]选项可用[<][>][^]之一,分别为靠左、靠右和居中对齐.数值参数默认靠" 注释 = "右对齐,其余参数默认靠左对齐."
            注释 = "  [符号]选项可用[+][-][ ],[+]表示在所有数值前插入加号或负号; [-]为默" 注释 = "认值,表示仅在负数前插入负号; [ ]表示在正数前插入空格,负数前插入负号."
            注释 = "  [#]选项只能用于数值参数,在输出2进制、8进制或16进制数值时加上前缀,比如" 注释 = "2进制的\"0b\"、8进制的\"0\"、16进制的\"0x\"."
            注释 = "  [0]只能用于数值参数,填充数字0来对齐,[填充字符]的优先级会高于此选项." 注释 = "  [宽度]选项指定填充对齐的最小宽度,可以使用\"{}\"实现动态宽度."
            注释 = "  [.精度]选项仅用于小数值,其中[精度]为十进制值,用来指定显示小数点后多少" 注释 = "位数字,如\"{:.2f}\"为显示小数点后两位.[精度]可以使用\"{}\"实现动态精度."
            注释 = "  [L]使用本地区域设置插入适当的数字分隔符,此选项仅对数字类型有效." 注释 = "  [类型]选项如下:" 注释 = "    s : 文本型(可省略)"
            注释 = "    c : 字符(可省略)" 注释 = "    b ：整数(以二进制替换,前缀为\"0b\")" 注释 = "    B ：整数(以二进制替换,前缀为\"0B\")"
            注释 = "    c : 整数(将数值转换为字符替换)" 注释 = "    d ：整数(以十进制格式替换,可省略)" 注释 = "    o ：整数(以八进制格式替换)"
            注释 = "    x ：整数(以小写的十六进制替换,前缀为\"0x\")" 注释 = "    X ：整数(以大写的十六进制替换,前缀为\"0X\")"
            注释 = "    a : 小数(以小写的十六进制格式替换,小数点9之后使用指数表示)" 注释 = "    A : 小数(以大写的十六进制格式替换,小数点9之后使用指数表示)"
            注释 = "    e : 小数(以指数格式替换,小写符号)" 注释 = "    E : 小数(以指数格式替换,大写符号)" 注释 = "    f : 小数(以非指数格式替换,小写符号)"
            注释 = "    F : 小数(以非指数格式替换,大写符号)" 注释 = "    g : 小数(根据值大小自动选择是否以指数格式替换,小写符号)"
            注释 = "    G : 小数(根据值大小自动选择是否以指数格式替换,大写符号)" @匹配类型 = 通用型>
    参数 替换数据 <注释 = "  用作给格式文本中的替换字段提供替换参数,替换参数和替换字段的数量可以不" 注释 = "一致. 如果替换字段中用了\"参数ID\",需要注意替换参数的顺序."
            注释 = "  支持类型: 通用数值型、文本型、标准文本类W、文本视图类W" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @<本文本>.append(fmt::format(fmt::runtime(PivS2WV{@<格式文本>}.sv), @<替换数据>))
    }

    方法 加入USC2文本 <公开 静态 类型 = 标准文本类W 注释 = "将以\"\\u\"开头的Unicode编码文本转换为文本并添加到当前文本尾部,返回文本对象自身."
            注释 = "例: \"\\u4f60\\u597d,\\u706b\\u5c71!\"转换为\"你好,火山!\"" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲加入USC2文本 <注释 = "提供所欲加入到尾部的USC2文本,支持类型:" 注释 = " 文本型、标准文本类(W/U/A)、文本视图类(W/U/A)、字节集类" @匹配类型 = 通用型>
    {
        @ @<本文本>.append(piv::encoding::usc2_to_str(PivS2W{@<欲加入USC2文本>}.str, std::wstring{}))
    }

    方法 加入小写文本 <公开 静态 类型 = 标准文本类W 注释 = "将所指定文本中的英文字母转换到小写后添加到当前文本尾部," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的UTF-16LE文本数据,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)"
            @匹配类型 = 通用型>
    {
        @ piv::str::append_lower(@<本文本>, PivS2WV{@<所欲添加的文本>}.sv)
    }

    方法 加入大写文本 <公开 静态 类型 = 标准文本类W 注释 = "将所指定文本中的英文字母转换到大写后添加到当前文本尾部," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的UTF-16LE文本数据,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)"
            @匹配类型 = 通用型>
    {
        @ piv::str::append_upper(@<本文本>, PivS2WV{@<所欲添加的文本>}.sv)
    }

    # 插入文本 ---

    方法 插入文本 <公开 静态 类型 = 标准文本类W 注释 = "将所指定文本插入到当前文本所指定位置,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲插入的索引位置 <类型 = 变整数 注释 = "指定所欲插入的字符索引位置,必须大于等于0且小于等于当前文本的长度.">
    参数 所欲插入的文本 <注释 = "提供所欲插入的UTF-16LE文本数据,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)"
            @匹配类型 = 通用型>
    {
        @ piv::str::insert(@<本文本>, static_cast<size_t>(@<所欲插入的索引位置>), PivS2WV{@<所欲插入的文本>}.sv)
    }

    方法 插入部分文本 <公开 静态 类型 = 标准文本类W 注释 = "将所指定文本的一部分插入到当前文本所指定位置,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲插入的索引位置 <类型 = 变整数 注释 = "指定所欲插入的字符索引位置,必须大于等于0且小于等于当前文本的长度.">
    参数 所欲插入的文本 <注释 = "提供所欲插入的UTF-16LE文本数据,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)"
            @匹配类型 = 通用型>
    参数 所欲插入的长度 <类型 = 变整数 注释 = "提供欲将指定文本的多少字符插入到当前文本的所指定位置">
    {
        @ piv::str::insert(@<本文本>, static_cast<size_t>(@<所欲插入的索引位置>), PivS2WV{@<所欲插入的文本>}.sv, static_cast<size_t>(@<所欲插入的长度>))
    }

    # 寻找文本 ---

    方法 寻找文本 <公开 静态 类型 = 变整数 注释 = "在文本中寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::search(@<本文本>, PivS2WV{@<欲寻找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 倒找文本 <公开 静态 类型 = 变整数 注释 = "在文本中逆向寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::rsearch(@<本文本>, PivS2WV{@<欲寻找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 寻找字符集合 <公开 静态 类型 = 变整数 注释 = "在文本中寻找指定字符集合中任意字符的首次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE);"
            注释 = "字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符" 注释 = "的首次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(piv::str::find_first_of(@<本文本>, PivS2WV{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找字符集合 <公开 静态 类型 = 变整数 注释 = "在文本中逆向寻找指定字符集合中任意字符的最后一次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE);"
            注释 = "字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符" 注释 = "的最后一次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::str::find_last_of(@<本文本>, PivS2WV{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 寻找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在文本中寻找首个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE);"
            注释 = "寻找并返回不等于字符集合中任意字符的首个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(piv::str::find_first_not_of(@<本文本>, PivS2WV{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在文本中逆向寻找最后一个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE);"
            注释 = "寻找并返回不等于字符集合中任意字符的最后一个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::str::find_last_not_of(@<本文本>, PivS2WV{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    # 替换文本 ---

    方法 文本替换 <公开 静态 类型 = 标准文本类W 注释 = "用指定文本数据替换当前文本对象的某一部分,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始替换索引位置 <类型 = 变整数 注释 = "指定替换的起始索引位置,必须大于等于0且小于等于被替换文本长度.">
    参数 替换长度 <类型 = 变整数 注释 = "指定所欲替换的文本部分的长度;" 注释 = "如果加上\"起始替换索引位置\"后大于等于当前的文本长度,"
            注释 = "则变成在当前文本后面加入用作替换的文本.">
    参数 用作替换的文本 <注释 = "支持类型: 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    {
        @ piv::str::replace(@<本文本>, static_cast<size_t>(@<起始替换索引位置>), static_cast<size_t>(@<替换长度>), PivS2WV{@<用作替换的文本>}.sv)
    }

    方法 子文本替换 <公开 静态 类型 = 标准文本类W 注释 = "将所指定文本中的指定内容子文本替换为另一个文本,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲被替换的子文本 <注释 = "提供欲被替换的子文本,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 用作替换的文本 <注释 = "提供用作替换所指定子文本的文本,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 起始替换索引位置 <类型 = 变整数 注释 = "指定在欲被替换文本中的起始搜寻索引位置;" 注释 = "必须大于等于0且小于等于当前文本的长度." @默认值 = 0>
    参数 替换次数 <类型 = 变整数 注释 = "指定所欲进行替换的次数,如果小于0则全部替换." @默认值 = -1>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::str::replace_text(@<本文本>, PivS2WV{@<欲被替换的子文本>}.sv, PivS2WV{@<用作替换的文本>}.sv, static_cast<size_t>(@<起始替换索引位置>), static_cast<size_t>(@<替换次数>), @<是否区分大小写>)
    }

    # 分割文本 ---

    方法 分割文本 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的字符集合进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE);"
            注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其" 注释 = "中任何一个字符时均认为发现了一个分割点)."
            注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三" 注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 标准文本数组类W 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本" 注释 = "存放在最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split(@<本文本>, PivS2WV{@<分割字符集合>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的子文本进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 标准文本数组类W 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split_substr(@<本文本>, PivS2WV{@<分割用子文本>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割文本视图 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的字符集合进行分割,然后将分割的视图存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  与\"分割文本\"不同,本方法不会产生文本复制,数组中的内容仍指向当前的文本,因此"
            注释 = "请勿在当前文本被修改后继续使用该数组." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE);"
            注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其" 注释 = "中任何一个字符时均认为发现了一个分割点)."
            注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三" 注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图数组类W 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split(@<本文本>, PivS2WV{@<分割字符集合>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本视图 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的子文本进行分割,然后将分割的视图存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  与\"分割子文本\"不同,本方法不会产生文本复制,数组中的内容仍指向当前的文本,"
            注释 = "因此请勿在当前文本被修改后继续使用该数组." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图数组类W 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split_substr(@<本文本>, PivS2WV{@<分割用子文本>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    # 提取文本 ---

    方法 取所有子文本中间 <公开 静态 类型 = 变整数 注释 = "循环取出所有位于两段指定文本中间的内容,并保存在数组中,返回数组的成员数." 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 子文本数组 <类型 = 标准文本数组类W 注释 = "所有获取的中间子文本会保存在此数组中">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::get_middles(@<本文本>, @<子文本数组>, PivS2WV{@<开始文本>}.sv, PivS2WV{@<结束文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                                           @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>))
    }

    方法 取子文本中间 <公开 静态 类型 = 标准文本类W 注释 = "取出两段文本中间的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类W、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本." @默认值 = 假>
    {
        @ piv::edit::get_middle(@<本文本>, PivS2WV{@<开始文本>}.sv, PivS2WV{@<结束文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                       @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>, @<失败返回原文本>)
    }

    方法 取子文本左边 <公开 静态 类型 = 标准文本类W 注释 = "寻找提供的文本,然后取出找到的文本左边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        @ piv::edit::get_left(@<本文本>, PivS2WV{@<要查找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                     @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    方法 取子文本右边 <公开 静态 类型 = 标准文本类W 注释 = "寻找提供的文本,然后取出找到的文本右边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        @ piv::edit::get_right(@<本文本>, PivS2WV{@<要查找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                      @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    # 比较文本 ---

    方法 是否相同 <公开 静态 类型 = 逻辑型 注释 = "判断两个文本的内容是否相同" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "所欲比较的另一个文本,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ (piv::edit::compare(@<本文本>, PivS2WV{@<所欲比较的文本>}.sv, @<是否区分大小写>) == 0)
    }

    方法 文本比较 <公开 静态 类型 = 整数 注释 = "比较两个文本,返回比较结果." 返回值注释 = "如果返回值小于0,表示本文本小于所比较文本;"
            返回值注释 = "如果等于0,表示本文本等于所比较文本;" 返回值注释 = "如果大于0,表示本文本大于所比较文本." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "提供所欲比较的文本,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类W、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::compare(@<本文本>, PivS2WV{@<所欲比较的文本>}.sv, @<是否区分大小写>)
    }

    方法 是否以文本开头 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否以所指定文本开头" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其开头的文本,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::starts_with(@<本文本>, PivS2WV{@<所欲检查的文本>}.sv, @<是否区分大小写>)
    }

    方法 是否以文本结束 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否以所指定文本结束" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其结束的文本,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::ends_with(@<本文本>, PivS2WV{@<所欲检查的文本>}.sv, @<是否区分大小写>)
    }

    # 输出文本 ---

    方法 取文本 <公开 静态 类型 = 文本型 注释 = "返回包含当前文本数据的火山文本型" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @an<CVolString>(@<本文本>.c_str())
    }

    方法 到文本型 <公开 静态 类型 = 文本型 注释 = "返回包含当前文本数据的火山文本型" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @an<CVolString>(@<本文本>.c_str())
    }

    方法 到标准文本 <公开 静态 类型 = 标准宽文本类 注释 = "返回官方\"标准文本类\"的参考" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<本文本>
    }

    方法 到文本视图 <公开 静态 类型 = 文本视图类W 注释 = "返回一个包含当前文本数据的视图" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @dt<文本视图类W>{@<本文本>}
    }

    方法 复制文本 <公开 静态 类型 = 变整数 注释 = "将文本指定的部分字符复制到提供的缓冲区中,返回复制的字符数." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲复制到的目标 <注释 = "  复制文本的目标位置,支持类型: 变整数、文本型、字节集类、标准文本类W" 注释 = "  其中变整数为文本指针,必须提前分配好足够的内存空间,"
            注释 = "其余类型会自动分配内存,如实际的复制字符数为0,将清空内容." @匹配类型 = 通用型>
    参数 欲复制的起始索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错.">
    参数 欲复制的字符数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置),将复制索引位置" 注释 = "后面的全部剩余字符.">
    {
        @ static_cast<INT_P>(piv::str::copy(@<本文本>, @<欲复制到的目标>, static_cast<size_t>(@<欲复制的起始索引位置>), static_cast<size_t>(@<欲复制的字符数目>)))
    }

    # 转换文本 ---

    方法 到UTF8 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本的编码转换到UTF-8并返回" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ PivW2U{@<本文本>}.str
    }

    方法 到多字节 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本的编码转换到ANSI多字节并返回" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 代码页 <类型 = 整数 注释 = "仅在读入文件的文本编码为\"多字节\"时有效,0表示使用本地编码,常用代码页:" 注释 = "  932 日文(Shift-JIS)"
            注释 = "  936 中文简体(GB2312)" 注释 = "  949 韩文" 注释 = "  950 中文繁体(Big5)" @默认值 = 0>
    {
        @ PivW2A{@<本文本>, -1, static_cast<uint32_t>(@<代码页>)}.str
    }

    方法 URL编码 <公开 静态 类型 = 标准文本类W 注释 = "将当前文本进行URL编码,返回编码后的文本对象." 返回值注释 = "返回编码后的文本对象" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否UTF8 <类型 = 逻辑型 注释 = "将文本内容以UTF-8方式编码,否则为多字节." @默认值 = 真>
    参数 不编码保留字符 <类型 = 逻辑型 注释 = "是否不编码保留字符(;/?:@=&),保留字符在URL中有特殊含义" @默认值 = 假>
    {
        @ piv::encoding::UrlStrEncode(@<本文本>, @<是否UTF8>, @<不编码保留字符>, std::wstring{})
    }

    方法 URL解码 <公开 静态 类型 = 标准文本类W 注释 = "将当前文本进行URL解码,返回解码后的文本对象." 返回值注释 = "返回解码后的文本对象" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否UTF8 <类型 = 逻辑型 注释 = "将文本内容以UTF-8方式编码,否则为多字节." @默认值 = 真>
    {
        @ piv::encoding::UrlStrDecode(@<本文本>, @<是否UTF8>, std::wstring{})
    }
}

类 标准文本类U <公开 基础类 = 标准文本模板 注释 = "UTF-8编码的标准文本类(std::string)." 折叠 @文档 = "category = \"文本操作\""
        @模板实现类 = "标准文本类U, 字符" @别名 = "std::string">
{

    # @ @def_macro CharT char
    # @ @def_macro EncodeT piv::utf8
    # 静态函数 ---

    方法 创建文本 <公开 静态 类型 = 标准文本类U 注释 = "通过字符串字面量创建一个UTF-8编码的文本对象." 注释 = "注意本方法需要以类名调用(而不是类变量),本方法不会产生文本编码转换."
            注释 = "另外有作用相同的全局方法\"创建文本对象U\"." 返回值注释 = "返回所创建的标准文本类(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量 @默认值 = "">
    {
        @ @dt<标准文本类U>{reinterpret_cast<const char *>(u8@sn<quot>@pvpt<文本字面量>@sn<quot>)}
    }

    # 文本赋值 ---

    方法 值 <公开 静态 属性写 注释 = "将所指定的文本数据置入到文本对象中" 注释 = "" 折叠 "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <类型 = 文本型 注释 = "所欲赋值的文本型数据">
    {
        @ piv::str::assign(@<本文本>, @<文本数据>);
    }

    方法 值 <公开 静态 属性读 类型 = 文本型 注释 = "以文本型返回文本对象的内容" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @an<CVolString>(@<本文本>.c_str())
    }

    方法 置字面量 <公开 静态 类型 = 标准文本类U 注释 = "将填入的一段字符串字面量置入到文本对象中." 注释 = "注意文本对象原本的内容会被覆盖,本方法不会产生文本编码转换." 折叠
            @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @<本文本>.assign(reinterpret_cast<const char *>(u8@sn<quot>@pvpt<文本字面量>@sn<quot>))
    }

    方法 置文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定的文本数据置入到文本对象中,返回文本对象自身." 注释 = "注意文本对象原本的内容会被覆盖."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲置入的UTF-8文本数据,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " 小数、通用整数型"
            @匹配类型 = 通用型>
    {
        @ piv::str::assign(@<本文本>, @<文本数据>)
    }

    方法 置部分文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定文本数据的一部分置入到文本对象中,返回文本对象自身." 注释 = "注意文本对象原本的内容会被覆盖."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲置入的UTF-8文本数据,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 所欲添加的长度 <类型 = 变整数 注释 = "提供欲将所指定文本的多少字符添加到当前文本尾部">
    {
        @ piv::str::assign(@<本文本>, @<文本数据>, static_cast<size_t>(@<所欲添加的长度>))
    }

    方法 置USC2文本 <公开 静态 类型 = 标准文本类U 注释 = "将以\"\\u\"开头的Unicode编码文本转换为文本并置入到本对象中,返回文本对象自身."
            注释 = "例: \"\\u4f60\\u597d,\\u706b\\u5c71!\"转换为\"你好,火山!\"" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲置入USC2文本 <注释 = "提供所欲置入的USC2文本,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ @<本文本>.assign(PivW2U{piv::encoding::usc2_to_str(PivS2V{@<欲置入USC2文本>}.sv, std::wstring{})}.str)

    }

    # 加入文本 ---

    方法 加入文本 <公开 静态 类型 = 标准文本类U 注释 = "将一个或多个文本数据加入到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "所欲加入的UTF-8文本数据,支持连续加入,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " 小数、通用整数型"
            @匹配类型 = 通用型 @可扩展 = "">
    {
        @ piv::str::appends(@<本文本>, @<文本数据>)
    }

    方法 加入文本行 <公开 静态 类型 = 标准文本类U 注释 = "将一个或多个文本数据加入到当前文本对象的尾部,并在最后加入一个换行符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)"
            折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "所欲加入的UTF-8文本数据,支持连续加入,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " 小数、通用整数型"
            @匹配类型 = 通用型 @可扩展 = "">
    {
        @ piv::str::append_line(@<本文本>, @<文本数据>)
    }

    方法 加入字面量 <公开 静态 类型 = 标准文本类U 注释 = "将一个文本字面量加入到当前文本对象的尾部,返回文本对象自身."
            注释 = "相比\"加入文本\",本方法不会产生编码转换,但只能填写文本常量." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @<本文本>.append(reinterpret_cast<const char *>(u8@sn<quot>@pvpt<文本字面量>@sn<quot>))
    }

    方法 加入部分文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定文本数据的一部分加入到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲加入的UTF-8文本数据,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 所欲添加的长度 <类型 = 变整数 注释 = "提供欲将所指定文本的多少字符添加到当前文本尾部">
    {
        @ piv::str::append(@<本文本>, @<文本数据>, static_cast<size_t>(@<所欲添加的长度>))
    }

    方法 加入重复文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定的文本重复多次加入当前文本的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的UTF-8文本数据,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 所欲添加的次数 <类型 = 变整数>
    {
        @ piv::str::append_repeat(@<本文本>, @<所欲添加的文本>, static_cast<size_t>(@<所欲添加的次数>))
    }

    方法 加入格式文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定的格式文本添加到当前文本尾部,返回文本对象自身." 注释 = "注意: 本方法填写文本参数时只能使用文本型."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 格式文本 <注释 = "本参数支持类型: 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = "提供其中可以包含格式替换符的文本,其中的格式替换符将被后续对应参数所替换."
            注释 = "以下为常用的格式替换符,详细信息请参阅C++文档中关于sprintf函数的说明." 注释 = "    %c: 字符" 注释 = "    %d: 整数(以有符号十进制格式替换)"
            注释 = "    %o: 整数(以无符号八进制格式替换)" 注释 = "    %u: 整数(以无符号十进制格式替换)" 注释 = "    %x: 整数(以无符号小写十六进制格式替换)"
            注释 = "    %X: 整数(以无符号大写十六进制格式替换)" 注释 = "    %I64d: 长整数(以有符号十进制格式替换)"
            注释 = "    %I64o: 长整数(以无符号八进制格式替换)" 注释 = "    %I64u: 长整数(以无符号十进制格式替换)"
            注释 = "    %I64x: 长整数(以无符号小写十六进制格式替换)" 注释 = "    %I64X: 长整数(以无符号大写十六进制格式替换)"
            注释 = "    %e, %E: 小数(以指数形式替换)" 注释 = "    %f: 小数(以非指数形式替换)" 注释 = "    %.8f: 小数(用来表达小数的带宽度限制的常用格式替换符)"
            注释 = "    %g, %G: 小数(根据值大小自动选择是否以指数形式替换)" 注释 = "    %s: 文本型" 注释 = "    %%: 百分号字符本身"
            注释 = "注意: 如果欲格式化\"变整数\"值,请务必将其先强制转换为整数或者长整数,再使用对应的格式替换符." @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." 注释 = "注意: 本参数填写文本数据时只能使用文本型."
            @匹配类型 = 通用基本型 @可扩展 = "">
    {
        @ @<本文本>.append(piv::edit::format<char>(PivS2V{@<格式文本>}.c_str(), @<替换数据>))
    }

    方法 加入格式化文本 <公开 静态 类型 = 标准文本类U 注释 = "使用{fmt}将指定的格式化文本添加到当前文本尾部,返回文本对象自身."
            注释 = "支持的文本类型: 文本型、标准文本类U、文本视图类U" 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "req_str_param_text_pointer_u8 = true" @强制依赖 = "标准格式化类">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 格式文本 <注释 = "  \"{[参数ID][:][填充字符][对齐][符号][#][0][宽度][.精度][L][类型]}\""
            注释 = "  一个标准的替换字段如上,只有首尾的\"{\"和\"}\"字符是必须,其他均可空,全部留" 注释 = "空则是按顺序把替换参数填进去."
            注释 = "  [参数ID]的范围是0-9,表示替换参数的顺序,同一个\"参数ID\"可以在\"格式文本\"" 注释 = "中多次出现."
            注释 = "  [:]选项可空,但如果要使用后面的选项则必须填写." 注释 = "  [填充字符]默认为空格,可填写除了\"{\"和\"}\"以外的任意单个字符;"
            注释 = "  [对齐]选项可用[<][>][^]之一,分别为靠左、靠右和居中对齐.数值参数默认靠" 注释 = "右对齐,其余参数默认靠左对齐."
            注释 = "  [符号]选项可用[+][-][ ],[+]表示在所有数值前插入加号或负号; [-]为默" 注释 = "认值,表示仅在负数前插入负号; [ ]表示在正数前插入空格,负数前插入负号."
            注释 = "  [#]选项只能用于数值参数,在输出2进制、8进制或16进制数值时加上前缀,比如" 注释 = "2进制的\"0b\"、8进制的\"0\"、16进制的\"0x\"."
            注释 = "  [0]只能用于数值参数,填充数字0来对齐,[填充字符]的优先级会高于此选项." 注释 = "  [宽度]选项指定填充对齐的最小宽度,可以使用\"{}\"实现动态宽度."
            注释 = "  [.精度]选项仅用于小数值,其中[精度]为十进制值,用来指定显示小数点后多少" 注释 = "位数字,如\"{:.2f}\"为显示小数点后两位.[精度]可以使用\"{}\"实现动态精度."
            注释 = "  [L]使用本地区域设置插入适当的数字分隔符,此选项仅对数字类型有效." 注释 = "  [类型]选项如下:" 注释 = "    s : 文本型(可省略)"
            注释 = "    c : 字符(可省略)" 注释 = "    b ：整数(以二进制替换,前缀为\"0b\")" 注释 = "    B ：整数(以二进制替换,前缀为\"0B\")"
            注释 = "    c : 整数(将数值转换为字符替换)" 注释 = "    d ：整数(以十进制格式替换,可省略)" 注释 = "    o ：整数(以八进制格式替换)"
            注释 = "    x ：整数(以小写的十六进制替换,前缀为\"0x\")" 注释 = "    X ：整数(以大写的十六进制替换,前缀为\"0X\")"
            注释 = "    a : 小数(以小写的十六进制格式替换,小数点9之后使用指数表示)" 注释 = "    A : 小数(以大写的十六进制格式替换,小数点9之后使用指数表示)"
            注释 = "    e : 小数(以指数格式替换,小写符号)" 注释 = "    E : 小数(以指数格式替换,大写符号)" 注释 = "    f : 小数(以非指数格式替换,小写符号)"
            注释 = "    F : 小数(以非指数格式替换,大写符号)" 注释 = "    g : 小数(根据值大小自动选择是否以指数格式替换,小写符号)"
            注释 = "    G : 小数(根据值大小自动选择是否以指数格式替换,大写符号)" @匹配类型 = 通用型>
    参数 替换数据 <注释 = "  用作给格式文本中的替换字段提供替换参数,替换参数和替换字段的数量可以不" 注释 = "一致. 如果替换字段中用了\"参数ID\",需要注意替换参数的顺序."
            注释 = "  支持类型: 通用数值型、文本型、标准文本类U、文本视图类U" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @<本文本>.append(fmt::format(fmt::runtime(PivS2V{@<格式文本>}.sv), @<替换数据>))
    }

    方法 加入USC2文本 <公开 静态 类型 = 标准文本类U 注释 = "将以\"\\u\"开头的Unicode编码文本转换为文本并添加到当前文本尾部,返回文本对象自身."
            注释 = "例: \"\\u4f60\\u597d,\\u706b\\u5c71!\"转换为\"你好,火山!\"" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲加入USC2文本 <注释 = "提供所欲加入到尾部的USC2文本,支持类型:" 注释 = " 文本型、标准文本类(W/U/A)、文本视图类(W/U/A)、字节集类" @匹配类型 = 通用型>
    {
        @ @<本文本>.append(PivW2U{piv::encoding::usc2_to_str(PivS2V{@<欲加入USC2文本>}.sv, std::wstring{})}.str)
    }

    方法 加入小写文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定文本中的英文字母转换到小写后添加到当前文本尾部," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的UTF-8文本数据,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ piv::str::append_lower(@<本文本>, PivS2V{@<所欲添加的文本>}.sv)
    }

    方法 加入大写文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定文本中的英文字母转换到大写后添加到当前文本尾部," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的UTF-8文本数据,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ piv::str::append_upper(@<本文本>, PivS2V{@<所欲添加的文本>}.sv)
    }

    # 插入文本 ---

    方法 插入文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定文本插入到当前文本所指定位置,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲插入的索引位置 <类型 = 变整数 注释 = "指定所欲插入的字符索引位置,必须大于等于0且小于等于当前文本的长度.">
    参数 所欲插入的文本 <注释 = "提供所欲插入的UTF-8文本数据,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ piv::str::insert(@<本文本>, static_cast<size_t>(@<所欲插入的索引位置>), PivS2V{@<所欲插入的文本>}.sv)
    }

    方法 插入部分文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定文本的一部分插入到当前文本所指定位置,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲插入的索引位置 <类型 = 变整数 注释 = "指定所欲插入的字符索引位置,必须大于等于0且小于等于当前文本的长度.">
    参数 所欲插入的文本 <注释 = "提供所欲插入的UTF-8文本数据,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 所欲插入的长度 <类型 = 变整数 注释 = "提供欲将指定文本的多少字符插入到当前文本的所指定位置">
    {
        @ piv::str::insert(@<本文本>, static_cast<size_t>(@<所欲插入的索引位置>), PivS2V{@<所欲插入的文本>}.sv, static_cast<size_t>(@<所欲插入的长度>))
    }

    # 寻找文本 ---

    方法 寻找文本 <公开 静态 类型 = 变整数 注释 = "在文本中寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::search(@<本文本>, PivS2V{@<欲寻找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 倒找文本 <公开 静态 类型 = 变整数 注释 = "在文本中逆向寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::rsearch(@<本文本>, PivS2V{@<欲寻找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 寻找字符集合 <公开 静态 类型 = 变整数 注释 = "在文本中寻找指定字符集合中任意字符的首次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8);"
            注释 = "字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符" 注释 = "的首次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(piv::str::find_first_of(@<本文本>, PivS2V{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找字符集合 <公开 静态 类型 = 变整数 注释 = "在文本中逆向寻找指定字符集合中任意字符的最后一次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8);"
            注释 = "字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符" 注释 = "的最后一次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::str::find_last_of(@<本文本>, PivS2V{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 寻找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在文本中寻找首个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8);"
            注释 = "寻找并返回不等于字符集合中任意字符的首个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(piv::str::find_first_not_of(@<本文本>, PivS2V{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在文本中逆向寻找最后一个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8);"
            注释 = "寻找并返回不等于字符集合中任意字符的最后一个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::str::find_last_not_of(@<本文本>, PivS2V{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    # 替换文本 ---

    方法 文本替换 <公开 静态 类型 = 标准文本类U 注释 = "用指定文本数据替换当前文本对象的某一部分,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始替换索引位置 <类型 = 变整数 注释 = "指定替换的起始索引位置,必须大于等于0且小于等于被替换文本长度.">
    参数 替换长度 <类型 = 变整数 注释 = "指定所欲替换的文本部分的长度;" 注释 = "如果加上\"起始替换索引位置\"后大于等于当前的文本长度,"
            注释 = "则变成在当前文本后面加入用作替换的文本.">
    参数 用作替换的文本 <注释 = "支持类型: 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ piv::str::replace(@<本文本>, static_cast<size_t>(@<起始替换索引位置>), static_cast<size_t>(@<替换长度>), PivS2V{@<用作替换的文本>}.sv)
    }

    方法 子文本替换 <公开 静态 类型 = 标准文本类U 注释 = "将所指定文本中的指定内容子文本替换为另一个文本,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲被替换的子文本 <注释 = "提供欲被替换的子文本,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 用作替换的文本 <注释 = "提供用作替换所指定子文本的文本,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 起始替换索引位置 <类型 = 变整数 注释 = "指定在欲被替换文本中的起始搜寻索引位置;" 注释 = "必须大于等于0且小于等于当前文本的长度." @默认值 = 0>
    参数 替换次数 <类型 = 变整数 注释 = "指定所欲进行替换的次数,如果小于0则全部替换." @默认值 = -1>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::str::replace_text(@<本文本>, PivS2V{@<欲被替换的子文本>}.sv, PivS2V{@<用作替换的文本>}.sv, static_cast<size_t>(@<起始替换索引位置>), static_cast<size_t>(@<替换次数>), @<是否区分大小写>)
    }

    # 分割文本 ---

    方法 分割文本 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的字符集合进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8);"
            注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其" 注释 = "中任何一个字符时均认为发现了一个分割点)."
            注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三" 注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 标准文本数组类U 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本" 注释 = "存放在最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split(@<本文本>, PivS2V{@<分割字符集合>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的子文本进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8);" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 标准文本数组类U 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split_substr(@<本文本>, PivS2V{@<分割用子文本>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割文本视图 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的字符集合进行分割,然后将分割的视图存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  与\"分割文本\"不同,本方法不会产生文本复制,数组中的内容仍指向当前的文本,因此"
            注释 = "请勿在当前文本被修改后继续使用该数组." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8);"
            注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其" 注释 = "中任何一个字符时均认为发现了一个分割点)."
            注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三" 注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图数组类U 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split(@<本文本>, PivS2V{@<分割字符集合>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本视图 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的子文本进行分割,然后将分割的视图存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  与\"分割子文本\"不同,本方法不会产生文本复制,数组中的内容仍指向当前的文本,"
            注释 = "因此请勿在当前文本被修改后继续使用该数组." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图数组类U 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split_substr(@<本文本>, PivS2V{@<分割用子文本>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    # 提取文本 ---

    方法 取所有子文本中间 <公开 静态 类型 = 变整数 注释 = "循环取出所有位于两段指定文本中间的内容,并保存在数组中,返回数组的成员数." 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 子文本数组 <类型 = 标准文本数组类U 注释 = "所有获取的中间子文本会保存在此数组中">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::get_middles(@<本文本>, @<子文本数组>, PivS2V{@<开始文本>}.sv, PivS2V{@<结束文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                                           @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>))
    }

    方法 取子文本中间 <公开 静态 类型 = 标准文本类U 注释 = "取出两段文本中间的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本." @默认值 = 假>
    {
        @ piv::edit::get_middle(@<本文本>, PivS2V{@<开始文本>}.sv, PivS2V{@<结束文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                       @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>, @<失败返回原文本>)
    }

    方法 取子文本左边 <公开 静态 类型 = 标准文本类U 注释 = "寻找提供的文本,然后取出找到的文本左边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        @ piv::edit::get_left(@<本文本>, PivS2V{@<要查找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                     @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    方法 取子文本右边 <公开 静态 类型 = 标准文本类U 注释 = "寻找提供的文本,然后取出找到的文本右边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        @ piv::edit::get_right(@<本文本>, PivS2V{@<要查找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                      @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    # 比较文本 ---

    方法 是否相同 <公开 静态 类型 = 逻辑型 注释 = "判断两个文本的内容是否相同" @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "所欲比较的另一个文本,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ (piv::edit::compare(@<本文本>, PivS2V{@<所欲比较的文本>}.sv, @<是否区分大小写>) == 0)
    }

    方法 文本比较 <公开 静态 类型 = 整数 注释 = "比较两个文本,返回比较结果." 返回值注释 = "如果返回值小于0,表示本文本小于所比较文本;"
            返回值注释 = "如果等于0,表示本文本等于所比较文本;" 返回值注释 = "如果大于0,表示本文本大于所比较文本." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "提供所欲比较的文本,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::compare(@<本文本>, PivS2V{@<所欲比较的文本>}.sv, @<是否区分大小写>)
    }

    方法 是否以文本开头 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否以所指定文本开头" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其开头的文本,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::starts_with(@<本文本>, PivS2V{@<所欲检查的文本>}.sv, @<是否区分大小写>)
    }

    方法 是否以文本结束 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否以所指定文本结束" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其结束的文本,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::ends_with(@<本文本>, PivS2V{@<所欲检查的文本>}.sv, @<是否区分大小写>)
    }

    # 输出文本 ---

    方法 取文本 <公开 静态 类型 = 文本型 注释 = "返回包含当前文本数据的火山文本型" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ PivU2Ws{@<本文本>}.str
    }

    方法 到文本型 <公开 静态 类型 = 文本型 注释 = "返回包含当前文本数据的火山文本型" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @an<CVolString>(@<本文本>.c_str())
    }

    方法 到标准文本 <公开 静态 类型 = 标准文本类 注释 = "返回官方\"标准文本类\"的参考" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<本文本>
    }

    方法 到文本视图 <公开 静态 类型 = 文本视图类U 注释 = "返回一个包含当前文本数据的视图." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @dt<文本视图类U>{@<本文本>}
    }

    方法 复制文本 <公开 静态 类型 = 变整数 注释 = "将文本指定的部分字符复制到提供的缓冲区中,返回复制的字符数." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲复制到的目标 <注释 = "  复制文本的目标位置,支持类型: 变整数、字节集类、标准文本类U" 注释 = "  其中变整数为文本指针,必须提前分配好足够的内存空间,"
            注释 = "其余类型会自动分配内存,如实际的复制字符数为0,将清空内容." @匹配类型 = 通用型>
    参数 欲复制的起始索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错.">
    参数 欲复制的字符数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置),将复制索引位置" 注释 = "后面的全部剩余字符.">
    {
        @ static_cast<INT_P>(piv::str::copy(@<本文本>, @<欲复制到的目标>, static_cast<size_t>(@<欲复制的起始索引位置>), static_cast<size_t>(@<欲复制的字符数目>)))
    }

    # 转换文本 ---

    方法 到UTF16 <公开 静态 类型 = 标准文本类W 注释 = "将当前文本的编码转换到UTF-16并返回" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ PivU2W{@<本文本>}.str
    }

    方法 到多字节 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本的编码转换到ANSI多字节并返回" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 代码页 <类型 = 整数 注释 = "仅在读入文件的文本编码为\"多字节\"时有效,0表示使用本地编码,常用代码页:" 注释 = "  932 日文(Shift-JIS)"
            注释 = "  936 中文简体(GB2312)" 注释 = "  949 韩文" 注释 = "  950 中文繁体(Big5)" @默认值 = 0>
    {
        @ PivU2A{@<本文本>, -1, static_cast<uint32_t>(@<代码页>)}.str
    }

    方法 URL编码 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本进行URL编码,返回编码后的文本对象." 返回值注释 = "返回编码后的文本对象" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 不编码保留字符 <类型 = 逻辑型 注释 = "是否不编码保留字符(;/?:@=&),保留字符在URL中有特殊含义" @默认值 = 假>
    {
        @ piv::encoding::UrlStrEncode(@<本文本>, true, @<不编码保留字符>, std::string{})
    }

    方法 URL解码 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本进行URL解码,返回解码后的文本对象." 返回值注释 = "返回解码后的文本对象" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ piv::encoding::UrlStrDecode(@<本文本>, true, std::string{})
    }
}

类 标准文本类A <公开 基础类 = 标准文本模板 注释 = "ANSI本地多字节编码的标准文本类(std::string)." 折叠 折叠2 @文档 = "category = \"文本操作\""
        @模板实现类 = "标准文本类A, 字符" @别名 = "std::string">
{

    # @ @def_macro CharT char
    # @ @def_macro EncodeT piv::ansi
    # 静态函数 ---

    方法 创建文本 <公开 静态 类型 = 标准文本类A 注释 = "通过字符串字面量创建一个ANSI编码的文本对象." 注释 = "注意本方法需要以类名调用(而不是类变量),本方法不会产生文本编码转换."
            注释 = "另外有作用相同的全局方法\"创建文本对象A\"." 返回值注释 = "返回所创建的标准文本类(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量 @默认值 = "">
    {
        @ @dt<标准文本类A>{@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    # 文本赋值 ---

    方法 值 <公开 静态 属性写 注释 = "将所指定的文本数据置入到文本对象中" 注释 = "" 折叠 "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <类型 = 文本型 注释 = "所欲赋值的文本型数据">
    {
        @ piv::str::assign(@<本文本>, @<文本数据>);
    }

    方法 值 <公开 静态 属性读 类型 = 文本型 注释 = "以文本型返回文本对象的内容" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ PivA2Ws{@<本文本>}.str
    }

    方法 置字面量 <公开 静态 类型 = 标准文本类A 注释 = "将填入的一段字符串字面量置入到文本对象中." 注释 = "注意文本对象原本的内容会被覆盖,本方法不会产生文本编码转换." 折叠
            @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @<本文本>.assign(@sn<quot>@pvpt<文本字面量>@sn<quot>)
    }

    方法 置文本 <公开 静态 类型 = 标准文本类A 注释 = "将所指定的文本数据置入到文本对象中,返回文本对象自身." 注释 = "注意文本对象原本的内容会被覆盖."
            返回值注释 = "返回自身(支持链式语法)" 折叠 隐藏值属性 = "0" @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲置入的ANSI文本数据,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(ANSI)" 注释 = " 小数、通用整数型" @匹配类型 = 通用型>
    {
        @ piv::str::assign(@<本文本>, @<文本数据>)
    }

    方法 置部分文本 <公开 静态 类型 = 标准文本类A 注释 = "将所指定文本数据的一部分置入到文本对象中,返回文本对象自身." 注释 = "注意文本对象原本的内容会被覆盖."
            返回值注释 = "返回自身(支持链式语法)" 折叠 隐藏值属性 = "0" @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲置入的ANSI文本数据,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 所欲添加的长度 <类型 = 变整数 注释 = "提供欲将所指定文本的多少字符添加到当前文本尾部">
    {
        @ piv::str::assign(@<本文本>, @<文本数据>, static_cast<size_t>(@<所欲添加的长度>))
    }

    方法 置USC2文本 <公开 静态 类型 = 标准文本类A 注释 = "将以\"\\u\"开头的Unicode编码文本转换为文本并置入到本对象中,返回文本对象自身."
            注释 = "例: \"\\u4f60\\u597d,\\u706b\\u5c71!\"转换为\"你好,火山!\"" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲置入USC2文本 <注释 = "提供所欲置入的USC2文本,支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI)" @匹配类型 = 通用型>
    {
        @ @<本文本>.assign(PivW2A{piv::encoding::usc2_to_str(PivS2AV{@<欲置入USC2文本>}.sv, std::wstring{})}.str)
    }

    # 加入文本 ---

    方法 加入文本 <公开 静态 类型 = 标准文本类A 注释 = "将一个或多个文本数据加入到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            隐藏值属性 = "0" @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "所欲加入的ANSI文本数据,支持连续加入,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(ANSI)" 注释 = " 小数、通用整数型"
            @匹配类型 = 通用型 @可扩展 = "">
    {
        @ piv::str::appends(@<本文本>, @<文本数据>)
    }

    方法 加入文本行 <公开 静态 类型 = 标准文本类A 注释 = "将一个或多个文本数据加入到当前文本对象的尾部,并在最后加入一个换行符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)"
            折叠 隐藏值属性 = "0" @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "所欲加入的ANSI文本数据,支持连续加入,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(ANSI)" 注释 = " 小数、通用整数型"
            @匹配类型 = 通用型 @可扩展 = "">
    {
        @ piv::str::append_line(@<本文本>, @<文本数据>)
    }

    方法 加入字面量 <公开 静态 类型 = 标准文本类A 注释 = "将一个文本字面量加入到当前文本对象的尾部,返回文本对象自身."
            注释 = "相比\"加入文本\",本方法不会产生编码转换,但只能填写文本常量." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @<本文本>.append(@sn<quot>@pvpt<文本字面量>@sn<quot>)
    }

    方法 加入部分文本 <公开 静态 类型 = 标准文本类A 注释 = "将所指定文本数据的一部分加入到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            隐藏值属性 = "0" @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲加入的ANSI文本数据,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 所欲添加的长度 <类型 = 变整数 注释 = "提供欲将所指定文本的多少字符添加到当前文本尾部">
    {
        @ piv::str::append(@<本文本>, @<文本数据>, static_cast<size_t>(@<所欲添加的长度>))
    }

    方法 加入重复文本 <公开 静态 类型 = 标准文本类A 注释 = "将所指定的文本重复多次加入当前文本的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            隐藏值属性 = "0" @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的ANSI文本数据,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 所欲添加的次数 <类型 = 变整数>
    {
        @ piv::str::append_repeat(@<本文本>, @<所欲添加的文本>, static_cast<size_t>(@<所欲添加的次数>))
    }

    方法 加入格式文本 <公开 静态 类型 = 标准文本类A 注释 = "将所指定的格式文本添加到当前文本尾部,返回文本对象自身." 注释 = "注意: 本方法填写文本参数时只能使用文本型."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 格式文本 <注释 = "本参数支持类型: 文本型、标准文本类A、文本视图类A、字节集类(ANSI)" 注释 = "提供其中可以包含格式替换符的文本,其中的格式替换符将被后续对应参数所替换."
            注释 = "以下为常用的格式替换符,详细信息请参阅C++文档中关于sprintf函数的说明." 注释 = "    %c: 字符" 注释 = "    %d: 整数(以有符号十进制格式替换)"
            注释 = "    %o: 整数(以无符号八进制格式替换)" 注释 = "    %u: 整数(以无符号十进制格式替换)" 注释 = "    %x: 整数(以无符号小写十六进制格式替换)"
            注释 = "    %X: 整数(以无符号大写十六进制格式替换)" 注释 = "    %I64d: 长整数(以有符号十进制格式替换)"
            注释 = "    %I64o: 长整数(以无符号八进制格式替换)" 注释 = "    %I64u: 长整数(以无符号十进制格式替换)"
            注释 = "    %I64x: 长整数(以无符号小写十六进制格式替换)" 注释 = "    %I64X: 长整数(以无符号大写十六进制格式替换)"
            注释 = "    %e, %E: 小数(以指数形式替换)" 注释 = "    %f: 小数(以非指数形式替换)" 注释 = "    %.8f: 小数(用来表达小数的带宽度限制的常用格式替换符)"
            注释 = "    %g, %G: 小数(根据值大小自动选择是否以指数形式替换)" 注释 = "    %s: 文本型" 注释 = "    %%: 百分号字符本身"
            注释 = "注意: 如果欲格式化\"变整数\"值,请务必将其先强制转换为整数或者长整数,再使用对应的格式替换符." @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." 注释 = "注意: 本参数填写文本数据时只能使用文本型."
            @匹配类型 = 通用基本型 @可扩展 = "">
    {
        @ @<本文本>.append(PivW2A{piv::edit::format<wchar_t>(PivS2WV{@<格式文本>}.c_str(), @<替换数据>)}.str)
    }

    方法 加入格式化文本 <公开 静态 类型 = 标准文本类A 注释 = "使用{fmt}将指定的格式化文本添加到当前文本尾部,返回文本对象自身." 注释 = "替换数据仅支持: 标准文本类A、文本视图类A"
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "req_str_param_text_pointer = true" @强制依赖 = "标准格式化类">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 格式文本 <注释 = "  \"{[参数ID][:][填充字符][对齐][符号][#][0][宽度][.精度][L][类型]}\""
            注释 = "  一个标准的替换字段如上,只有首尾的\"{\"和\"}\"字符是必须,其他均可空,全部留" 注释 = "空则是按顺序把替换参数填进去."
            注释 = "  [参数ID]的范围是0-9,表示替换参数的顺序,同一个\"参数ID\"可以在\"格式文本\"" 注释 = "中多次出现."
            注释 = "  [:]选项可空,但如果要使用后面的选项则必须填写." 注释 = "  [填充字符]默认为空格,可填写除了\"{\"和\"}\"以外的任意单个字符;"
            注释 = "  [对齐]选项可用[<][>][^]之一,分别为靠左、靠右和居中对齐.数值参数默认靠" 注释 = "右对齐,其余参数默认靠左对齐."
            注释 = "  [符号]选项可用[+][-][ ],[+]表示在所有数值前插入加号或负号; [-]为默" 注释 = "认值,表示仅在负数前插入负号; [ ]表示在正数前插入空格,负数前插入负号."
            注释 = "  [#]选项只能用于数值参数,在输出2进制、8进制或16进制数值时加上前缀,比如" 注释 = "2进制的\"0b\"、8进制的\"0\"、16进制的\"0x\"."
            注释 = "  [0]只能用于数值参数,填充数字0来对齐,[填充字符]的优先级会高于此选项." 注释 = "  [宽度]选项指定填充对齐的最小宽度,可以使用\"{}\"实现动态宽度."
            注释 = "  [.精度]选项仅用于小数值,其中[精度]为十进制值,用来指定显示小数点后多少" 注释 = "位数字,如\"{:.2f}\"为显示小数点后两位.[精度]可以使用\"{}\"实现动态精度."
            注释 = "  [L]使用本地区域设置插入适当的数字分隔符,此选项仅对数字类型有效." 注释 = "  [类型]选项如下:" 注释 = "    s : 文本型(可省略)"
            注释 = "    c : 字符(可省略)" 注释 = "    b ：整数(以二进制替换,前缀为\"0b\")" 注释 = "    B ：整数(以二进制替换,前缀为\"0B\")"
            注释 = "    c : 整数(将数值转换为字符替换)" 注释 = "    d ：整数(以十进制格式替换,可省略)" 注释 = "    o ：整数(以八进制格式替换)"
            注释 = "    x ：整数(以小写的十六进制替换,前缀为\"0x\")" 注释 = "    X ：整数(以大写的十六进制替换,前缀为\"0X\")"
            注释 = "    a : 小数(以小写的十六进制格式替换,小数点9之后使用指数表示)" 注释 = "    A : 小数(以大写的十六进制格式替换,小数点9之后使用指数表示)"
            注释 = "    e : 小数(以指数格式替换,小写符号)" 注释 = "    E : 小数(以指数格式替换,大写符号)" 注释 = "    f : 小数(以非指数格式替换,小写符号)"
            注释 = "    F : 小数(以非指数格式替换,大写符号)" 注释 = "    g : 小数(根据值大小自动选择是否以指数格式替换,小写符号)"
            注释 = "    G : 小数(根据值大小自动选择是否以指数格式替换,大写符号)" @匹配类型 = 通用型>
    参数 替换数据 <注释 = "  用作给格式文本中的替换字段提供替换参数,替换参数和替换字段的数量可以不" 注释 = "一致. 如果替换字段中用了\"参数ID\",需要注意替换参数的顺序."
            注释 = "  支持类型: 通用数值型、标准文本类A、文本视图类A" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @<本文本>.append(fmt::format(fmt::runtime(PivS2AV{@<格式文本>}.sv), @<替换数据>))
    }

    方法 加入USC2文本 <公开 静态 类型 = 标准文本类A 注释 = "将以\"\\u\"开头的Unicode编码文本转换为文本并添加到当前文本尾部,返回文本对象自身."
            注释 = "例: \"\\u4f60\\u597d,\\u706b\\u5c71!\"转换为\"你好,火山!\"" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲加入USC2文本 <注释 = "提供所欲加入到尾部的USC2文本,支持类型:" 注释 = " 文本型、标准文本类(W/U/A)、文本视图类(W/U/A)、字节集类" @匹配类型 = 通用型>
    {
        @ @<本文本>.append(PivW2A{piv::encoding::usc2_to_str(PivS2AV{@<欲加入USC2文本>}.sv, std::wstring{})}.str)
    }

    方法 加入小写文本 <公开 静态 类型 = 标准文本类A 注释 = "将所指定文本中的英文字母转换到小写后添加到当前文本尾部," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的ANSI文本数据,支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI)" @匹配类型 = 通用型>
    {
        @ piv::str::append_lower(@<本文本>, PivS2AV{@<所欲添加的文本>}.sv)
    }

    方法 加入大写文本 <公开 静态 类型 = 标准文本类A 注释 = "将所指定文本中的英文字母转换到大写后添加到当前文本尾部," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的ANSI文本数据,支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI)" @匹配类型 = 通用型>
    {
        @ piv::str::append_upper(@<本文本>, PivS2AV{@<所欲添加的文本>}.sv)
    }

    # 插入文本 ---

    方法 插入文本 <公开 静态 类型 = 标准文本类A 注释 = "将所指定文本插入到当前文本所指定位置,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲插入的索引位置 <类型 = 变整数 注释 = "指定所欲插入的字符索引位置,必须大于等于0且小于等于当前文本的长度.">
    参数 所欲插入的文本 <注释 = "提供所欲插入的ANSI文本数据,支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI)" @匹配类型 = 通用型>
    {
        @ piv::str::insert(@<本文本>, static_cast<size_t>(@<所欲插入的索引位置>), PivS2AV{@<所欲插入的文本>}.sv)
    }

    方法 插入部分文本 <公开 静态 类型 = 标准文本类A 注释 = "将所指定文本的一部分插入到当前文本所指定位置,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲插入的索引位置 <类型 = 变整数 注释 = "指定所欲插入的字符索引位置,必须大于等于0且小于等于当前文本的长度.">
    参数 所欲插入的文本 <注释 = "提供所欲插入的ANSI文本数据,支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 所欲插入的长度 <类型 = 变整数 注释 = "提供欲将指定文本的多少字符插入到当前文本的所指定位置">
    {
        @ piv::str::insert(@<本文本>, static_cast<size_t>(@<所欲插入的索引位置>), PivS2AV{@<所欲插入的文本>}.sv, static_cast<size_t>(@<所欲插入的长度>))
    }

    # 寻找文本 ---

    方法 寻找文本 <公开 静态 类型 = 变整数 注释 = "在文本中寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::search(@<本文本>, PivS2AV{@<欲寻找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 倒找文本 <公开 静态 类型 = 变整数 注释 = "在文本中逆向寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::rsearch(@<本文本>, PivS2AV{@<欲寻找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 寻找字符集合 <公开 静态 类型 = 变整数 注释 = "在文本中寻找指定字符集合中任意字符的首次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI);"
            注释 = "字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符" 注释 = "的首次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(piv::str::find_first_of(@<本文本>, PivS2AV{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找字符集合 <公开 静态 类型 = 变整数 注释 = "在文本中逆向寻找指定字符集合中任意字符的最后一次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI);"
            注释 = "字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符" 注释 = "的最后一次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::str::find_last_of(@<本文本>, PivS2AV{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 寻找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在文本中寻找首个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI);"
            注释 = "寻找并返回不等于字符集合中任意字符的首个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(piv::str::find_first_not_of(@<本文本>, PivS2AV{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在文本中逆向寻找最后一个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI);"
            注释 = "寻找并返回不等于字符集合中任意字符的最后一个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::str::find_last_not_of(@<本文本>, PivS2AV{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    # 替换文本 ---

    方法 文本替换 <公开 静态 类型 = 标准文本类A 注释 = "用指定文本数据替换当前文本对象的某一部分,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始替换索引位置 <类型 = 变整数 注释 = "指定替换的起始索引位置,必须大于等于0且小于等于被替换文本长度.">
    参数 替换长度 <类型 = 变整数 注释 = "指定所欲替换的文本部分的长度;" 注释 = "如果加上\"起始替换索引位置\"后大于等于当前的文本长度,"
            注释 = "则变成在当前文本后面加入用作替换的文本.">
    参数 用作替换的文本 <注释 = "提供用作替换所指定子文本的文本支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI)" @匹配类型 = 通用型>
    {
        @ piv::str::replace(@<本文本>, static_cast<size_t>(@<起始替换索引位置>), static_cast<size_t>(@<替换长度>), PivS2AV{@<用作替换的文本>}.sv)
    }

    方法 子文本替换 <公开 静态 类型 = 标准文本类A 注释 = "将所指定文本中的指定内容子文本替换为另一个文本,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲被替换的子文本 <注释 = "提供欲被替换的子文本,支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 用作替换的文本 <注释 = "提供用作替换所指定子文本的文本,支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 起始替换索引位置 <类型 = 变整数 注释 = "指定在欲被替换文本中的起始搜寻索引位置;" 注释 = "必须大于等于0且小于等于当前文本的长度." @默认值 = 0>
    参数 替换次数 <类型 = 变整数 注释 = "指定所欲进行替换的次数,如果小于0则全部替换." @默认值 = -1>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::str::replace_text(@<本文本>, PivS2AV{@<欲被替换的子文本>}.sv, PivS2AV{@<用作替换的文本>}.sv, static_cast<size_t>(@<起始替换索引位置>), static_cast<size_t>(@<替换次数>), @<是否区分大小写>)
    }

    # 分割文本 ---

    方法 分割文本 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的字符集合进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI);"
            注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其" 注释 = "中任何一个字符时均认为发现了一个分割点)."
            注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三" 注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 标准文本数组类A 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本" 注释 = "存放在最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split(@<本文本>, PivS2AV{@<分割字符集合>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的子文本进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI);" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 标准文本数组类A 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split_substr(@<本文本>, PivS2AV{@<分割用子文本>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割文本视图 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的字符集合进行分割,然后将分割的视图存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  与\"分割文本\"不同,本方法不会产生文本复制,数组中的内容仍指向当前的文本,因此"
            注释 = "请勿在当前文本被修改后继续使用该数组." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI);"
            注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其" 注释 = "中任何一个字符时均认为发现了一个分割点)."
            注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三" 注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图数组类A 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split(@<本文本>, PivS2AV{@<分割字符集合>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本视图 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的子文本进行分割,然后将分割的视图存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  与\"分割子文本\"不同,本方法不会产生文本复制,数组中的内容仍指向当前的文本,"
            注释 = "因此请勿在当前文本被修改后继续使用该数组." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图数组类A 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split_substr(@<本文本>, PivS2AV{@<分割用子文本>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    # 提取文本 ---

    方法 取所有子文本中间 <公开 静态 类型 = 变整数 注释 = "循环取出所有位于两段指定文本中间的内容,并保存在数组中,返回数组的成员数." 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 子文本数组 <类型 = 标准文本数组类U 注释 = "所有获取的中间子文本会保存在此数组中">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::get_middles(@<本文本>, @<子文本数组>, PivS2AV{@<开始文本>}.sv, PivS2AV{@<结束文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                                           @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>))
    }

    方法 取子文本中间 <公开 静态 类型 = 标准文本类A 注释 = "取出两段文本中间的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本." @默认值 = 假>
    {
        @ piv::str::get_middle<@m<EncodeT>>(@<本文本>, @<开始文本>, @<结束文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                                   @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>, @<失败返回原文本>)
    }

    方法 取子文本左边 <公开 静态 类型 = 标准文本类A 注释 = "寻找提供的文本,然后取出找到的文本左边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        @ piv::edit::get_left(@<本文本>, PivS2AV{@<要查找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                     @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    方法 取子文本右边 <公开 静态 类型 = 标准文本类A 注释 = "寻找提供的文本,然后取出找到的文本右边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        @ piv::edit::get_right(@<本文本>, PivS2AV{@<要查找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                      @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    # 比较文本 ---

    方法 是否相同 <公开 静态 类型 = 逻辑型 注释 = "判断两个文本的内容是否相同" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "所欲比较的另一个文本,支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ (piv::edit::compare(@<本文本>, PivS2AV{@<所欲比较的文本>}.sv, @<是否区分大小写>) == 0)
    }

    方法 文本比较 <公开 静态 类型 = 整数 注释 = "比较两个文本,返回比较结果." 返回值注释 = "如果返回值小于0,表示本文本小于所比较文本;"
            返回值注释 = "如果等于0,表示本文本等于所比较文本;" 返回值注释 = "如果大于0,表示本文本大于所比较文本." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "提供所欲比较的文本,支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::compare(@<本文本>, PivS2AV{@<所欲比较的文本>}.sv, @<是否区分大小写>)
    }

    方法 是否以文本开头 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否以所指定文本开头" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其开头的文本,支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::starts_with(@<本文本>, PivS2AV{@<所欲检查的文本>}.sv, @<是否区分大小写>)
    }

    方法 是否以文本结束 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否以所指定文本结束" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其结束的文本,支持类型:" 注释 = " 文本型、标准文本类(A/W)、文本视图类(A/W)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::ends_with(@<本文本>, PivS2AV{@<所欲检查的文本>}.sv, @<是否区分大小写>)
    }

    # 输出文本 ---

    方法 取文本 <公开 静态 类型 = 文本型 注释 = "返回包含当前文本数据的火山文本型" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ PivA2Ws{@<本文本>}.str
    }

    方法 到文本型 <公开 静态 类型 = 文本型 注释 = "返回包含当前文本数据的火山文本型" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ PivA2Ws{@<本文本>}.str
    }

    方法 到标准文本 <公开 静态 类型 = 标准文本类 注释 = "返回官方\"标准文本类\"的参考" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<本文本>
    }

    方法 到文本视图 <公开 静态 类型 = 文本视图类A 注释 = "返回一个包含当前文本数据的视图." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @dt<文本视图类A>{@<本文本>}
    }

    方法 复制文本 <公开 静态 类型 = 变整数 注释 = "将文本指定的部分字符复制到提供的缓冲区中,返回复制的字符数." 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲复制到的目标 <注释 = "  复制文本的目标位置,支持类型: 变整数、字节集类、标准文本类A" 注释 = "  其中变整数为文本指针,必须提前分配好足够的内存空间,"
            注释 = "其余类型会自动分配内存,如实际的复制字符数为0,将清空内容." @匹配类型 = 通用型>
    参数 欲复制的起始索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错.">
    参数 欲复制的字符数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置),将复制索引位置" 注释 = "后面的全部剩余字符.">
    {
        @ static_cast<INT_P>(piv::str::copy(@<本文本>, @<欲复制到的目标>, static_cast<size_t>(@<欲复制的起始索引位置>), static_cast<size_t>(@<欲复制的字符数目>)))
    }

    # 转换文本 ---

    方法 到UTF16 <公开 静态 类型 = 标准文本类W 注释 = "将当前文本的编码转换到UTF-16并返回" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ PivA2W{@<本文本>}.str
    }

    方法 到UTF8 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本的编码转换到UTF-8并返回" 折叠 @嵌入式方法 = "">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 代码页 <类型 = 整数 注释 = "仅在读入文件的文本编码为\"多字节\"时有效,0表示使用本地编码,常用代码页:" 注释 = "  932 日文(Shift-JIS)"
            注释 = "  936 中文简体(GB2312)" 注释 = "  949 韩文" 注释 = "  950 中文繁体(Big5)" @默认值 = 0>
    {
        @ PivA2U{@<本文本>, -1, static_cast<uint32_t>(@<代码页>)}.str
    }

    方法 URL编码 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本进行URL编码,返回编码后的文本对象." 返回值注释 = "返回编码后的文本对象" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 不编码保留字符 <类型 = 逻辑型 注释 = "是否不编码保留字符(;/?:@=&),保留字符在URL中有特殊含义" @默认值 = 假>
    {
        @ piv::encoding::UrlStrEncode(@<本文本>, false, @<不编码保留字符>, std::string{})
    }

    方法 URL解码 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本进行URL解码,返回解码后的文本对象." 返回值注释 = "返回解码后的文本对象" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ piv::encoding::UrlStrDecode(@<本文本>, false, std::string{})
    }
}

# 文本视图(std::basic_string_view) ====

类 文本视图模板 <公开 注释 = "文本视图类(std::basic_string_view)的模板基础类." 注释 = "\"模板类型1\"为模板实现类的类型(用于返回值)."
        注释 = "\"模板类型2\"为字符类型." 注释 = "\"模板类型3\"为对应编码的标准文本类(用于返回值)." 折叠 @文档 = "category = \"文本操作\""
        "@视窗.外部头文件.全局-111" = "src\\piv_string.hpp" @视窗.附加编译参数 = "cpp: /std:c++17" @模板基础类 = 真 @别名类型 = 本地类>
{

    # 视图属性 ---

    方法 是否为空 <公开 静态 类型 = 逻辑型 注释 = "返回文本视图是否为空" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<本视图>.empty()
    }

    方法 取文本指针 <公开 静态 类型 = 变整数 注释 = "  获取文本视图的首字符指针,无法保证该指针含结束零字符," 注释 = "一般需要配合\"取文本长度\"使用." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ reinterpret_cast<INT_P>(@<本视图>.data())
    }

    方法 取文本长度 <公开 静态 类型 = 整数 注释 = "获取文本视图的文本长度(字符数量)." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ static_cast<INT>(@<本视图>.size())
    }

    方法 取字节长度 <公开 静态 类型 = 整数 注释 = "获取文本视图的字节长度" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ static_cast<INT>(@<本视图>.size() * sizeof(@m<CharT>))
    }

    方法 取文字长度 <公开 静态 类型 = 整数 注释 = "  返回文本视图的文字长度,对于UTF-8和多字节,一个文字往往会占用一或多个字符,"
            注释 = "即便Unicode也不是所有文字都占一个字符,比如Emoji表情就占两个字符." 注释 = "  本方法可以准确返回文本中所有文字的数量." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ static_cast<INT>(piv::edit::count_with_word<@m<EncodeT>>(@<本视图>))
    }

    方法 取文本哈希值 <公开 静态 类型 = 变整数 注释 = "  计算并返回文本视图的哈希值,区分英文字母的大小写." 注释 = "  文本哈希值可以在比较两个文本是否相同时使用(即如果"
            注释 = "两个文本的哈希值不同,则两个文本必定不相同)." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ static_cast<INT_P>(std::hash<@dt<模板类型1>>{}(@<本视图>))
    }

    方法 取文本大小写无关哈希值 <公开 静态 类型 = 变整数 注释 = "  计算并返回文本视图的哈希值,不区分英文字母的大小写." 注释 = "  文本哈希值可以在比较两个文本是否相同时使用(即如果"
            注释 = "两个文本的哈希值不同,则两个文本必定不相同)." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ static_cast<INT_P>(piv::ci_hash<@dt<模板类型1>>{}(@<本视图>))
    }

    方法 取对象自身指针 <公开 静态 类型 = 变整数 注释 = "返回本视图视图(std::basic_string_view)自身的指针" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ reinterpret_cast<INT_P>(&@<本视图>)
    }

    # 视图赋值 ---

    方法 置文本指针 <公开 静态 类型 = 模板类型1 注释 = "将文本视图指向所指定的文本指针,返回文本视图自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本指针 <类型 = 变整数 注释 = "所欲指向的文本指针,指针的编码类型必须跟文本视图一致.">
    参数 文本长度 <类型 = 变整数 注释 = "提供文本的字符长度;" 注释 = "参数为-1时会自动识别长度,但指向的文本必须带结束零字符."
            注释 = "如果文本不含结束零字符或者要置入部分文本,则必须提供正确的字符长度." @默认值 = -1>
    {
        @ (@<本视图> = piv::make_sv<@m<CharT>>(reinterpret_cast<const @m<CharT> *>(@<文本指针>), static_cast<size_t>(@<文本长度>)))
    }

    方法 置文件资源 <公开 静态 类型 = 逻辑型 注释 = "将文本视图指向所指定的文件资源,返回是否载入成功." 返回值注释 = "无论是否成功,视图都会先被清空." 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲指向的数据资源 <类型 = 视窗文件资源 注释 = "所欲指向的文本数据资源,文本编码必须跟文本视图一致.">
    {
        @ piv::edit::load_resdata<@m<CharT>>(@<本视图>, @<所欲指向的数据资源>)
    }

    # 删除字符 ---

    方法 清空视图 <公开 静态 注释 = "清空文本视图" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<本视图> = @dt<模板类型1>{}
    }

    方法 后移起点 <公开 静态 类型 = 模板类型1 注释 = "  从文本视图的起点向后移动所指定的字符数,以收缩视图的长度," 注释 = "返回文本视图自身."
            注释 = "  本方法只改动指针值,不会修改视图所指向的文本数据." 返回值注释 = "返回自身(支持链式语法)" 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲移除字符数 <类型 = 变整数 注释 = "所欲从视图起始移除的字符数,大于等于视图长度将删空视图.">
    {
        // @ PIV_ASSERT(static_cast<size_t>(@<所欲移除字符数>) <= @<本视图>.size(), L"所欲移除的字符数不能大于文本视图的长度.", @sn<current_source_class>"::"@sn<current_source_method>);
        @ @<本视图>.remove_prefix((std::min<size_t>)(@<本视图>.size(), @<所欲移除字符数>));
        @ return @<本视图>;
    }

    方法 前移终点 <公开 静态 类型 = 模板类型1 注释 = "  从文本视图的终点向前移动所指定的字符数,以收缩视图的长度," 注释 = "返回文本视图自身."
            注释 = "  本方法只改动指针值,不会修改视图所指向的文本数据." 返回值注释 = "返回自身(支持链式语法)" 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲移除字符数 <类型 = 变整数 注释 = "所欲从视图终点移除的字符数,大于等于视图长度将删空视图.">
    {
        // @ PIV_ASSERT(static_cast<size_t>(@<所欲移除字符数>) <= @<本视图>.size(), L"所欲移除的字符数不能大于文本视图的长度.", @sn<current_source_class>"::"@sn<current_source_method>);
        @ @<本视图>.remove_suffix((std::min<size_t>)(@<本视图>.size(), @<所欲移除字符数>));
        @ return @<本视图>;
    }

    方法 删首空 <公开 静态 类型 = 模板类型1 注释 = "删除文本视图首部的所有空白字符,返回文本视图自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ piv::edit::trim_left(@<本视图>)
    }

    方法 删尾空 <公开 静态 类型 = 模板类型1 注释 = "删除文本视图尾部的所有空白字符,返回文本视图自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ piv::edit::trim_right(@<本视图>)
    }

    方法 删首尾空 <公开 静态 类型 = 模板类型1 注释 = "删除文本视图首部和尾部的所有空白字符,返回文本视图自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ piv::edit::trim_right(piv::edit::trim_left(@<本视图>))
    }

    # 寻找文本 ---

    方法 寻找字符 <公开 静态 类型 = 变整数 注释 = "在文本视图中查找所指定字符的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    参数 所欲查找的字符 <类型 = 模板类型2 注释 = "提供所欲查找的字符;" 注释 = "\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节).">
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,应大于等于0且小于等于文本长度." @默认值 = 0>
    {
        @ static_cast<INT_P>(@<本视图>.find(@<所欲查找的字符>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找字符 <公开 静态 类型 = 变整数 注释 = "在文本视图中逆向查找所指定字符的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    参数 所欲查找的字符 <类型 = 模板类型2 注释 = "提供所欲查找的字符;" 注释 = "\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节).">
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,应小于等于文本长度,小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(@<本视图>.rfind(@<所欲查找的字符>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    # 提取文本 ---

    方法 取字符 <公开 静态 类型 = 模板类型2 注释 = "返回文本视图中所指定索引位置处的字符,文本视图为空时将报错."
            返回值注释 = "返回\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节)" 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    参数 字符索引位置 <类型 = 整数 注释 = "提供所欲获取字符的索引位置,必须大于等于0小于文本视图的长度.">
    {
        @ PIV_ASSERT(@<字符索引位置> >= 0 && (size_t)@<字符索引位置> < @<本视图>.size() && @<本视图>.empty() == false,
        @     L"索引位置必须大于等于0且小于文本视图长度,且文本视图不能为空.", @sn<current_source_class>"::"@sn<current_source_method>);
        @ return @<本视图>[static_cast<size_t>(@<字符索引位置>)];
    }

    方法 取首字符 <公开 静态 类型 = 模板类型2 注释 = "返回文本视图的首字符,文本视图为空时将报错." 返回值注释 = "返回\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节)"
            折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    {
        @ PIV_ASSERT(!@<本视图>.empty(), L"文本视图不能为空.", @sn<current_source_class>"::"@sn<current_source_method>);
        @ return @<本视图>.front();
    }

    方法 取尾字符 <公开 静态 类型 = 模板类型2 注释 = "返回文本视图的尾字符,文本视图为空时将报错." 返回值注释 = "返回\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节)"
            折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    {
        @ PIV_ASSERT(!@<本视图>.empty(), L"文本视图不能为空.", @sn<current_source_class>"::"@sn<current_source_method>);
        @ return @<本视图>.back();
    }

    方法 取文本中间 <公开 静态 类型 = 模板类型1 注释 = "返回一个文本视图,其中包含当前文本中从指定位置算起指定数量的字符." 注释 = "异常类型: std::out_of_range" 折叠
            @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    参数 起始取出索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于文本长度,否则报错.">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置)," 注释 = "将返回索引位置后面的全部剩余字符.">
    {
        @ PIV_ASSERT(static_cast<size_t>(@<起始取出索引位置>) <= @<本视图>.size(),
        @            L"索引位置不能大于文本长度", @sn<current_source_class>"::"@sn<current_source_method>);
        @ return @<本视图>.substr(static_cast<size_t>(@<起始取出索引位置>), static_cast<size_t>(@<欲取出字符的数目>));
    }

    方法 取文本左边 <公开 静态 类型 = 模板类型1 注释 = "返回一个文本视图,其中包含当前文本中从左边算起指定数量的字符." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本长度,将返回完整的文本.">
    {
        @ @<本视图>.substr(0, static_cast<size_t>(@<欲取出字符的数目>))
    }

    方法 取文本右边 <公开 静态 类型 = 模板类型1 注释 = "返回一个文本视图,其中包含当前文本中从右边算起指定数量的字符." 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本长度,将返回完整的文本.">
    {
        @ size_t pos = (static_cast<size_t>(@<欲取出字符的数目>) > @<本视图>.size()) ? 0 : @<本视图>.size() - static_cast<size_t>(@<欲取出字符的数目>);
        @ return @<本视图>.substr(pos, static_cast<size_t>(@<欲取出字符的数目>));
    }

    方法 取中间文字 <公开 静态 类型 = 模板类型1 注释 = "返回一个文本视图,其中包含当前文本中从指定位置算起指定数量的文字."
            注释 = "注: 跟\"取文本中间\"不同,本方法以实际显示的文字为单位(一个文字可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 起始取出索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首文字位置,如果大于文本的文字数量会返回空文本.">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于等于(文字数目-索引位置),将返回索引位置后面" 注释 = "的全部剩余文字.">
    {
        @ piv::edit::substr_with_word<@m<EncodeT>>(@<本视图>, static_cast<size_t>(@<起始取出索引位置>), static_cast<size_t>(@<欲取出文字的数目>))
    }

    方法 取左边文字 <公开 静态 类型 = 模板类型1 注释 = "返回一个文本视图,其中包含当前文本中从左边算起指定数量的文字."
            注释 = "注: 跟\"取文本左边\"不同,本方法以实际显示的文字为单位(一个文字可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本的文字长度,将返回完整的文本.">
    {
        @ piv::edit::substr_with_word<@m<EncodeT>>(@<本视图>, 0, static_cast<size_t>(@<欲取出文字的数目>))
    }

    方法 取右边文字 <公开 静态 类型 = 模板类型1 注释 = "返回一个文本视图,其中包含当前文本中从右边算起指定数量的文字."
            注释 = "注: 跟\"取文本右边\"不同,本方法以实际显示的文字为单位(一个文字可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本的文字长度,将返回完整的文本.">
    {
        @ size_t length = piv::edit::count_with_word<@m<EncodeT>, @dt<模板类型1>>(@<本视图>);
        @ size_t pos = (static_cast<size_t>(@<欲取出文字的数目>) >= length) ? 0 : (length - static_cast<size_t>(@<欲取出文字的数目>));
        @ return piv::edit::substr_with_word<@m<EncodeT>>(@<本视图>, pos, static_cast<size_t>(@<欲取出文字的数目>));
    }

    # 文本比较 ---

    方法 是否以字符开头 <公开 静态 类型 = 逻辑型 注释 = "返回当前视图是否以所指定字符开头" 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    参数 所欲检查的字符 <类型 = 模板类型2 注释 = "提供用来检查是否以其开头的字符," 注释 = "\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节).">
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ if (@<本视图>.empty())
        @     return FALSE;
        @ if (@<是否区分大小写>)
        @     return (@<本视图>.front() == @<所欲检查的字符>);
        @ else
        @     return (piv::edit::tolower(static_cast<uint16_t>(@<本视图>.front())) == piv::edit::tolower(static_cast<uint16_t>(@<所欲检查的字符>)));
    }

    方法 是否以字符结束 <公开 静态 类型 = 逻辑型 注释 = "返回当前视图是否以所指定字符结束" 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    参数 所欲检查的字符 <类型 = 模板类型2 注释 = "提供用来检查是否以其结束的字符," 注释 = "\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节).">
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ if (@<本视图>.empty())
        @     return FALSE;
        @ if (@<是否区分大小写>)
        @     return (@<本视图>.back() == @<所欲检查的字符>);
        @ else
        @     return (piv::edit::tolower(static_cast<uint16_t>(@<本视图>.back())) == piv::edit::tolower(static_cast<uint16_t>(@<所欲检查的字符>)));
    }

    方法 取文本MD5 <公开 静态 类型 = 模板类型3 注释 = "计算并返回文本视图的MD5数据摘要(32个字符)." 返回值注释 = "\"模板类型3\"为本视图对应编码的标准文本类" 折叠
            @嵌入式方法 = "" @强制依赖 = "MD5校验类">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本对象,本参数无需填写." @视窗.前缀文本 = "const ">
    参数 是否大写 <类型 = 逻辑型 注释 = "默认返回大写字符,为假时返回小写字符." @默认值 = 真>
    {
        @ piv::GetStringMd5(@<本视图>, static_cast<bool>(@<是否大写>))
    }

    # 视图输出

    方法 复制到字符数组 <公开 静态 类型 = 变整数 注释 = "将文本视图的内容复制到所指定的字符数组中,返回复制的字符数." 注释 = "注: 出错将抛出异常" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲复制到的字符数组 <类型 = "模板类型2 []" 注释 = "提供所欲复制到的字符数组,成员\"模板类型2\"为字符(Unicode)或字节(UTF-8和多字节).">
    参数 欲复制的起始索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错.">
    参数 欲复制的字符数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置);" 注释 = "将复制索引位置后面的全部剩余字符.">
    {
        @ (INT_P>)@<本视图>.copy(@<所欲复制到的字符数组>, static_cast<size_t>(@<欲复制的起始索引位置>), static_cast<size_t>(@<欲复制的字符数目>))
    }

    方法 到字节集 <公开 静态 类型 = 字节集类 注释 = "返回一个包含当前视图内容的字节集,本方法会产生内存复制." 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    参数 是否添加结束零字符 <类型 = 逻辑型 注释 = "指定返回的文本字节集中是否包括结束零字符" @默认值 = 假>
    {
        @ return @an<CVolMem>{@<本视图>.data(), (@<本视图>.size() + (@<是否添加结束零字符> ? 1 : 0)) * sizeof(@m<CharT>)};
    }

    方法 到整数 <公开 静态 类型 = 整数 注释 = "将当前文本视图的整数值文本转换到整数并返回" 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    参数 进制 <类型 = 整数 注释 = "提供整数文本的进制类型,范围为2到36进制." 注释 = "默认值0表示根据数值前缀自动识别进制,如\"0x\"为16进制,"
            注释 = "\'0\'开头为8进制,1-9开头为10进制." @默认值 = 0>
    {
        @ @m<CharT> buf[34] = {'\0'};
        @ @<本视图>.copy(buf, 32, 0);
        @ PIV_IF (sizeof(@m<CharT>) == 2)
        @     return static_cast<int32_t>(wcstoul((const wchar_t *)buf, nullptr, @<进制>));
        @ else
        @     return static_cast<int32_t>(strtoul((const char *)buf, nullptr, @<进制>));
    }

    方法 到长整数 <公开 静态 类型 = 长整数 注释 = "将当前文本视图的长整数值文本转换到长整数并返回" 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    参数 进制 <类型 = 整数 注释 = "提供整数文本的进制类型,范围为2到36进制." 注释 = "默认值0表示根据数值前缀自动识别进制,如\"0x\"为16进制,"
            注释 = "\'0\'开头为8进制,1-9开头为10进制." @默认值 = 0>
    {
        @ @m<CharT> buf[66] = {'\0'};
        @ @<本视图>.copy(buf, 64, 0);
        @ PIV_IF (sizeof(@m<CharT>) == 2)
        @     return static_cast<int64_t>(wcstoull((const wchar_t *)buf, nullptr, @<进制>));
        @ else
        @     return static_cast<int64_t>(strtoull((const char *)buf, nullptr, @<进制>));
    }

    方法 到小数 <公开 静态 类型 = 小数 注释 = "将当前文本视图的双精度浮点数文本转换到小数并返回" 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    {
        @ @m<CharT> buf[130] = {'\0'};
        @ @<本视图>.copy(buf, 128, 0);
        @ PIV_IF (sizeof(@m<CharT>) == 2)
        @     return _wtof(reinterpret_cast<const wchar_t *>(buf));
        @ else
        @     return atof(reinterpret_cast<const char *>(buf));
    }

    方法 到十六进制 <公开 静态 类型 = 模板类型3 注释 = "将本文本视图的内容转换为十六进制格式的连续文本" 返回值注释 = "\"模板类型3\"为本视图对应编码的标准文本类" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否分隔字符 <类型 = 逻辑型 注释 = "是否用空格分隔十六进制字符" @默认值 = 假>
    {
        @ piv::encoding::str_to_hex<@m<CharT>>(@<本视图>, @<是否分隔字符>, @dt<模板类型3>{})
    }

    方法 到十六进制文本 <公开 静态 类型 = 文本型 注释 = "将本文本视图的内容转换为十六进制格式的连续文本,返回火山的文本型." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否分隔字符 <类型 = 逻辑型 注释 = "是否用空格分隔十六进制字符" @默认值 = 假>
    {
        @ piv::encoding::str_to_hex(@<本视图>, @<是否分隔字符>, @an<CVolString>{})
    }

    方法 到USC2 <公开 静态 类型 = 模板类型3 注释 = "将文本视图的内容转换为以\"\\u\"开头的Unicode编码文本."
            注释 = "例: \"你好,火山!\"编码为\"\\u4f60\\u597d,\\u706b\\u5c71!\"" 返回值注释 = "\"模板类型3\"为本视图对应编码的标准文本类" 折叠
            @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "是否编码ASCII字符" @默认值 = 假>
    {
        @ PIV_IF(sizeof(@m<EncodeT>) == 2)
        @     return piv::encoding::to_usc2(@<本视图>, @<编码ASCII字符>, @dt<模板类型3>{});
        @ PIV_ELSE_IF(sizeof(@m<EncodeT>) == 3)
        @     return piv::encoding::to_usc2(PivU2W{reinterpret_cast<const char *>(@<本视图>.c_str())}.str, @<编码ASCII字符>, @dt<模板类型3>{});
        @ else
        @     return piv::encoding::to_usc2(PivA2W{reinterpret_cast<const char *>(@<本视图>.c_str())}.str, @<编码ASCII字符>, @dt<模板类型3>{});
    }

    方法 到USC2文本 <公开 静态 类型 = 文本型 注释 = "将文本视图的内容转换为以\"\\u\"开头的Unicode编码文本,返回火山的文本型."
            注释 = "例: \"你好,火山!\"编码为\"\\u4f60\\u597d,\\u706b\\u5c71!\"" 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "是否编码ASCII字符" @默认值 = 假>
    {
        @ PIV_IF(sizeof(@m<EncodeT>) == 2)
        @     return piv::encoding::to_usc2(@<本视图>, @<编码ASCII字符>, @an<CVolString>{});
        @ PIV_ELSE_IF(sizeof(@m<EncodeT>) == 3)
        @     return piv::encoding::to_usc2(PivU2W{reinterpret_cast<const char *>(@<本视图>.data()), @<本视图>.size()}.str, @<编码ASCII字符>, @an<CVolString>{});
        @ else
        @     return piv::encoding::to_usc2(PivA2W{reinterpret_cast<const char *>(@<本视图>.data()), @<本视图>.size()}.str, @<编码ASCII字符>, @an<CVolString>{});
    }

    # 转换文本 ---

    方法 到小写 <公开 静态 类型 = 模板类型3 注释 = "将文本视图中的所有英文字母转换为小写,返回转换后的结果文本." 返回值注释 = "\"模板类型3\"为本视图对应编码的标准文本类" 折叠
            @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    {
        @ @dt<模板类型3> lower;
        @ lower.resize(@<本视图>.size());
        @ std::transform(@<本视图>.begin(), @<本视图>.end(), lower.begin(),
        @                [](@m<CharT> c) -> @m<CharT>
        @                { return (@m<CharT>)piv::edit::tolower(static_cast<uint16_t>(c)); });
        @ return lower;
    }

    方法 到大写 <公开 静态 类型 = 模板类型3 注释 = "将文本视图中的所有英文字母转换为大写,返回转换后的结果文本." 返回值注释 = "\"模板类型3\"为本视图对应编码的标准文本类" 折叠
            @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    {
        @ @dt<模板类型3> upper;
        @ upper.resize(@<本视图>.size());
        @ std::transform(@<本视图>.begin(), @<本视图>.end(), upper.begin(),
        @                [](@m<CharT> c) -> @m<CharT>
        @                { return (@m<CharT>)piv::edit::toupper(static_cast<uint16_t>(c)); });
        @ return upper;
    }

    方法 到半角 <公开 静态 类型 = 模板类型3 注释 = "将文本视图中所有的全角ASCII字符转换为对应的半角字符,返回转换后的结果文本."
            返回值注释 = "\"模板类型3\"为本视图对应编码的标准文本类" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    参数 转换选项 <类型 = 整数 注释 = "选择要转换全角字符,默认转换全部全角ASCII字符,可选参数如下:" 注释 = "  1 = 标点符号;" 注释 = "  2 = 数字(0-9);"
            注释 = "  4 = 英文字母(a-z/A-Z);" 注释 = "可以使用\"位或\"组合多种选项." @默认值 = 7>
    {
        @ piv::edit::to_halfwidth<@m<EncodeT>>(@<本视图>, @<转换选项>)
    }

    方法 到全角 <公开 静态 类型 = 模板类型3 注释 = "将文本视图中所有的半角ASCII字符转换为对应的全角字符,返回转换后的结果文本."
            返回值注释 = "\"模板类型3\"为本视图对应编码的标准文本类" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    参数 转换选项 <类型 = 整数 注释 = "选择要转换半角字符,默认转换全部半角字符,可选参数如下:" 注释 = "  1 = 标点符号;" 注释 = "  2 = 数字(0-9);"
            注释 = "  4 = 英文字母(a-z/A-Z);" 注释 = "可以使用\"位或\"组合多种选项." @默认值 = 7>
    {
        @ piv::edit::to_fullwidth<@m<EncodeT>>(@<本视图>, @<转换选项>)
    }

    方法 取逆序文本 <公开 静态 类型 = 模板类型3 注释 = "将当前文本视图的内容逆序翻转,然后将其返回." 返回值注释 = "\"模板类型3\"为本视图对应编码的标准文本类" 折叠
            @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ piv::edit::reverse_text<@m<EncodeT>>(@<本视图>)
    }

    # BASE编码 ---

    方法 BASE64编码 <公开 静态 类型 = 模板类型3 注释 = "返回当前文本视图所对应的BASE64编码格式文本内容" 返回值注释 = "\"模板类型3\"为本视图对应编码的标准文本类" 折叠
            @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 每行最大字符数 <类型 = 整数 注释 = "指定每行编码文本的最大字符数,小于0表示无限制,等于0表示使用默认每行字符数(76)." @默认值 = 0>
    {
        @ piv::base64<@m<CharT>>{}.encode(@<本视图>, @dt<模板类型3>{}, @<每行最大字符数>)
    }

    方法 BASE64解码 <公开 静态 类型 = 模板类型3 注释 = "  将当前的BASE64编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE64到字节集\"." 返回值注释 = "\"模板类型3\"为本视图对应编码的标准文本类" 折叠
            @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ piv::base64<@m<CharT>>{}.decode(@<本视图>)
    }

    方法 BASE85编码 <公开 静态 类型 = 模板类型3 注释 = "返回当前文本视图所对应的BASE85编码格式文本内容" 返回值注释 = "\"模板类型3\"为本视图对应编码的标准文本类" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 自动填充 <类型 = 逻辑型 注释 = "为真时将自动在临时文本后填充0字符,以满足字节对齐为4的倍数." 注释 = "如果为假,文本长度必须为4的倍数,否则将失败返回空文本." @默认值 = 真>
    {
        @ piv::base85<@m<CharT>>{}.encode(@<本视图>, @<自动填充>)
    }

    方法 BASE85解码 <公开 静态 类型 = 模板类型3 注释 = "  将当前的BASE85编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE85到字节集\"." 返回值注释 = "\"模板类型3\"为本视图对应编码的标准文本类" 折叠
            @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ piv::base85<@m<CharT>>{}.decode(@<本视图>)
    }

    方法 BASE91编码 <公开 静态 类型 = 模板类型3 注释 = "返回当前文本视图所对应的BASE91编码格式文本内容." 注释 = "保留ASCII字符为{<>\"}."
            返回值注释 = "\"模板类型3\"为本视图对应编码的标准文本类" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ piv::base91<@m<CharT>>{}.encode(@<本视图>)
    }

    方法 BASE91解码 <公开 静态 类型 = 模板类型3 注释 = "  将当前的BASE91编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE91到字节集\"." 注释 = "  保留ASCII字符为{<>\"}."
            返回值注释 = "\"模板类型3\"为本视图对应编码的标准文本类" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ piv::base91<@m<CharT>>{}.decode(@<本视图>)
    }

    方法 BASE64到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE64编码格式文本视图,解码为对应的字节集后返回." 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    {
        @ @an<CVolMem> buffer;
        @ piv::base64<@m<CharT>>{}.decode(@<本视图>, buffer);
        @ return buffer;
    }

    方法 BASE85到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE85编码格式文本视图,解码为对应的字节集后返回." 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    {
        @ @an<CVolMem> buffer;
        @ piv::base85<@m<CharT>>{}.decode(@<本视图>, buffer);
        @ return buffer;
    }

    方法 BASE91到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE91编码格式文本视图,解码为对应的字节集后返回." 注释 = "保留ASCII字符为{<>\"}." 折叠
            @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图模板 注释 = "所欲操作的文本视图,本参数无需填写." @视窗.前缀文本 = "const ">
    {
        @ @an<CVolMem> buffer;
        @ piv::base91<@m<CharT>>{}.decode(@<本视图>, buffer);
        @ return buffer;
    }
}

类 文本视图类W <公开 基础类 = 文本视图模板 注释 = "UTF-16LE编码(与\"文本型\"相同编码)的文本视图类."
        注释 = "文本视图(wstring_view)本身不拥有数据,而是指向其他文本的字符缓冲区." 注释 = "使用文本视图内存开销小,速度快,缺点是视图不能修改文本数据." 折叠
        @文档 = "category = \"文本操作\"" @模板实现类 = "文本视图类W, 字符, 标准文本类W" @别名 = "std::wstring_view">
{

    # @ @def_macro CharT wchar_t
    # @ @def_macro EncodeT piv::utf16_le
    # 静态函数 ---

    方法 创建视图 <公开 静态 类型 = 文本视图类W 注释 = "创建一个文本视图,并将它指向填入的一段字符串字面量." 注释 = "另外有作用相同的全局方法\"创建文本视图W\"."
            返回值注释 = "返回所创建的文本视图(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @dt<文本视图类W>{L@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    # 文本赋值 ---

    方法 值 <公开 静态 属性写 注释 = "将当前的文本视图指向提供的文本型变量." 注释 = "注意: 在文本视图释放所有权之前需要保证该变量的生命周期." 折叠>
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本数据 <类型 = 文本型 注释 = "所欲引用的文本对象">
    {
        @ @<本视图> = std::wstring_view{@<文本数据>.GetText()}
    }

    方法 值 <公开 静态 属性读 类型 = 文本型 注释 = "以文本型返回当前文本视图" 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ return @an<CVolString>{@<本视图>.data(), @<本视图>.size()};
    }

    方法 置字面量 <公开 静态 注释 = "  将文本视图指向填入的一段字符串字面量." 注释 = "  注: 字符串字面量存储在全局的只读存储区中,在程序的整个" 注释 = "生命周期中可用."
            注释 = "  因此我们无需考虑填入的文本是否会被销毁." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @<本视图> = L@sn<quot>@pvpt<文本字面量>@sn<quot>
    }

    方法 置文本 <公开 静态 类型 = 文本视图类W 注释 = "将当前的文本视图指向提供的UTF-16LE编码的文本数据变量,返回文本视图自身."
            注释 = "注意: 在文本视图释放所有权之前需要保证该变量的生命周期." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本数据 <注释 = "所欲指向的文本数据,只能提供UTF-16LE编码的文本数据变量,支持类型:" 注释 = "  文本型、标准文本类W、文本视图类W、字节集类(UTF-16LE)"
            @需求类型 = 可写入变量 @匹配类型 = 通用型>
    参数 文本长度 <类型 = 变整数 注释 = "提供文本数据的字符长度,-1表示指定整个文本." @默认值 = -1>
    {
        @ (@<本视图> = piv::make_sv<@m<CharT>>(@<文本数据>, static_cast<size_t>(@<文本长度>)))
    }

    # 寻找文本 ---

    方法 寻找文本 <公开 静态 类型 = 变整数 注释 = "在视图中寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::search(@<本视图>, PivS2WV{@<欲寻找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 倒找文本 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::rsearch(@<本视图>, PivS2WV{@<欲寻找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 寻找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找指定字符集合中任意字符的首次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE);"
            注释 = "字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符" 注释 = "的首次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(piv::str::find_first_of(@<本视图>, PivS2WV{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找指定字符集合中任意字符的最后一次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE);"
            注释 = "字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符" 注释 = "的最后一次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::str::find_last_of(@<本视图>, PivS2WV{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 寻找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找首个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE);"
            注释 = "寻找并返回不等于字符集合中任意字符的首个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(piv::str::find_first_not_of(@<本视图>, PivS2WV{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找最后一个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE);"
            注释 = "寻找并返回不等于字符集合中任意字符的最后一个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::str::find_last_not_of(@<本视图>, PivS2WV{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    # 分割文本 ---

    方法 分割文本 <公开 静态 类型 = 变整数 注释 = "  将视图基于所指定的字符集合进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  分割结果数组也是指向视图引用的文本数据,请注意维持文本数据的生命周期."
            返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE);"
            注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其" 注释 = "中任何一个字符时均认为发现了一个分割点)."
            注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三" 注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图数组类W 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split(@<本视图>, PivS2WV{@<分割字符集合>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本 <公开 静态 类型 = 变整数 注释 = "  将视图基于所指定的子文本进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  分割结果数组也是指向视图引用的文本数据,请注意维持文本数据的生命周期."
            返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图数组类W 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split_substr(@<本视图>, PivS2WV{@<分割用子文本>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    # 提取文本 ---

    方法 取所有子文本中间 <公开 静态 类型 = 变整数 注释 = "循环取出所有位于两段指定文本中间的内容,并保存在数组中,返回数组的成员数." 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 子文本数组 <类型 = 标准文本数组类W 注释 = "所有获取的中间子文本会保存在此数组中">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::get_middles(@<本视图>, @<子文本数组>, PivS2WV{@<开始文本>}.sv, PivS2WV{@<结束文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                                           @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>))
    }

    方法 取子文本中间 <公开 静态 类型 = 文本视图类W 注释 = "取出两段文本中间的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类W、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本." @默认值 = 假>
    {
        @ piv::edit::get_middle(@<本视图>, PivS2WV{@<开始文本>}.sv, PivS2WV{@<结束文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                       @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>, @<失败返回原文本>)
    }

    方法 取子文本左边 <公开 静态 类型 = 文本视图类W 注释 = "寻找提供的文本,然后取出找到的文本左边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        @ piv::edit::get_left(@<本视图>, PivS2WV{@<要查找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                     @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    方法 取子文本右边 <公开 静态 类型 = 文本视图类W 注释 = "寻找提供的文本,然后取出找到的文本右边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        @ piv::edit::get_right(@<本视图>, PivS2WV{@<要查找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                      @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    # 比较文本 ---

    方法 是否相同 <公开 静态 类型 = 逻辑型 注释 = "判断两个文本视图的内容是否相同" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "所欲比较的另一个文本,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ (piv::edit::compare(@<本视图>, PivS2WV{@<所欲比较的文本>}.sv, @<是否区分大小写>) == 0)
    }

    方法 文本比较 <公开 静态 类型 = 整数 注释 = "比较两个文本视图,返回比较结果." 返回值注释 = "如果返回值小于0,表示本文本小于所比较文本;"
            返回值注释 = "如果等于0,表示本文本等于所比较文本;" 返回值注释 = "如果大于0,表示本文本大于所比较文本." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "提供所欲比较的文本,支持类型:" 注释 = " 文本型、标准文本类W、文本视图类W、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::compare(@<本视图>, PivS2WV{@<所欲比较的文本>}.sv, @<是否区分大小写>)
    }

    方法 是否以文本开头 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本视图是否以所指定文本开头" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其开头的文本,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::starts_with(@<本视图>, PivS2WV{@<所欲检查的文本>}.sv, @<是否区分大小写>)
    }

    方法 是否以文本结束 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本视图是否以所指定文本结束" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其结束的文本,支持类型:" 注释 = " 文本型、标准文本类(W/U)、文本视图类(W/U)、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::ends_with(@<本视图>, PivS2WV{@<所欲检查的文本>}.sv, @<是否区分大小写>)
    }

    # 输出文本 ---

    方法 取文本 <公开 静态 类型 = 文本型 注释 = "返回包含当前文本数据的火山文本型" 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ return @an<CVolString>{@<本视图>.data(), static_cast<INT_P>(@<本视图>.size())};
    }

    方法 到文本型 <公开 静态 类型 = 文本型 注释 = "返回包含当前文本数据的火山文本型" 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ return @an<CVolString>{@<本视图>.data(), static_cast<INT_P>(@<本视图>.size())};
    }

    方法 复制文本 <公开 静态 类型 = 变整数 注释 = "将文本视图指定的部分字符复制到提供的缓冲区中,返回复制的字符数." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲复制到的目标 <注释 = "复制文本的目标位置,支持类型:" 注释 = "  变整数、文本型、字节集类、标准文本类W" 注释 = "  其中变整数为文本指针,必须提前分配好足够的内存空间,"
            注释 = "其余类型会自动分配内存,如实际的复制字符数为0,将清空内容." @匹配类型 = 通用型>
    参数 欲复制的起始索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错.">
    参数 欲复制的字符数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置),将复制索引位置" 注释 = "后面的全部剩余字符.">
    {
        @ static_cast<INT_P>(piv::sv::copy(@<本视图>, @<欲复制到的目标>, static_cast<size_t>(@<欲复制的起始索引位置>), static_cast<size_t>(@<欲复制的字符数目>)))
    }

    # 转换文本 ---

    方法 到UTF8 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本的编码转换到UTF-8并返回." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ PivW2U{@<本视图>}.str
    }

    方法 到多字节 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本的编码转换到ANSI多字节并返回." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ PivW2A{@<本视图>}.str
    }

    方法 URL编码 <公开 静态 类型 = 标准文本类W 注释 = "将当前文本视图进行URL编码,返回编码后的文本对象." 返回值注释 = "返回编码后的文本对象"
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否UTF8 <类型 = 逻辑型 注释 = "将文本内容以UTF-8方式编码,否则为多字节." @默认值 = 真>
    参数 不编码保留字符 <类型 = 逻辑型 注释 = "是否不编码保留字符(;/?:@=&),保留字符在URL中有特殊含义" @默认值 = 假>
    {
        @ piv::encoding::UrlStrEncode(@<本视图>, @<是否UTF8>, @<不编码保留字符>, std::wstring{})
    }

    方法 URL解码 <公开 静态 类型 = 标准文本类W 注释 = "将当前文本视图进行URL解码,返回解码后的文本对象." 返回值注释 = "返回解码后的文本对象"
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类W 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否UTF8 <类型 = 逻辑型 注释 = "将文本内容以UTF-8方式编码,否则为多字节." @默认值 = 真>
    {
        @ piv::encoding::UrlStrDecode(@<本视图>, @<是否UTF8>, std::wstring{})
    }
}

类 文本视图类U <公开 基础类 = 文本视图模板 注释 = "UTF-8编码的文本视图类." 注释 = "文本视图(string_view)本身不拥有数据,而是指向其他文本的字符缓冲区."
        注释 = "使用文本视图内存开销小,速度快,缺点是视图不能修改文本数据." 折叠 @文档 = "category = \"文本操作\"" @模板实现类 = "文本视图类U, 字节, 标准文本类U"
        @别名 = "std::string_view">
{

    # @ @def_macro CharT char
    # @ @def_macro EncodeT piv::utf8
    # 静态函数 ---

    方法 创建视图 <公开 静态 类型 = 文本视图类U 注释 = "创建一个文本视图,并将它指向填入的一段字符串字面量." 注释 = "另外有作用相同的全局方法\"创建文本视图W\"."
            返回值注释 = "返回所创建的文本视图(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @dt<文本视图类U>{reinterpret_cast<const char *>(u8@sn<quot>@pvpt<文本字面量>@sn<quot>)}
    }

    # 文本赋值 ---

    方法 值 <公开 静态 属性写 注释 = "将当前的文本视图指向提供的标准文本类U变量." 注释 = "注意: 在文本视图释放所有权之前需要保证该变量的生命周期." 折叠>
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本数据 <类型 = 标准文本类U 注释 = "所欲引用的文本对象">
    {
        @ @<本视图> = std::string_view{@<文本数据>}
    }

    方法 值 <公开 静态 属性读 类型 = 标准文本类U 注释 = "以标准文本类U返回当前文本视图" 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ return std::string{@<本视图>.data(), @<本视图>.size()};
    }

    方法 置字面量 <公开 静态 注释 = "  将文本视图指向填入的一段字符串字面量." 注释 = "  注: 字符串字面量存储在全局的只读存储区中,在程序的整个" 注释 = "生命周期中可用."
            注释 = "  因此我们无需考虑填入的文本是否会被销毁." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @<本视图> = reinterpret_cast<const char *>(u8@sn<quot>@pvpt<文本字面量>@sn<quot>)
    }

    方法 置文本 <公开 静态 类型 = 文本视图类U 注释 = "将当前的文本视图指向提供的UTF-8编码的文本数据变量,返回文本视图自身."
            注释 = "注意: 在文本视图释放所有权之前需要保证该变量的生命周期." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本数据 <注释 = "所欲指向的文本数据,只能提供UTF-8编码的文本数据变量,支持类型:" 注释 = "  文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @需求类型 = 可写入变量
            @匹配类型 = 通用型>
    参数 文本长度 <类型 = 变整数 注释 = "提供文本数据的字符长度,-1表示指定整个文本." @默认值 = -1>
    {
        @ (@<本视图> = piv::make_sv<@m<CharT>>(@<文本数据>, static_cast<size_t>(@<文本长度>)))
    }

    # 寻找文本 ---

    方法 寻找文本 <公开 静态 类型 = 变整数 注释 = "在视图中寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::search(@<本视图>, PivS2V{@<欲寻找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 倒找文本 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::rsearch(@<本视图>, PivS2V{@<欲寻找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 寻找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找指定字符集合中任意字符的首次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8);"
            注释 = "字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符" 注释 = "的首次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(piv::str::find_first_of(@<本视图>, PivS2V{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找指定字符集合中任意字符的最后一次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8);"
            注释 = "字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符" 注释 = "的最后一次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::str::find_last_of(@<本视图>, PivS2V{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 寻找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找首个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8);"
            注释 = "寻找并返回不等于字符集合中任意字符的首个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(piv::str::find_first_not_of(@<本视图>, PivS2V{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找最后一个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8);"
            注释 = "寻找并返回不等于字符集合中任意字符的最后一个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::str::find_last_not_of(@<本视图>, PivS2V{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    # 分割文本 ---

    方法 分割文本 <公开 静态 类型 = 变整数 注释 = "  将视图基于所指定的字符集合进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  分割结果数组也是指向视图引用的文本数据,请注意维持文本数据的生命周期."
            返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8);"
            注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其" 注释 = "中任何一个字符时均认为发现了一个分割点)."
            注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三" 注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图数组类U 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split(@<本视图>, PivS2V{@<分割字符集合>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本 <公开 静态 类型 = 变整数 注释 = "  将视图基于所指定的子文本进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  分割结果数组也是指向视图引用的文本数据,请注意维持文本数据的生命周期."
            返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图数组类U 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split_substr(@<本视图>, PivS2V{@<分割用子文本>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    # 提取文本 ---

    方法 取所有子文本中间 <公开 静态 类型 = 变整数 注释 = "循环取出所有位于两段指定文本中间的内容,并保存在数组中,返回数组的成员数." 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 子文本数组 <类型 = 标准文本数组类U 注释 = "所有获取的中间子文本会保存在此数组中">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::get_middles(@<本视图>, @<子文本数组>, PivS2V{@<开始文本>}.sv, PivS2V{@<结束文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                                           @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>))
    }

    方法 取子文本中间 <公开 静态 类型 = 文本视图类U 注释 = "取出两段文本中间的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本." @默认值 = 假>
    {
        @ piv::edit::get_middle(@<本视图>, PivS2V{@<开始文本>}.sv, PivS2V{@<结束文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                       @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>, @<失败返回原文本>)
    }

    方法 取子文本左边 <公开 静态 类型 = 文本视图类U 注释 = "寻找提供的文本,然后取出找到的文本左边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        @ piv::edit::get_left(@<本视图>, PivS2V{@<要查找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                     @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    方法 取子文本右边 <公开 静态 类型 = 文本视图类U 注释 = "寻找提供的文本,然后取出找到的文本右边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        @ piv::edit::get_right(@<本视图>, PivS2V{@<要查找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                      @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    # 比较文本 ---

    方法 是否相同 <公开 静态 类型 = 逻辑型 注释 = "判断两个文本视图的内容是否相同" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "所欲比较的另一个文本,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ (piv::edit::compare(@<本视图>, PivS2V{@<所欲比较的文本>}.sv, @<是否区分大小写>) == 0)
    }

    方法 文本比较 <公开 静态 类型 = 整数 注释 = "比较两个文本视图,返回比较结果." 返回值注释 = "如果返回值小于0,表示本文本小于所比较文本;"
            返回值注释 = "如果等于0,表示本文本等于所比较文本;" 返回值注释 = "如果大于0,表示本文本大于所比较文本." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "提供所欲比较的文本,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::compare(@<本视图>, PivS2V{@<所欲比较的文本>}.sv, @<是否区分大小写>)
    }

    方法 是否以文本开头 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本视图是否以所指定文本开头" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其开头的文本,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::starts_with(@<本视图>, PivS2V{@<所欲检查的文本>}.sv, @<是否区分大小写>)
    }

    方法 是否以文本结束 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本视图是否以所指定文本结束" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其结束的文本,支持类型:" 注释 = " 文本型、标准文本类(U/W)、文本视图类(U/W)、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::ends_with(@<本视图>, PivS2V{@<所欲检查的文本>}.sv, @<是否区分大小写>)
    }

    # 输出文本 ---

    方法 取文本 <公开 静态 类型 = 文本型 注释 = "返回包含当前文本数据的火山文本型" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ PivU2Ws{@<本视图>}.str
    }

    方法 到文本型 <公开 静态 类型 = 文本型 注释 = "返回包含当前文本数据的火山文本型" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ PivU2Ws{@<本视图>}.str
    }

    方法 复制文本 <公开 静态 类型 = 变整数 注释 = "将文本视图指定的部分字符复制到提供的缓冲区中,返回复制的字符数." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲复制到的目标 <注释 = "复制文本的目标位置,支持类型:" 注释 = "  变整数、字节集类、标准文本类U" 注释 = "  其中变整数为文本指针,必须提前分配好足够的内存空间,"
            注释 = "其余类型会自动分配内存,如实际的复制字符数为0,将清空内容." @匹配类型 = 通用型>
    参数 欲复制的起始索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错.">
    参数 欲复制的字符数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置),将复制索引位置" 注释 = "后面的全部剩余字符.">
    {
        @ static_cast<INT_P>(piv::sv::copy(@<本视图>, @<欲复制到的目标>, static_cast<size_t>(@<欲复制的起始索引位置>), static_cast<size_t>(@<欲复制的字符数目>)))
    }

    # 转换文本 ---

    方法 到UTF16 <公开 静态 类型 = 标准文本类W 注释 = "将当前文本的编码转换到UTF-16LE并返回." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ PivU2W{@<本视图>}.str
    }

    方法 到多字节 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本的编码转换到ANSI多字节并返回." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ PivU2A{@<本视图>}.str
    }

    方法 URL编码 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本视图进行URL编码,返回编码后的文本对象." 返回值注释 = "返回编码后的文本对象"
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 不编码保留字符 <类型 = 逻辑型 注释 = "是否不编码保留字符(;/?:@=&),保留字符在URL中有特殊含义" @默认值 = 假>
    {
        @ piv::encoding::UrlStrEncode(@<本视图>, true, @<不编码保留字符>, std::string{})
    }

    方法 URL解码 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本视图进行URL解码,返回解码后的文本对象." 返回值注释 = "返回解码后的文本对象" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ piv::encoding::UrlStrDecode(@<本视图>, true, std::string{})
    }
}

类 文本视图类A <公开 基础类 = 文本视图模板 注释 = "本地多字节ANSI编码的文本视图类." 注释 = "文本视图(string_view)本身不拥有数据,而是指向其他文本的字符缓冲区."
        注释 = "使用文本视图内存开销小,速度快,缺点是视图不能修改文本数据." 折叠 @文档 = "category = \"文本操作\"" @模板实现类 = "文本视图类A, 字符, 标准文本类A"
        @别名 = "std::string_view">
{

    # @ @def_macro CharT char
    # @ @def_macro EncodeT piv::utf8
    # 静态函数 ---

    方法 创建视图 <公开 静态 类型 = 文本视图类A 注释 = "创建一个文本视图,并将它指向填入的一段字符串字面量." 注释 = "另外有作用相同的全局方法\"创建文本视图W\"."
            返回值注释 = "返回所创建的文本视图(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @dt<文本视图类A>{@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    # 文本赋值 ---

    方法 值 <公开 静态 属性写 注释 = "将当前的文本视图指向提供的标准文本类A变量." 注释 = "注意: 在文本视图释放所有权之前需要保证该变量的生命周期." 折叠>
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本数据 <类型 = 标准文本类A 注释 = "所欲引用的文本对象">
    {
        @ @<本视图> = std::string_view{@<文本数据>}
    }

    方法 值 <公开 静态 属性读 类型 = 标准文本类A 注释 = "以标准文本类A返回当前文本视图" 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ return std::string{@<本视图>.data(), @<本视图>.size()};
    }

    方法 置字面量 <公开 静态 注释 = "  将文本视图指向填入的一段字符串字面量." 注释 = "  注: 字符串字面量存储在全局的只读存储区中,在程序的整个" 注释 = "生命周期中可用."
            注释 = "  因此我们无需考虑填入的文本是否会被销毁." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @<本视图> = @sn<quot>@pvpt<文本字面量>@sn<quot>
    }

    方法 置文本 <公开 静态 类型 = 文本视图类A 注释 = "将当前的文本视图指向提供的ANSI编码的文本数据变量,返回文本视图自身."
            注释 = "注意: 在文本视图释放所有权之前需要保证该变量的生命周期." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本数据 <注释 = "所欲指向的文本数据,只能提供ANSI编码的文本数据变量,支持类型:" 注释 = "  文本型、标准文本类A、文本视图类A、字节集类(ANSI)" @需求类型 = 可写入变量
            @匹配类型 = 通用型>
    参数 文本长度 <类型 = 变整数 注释 = "提供文本数据的字符长度,-1表示指定整个文本." @默认值 = -1>
    {
        @ (@<本视图> = piv::make_sv<@m<CharT>>(@<文本数据>, static_cast<size_t>(@<文本长度>)))
    }

    # 寻找文本 ---

    方法 寻找文本 <公开 静态 类型 = 变整数 注释 = "在视图中寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/A)、文本视图类(W/A)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::search(@<本视图>, PivS2AV{@<欲寻找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 倒找文本 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/A)、文本视图类(W/A)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::rsearch(@<本视图>, PivS2AV{@<欲寻找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 寻找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找指定字符集合中任意字符的首次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(W/A)、文本视图类(W/A)、字节集类(ANSI);"
            注释 = "字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符" 注释 = "的首次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(piv::str::find_first_of(@<本视图>, PivS2AV{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找指定字符集合中任意字符的最后一次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(W/A)、文本视图类(W/A)、字节集类(ANSI);"
            注释 = "字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符" 注释 = "的最后一次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::str::find_last_of(@<本视图>, PivS2AV{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 寻找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找首个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(W/A)、文本视图类(W/A)、字节集类(ANSI);"
            注释 = "寻找并返回不等于字符集合中任意字符的首个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(piv::str::find_first_not_of(@<本视图>, PivS2AV{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找最后一个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "提供所欲寻找的字符集合,支持类型:" 注释 = "  文本型、标准文本类(W/A)、文本视图类(W/A)、字节集类(ANSI);"
            注释 = "寻找并返回不等于字符集合中任意字符的最后一个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::str::find_last_not_of(@<本视图>, PivS2AV{@<欲寻找的字符集合>}.sv, static_cast<size_t>(@<起始搜寻位置>)))
    }

    # 分割文本 ---

    方法 分割文本 <公开 静态 类型 = 变整数 注释 = "  将视图基于所指定的字符集合进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  分割结果数组也是指向视图引用的文本数据,请注意维持文本数据的生命周期."
            返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、标准文本类(W/A)、文本视图类(W/A)、字节集类(ANSI);"
            注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其" 注释 = "中任何一个字符时均认为发现了一个分割点)."
            注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三" 注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图数组类A 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split(@<本视图>, PivS2AV{@<分割字符集合>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本 <公开 静态 类型 = 变整数 注释 = "  将视图基于所指定的子文本进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  分割结果数组也是指向视图引用的文本数据,请注意维持文本数据的生命周期."
            返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = " 文本型、标准文本类(W/A)、文本视图类(W/A)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图数组类A 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(piv::edit::split_substr(@<本视图>, PivS2AV{@<分割用子文本>}.sv, @<结果存放数组>, @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    # 提取文本 ---

    方法 取所有子文本中间 <公开 静态 类型 = 变整数 注释 = "循环取出所有位于两段指定文本中间的内容,并保存在数组中,返回数组的成员数." 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 子文本数组 <类型 = 标准文本数组类A 注释 = "所有获取的中间子文本会保存在此数组中">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/A)、文本视图类(W/A)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/A)、文本视图类(W/A)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" @默认值 = 假>
    {
        @ static_cast<INT_P>(piv::edit::get_middles(@<本视图>, @<子文本数组>, PivS2AV{@<开始文本>}.sv, PivS2AV{@<结束文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                                           @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>))
    }

    方法 取子文本中间 <公开 静态 类型 = 文本视图类A 注释 = "取出两段文本中间的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本." @默认值 = 假>
    {
        @ piv::edit::get_middle(@<本视图>, PivS2AV{@<开始文本>}.sv, PivS2AV{@<结束文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                       @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>, @<失败返回原文本>)
    }

    方法 取子文本左边 <公开 静态 类型 = 文本视图类A 注释 = "寻找提供的文本,然后取出找到的文本左边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/A)、文本视图类(W/A)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        @ piv::edit::get_left(@<本视图>, PivS2AV{@<要查找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                     @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    方法 取子文本右边 <公开 静态 类型 = 文本视图类A 注释 = "寻找提供的文本,然后取出找到的文本右边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类(W/A)、文本视图类(W/A)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        @ piv::edit::get_right(@<本视图>, PivS2AV{@<要查找的文本>}.sv, static_cast<size_t>(@<起始搜寻位置>),
        @                      @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    # 比较文本 ---

    方法 是否相同 <公开 静态 类型 = 逻辑型 注释 = "判断两个文本视图的内容是否相同" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "所欲比较的另一个文本,支持类型:" 注释 = " 文本型、标准文本类(W/A)、文本视图类(W/A)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ (piv::edit::compare(@<本视图>, PivS2AV{@<所欲比较的文本>}.sv, @<是否区分大小写>) == 0)
    }

    方法 文本比较 <公开 静态 类型 = 整数 注释 = "比较两个文本视图,返回比较结果." 返回值注释 = "如果返回值小于0,表示本文本小于所比较文本;"
            返回值注释 = "如果等于0,表示本文本等于所比较文本;" 返回值注释 = "如果大于0,表示本文本大于所比较文本." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "提供所欲比较的文本,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::compare(@<本视图>, PivS2AV{@<所欲比较的文本>}.sv, @<是否区分大小写>)
    }

    方法 是否以文本开头 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本视图是否以所指定文本开头" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其开头的文本,支持类型:" 注释 = " 文本型、标准文本类(W/A)、文本视图类(W/A)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::starts_with(@<本视图>, PivS2AV{@<所欲检查的文本>}.sv, @<是否区分大小写>)
    }

    方法 是否以文本结束 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本视图是否以所指定文本结束" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其结束的文本,支持类型:" 注释 = " 文本型、标准文本类(W/A)、文本视图类(W/A)、字节集类(ANSI)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ piv::edit::ends_with(@<本视图>, PivS2AV{@<所欲检查的文本>}.sv, @<是否区分大小写>)
    }

    # 输出文本 ---

    方法 取文本 <公开 静态 类型 = 文本型 注释 = "返回包含当前文本数据的火山文本型" 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ PivA2Ws{@<本视图>}.str
    }

    方法 到文本型 <公开 静态 类型 = 文本型 注释 = "返回包含当前文本数据的火山文本型" 折叠 @禁止流程检查 = 真>
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ PivA2Ws{@<本视图>}.str
    }

    方法 复制文本 <公开 静态 类型 = 变整数 注释 = "将文本视图指定的部分字符复制到提供的缓冲区中,返回复制的字符数." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲复制到的目标 <注释 = "复制文本的目标位置,支持类型:" 注释 = "  变整数、字节集类、标准文本类A" 注释 = "  其中变整数为文本指针,必须提前分配好足够的内存空间,"
            注释 = "其余类型会自动分配内存,如实际的复制字符数为0,将清空内容." @匹配类型 = 通用型>
    参数 欲复制的起始索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错.">
    参数 欲复制的字符数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置),将复制索引位置" 注释 = "后面的全部剩余字符.">
    {
        @ static_cast<INT_P>(piv::sv::copy(@<本视图>, @<欲复制到的目标>, static_cast<size_t>(@<欲复制的起始索引位置>), static_cast<size_t>(@<欲复制的字符数目>)))
    }

    # 转换文本 ---

    方法 到UTF16 <公开 静态 类型 = 标准文本类W 注释 = "将当前文本的编码转换到UTF-16LE并返回." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ PivA2W{@<本视图>}.str
    }

    方法 到UTF8 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本的编码转换到UTF-8并返回." 折叠 @嵌入式方法 = "">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ PivA2U{@<本视图>}.str
    }

    方法 URL编码 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本视图进行URL编码,返回编码后的文本对象." 返回值注释 = "返回编码后的文本对象"
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否UTF8 <类型 = 逻辑型 注释 = "将文本内容以UTF-8方式编码,否则为多字节." @默认值 = 真>
    参数 不编码保留字符 <类型 = 逻辑型 注释 = "是否不编码保留字符(;/?:@=&),保留字符在URL中有特殊含义" @默认值 = 假>
    {
        @ piv::encoding::UrlStrEncode(@<本视图>, @<是否UTF8>, @<不编码保留字符>, std::string{})
    }

    方法 URL解码 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本视图进行URL解码,返回解码后的文本对象." 返回值注释 = "返回解码后的文本对象"
            @嵌入式方法 = "req_cpp_bool = true">
    参数 本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否UTF8 <类型 = 逻辑型 注释 = "将文本内容以UTF-8方式编码,否则为多字节." @默认值 = 真>
    {
        @ piv::encoding::UrlStrDecode(@<本视图>, @<是否UTF8>, std::string{})
    }
}

# ---

类 标准文本数组类W <公开 基础类 = PIV数组模板 注释 = "\"标准文本类W\"的std::vector动态数组,为本地类封装." @文档 = "category = \"数组操作.文本数组\""
        @模板实现类 = "标准文本类W">

类 标准文本数组类U <公开 基础类 = PIV数组模板 注释 = "\"标准文本类U\"的std::vector动态数组,为本地类封装." @文档 = "category = \"数组操作.文本数组\""
        @模板实现类 = "标准文本类U">

类 标准文本数组类A <公开 基础类 = PIV数组模板 注释 = "\"标准文本类A\"的std::vector动态数组,为本地类封装." @文档 = "category = \"数组操作.文本数组\""
        @模板实现类 = "标准文本类A">

类 文本视图数组类W <公开 基础类 = PIV数组模板 注释 = "\"文本视图类W\"的std::vector动态数组,为本地类封装." @文档 = "category = \"数组操作.文本数组\""
        @模板实现类 = "文本视图类W">

类 文本视图数组类U <公开 基础类 = PIV数组模板 注释 = "\"文本视图类U\"的std::vector动态数组,为本地类封装." @文档 = "category = \"数组操作.文本数组\""
        @模板实现类 = "文本视图类U">

类 文本视图数组类A <公开 基础类 = PIV数组模板 注释 = "\"文本视图类A\"的std::vector动态数组,为本地类封装." @文档 = "category = \"数组操作.文本数组\""
        @模板实现类 = "文本视图类A">

# ===

类 二维文本数组类 <公开 基础类 = 对象数组模板类 注释 = "二维的文本数组类" @文档 = "category = \"文本操作\"" @模板实现类 = "文本数组类">

# OpenCC ====

类 OpenCC简繁转换类 <公开 注释 = "  中文简繁转换开源项目,支持词汇级别的转换、异体字转换" 注释 = "和地区习惯用词转换(中国大陆、台湾、香港、日本新字体)."
        注释 = "  源码: https://github.com/BYVoid/OpenCC" 注释 = "  版本: 1.1.6" 折叠 @文档 = "category = \"文本操作.简繁转换\""
        @视窗.外部头文件 = "OpenCC\\include\\opencc.h" @视窗.外部库 = "OpenCC\\$(p)\\opencc.lib"
        @视窗.附属文件 = "OpenCC\\$(p)\\opencc.dll" @视窗.附属文件 = "附属文件\\opencc > opencc">
{
    方法 类_清理 <折叠>
    {
        销毁 ()
    }

    方法 初始化 <公开 类型 = 逻辑型 注释 = "初始化OpenCC并选择使用的配置文件,配置文件决定了转换的类型." 注释 = "注意: 本方法可能会耗时2秒以上."
            返回值注释 = "返回是否成功,失败时可用\"取错误信息\"获取失败原因." 折叠 @禁止流程检查 = 真>
    参数 配置文件 <类型 = OpenCC配置文件 注释 = "  提供中文简体转换的配置文件名,配置文件决定转换方式," 注释 = "  比如\"简体到繁体\"和\"繁体到简体\"等."
            @默认值 = OpenCC配置文件.简体到繁体>
    参数 配置路径 <类型 = 文本型 注释 = "  提供OpenCC配置文件所在位置的绝对路径,默认为\"运行目录\\opencc\\\","
            注释 = "如果你需要自定义该路径,请更改本参数并在编译后手动移动opencc文件夹." @默认值 = 空对象>
    {
        销毁 ()
        @ @an<CVolString> szConfigFileName;
        @ if (@<配置路径>.IsEmpty ()) {
        @     GetInstancePath (szConfigFileName);
        @     szConfigFileName.AddText (L"opencc\\");
        @ } else {
        @     szConfigFileName.AddText (@<配置路径>.GetText ());
        @ }
        @ szConfigFileName.CheckAddPathChar ();
        @ szConfigFileName.AddText (@<配置文件>.GetText ());
        @ m_opencc = opencc_open_w (szConfigFileName.GetText ());
        @ return (m_opencc != (opencc_t)-1);
    }

    方法 转换字节集 <公开 类型 = 字节集类 注释 = "根据\"初始化\"提供的配置类型进行UTF8文本数据的转换." 返回值注释 = "成功返回UTF8编码的转换结果,失败返回空字节集." 折叠
            @禁止流程检查 = 真>
    参数 欲转换文本数据 <类型 = 字节集类 注释 = "提供所欲转换的文本数据,必须为UTF8编码">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    {
        @ if (m_opencc == (opencc_t)-1) return @an<CVolMem> ();
        @ @an<CVolMem> out;
        @ char* converted = opencc_convert_utf8 (m_opencc,
        @                   reinterpret_cast<const char*>(@<欲转换文本数据>.GetPtr ()), @<欲转换文本数据>.GetSize ());
        @ if (converted) {
        @     out.Append (converted, strlen (converted) + (@<是否包括结束零字符> ? 1 : 0));
        @     opencc_convert_utf8_free (converted);
        @ }
        @ return out;
    }

    方法 转换文本 <公开 类型 = 文本型 注释 = "根据\"初始化\"提供的配置类型进行文本数据的转换." 返回值注释 = "成功返回转换结果,失败返回空文本." 折叠 @禁止流程检查 = 真>
    参数 欲转换文本 <类型 = 文本型 注释 = "提供所欲转换的文本">
    {
        返回 (UTF8到文本 (本对象.转换字节集 (文本到UTF8 (欲转换文本, 假), 假)))
    }

    方法 销毁 <公开 类型 = 逻辑型 注释 = "释放OpenCC,释放后必须重新初始化才能进行转换." 注释 = "类析构时会自动销毁,一般无需手动调用." 折叠 @禁止流程检查 = 真>
    {
        @ if (m_opencc != (opencc_t)-1) {
        @     if (opencc_close (m_opencc) == 0)
        @         m_opencc = (opencc_t)-1;
        @     else
        @         return FALSE;
        @ }
        @ return TRUE;
    }

    方法 取错误信息 <公开 类型 = 文本型 注释 = "获取OpenCC最后一次返回的错误信息." 注释 = "注意: 本方法非线程安全,为OpenCC全局返回的错误." 折叠 @嵌入式方法 = "">
    {
        @ @an<CVolString> ((const CHAR*)opencc_error())
    }

    # @begin
    # <> <include>
    # opencc_t m_opencc = (opencc_t) -1;
    # <> </include>
    # @end
}

类 OpenCC配置文件 <公开 注释 = "中文简繁转换的类型" 折叠 @文档 = "category = \"文本操作.简繁转换.辅助类\"" @常量类 = 文本型>
{
    常量 简体到繁体 <公开 值 = "s2t.json">
    常量 繁体到简体 <公开 值 = "t2s.json">
    常量 简体到台湾正体 <公开 值 = "s2tw.json">
    常量 台湾正体到简体 <公开 值 = "tw2s.json">
    常量 简体到香港繁体 <公开 值 = "s2hk.json">
    常量 香港繁体到简体 <公开 值 = "hk2s.json">
    常量 简体到台湾正体词汇 <公开 值 = "s2twp.json" 注释 = "简体到繁体(台湾正体标准)并转换为台湾常用词汇">
    常量 台湾正体到简体词汇 <公开 值 = "tw2sp.json" 注释 = "繁体(台湾正体标准)到简体并转换为中国大陆常用词汇">
    常量 繁体到台湾正体 <公开 值 = "t2tw.json" 注释 = "繁体(OpenCC标准)到台湾正体">
    常量 香港繁体到繁体 <公开 值 = "hk2t.json" 注释 = "香港繁体到繁体(OpenCC标准)">
    常量 繁体到香港繁体 <公开 值 = "t2hk.json" 注释 = "繁体(OpenCC标准)到香港繁体">
    常量 繁体到日文新字体 <公开 值 = "t2jp.json" 注释 = "繁体(OpenCC标准,旧字体)到日文新字体">
    常量 日文新字体到繁体 <公开 值 = "jp2t.json" 注释 = "日文新字体到繁体(OpenCC标准,旧字体)">
    常量 台湾正体到繁体 <公开 值 = "tw2t.json" 注释 = "台湾正体到繁体(OpenCC标准)">

    #
}
