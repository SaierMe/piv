<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV扩展类 <注释 = "网络传输相关的类库" 注释 = "https://github.com/SaierMe/piv" "">

类 Curl传输类 <公开 基础类 = 网络传输类 注释 = "基于\"Curl网络传输\"的网络传输类,增加了多线程接口."
        注释 = "本类专供\"并发网络访问类\"使用,普通用户请使用官方的网络传输类." 折叠 @文档 = "category = \"高并发网络访问\"">
{
    变量 成_访问类型 <公开 类型 = 整数 注释 = "0=网页访问, 1=下载, 2=上传(未写)...">
    变量 成_返回结果 <公开 类型 = 字节集类 注释 = "保存网页访问的返回结果,每次请求前需要调用\"重置参数\".">
    变量 成_响应头 <公开 类型 = 文本数组类 注释 = "保存响应头数组,每次请求前需要调用\"重置参数\".">
    变量 成_文件路径 <公开 类型 = 文本型 注释 = "下载的文件保存在此位置中,请以\"\\\\\"结尾,开始下载之前,本参数会修改为最终的全路径文件名.">
    变量 成_类指针 <公开 类型 = 变整数 注释 = "\"并发网络访问类\"的实例指针.">
    变量 成_文件操作 <公开 类型 = 文件读写类EX 注释 = "每次请求前需要调用\"重置参数\".">
    变量 成_下载信息 <公开 类型 = Curl下载信息指针>

    方法 取会话句柄 <公开 类型 = 变整数 注释 = "获取当前的会话句柄,用于Curl的多线程接口." 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data().GetCurl()
    }

    方法 重置参数 <公开 注释 = "重置选项和各种列表,准备下一次请求." 折叠>
    {
        成_文件操作.关闭文件 ()
        成_下载信息.重置 ()
        成_文件路径 = ""
        成_返回结果.释放字节集 ()
        成_响应头.删除所有成员 ()
        @ curl_easy_reset(data().GetCurl());
        @ data().ClearHeaderList();
        @ data().ClearProxyHeaderList();
        @ data().ClearConnectToList();
        @ data().ClearAliasesList();
        @ data().ClearRcptsList();
        @ data().ClearFtpQuoteCmdsList();
        @ data().ClearFtpPostQuoteCmdsList();
        @ data().ClearFtpPreQuoteCmdsList();
    }

    方法 添加会话句柄 <公开 类型 = 整数 注释 = "将当前的会话句柄添加到多会话句柄中." 返回值注释 = "请参考\"多会话状态码\"中所提供的常量定义." 折叠 @嵌入式方法 = "">
    参数 多会话句柄 <类型 = 变整数>
    {
        @ curl_multi_add_handle((CURLM *)@<多会话句柄>, @sn<this>.data().GetCurl())
    }

    方法 移除会话句柄 <公开 类型 = 整数 注释 = "将当前的会话句柄从多会话句柄中移除." 返回值注释 = "请参考\"多会话状态码\"中所提供的常量定义." 折叠 @嵌入式方法 = "">
    参数 多会话句柄 <类型 = 变整数>
    {
        @ curl_multi_remove_handle((CURLM *)@<多会话句柄>, @sn<this>.data().GetCurl())
    }

    方法 创建多会话句柄 <公开 静态 类型 = 变整数 注释 = "创建一个Curl多会话句柄." 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)curl_multi_init()
    }

    方法 释放多会话句柄 <公开 静态 类型 = 整数 注释 = "释放Curl多会话句柄." 返回值注释 = "请参考\"多会话状态码\"中所提供的常量定义." 折叠 @嵌入式方法 = "">
    参数 多会话句柄 <类型 = 变整数>
    {
        @ curl_multi_cleanup((CURLM *)@<多会话句柄>)
    }

    方法 发送多会话请求 <公开 静态 类型 = 整数 注释 = "在添加会话句柄后,调用本方法以发送多会话请求." 注释 = "注意:本方法为异步操作,会立即返回."
            返回值注释 = "请参考\"多会话状态码\"中所提供的常量定义." 折叠 @嵌入式方法 = "">
    参数 多会话句柄 <类型 = 变整数>
    参数 传输数量 <类型 = 整数 注释 = "请传入整数变量,返回仍在传输的会话数量" @需求类型 = 可写入变量>
    {
        @ curl_multi_perform((CURLM *)@<多会话句柄>, &@<传输数量>)
    }

    方法 取多会话信息 <公开 静态 类型 = CURL信息指针 注释 = "读取多会话的栈信息,返回CURL信息指针." 注释 = "由于执行失败会返回空指针,执行后调用该参数必须先判断指针是否为空." 折叠
            @嵌入式方法 = "">
    参数 多会话句柄 <类型 = 变整数>
    参数 消息队列数 <类型 = 整数 注释 = "返回剩余的消息队列数" @需求类型 = 可写入变量>
    {
        @ curl_multi_info_read((CURLM *)@<多会话句柄>, &@<消息队列数>)
    }

    方法 轮询 <公开 静态 类型 = 整数 注释 = "轮询多句柄,等待有任务完成的通知." 返回值注释 = "请参考\"多会话状态码\"中所提供的常量定义." 折叠 @嵌入式方法 = "">
    参数 多会话句柄 <类型 = 变整数>
    参数 超时时间 <类型 = 整数 注释 = "毫秒">
    参数 完成任务数 <类型 = 整数 注释 = "请传入整数变量,返回完成的任务数量" @需求类型 = 可写入变量>
    {
        @ curl_multi_poll((CURLM *)@<多会话句柄>, NULL, 0, @<超时时间>, &@<完成任务数>)
    }

    方法 唤醒 <公开 静态 类型 = 整数 注释 = "可以从任何线程调用,使\"轮询\"立即返回,而不需要等待到达超时时间." 返回值注释 = "请参考\"多会话状态码\"中所提供的常量定义." 折叠
            @嵌入式方法 = "">
    参数 多会话句柄 <类型 = 变整数>
    {
        @ curl_multi_wakeup((CURLM *)@<多会话句柄>)
    }

    方法 取多会话错误描述 <公开 静态 类型 = 文本型 注释 = "根据指定的返回值代码获取对应的描述内容." 折叠 @嵌入式方法 = "">
    参数 错误码 <类型 = 整数>
    {
        @ @an<CVolString> (curl_multi_strerror(@<错误码>))
    }

    方法 置多会话单主机最大连接数 <公开 静态 类型 = 整数 注释 = "设置多会话的单主机最大连接数,达到限制后会话将处于挂起状态." 返回值注释 = "请参考\"多会话状态码\"中所提供的常量定义."
            折叠 @嵌入式方法 = "">
    参数 多会话句柄 <类型 = 变整数>
    参数 最大连接数 <类型 = 整数 注释 = "默认为0,无限制.">
    {
        @ curl_multi_setopt((CURLM *)@<多会话句柄>, CURLMOPT_MAX_HOST_CONNECTIONS , @<最大连接数>)
    }

    方法 置多会话最大连接数 <公开 静态 类型 = 整数 注释 = "设置多会话最大同时打开的连接数." 返回值注释 = "请参考\"多会话状态码\"中所提供的常量定义." 折叠 @嵌入式方法 = "">
    参数 多会话句柄 <类型 = 变整数>
    参数 最大连接 <类型 = 整数 注释 = "默认为0,无限制.">
    {
        @ curl_multi_setopt((CURLM *)@<多会话句柄>, CURLMOPT_MAX_TOTAL_CONNECTIONS , @<最大连接>)
    }

    方法 置多会话连接缓存大小 <公开 静态 类型 = 整数 注释 = "设置多会话的连接缓存大小." 返回值注释 = "请参考\"多会话状态码\"中所提供的常量定义." 折叠 @嵌入式方法 = "">
    参数 多会话句柄 <类型 = 变整数>
    参数 最大值 <类型 = 整数 注释 = "内部自动设置的默认值为简易会话句柄的4倍.">
    {
        @ curl_multi_setopt((CURLM *)@<多会话句柄>, CURLMOPT_MAXCONNECTS , @<最大值>)
    }

    方法 取下载文件名 <公开 类型 = 文本型 注释 = "  从响应头中获取下载的文件名,必须在获取到响应头之后使用."
            注释 = "  如果获取不到文件名,将返回\"<现行时间戳的十六进制文本>.downlaod\"作为默认文件名." 折叠>
    参数 是否UTF8 <类型 = 逻辑型 注释 = "  如果响应头没有声明文件名的编码,则以该选项确定用UTF8还是多字节进行转码." @默认值 = 真>
    {
        变量 Disposition <类型 = 文本型>
        变量 找到位置 <类型 = 整数>
        成_响应头.枚举循环 ()
        {
            变量 当前值 <类型 = 文本型>
            当前值 = 成_响应头.取枚举值 ()
            如果 (是否以文本开头 (当前值, "Content-Disposition", 假))
            {
                Disposition = 当前值
                跳出循环
            }

        }
        如果 (文本是否为空 (Disposition) == 假)
        {
            删自身尾空 (Disposition)
            找到位置 = 寻找文本 (Disposition, "filename*=UTF-8\'\'", 0, 真)
            如果 (找到位置 != -1)
            {
                删除字符 (Disposition, 0, 找到位置 + 取文本长度 ("filename*=UTF-8\'\'"))
                找到位置 = 寻找字符 (Disposition, ';')
                如果 (找到位置 != -1)
                {
                    删除字符 (Disposition, 找到位置, 取文本长度 (Disposition) - 找到位置)
                }
                找到位置 = 寻找字符 (Disposition, '\"')
                如果 (找到位置 != -1)
                {
                    删除字符 (Disposition, 找到位置, 取文本长度 (Disposition) - 找到位置)
                }
                返回 (UTF8到文本 (URL解码 (Disposition)))

            }
            找到位置 = 寻找文本 (Disposition, "filename=", 0, 真)
            如果 (找到位置 != -1)
            {
                删除字符 (Disposition, 0, 找到位置 + 取文本长度 ("filename="))
                如果 (是否以字符开头 (Disposition, '\"'))
                {
                    删除字符 (Disposition, 0, 1)
                }
                找到位置 = 寻找字符 (Disposition, ';')
                如果 (找到位置 != -1)
                {
                    删除字符 (Disposition, 找到位置, 取文本长度 (Disposition) - 找到位置)
                }
                找到位置 = 寻找字符 (Disposition, '\"')
                如果 (找到位置 != -1)
                {
                    删除字符 (Disposition, 找到位置, 取文本长度 (Disposition) - 找到位置)
                }
                返回 (URL编解码类.解码文本 (Disposition, 是否UTF8))
            }

        }
        // 如果找不到文件名,使用URL中的路径名称
        变量 文件名 <类型 = 文本型>
        文件名 = 取上次请求地址 ()
        找到位置 = 倒找字符 (文件名, '/')
        如果 (找到位置 != -1)
        {
            删除字符 (文件名, 0, 找到位置 + 1)
        }
        找到位置 = 寻找字符 (文件名, '?')
        如果 (找到位置 != -1)
        {
            删除字符 (文件名, 找到位置, 取文本长度 (文件名) - 找到位置)
        }
        如果 (文本是否为空 (文件名))
        {
            返回 (取十六进制文本 (取时间戳 (取现行时间 ()), 8) + ".html")
        }
        否则
        {
            返回 (URL编解码类.解码文本 (文件名, 是否UTF8))
        }
    }
}

类 高并发网络访问类 <公开 注释 = "基于Curl的多线程接口封装的并发网络访问类,提供异步的网页访问和下载功能." 折叠 @文档 = "category = \"高并发网络访问\"">
{
    变量 成_退出信号 <类型 = 信号灯类>
    变量 成_空闲句柄 <类型 = 变整数数组类 注释 = "处于空闲的Curl传输对象">
    变量 成_工作句柄 <类型 = 变整数数组类 注释 = "正在工作的Curl传输对象">
    变量 成_传输对象表 <类型 = 会话句柄到传输指针表 注释 = "按会话句柄获取传输对象">
    变量 成_任务队列 <类型 = 网络访问参数队列类 注释 = "存放已提交的传输参数">
    变量 成_任务锁 <类型 = 互斥对象类 注释 = "任务的线程锁">
    变量 成_并发数 <类型 = 原子整数类>
    变量 成_任务上限 <类型 = 原子整数类>
    变量 成_多会话句柄 <类型 = 变整数>
    变量 成_轮询时间 <类型 = 整数>
    变量 成_Cookie文件 <类型 = 文本型>

    方法 类_清理 <折叠>
    {
        销毁连接池 ()
    }

    # 公开方法

    方法 Cookie管理文件 <公开 属性写 注释 = "提供Cookie管理文件,如果为空对象则不会管理Cookie内容(可使用\"提交协议头/提交Cookie\"参数自行提交)."
            注释 = "如提供空文本则表示在内存中管理Cookie(非持久化储存),如果指定了文件则表示持久化储存管理Cookie." 折叠>
    参数 文件 <类型 = 文本型 @默认值 = 空对象>
    {
        成_Cookie文件 = 文件
    }

    方法 启动连接池 <公开 类型 = 逻辑型 注释 = "必须启动连接池才会开始进行网络传输,可以在投递任务后执行." 返回值注释 = "返回是否启动成功,重复运行本方法会返回假." 折叠>
    参数 最大并发数 <类型 = 整数 注释 = "网络传输的最大并发数(最小值为1),也等于Curl会话句柄的最大数量." @默认值 = 10>
    参数 最大任务数 <类型 = 整数 注释 = "最大可提交的任务数量,0为不限制数量. 超过此上限后投递任务会返回失败." 注释 = "提交任务过多时,任务队列会占用较大的内存." @默认值 = 0>
    参数 轮询时间 <类型 = 整数 注释 = "轮询是否有任务完成的超时等待时间,单位为毫秒.该时间会影响批量发起请求的间隔." @默认值 = 200>
    {
        如果 (成_多会话句柄 != 0)
        {
            返回 (假)
        }
        成_多会话句柄 = Curl传输类.创建多会话句柄 ()
        如果 (最大并发数 < 1)
        {
            最大并发数 = 1
        }
        成_并发数.置值 (最大并发数)
        成_任务上限.置值 (最大任务数)
        计次循环 (成_并发数.取值 ())
        {
            变量 对象指针 <类型 = Curl传输指针>
            对象指针 = Curl传输指针.创建 ()
            如果 (对象指针.为空指针 () == 假)
            {
                成_空闲句柄.加入成员 (对象指针.值.取会话句柄 ())
                成_传输对象表.插入 (对象指针.值.取会话句柄 (), 对象指针)
            }
        }
        成_轮询时间 = 轮询时间
        成_退出信号.重置 ()
        线程对象类.启动无参数无返回值动态线程 (本对象, _处理任务)
        线程对象类.启动无参数无返回值动态线程 (本对象, _处理响应)
        返回 (真)
    }

    方法 销毁连接池 <公开 注释 = "当你不再使用本类时,应当手动调用本方法提前释放被占用的资源." 注释 = "类析构时会自动调用." 折叠>
    {
        如果 (成_多会话句柄 != 0)
        {
            成_退出信号.放行 ()
            成_退出信号.放行 ()
            成_任务锁.加锁 ()
            成_任务队列.清空 ()
            成_工作句柄.枚举循环 ()
            {
                成_传输对象表.取值 (成_工作句柄.取枚举值 ()).值.暂停传输 (5)
                成_传输对象表.取值 (成_工作句柄.取枚举值 ()).值.移除会话句柄 (成_多会话句柄)
                成_传输对象表.取值 (成_工作句柄.取枚举值 ()).值.重置参数 ()
            }
            成_工作句柄.删除所有成员 ()
            成_空闲句柄.枚举循环 ()
            {
                成_传输对象表.取值 (成_空闲句柄.取枚举值 ()).值.重置参数 ()
            }
            成_空闲句柄.删除所有成员 ()
            成_传输对象表.清空 ()
            成_任务锁.解锁 ()
            Curl传输类.释放多会话句柄 (成_多会话句柄)
            成_多会话句柄 = 0
        }
    }

    方法 最大并发数 <公开 属性读 类型 = 整数 注释 = "返回网络传输的最大并发数" 折叠>
    {
        返回 (成_并发数.取值 ())
    }

    方法 最大并发数 <公开 属性写 注释 = "设置网络传输的最大并发数" 折叠>
    参数 上限值 <类型 = 整数>
    {
        成_并发数.置值 (上限值)
        变量 句柄数 <类型 = 整数>
        成_任务锁.互斥自动锁 ()
        句柄数 = 成_空闲句柄.取成员数 () + 成_工作句柄.取成员数 ()
        如果 (句柄数 < 成_并发数.取值 ())
        {
            计次循环 (成_并发数.取值 () - 句柄数)
            {
                变量 对象指针 <类型 = Curl传输指针>
                对象指针 = Curl传输指针.创建 ()
                如果 (对象指针.为空指针 () == 假)
                {
                    成_空闲句柄.加入成员 (对象指针.值.取会话句柄 ())
                    成_传输对象表.插入 (对象指针.值.取会话句柄 (), 对象指针)
                }
            }
        }
        否则 (句柄数 > 成_并发数.取值 ())
        {
            如果 (成_空闲句柄.取成员数 () > 0)
            {
                变量 待释放数 <类型 = 整数>
                待释放数 = 句柄数 - 成_并发数.取值 ()
                待释放数 = 选择 (成_空闲句柄.取成员数 () >= 待释放数, 待释放数, 成_空闲句柄.取成员数 ())
                计次循环 (待释放数)
                {
                    变量 会话句柄 <类型 = 变整数>
                    会话句柄 = 成_空闲句柄.取成员 (0)
                    如果 (会话句柄 != 0 && 成_传输对象表.删除 (会话句柄))
                    {
                        成_空闲句柄.删除成员 (0)
                    }

                }
            }
        }
    }

    方法 任务上限数 <公开 属性读 类型 = 整数 注释 = "返回最大可提交的任务数量,0为不限制数量." 注释 = "提交任务过多时,任务队列会占用较大的内存,应适度限制." 折叠>
    {
        返回 (成_任务上限.取值 ())
    }

    方法 任务上限数 <公开 属性写 注释 = "设置最大可提交的任务数量,0为不限制数量." 折叠>
    参数 上限值 <类型 = 整数>
    {
        成_任务上限.置值 (上限值)
    }

    方法 执行任务数 <公开 属性读 类型 = 整数 注释 = "获取当前正在执行的任务数量" 折叠>
    {
        变量 任务数 <类型 = 整数>
        成_任务锁.互斥自动锁 ()
        任务数 = 成_工作句柄.取成员数 ()
        返回 (任务数)
    }

    方法 剩余任务数 <公开 属性读 类型 = 整数 注释 = "获取剩余的任务数量" 折叠>
    {
        变量 任务数 <类型 = 整数>
        成_任务锁.互斥自动锁 ()
        任务数 = 成_任务队列.取成员数 ()
        返回 (任务数)
    }

    方法 投递下载 <公开 类型 = 逻辑型 注释 = "下载指定网址的文件,传输过程中会响应\"下载进度改变\"事件,下载结束后将响应\"下载完毕\"." 注释 = "支持断点续传(需目标服务器支持)."
            折叠>
    参数 网址 <类型 = 文本型 注释 = "提供所欲访问的网址内容.">
    参数 保存位置 <类型 = 文本型 注释 = "提供下载的保存位置,留空为\"运行目录\\download\\\".目录不存在时会自动创建,如路径错误或不能访问,会直接返回假." @默认值 = 空对象>
    参数 访问方式 <类型 = 网页访问方式 注释 = "提供所欲使用的请求方式." @默认值 = 网页访问方式.GET>
    参数 提交信息 <类型 = 文本型 注释 = "设置本次请求所提交的数据,非POST请求也支持提交请求体,如需携带请求体务必保证该参数不为空对象,如果需要提交空请求体提供空文本内容即可."
            注释 = "如果提交信息为JSON数据,会自动加入协议头\"Content type \'application/json;charset=UTF-8\",无需你手动添加." @默认值 = 空对象>
    参数 提交协议头 <类型 = 文本数组类 注释 = "提供本次请求所欲使用的附加协议头,每个成员表示一个协议,默认已设置Accept-Language和User-Agent." @默认值 = 空对象>
    参数 提交Cookie <类型 = 文本型 注释 = "提供本次请求所欲使用的Cookie内容,注意该参数提交的内容不会同步到\"Cookie管理文件\"(不会写出至管理文件)." @默认值 = "">
    参数 最大下载速度 <类型 = 变整数 注释 = "限定最大下载速度,单位:字节/秒,为0表示不限制.如1024等于1KB/秒;1024*1024等于1MB/秒." @默认值 = 0>
    参数 代理地址 <类型 = 文本型
            注释 = "提供所欲使用的代理地址,支持多种协议(http,https,socks4,socks4a,socks5,socks5h),例如(http协议):http://127.0.0.1:8080" @默认值 = "">
    参数 代理账号 <类型 = 文本型 注释 = "提供代理地址所需的用户名." @默认值 = "">
    参数 代理密码 <类型 = 文本型 注释 = "提供代理地址所需的用户密码." @默认值 = "">
    参数 超时时间 <类型 = 整数 注释 = "指定本次完成整个请求所限定的超时时间,为-1时不限制,单位:毫秒." @默认值 = -1>
    参数 重定向次数 <类型 = 整数 注释 = "欲遵循网站重定向的最大次数,为-1时无限制,为0时禁止重定向." @默认值 = -1>
    参数 忽略SSL错误 <类型 = 逻辑型 注释 = "是否忽略任何SSL验证相关错误,即不验证证书也不验证服务器(如使用了代理将会被一同忽略)." @默认值 = 真>
    参数 是否优先 <类型 = 逻辑型 注释 = "是否优先执行该任务,为真时将压入到任务队列的首部,否则压入到尾部.优先时不受任务上限数限制." @默认值 = 假>
    {
        变量 提交内容 <类型 = 字节集类>
        如果 (文本是否为空对象 (提交信息) == 假)
        {
            如果 (文本是否为空 (提交信息) == 假)
            {
                提交内容 = 文本到多字节 (提交信息, 假)
            }
            // 否则提供0长度,空请求体
        }
        否则
        {
            提交内容.重置为空对象 ()  // 空对象标志
        }
        返回 (投递下载2 (网址, 保存位置, 访问方式, 提交内容, 提交协议头, 提交Cookie, 最大下载速度, 代理地址, 代理账号, 代理密码, 超时时间, 重定向次数, 忽略SSL错误, 是否优先))
    }

    方法 投递下载2 <公开 类型 = 逻辑型 注释 = "下载指定网址的文件,传输过程中会响应\"下载进度改变\"事件,下载结束后将响应\"下载完毕\"." 注释 = "支持断点续传(需目标服务器支持)."
            注释 = "与\"投递下载\"命令基本一致,不同的是本方法提交的请求体内容为字节集类型." 折叠>
    参数 网址 <类型 = 文本型 注释 = "提供所欲访问的网址内容.">
    参数 保存位置 <类型 = 文本型 注释 = "提供下载的保存位置,留空为\"运行目录\\download\\\".目录不存在时会自动创建,如路径错误或不能访问,会直接返回假." @默认值 = 空对象>
    参数 访问方式 <类型 = 网页访问方式 注释 = "提供所欲使用的请求方式." @默认值 = 网页访问方式.GET>
    参数 提交信息 <类型 = 字节集类 注释 = "设置本次请求所提交的数据,非POST请求也支持提交请求体,如需携带请求体务必保证该参数不为空对象,如果需要提交空请求体提供空字节集即可."
            注释 = "如果提交信息为JSON数据,会自动加入协议头\"Content type \'application/json;charset=UTF-8\",无需你手动添加." @默认值 = 空对象>
    参数 提交协议头 <类型 = 文本数组类 注释 = "提供本次请求所欲使用的附加协议头,每个成员表示一个协议,默认已设置Accept-Language和User-Agent." @默认值 = 空对象>
    参数 提交Cookie <类型 = 文本型 注释 = "提供本次请求所欲使用的Cookie内容,注意该参数提交的内容不会同步到\"Cookie管理文件\"(不会写出至管理文件)." @默认值 = "">
    参数 最大下载速度 <类型 = 变整数 注释 = "限定最大下载速度,单位:字节/秒,为0表示不限制.如1024等于1KB/秒;1024*1024等于1MB/秒." @默认值 = 0>
    参数 代理地址 <类型 = 文本型
            注释 = "提供所欲使用的代理地址,支持多种协议(http,https,socks4,socks4a,socks5,socks5h),例如(http协议):http://127.0.0.1:8080"
            @默认值 = "">
    参数 代理账号 <类型 = 文本型 注释 = "提供代理地址所需的用户名." @默认值 = "">
    参数 代理密码 <类型 = 文本型 注释 = "提供代理地址所需的用户密码." @默认值 = "">
    参数 超时时间 <类型 = 整数 注释 = "指定本次完成整个请求所限定的超时时间,为-1时不限制,单位:毫秒." @默认值 = -1>
    参数 重定向次数 <类型 = 整数 注释 = "欲遵循网站重定向的最大次数,为-1时无限制,为0时禁止重定向." @默认值 = -1>
    参数 忽略SSL错误 <类型 = 逻辑型 注释 = "是否忽略任何SSL验证相关错误,即不验证证书也不验证服务器(如使用了代理将会被一同忽略)." @默认值 = 真>
    参数 是否优先 <类型 = 逻辑型 注释 = "是否优先执行该任务,为真时将压入到任务队列的首部,否则压入到尾部.优先时不受任务上限数限制." @默认值 = 假>
    {
        变量 参数 <类型 = 网络访问参数指针>
        <> 参数 = 网络访问参数指针.创建 ()
        参数.值.访问类型 = 1
        参数.值.网址 = 网址
        参数.值.保存位置 = 选择 (文本是否为空 (保存位置), 取运行目录 () + "download\\", 保存位置)
        检查加入路径字符 (参数.值.保存位置)
        如果 (创建目录 (参数.值.保存位置) == 假)
        {
            返回 (假)
        }
        参数.值.访问方式 = 访问方式
        参数.值.提交信息 = 提交信息
        参数.值.提交协议头 = 提交协议头
        参数.值.提交Cookie = 提交Cookie
        参数.值.最大下载速度 = 最大下载速度
        参数.值.内容编码 = ""
        参数.值.代理地址 = 代理地址
        参数.值.代理账号 = 代理账号
        参数.值.代理密码 = 代理密码
        参数.值.超时时间 = 超时时间
        参数.值.重定向次数 = 重定向次数
        参数.值.忽略SSL错误 = 忽略SSL错误
        成_任务锁.互斥自动锁 ()
        如果 (成_任务上限.取值 () != 0 && 成_任务队列.取成员数 () >= 成_任务上限.取值 () && 是否优先 == 假)
        {
            返回 (假)
        }
        否则
        {
            如果 (是否优先)
            {
                成_任务队列.压入到首部 (参数)
            }
            否则
            {
                成_任务队列.压入到尾部 (参数)
            }
        }
        返回 (真)
    }

    方法 投递网页访问 <公开 类型 = 逻辑型 注释 = "对指定网址发送请求,当传输结束后,请在\"网页访问完毕\"事件中获取响应内容." 折叠>
    参数 网址 <类型 = 文本型 注释 = "提供所欲访问的网址内容.">
    参数 访问方式 <类型 = 网页访问方式 注释 = "提供所欲使用的请求方式." @默认值 = 网页访问方式.GET>
    参数 提交信息 <类型 = 文本型 注释 = "设置本次请求所提交的数据,非POST请求也支持提交请求体,如需携带请求体务必保证该参数不为空对象,如果需要提交空请求体提供空文本内容即可."
            注释 = "如果提交信息为JSON数据,会自动加入协议头\"Content type \'application/json;charset=UTF-8\",无需你手动添加." @默认值 = 空对象>
    参数 提交协议头 <类型 = 文本数组类 注释 = "提供本次请求所欲使用的附加协议头,每个成员表示一个协议.默认已设置Accept-Language和User-Agent." @默认值 = 空对象>
    参数 提交Cookie <类型 = 文本型 注释 = "提供本次请求所欲使用的Cookie内容,注意该参数提交的内容不会同步到\"Cookie管理文件\"(不会写出至管理文件)." @默认值 = "">
    参数 内容编码 <类型 = 文本型
            注释 = "指定所欲请求服务器使用的内容编码(压缩)方式,即\"Accept-Encoding\"协议内容,例如\"gzip, deflate, br\",提供空文本则自动选择,提供空对象则禁用."
            @默认值 = "">
    参数 代理地址 <类型 = 文本型
            注释 = "提供所欲使用的代理地址,支持多种协议(http,https,socks4,socks4a,socks5,socks5h),例如(http协议):http://127.0.0.1:8080" @默认值 = "">
    参数 代理账号 <类型 = 文本型 注释 = "提供代理地址所需的用户名." @默认值 = "">
    参数 代理密码 <类型 = 文本型 注释 = "提供代理地址所需的用户密码." @默认值 = "">
    参数 超时时间 <类型 = 整数 注释 = "指定本次完成整个请求所限定的超时时间,为-1时不限制,单位:毫秒." @默认值 = -1>
    参数 重定向次数 <类型 = 整数 注释 = "欲遵循网站重定向的最大次数,为-1时无限制,为0时禁止重定向." @默认值 = -1>
    参数 忽略SSL错误 <类型 = 逻辑型 注释 = "是否忽略任何SSL验证相关错误,即不验证证书也不验证服务器(如使用了代理将会被一同忽略)." @默认值 = 真>
    参数 是否优先 <类型 = 逻辑型 注释 = "是否优先执行该任务,为真时将压入到任务队列的首部,否则压入到尾部.优先时不受任务上限数限制." @默认值 = 假>
    {
        变量 提交内容 <类型 = 字节集类>
        如果 (文本是否为空对象 (提交信息) == 假)
        {
            如果 (文本是否为空 (提交信息) == 假)
            {
                提交内容 = 文本到多字节 (提交信息, 假)
            }
            // 否则提供0长度,空请求体
        }
        否则
        {
            提交内容.重置为空对象 ()  // 空对象标志
        }
        返回 (投递网页访问2 (网址, 访问方式, 提交内容, 提交协议头, 提交Cookie, 内容编码, 代理地址, 代理账号, 代理密码, 超时时间, 重定向次数, 忽略SSL错误, 是否优先))
    }

    方法 投递网页访问2 <公开 类型 = 逻辑型 注释 = "对指定网址发送请求,当传输结束后,请在\"网页访问完毕\"事件中获取响应内容."
            注释 = "与\"投递网页访问\"命令基本一致,不同的是本方法提交的请求体内容为字节集类型." 折叠>
    参数 网址 <类型 = 文本型 注释 = "提供所欲访问的网址内容.">
    参数 访问方式 <类型 = 网页访问方式 注释 = "提供所欲使用的请求方式." @默认值 = 网页访问方式.GET>
    参数 提交信息 <类型 = 字节集类 注释 = "设置本次请求所提交的数据,非POST请求也支持提交请求体,如需携带请求体务必保证该参数不为空对象,如果需要提交空请求体提供空字节集即可."
            注释 = "如果提交信息为JSON数据,会自动加入协议头\"Content type \'application/json;charset=UTF-8\",无需你手动添加." @默认值 = 空对象>
    参数 提交协议头 <类型 = 文本数组类 注释 = "提供本次请求所欲使用的附加协议头,每个成员表示一个协议.默认已设置Accept-Language和User-Agent." @默认值 = 空对象>
    参数 提交Cookie <类型 = 文本型 注释 = "提供本次请求所欲使用的Cookie内容,注意该参数提交的内容不会同步到\"Cookie管理文件\"(不会写出至管理文件)." @默认值 = "">
    参数 内容编码 <类型 = 文本型
            注释 = "指定所欲请求服务器使用的内容编码(压缩)方式,即\"Accept-Encoding\"协议内容,例如\"gzip, deflate, br\",提供空文本则自动选择,提供空对象则禁用."
            @默认值 = "">
    参数 代理地址 <类型 = 文本型
            注释 = "提供所欲使用的代理地址,支持多种协议(http,https,socks4,socks4a,socks5,socks5h),例如(http协议):http://127.0.0.1:8080" @默认值 = "">
    参数 代理账号 <类型 = 文本型 注释 = "提供代理地址所需的用户名." @默认值 = "">
    参数 代理密码 <类型 = 文本型 注释 = "提供代理地址所需的用户密码." @默认值 = "">
    参数 超时时间 <类型 = 整数 注释 = "指定本次完成整个请求所限定的超时时间,为-1时不限制,单位:毫秒." @默认值 = -1>
    参数 重定向次数 <类型 = 整数 注释 = "欲遵循网站重定向的最大次数,为-1时无限制,为0时禁止重定向." @默认值 = -1>
    参数 忽略SSL错误 <类型 = 逻辑型 注释 = "是否忽略任何SSL验证相关错误,即不验证证书也不验证服务器(如使用了代理将会被一同忽略)." @默认值 = 真>
    参数 是否优先 <类型 = 逻辑型 注释 = "是否优先执行该任务,为真时将压入到任务队列的首部,否则压入到尾部.优先时不受任务上限数限制." @默认值 = 假>
    {
        // 返回 (网页访问 (网址, 访问方式, 提交信息, 是否优先, 提交协议头, 提交Cookie, 内容编码, 代理地址, 代理账号, 代理密码, 超时时间, 重定向次数, 忽略SSL错误))
        变量 参数 <类型 = 网络访问参数指针>
        <> 参数 = 网络访问参数指针.创建 ()
        参数.值.访问类型 = 0
        参数.值.网址 = 网址
        参数.值.访问方式 = 访问方式
        参数.值.提交信息 = 提交信息
        参数.值.提交协议头 = 提交协议头
        参数.值.提交Cookie = 提交Cookie
        参数.值.内容编码 = 内容编码
        参数.值.代理地址 = 代理地址
        参数.值.代理账号 = 代理账号
        参数.值.代理密码 = 代理密码
        参数.值.超时时间 = 超时时间
        参数.值.重定向次数 = 重定向次数
        参数.值.忽略SSL错误 = 忽略SSL错误
        成_任务锁.互斥自动锁 ()
        如果 (成_任务上限.取值 () != 0 && 成_任务队列.取成员数 () >= 成_任务上限.取值 () && 是否优先 == 假)
        {
            返回 (假)
        }
        否则
        {
            如果 (是否优先)
            {
                成_任务队列.压入到首部 (参数)
            }
            否则
            {
                成_任务队列.压入到尾部 (参数)
            }
        }
        返回 (真)
    }

    方法 全部暂停 <公开 注释 = "暂停所有传输" 折叠>
    {
        成_任务锁.互斥自动锁 ()
        成_工作句柄.枚举循环 ()
        {
            成_传输对象表.取值 (成_工作句柄.取枚举值 ()).值.暂停传输 (5)
        }
    }

    方法 全部恢复 <公开 注释 = "恢复所有传输" 折叠>
    {
        成_任务锁.互斥自动锁 ()
        成_工作句柄.枚举循环 ()
        {
            成_传输对象表.取值 (成_工作句柄.取枚举值 ()).值.暂停传输 (0)
        }
    }

    方法 清空任务 <公开 注释 = "清空所有已投递的网络传输任务,传输中的任务仍会继续完成." 折叠>
    {
        成_任务锁.互斥自动锁 ()
        成_任务队列.清空 ()
    }

    方法 下载进度改变 <公开 定义事件 类型 = 整数 注释 = "开始下载后,最长每隔1秒响应本事件,当下载进度发生变化时,会立即响应." 注释 = "即使暂停下载后,仍每隔一秒发送本事件."
            返回值注释 = "返回0继续传输,返回非0则中止传输." 折叠>
    参数 传输对象 <类型 = Curl传输类 注释 = "本次下载所用的实例对象.">
    参数 下载地址 <类型 = 文本型 注释 = "本次访问请求的地址.">
    参数 下载总量 <类型 = 长整数 注释 = "预计需要下载的字节数,断点续传和分块下载时不等于文件大小.">
    参数 当前下载 <类型 = 长整数 注释 = "当前已下载的字节数.">

    方法 下载完毕 <公开 定义事件 类型 = 整数 注释 = "下载结束后,将会响应本事件." 注释 = "为免阻塞连接池,请尽快返回,如有耗时操作请在线程中执行." 返回值注释 = "该返回值无意义."
            折叠>
    参数 传输对象 <类型 = Curl传输类 注释 = "本次下载所用的实例对象.">
    参数 下载地址 <类型 = 文本型 注释 = "本次访问请求的地址.">
    参数 下载响应 <类型 = 网络下载响应类 注释 = "本次下载返回的响应头和结果.离开本事件后,该对象立即释放.">

    方法 网页访问完毕 <公开 定义事件 类型 = 整数 注释 = "网页访问结束后,将会响应本事件." 注释 = "为免阻塞连接池,请尽快返回,如有耗时操作请在线程中执行."
            返回值注释 = "该返回值无意义." 折叠>
    参数 传输对象 <类型 = Curl传输类 注释 = "本次网页访问所用的实例对象.">
    参数 访问地址 <类型 = 文本型 注释 = "本次访问请求的地址.">
    参数 访问响应 <类型 = 网页访问响应类 注释 = "本次访问返回的请求结果和响应.离开本事件后,该对象立即释放.">

    # 内部方法 ---

    方法 _处理任务 <折叠>
    {
        判断循环 (成_退出信号.限时等待 (0) == 假)
        {
            成_任务锁.加锁 ()
            如果 (成_任务队列.取成员数 () > 0)
            {
                如果 (成_空闲句柄.取成员数 () > 0)
                {
                    变量 参数 <类型 = 网络访问参数指针>
                    变量 会话句柄 <类型 = 变整数>
                    <> 参数 = 成_任务队列.取首成员 ()
                    成_任务队列.弹出首部 ()
                    会话句柄 = 成_空闲句柄.取成员 (0)
                    成_工作句柄.加入成员 (会话句柄)
                    成_空闲句柄.删除成员 (0)
                    成_任务锁.解锁 ()
                    分支判断 (参数.值.访问类型)
                    {
                        分支 (0)  // 网页访问
                        {
                            设置网页访问 (成_传输对象表.取值 (会话句柄).值, 参数.值)
                        }
                        分支 (1)  // 下载
                        {
                            设置下载 (成_传输对象表.取值 (会话句柄).值, 参数.值)
                        }
                    }
                }
                否则
                {
                    成_任务锁.解锁 ()
                    延时 (成_轮询时间)
                }
            }
            否则
            {
                // 成_任务队列.清空 ()
                成_任务锁.解锁 ()
                延时 (成_轮询时间)
            }
            // 判断循环尾
        }

    }

    方法 _处理响应
    {
        变量 当前传输数量 <类型 = 整数>
        变量 完成任务数 <类型 = 整数>
        变量 剩余消息数 <类型 = 整数>
        变量 会话信息 <类型 = CURL信息指针>
        判断循环 (成_退出信号.限时等待 (0) == 假)
        {
            Curl传输类.发送多会话请求 (成_多会话句柄, 当前传输数量)
            如果 (Curl传输类.轮询 (成_多会话句柄, 成_轮询时间, 完成任务数) == 0)
            {
                循环判断首 ()
                {
                    会话信息 = Curl传输类.取多会话信息 (成_多会话句柄, 剩余消息数)
                    如果 (会话信息.为空指针 () == 真 || 会话信息.信息 != 1)
                    {
                        到循环尾
                    }
                    变量 对象指针 <类型 = Curl传输指针>
                    如果 (会话信息.会话句柄 != 0)
                    {
                        成_任务锁.互斥自动锁 ()
                        对象指针 = 成_传输对象表.取值 (会话信息.会话句柄)
                        如果 (对象指针.为空指针 ())
                        {
                            到循环尾
                        }
                    }
                    否则
                    {
                        到循环尾
                    }
                    // 获取传输响应
                    分支判断 (对象指针.值.成_访问类型)
                    {
                        分支 (0)  // 网页访问
                        {
                            变量 访问响应 <类型 = 网页访问响应类>
                            取网页访问响应 (对象指针.值, 访问响应)
                            网页访问完毕 (对象指针.值, 对象指针.值.取上次请求地址 (), 访问响应)
                        }
                        分支 (1)  // 下载
                        {
                            开始俘获异常 ()
                            {
                                如果 (对象指针.值.成_文件操作.是否已打开 () == 真)
                                {
                                    如果 (对象指针.值.成_下载信息.为空指针 () == 假 && 对象指针.值.成_文件操作.取文件长度 () != 对象指针.值.成_下载信息.值.文件大小)
                                    {
                                        到循环尾  // 继续下载
                                    }
                                    变量 下载响应 <类型 = 网络下载响应类>
                                    取下载响应 (对象指针.值, 下载响应)
                                    下载完毕 (对象指针.值, 对象指针.值.取上次请求地址 (), 下载响应)
                                }
                                否则  // 仅获取了响应头,需要继续下载主体
                                {
                                    如果 (准备下载 (对象指针.值) == 真)
                                    {
                                        到循环尾
                                    }
                                    否则
                                    {
                                        变量 下载响应 <类型 = 网络下载响应类>
                                        取下载响应 (对象指针.值, 下载响应)
                                        下载完毕 (对象指针.值, 对象指针.值.取上次请求地址 (), 下载响应)

                                    }
                                }

                            }
                            俘获所有异常 ()
                            {
                                调试输出 (取当前语句位置 ())
                            }

                        }
                    }
                    // 移除会话句柄
                    对象指针.值.移除会话句柄 (成_多会话句柄)
                    成_任务锁.互斥自动锁 ()
                    // 从工作对象中移除
                    成_工作句柄.查找删除成员 (会话信息.会话句柄)
                    // 加入到空闲对象,等待复用
                    如果 (成_工作句柄.取成员数 () + 成_空闲句柄.取成员数 () >= 成_并发数.取值 ())
                    {
                        成_传输对象表.删除 (会话信息.会话句柄)
                    }
                    否则
                    {
                        对象指针.值.重置参数 ()
                        成_空闲句柄.加入成员 (会话信息.会话句柄)
                    }

                }
                循环判断尾 (剩余消息数 > 0)

            }
        }

    }

    方法 下载写入数据回调 <静态 类型 = 变整数 注释 = "\"置写入数据回调函数\"对应的方法模板." 注释 = "注意:定义该回调方法时务必定义为\"CDECL\"调用方式."
            返回值注释 = "返回所处理的数据长度,返回0x10000001可暂停传输." 折叠 @视窗.前缀文本 = "@CDECL">
    参数 数据 <类型 = 变整数 注释 = "本次回调提供的数据指针.">
    参数 数据尺寸 <类型 = 变整数 注释 = "本次回调提供单个数据的长度,即总长度应为 \"数据尺寸\"*\"数据数量\".">
    参数 数据数量 <类型 = 变整数 注释 = "本次回调提供数据的个数.">
    参数 用户数据 <类型 = 变整数 注释 = "设置回调函数所传入的\"用户数据\"参数.">
    {
        读指针处对象 (用户数据, Curl传输类).成_文件操作.写指针数据 (数据, 数据尺寸 * 数据数量)
        返回 (数据尺寸 * 数据数量)
    }

    方法 下载进度回调 <静态 类型 = 整数 注释 = "传输进度发生变化时将会调用该方法." 注释 = "注意:定义该回调方法时务必定义为\"CDECL\"调用方式."
            返回值注释 = "返回0继续传输,返回非0则中止传输." 折叠 @视窗.前缀文本 = "@CDECL">
    参数 用户数据 <类型 = 变整数 注释 = "设置回调函数所传入的\"用户数据\"参数.">
    参数 下载总量 <类型 = 长整数 注释 = "预计所需下载数据的总尺寸.">
    参数 当前下载 <类型 = 长整数 注释 = "当前所下载的数据尺寸.">
    参数 上传总量 <类型 = 长整数 注释 = "预计所需上传数据的总尺寸.">
    参数 当前上传 <类型 = 长整数 注释 = "当前所上传的数据尺寸.">
    {
        // 接收响应头时亦会响应回调,通过下载总量是否为0可以判断是否开始下载,这里屏蔽了响应头的回调.
        如果 (下载总量 > 0)
        {
            返回 (读指针处对象 (读指针处对象 (用户数据, Curl传输类).成_类指针, 高并发网络访问类).下载进度改变 (读指针处对象 (用户数据, Curl传输类), 读指针处对象 (用户数据, Curl传输类).取上次请求地址 (), 下载总量, 当前下载))
        }
        否则
        {
            返回 (0)
        }
    }

    方法 网页写入数据回调 <静态 类型 = 变整数 注释 = "\"置写入数据回调函数\"对应的方法模板." 注释 = "注意:定义该回调方法时务必定义为\"CDECL\"调用方式."
            返回值注释 = "返回所处理的数据长度,返回0x10000001可暂停传输." 折叠 @视窗.前缀文本 = "@CDECL">
    参数 数据 <类型 = 变整数 注释 = "本次回调提供的数据指针.">
    参数 数据尺寸 <类型 = 变整数 注释 = "本次回调提供单个数据的长度,即总长度应为 \"数据尺寸\"*\"数据数量\".">
    参数 数据数量 <类型 = 变整数 注释 = "本次回调提供数据的个数.">
    参数 用户数据 <类型 = 变整数 注释 = "设置回调函数所传入的\"用户数据\"参数.">
    {
        读指针处对象 (用户数据, 字节集类).指针添加字节集 (数据, (整数)(数据尺寸 * 数据数量))
        返回 (数据尺寸 * 数据数量)
    }

    方法 接收响应头回调 <静态 类型 = 整数 注释 = "\"置接收响应头回调函数\"对应的方法模板,每解析完成一个响应头时本方法被调用一次."
            注释 = "注意:定义该回调方法时务必定义为\"CDECL\"调用方式." 返回值注释 = "返回响应头数据长度." 折叠 @视窗.前缀文本 = "@CDECL">
    参数 缓冲区 <类型 = 变整数 注释 = "响应头内容.">
    参数 数据尺寸 <类型 = 整数 注释 = "本次回调提供单个数据的长度,即总长度应为\"数据尺寸 * 数据数量\".">
    参数 数据数量 <类型 = 整数 注释 = "本次回调提供数据的个数.">
    参数 用户数据 <类型 = 变整数 注释 = "设置回调函数所传入的\"用户数据\"参数.">
    {
        如果 (数据尺寸 == 2)
        {
            @ ((@dt<文本数组类>*)@<用户数据>)->data().Add((const WCHAR *)@<缓冲区>);
        }
        否则
        {
            @ ((@dt<文本数组类>*)@<用户数据>)->data().Add(CU8String((const CHAR *)@<缓冲区>).GetText());
        }
        返回 (数据尺寸 * 数据数量)
    }

    方法 设置下载 <注释 = "设置下载参数,仅获取响应头" 折叠>
    参数 传输对象 <类型 = Curl传输类>
    参数 访问参数 <类型 = 网络访问参数类>
    {
        传输对象.成_访问类型 = 1
        传输对象.成_类指针 = 本对象.取对象自身指针 ()
        传输对象.快速打开 = 真
        传输对象.置接收响应头回调函数 (接收响应头回调, 传输对象.成_响应头.取对象自身指针 ())
        传输对象.地址 = 访问参数.网址
        如果 (访问参数.访问方式 == 网页访问方式.GET)
        {
            传输对象.置请求方式 ("GET")
        }
        否则 (访问参数.访问方式 == 网页访问方式.POST)
        {
            传输对象.置请求方式 ("POST")
        }
        否则 (访问参数.访问方式 == 网页访问方式.HEAD)
        {
            传输对象.置请求方式 ("HEAD")
            传输对象.忽略主体请求 = 真
        }
        否则 (访问参数.访问方式 == 网页访问方式.PUT)
        {
            传输对象.置请求方式 ("PUT")
        }
        否则 (访问参数.访问方式 == 网页访问方式.OPTIONS)
        {
            传输对象.置请求方式 ("OPTIONS")
        }
        否则 (访问参数.访问方式 == 网页访问方式.DELETE)
        {
            传输对象.置请求方式 ("DELETE")
        }
        否则 (访问参数.访问方式 == 网页访问方式.TRACE)
        {
            传输对象.置请求方式 ("TRACE")
        }
        否则 (访问参数.访问方式 == 网页访问方式.CONNECT)
        {
            传输对象.置请求方式 ("CONNECT")
        }
        否则 (访问参数.访问方式 == 网页访问方式.PATCH)
        {
            传输对象.置请求方式 ("PATCH")
        }
        否则
        {
            传输对象.置请求方式 ("GET")
        }
        传输对象.置Cookie内容 (访问参数.提交Cookie)
        如果 (文本是否为空对象 (成_Cookie文件) == 假)
        {
            如果 (文本是否为空 (成_Cookie文件))
            {
                传输对象.置读Cookie文件 ("")
                传输对象.置写Cookie文件 (空对象)
            }
            否则
            {
                传输对象.置读Cookie文件 (成_Cookie文件)
                传输对象.置写Cookie文件 (成_Cookie文件)
            }
        }
        否则
        {
            传输对象.置读Cookie文件 (空对象)  // 空对象置入过去等于清除原设置
            传输对象.置写Cookie文件 (空对象)
        }
        如果 (是否为空对象 (访问参数.提交信息) == 假)
        {
            如果 (访问参数.提交信息.取字节集长度 () > 0)
            {
                如果 (访问参数.提交信息.取字节集数据 (0, 字节) == 123)  // 首尾字符为"{",表示是JSON
                {
                    访问参数.提交协议头.加入成员 ("Content-Type: application/json; charset=utf-8")
                }
                传输对象.置提交数据 (访问参数.提交信息, 真)
                传输对象.置提交数据尺寸 (访问参数.提交信息.取字节集长度 ())
            }
            否则
            {
                传输对象.置提交数据 (空对象, 假)
                传输对象.置提交数据尺寸 (0)
            }
        }
        否则
        {
            传输对象.置提交数据尺寸 (0)
        }
        访问参数.提交协议头.加入成员 ("Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,zh-TW;q=0.5")
        访问参数.提交协议头.加入成员 ("User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36 Edg/100.0.1185.29")
        传输对象.置请求头 (访问参数.提交协议头)
        传输对象.编码内容 = 访问参数.内容编码  // 覆盖提交协议头里的Accept-Encoding,如果仅提交协议头返回的内容不会自动解码!
        传输对象.代理地址 = 访问参数.代理地址
        传输对象.代理身份验证账号 = 访问参数.代理账号
        传输对象.代理身份验证密码 = 访问参数.代理密码
        如果 (访问参数.重定向次数 == 0)
        {
            传输对象.遵循重定向 = 假
        }
        否则
        {
            传输对象.遵循重定向 = 真
            传输对象.重定向最大次数 = 访问参数.重定向次数
        }
        传输对象.请求超时 = 选择 (访问参数.超时时间 > 0, 访问参数.超时时间, 0)
        如果 (访问参数.忽略SSL错误)
        {
            传输对象.SSL证书检查 = 假
            传输对象.SSL验证证书主机名 = 假
            传输对象.SSL代理证书检查 = 假
        }
        传输对象.SSL代理验证证书主机名 = 假
        传输对象.忽略主体请求 = 真  // 第一次只读响应头
        传输对象.最大下载速度 = 访问参数.最大下载速度
        传输对象.成_文件路径 = 访问参数.保存位置
        传输对象.添加会话句柄 (成_多会话句柄)
    }

    方法 准备下载 <类型 = 逻辑型 注释 = "获取下载的响应头后,开始下载本体" 折叠>
    参数 传输对象 <类型 = Curl传输类>
    {
        变量 响应码 <类型 = 整数>
        响应码 = 传输对象.取上次请求响应码 ()
        如果 (响应码 < 200 || 响应码 >= 400)  // 下载错误时可能得到的错误码
        {
            传输对象.成_文件路径 = ""
            返回 (假)
        }
        传输对象.成_下载信息 = Curl下载信息指针.创建 ()
        如果 (传输对象.成_下载信息.为空指针 () == 真)
        {
            传输对象.成_文件路径 = ""
            返回 (假)
        }
        传输对象.成_下载信息.值.响应头 = 传输对象.成_响应头
        传输对象.成_下载信息.值.响应头.枚举循环 ()
        {
            变量 当前值 <类型 = 文本型>
            当前值 = 传输对象.成_下载信息.值.响应头.取枚举值 ()
            如果 (是否以文本开头 (当前值, "Accept-Ranges", 假))
            {
                传输对象.成_下载信息.值.断点续传 = 真
                跳出循环
            }
            // 如果 (是否以文本开头 (当前值, "Content-Range", 假))  // 未实现
            {
                // // Content-Range: bytes 0-10000/183404616"
                // 传输对象.成_下载信息.值.分块传输 = 真
                // 跳出循环

            }
        }
        传输对象.成_下载信息.值.创建日期 = 取现行时间 ()
        传输对象.成_下载信息.值.文件大小 = 传输对象.取内容长度 ()
        传输对象.成_下载信息.值.文件路径 = 传输对象.成_文件路径 + 传输对象.取下载文件名 (真)
        传输对象.成_下载信息.值.下载地址 = 传输对象.取上次请求地址 ()
        传输对象.成_下载信息.值.已下载 = 取文件尺寸 (传输对象.成_下载信息.值.文件路径)
        如果 (传输对象.成_下载信息.值.已下载 != -1)  // 文件已存在
        {
            变量 是否新建文件 <类型 = 逻辑型 值 = 真>
            如果 (传输对象.成_下载信息.值.断点续传)  // 断点续传
            {
                变量 下载配置文件 <类型 = 字节集类>
                如果 (下载配置文件.从文件读字节集 (传输对象.成_下载信息.值.文件路径 + ".curldownload") >= 76)
                {
                    如果 (下载配置文件.取字节集数据 (0, 长整数) == 0x4C444C525543)
                    {
                        变量 下载配置 <类型 = Curl下载信息类>
                        下载配置.置对象数据 (下载配置文件)
                        如果 (下载配置.文件大小 == 传输对象.成_下载信息.值.文件大小 && 下载配置.下载地址 == 传输对象.成_下载信息.值.下载地址)
                        {
                            如果 (传输对象.成_下载信息.值.已下载 == 传输对象.成_下载信息.值.文件大小)  // 如果文件已经下载完成
                            {
                                如果 (文件是否存在 (传输对象.成_下载信息.值.文件路径 + ".curldownload"))
                                {
                                    删除文件 (传输对象.成_下载信息.值.文件路径 + ".curldownload")  // 清理下载配置文件
                                }
                            }
                            否则  // 未下载完则开始断点续传
                            {
                                // 传输对象.恢复传输 = 传输对象.成_下载信息.值.已下载
                                传输对象.请求数据范围 = 取格式文本 ("%I64d-", 传输对象.成_下载信息.值.已下载)
                                是否新建文件 = 假

                            }
                        }
                    }
                }
            }
            如果 (是否新建文件 == 真)  // 另起新文件名从头下载
            {
                取文件名副本 (传输对象.成_下载信息.值.文件路径)

            }
        }
        如果 (传输对象.成_文件操作.打开文件 (传输对象.成_下载信息.值.文件路径, 文件访问权限.读写, 文件共享模式.禁止写, 文件创建方式.创建并覆盖) == 假)
        {
            传输对象.成_文件路径 = ""
            返回 (假)
        }
        传输对象.成_文件操作.移到文件尾 ()
        传输对象.成_文件路径 = 传输对象.成_下载信息.值.文件路径
        传输对象.成_响应头.删除所有成员 ()
        传输对象.进度反馈 = 真
        传输对象.置传输进度回调函数 (下载进度回调, 传输对象.取对象自身指针 ())
        传输对象.置写入数据回调函数 (下载写入数据回调, 传输对象.取对象自身指针 ())
        传输对象.忽略主体请求 = 假
        传输对象.成_下载信息.值.取对象数据 ().写字节集到文件 (传输对象.成_下载信息.值.文件路径 + ".curldownload")
        传输对象.移除会话句柄 (成_多会话句柄)
        传输对象.添加会话句柄 (成_多会话句柄)
        返回 (真)
    }

    方法 取文件名副本 <注释 = "如果目标文件名已存在,返回一个不存在的文件名,比如在文件名后加\"(1)\"" 折叠>
    参数 文件路径 <类型 = 文本型>
    {
        变量 临时路径 <类型 = 文本型>
        变量 索引 <类型 = 整数 值 = 1>
        临时路径 = 文件路径
        判断循环 (文件是否存在 (临时路径))
        {
            变量 找到位置 <类型 = 整数>
            找到位置 = 倒找字符 (文件路径, '.')
            如果 (找到位置 > 倒找字符 (文件路径, '\\'))
            {
                临时路径 = 文件路径
                插入文本 (临时路径, 找到位置, "(" + 到文本 (索引) + ")")
            }
            否则
            {
                临时路径 = 文件路径 + "(" + 到文本 (索引) + ")"
            }
            索引 = 索引 + 1

        }
        文件路径 = 临时路径
    }

    方法 设置网页访问 <折叠>
    参数 传输对象 <类型 = Curl传输类>
    参数 访问参数 <类型 = 网络访问参数类>
    {
        传输对象.成_访问类型 = 0
        传输对象.快速打开 = 真
        传输对象.置写入数据回调函数 (网页写入数据回调, 传输对象.成_返回结果.取对象自身指针 ())
        传输对象.置接收响应头回调函数 (接收响应头回调, 传输对象.成_响应头.取对象自身指针 ())
        传输对象.地址 = 访问参数.网址
        如果 (访问参数.访问方式 == 网页访问方式.GET)
        {
            传输对象.置请求方式 ("GET")
        }
        否则 (访问参数.访问方式 == 网页访问方式.POST)
        {
            传输对象.置请求方式 ("POST")
        }
        否则 (访问参数.访问方式 == 网页访问方式.HEAD)
        {
            传输对象.置请求方式 ("HEAD")
            传输对象.忽略主体请求 = 真
        }
        否则 (访问参数.访问方式 == 网页访问方式.PUT)
        {
            传输对象.置请求方式 ("PUT")
        }
        否则 (访问参数.访问方式 == 网页访问方式.OPTIONS)
        {
            传输对象.置请求方式 ("OPTIONS")
        }
        否则 (访问参数.访问方式 == 网页访问方式.DELETE)
        {
            传输对象.置请求方式 ("DELETE")
        }
        否则 (访问参数.访问方式 == 网页访问方式.TRACE)
        {
            传输对象.置请求方式 ("TRACE")
        }
        否则 (访问参数.访问方式 == 网页访问方式.CONNECT)
        {
            传输对象.置请求方式 ("CONNECT")
        }
        否则 (访问参数.访问方式 == 网页访问方式.PATCH)
        {
            传输对象.置请求方式 ("PATCH")
        }
        否则
        {
            传输对象.置请求方式 ("GET")
        }
        传输对象.置Cookie内容 (访问参数.提交Cookie)
        如果 (文本是否为空对象 (成_Cookie文件) == 假)
        {
            如果 (文本是否为空 (成_Cookie文件))
            {
                传输对象.置读Cookie文件 ("")
                传输对象.置写Cookie文件 (空对象)
            }
            否则
            {
                传输对象.置读Cookie文件 (成_Cookie文件)
                传输对象.置写Cookie文件 (成_Cookie文件)
            }
        }
        否则
        {
            传输对象.置读Cookie文件 (成_Cookie文件)  // 空对象置入过去等于清除原设置
            传输对象.置写Cookie文件 (成_Cookie文件)
        }
        如果 (是否为空对象 (访问参数.提交信息) == 假)
        {
            如果 (访问参数.提交信息.取字节集长度 () > 0)
            {
                如果 (访问参数.提交信息.取字节集数据 (0, 字节) == 123)  // 首尾字符为"{",表示是JSON
                {
                    访问参数.提交协议头.加入成员 ("Content-Type: application/json; charset=utf-8")
                }
                否则
                {
                    访问参数.提交协议头.加入成员 ("Content-Type: application/x-www-form-urlencoded; charset=utf-8")
                }
                传输对象.置提交数据 (访问参数.提交信息, 真)
                传输对象.置提交数据尺寸 (访问参数.提交信息.取字节集长度 ())
            }
            否则
            {
                传输对象.置提交数据 (空对象, 假)
                传输对象.置提交数据尺寸 (0)
            }
        }
        否则
        {
            传输对象.置提交数据尺寸 (0)
        }
        访问参数.提交协议头.加入成员 ("Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,zh-TW;q=0.5")
        访问参数.提交协议头.加入成员 ("User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36 Edg/100.0.1185.29")
        传输对象.置请求头 (访问参数.提交协议头)
        传输对象.编码内容 = 访问参数.内容编码  // 覆盖提交协议头里的Accept-Encoding,如果仅提交协议头返回的内容不会自动解码!
        如果 (访问参数.重定向次数 == 0)
        {
            传输对象.遵循重定向 = 假
        }
        否则
        {
            传输对象.遵循重定向 = 真
            传输对象.重定向最大次数 = 访问参数.重定向次数
        }
        传输对象.代理地址 = 访问参数.代理地址
        传输对象.代理身份验证账号 = 访问参数.代理账号
        传输对象.代理身份验证密码 = 访问参数.代理密码
        传输对象.请求超时 = 选择 (访问参数.超时时间 > 0, 访问参数.超时时间, 0)
        如果 (访问参数.忽略SSL错误)
        {
            传输对象.SSL证书检查 = 假
            传输对象.SSL验证证书主机名 = 假
            传输对象.SSL代理证书检查 = 假
            传输对象.SSL代理验证证书主机名 = 假
        }
        传输对象.添加会话句柄 (成_多会话句柄)
    }

    方法 取下载响应 <折叠>
    参数 传输对象 <类型 = Curl传输类>
    参数 返回结果 <类型 = 网络下载响应类>
    {
        返回结果.下载地址 = 传输对象.取上次请求地址 ()
        返回结果.响应头 = 传输对象.成_响应头
        返回结果.响应头.枚举循环 ()
        {
            变量 当前值 <类型 = 文本型>
            当前值 = 返回结果.响应头.取枚举值 ()
            如果 (是否以文本开头 (当前值, "Set-Cookie:", 假))
            {
                删除字符 (当前值, 0, 取文本长度 ("Set-Cookie:"))
                如果 (文本是否为空 (返回结果.Cookies) == 假)
                {
                    加入文本 (返回结果.Cookies, "; ")
                }
                加入文本 (返回结果.Cookies, 删首尾空 (当前值))
            }
            如果 (是否以文本开头 (当前值, "Location:", 假))
            {
                删除字符 (当前值, 0, 取文本长度 ("Location:"))
                返回结果.重定向地址 = 删首尾空 (当前值)
            }
        }
        返回结果.重定向次数 = 传输对象.取重定向次数 ()
        返回结果.文件名 = 传输对象.取下载文件名 (真)
        返回结果.文件路径 = 传输对象.成_文件路径
        返回结果.响应码 = 传输对象.取上次请求响应码 ()
        返回结果.下载耗时 = 传输对象.取接收时长 ()
        返回结果.平均下载速度 = 传输对象.取平均下载速度 ()
        如果 (传输对象.成_下载信息.为空指针 () == 假)
        {
            返回结果.文件大小 = 传输对象.成_下载信息.值.文件大小
            传输对象.成_下载信息.值.已下载 = 传输对象.成_文件操作.取文件长度 ()
            如果 (传输对象.成_下载信息.值.已下载 == 传输对象.成_下载信息.值.文件大小)
            {
                如果 (文件是否存在 (返回结果.文件路径 + ".curldownload"))
                {
                    删除文件 (返回结果.文件路径 + ".curldownload")
                }
            }
            否则
            {
                传输对象.成_下载信息.值.取对象数据 ().写字节集到文件 (返回结果.文件路径 + ".curldownload")
            }
        }
        传输对象.成_文件操作.关闭文件 ()
    }

    方法 取网页访问响应 <折叠>
    参数 传输对象 <类型 = Curl传输类>
    参数 返回结果 <类型 = 网页访问响应类>
    {
        返回结果.响应头 = 传输对象.成_响应头
        返回结果.请求结果 = 传输对象.成_返回结果
        返回结果.响应头.枚举循环 ()
        {
            变量 当前值 <类型 = 文本型>
            当前值 = 返回结果.响应头.取枚举值 ()
            如果 (是否以文本开头 (当前值, "Set-Cookie", 假))
            {
                删除部分文本 (当前值, 0, 取文本长度 ("Set-Cookie: "))
                如果 (是否以文本结束 (当前值, "\r\n", 假))
                {
                    删除部分文本 (当前值, 取文本长度 (当前值) - 2, 2)
                }
                返回结果.Cookies.加入成员 (当前值)
            }
            如果 (是否以文本开头 (当前值, "Location", 假))
            {
                返回结果.重定向地址 = 取文本中间 (当前值, 取文本长度 ("Location: "), 取文本长度 (当前值) - 取文本长度 ("Location: "))
            }
        }
        返回结果.重定向次数 = 传输对象.取重定向次数 ()
        返回结果.响应码 = 传输对象.取上次请求响应码 ()
        返回结果.请求耗时 = 传输对象.取接收时长 ()
    }
}

类 多会话状态码 <公开 注释 = "提供\"Curl传输类\"中的一些结果码返回值定义." 折叠 @文档 = "category = \"高并发网络访问.辅助类\"">
{
    常量 成功 <公开 类型 = 整数 值 = 0 注释 = "表示执行成功.">
    常量 多句柄错误 <公开 类型 = 整数 值 = 1 注释 = "传入的句柄不是有效的多句柄.">
    常量 简易句柄错误 <公开 类型 = 整数 值 = 2 注释 = "简易句柄有问题或不可用.可能是此句柄不是有效的简易句柄,或者它已经被用于其他多句柄.">
    常量 内存不足 <公开 类型 = 整数 值 = 3 注释 = "表示内存不足无法申请空间.">
    常量 内部错误 <公开 类型 = 整数 值 = 4 注释 = "只有libcurl出现bug时返回此代码,请反馈给官方.">
    常量 套接字错误 <公开 类型 = 整数 值 = 5 注释 = "传入的套接字不是libcurl已经知道的有效套接字.">
    常量 无法识别选项 <公开 类型 = 整数 值 = 6 注释 = "无法识别的选项.">
    常量 已被添加 <公开 类型 = 整数 值 = 7 注释 = "此简易会话句柄已经添加到多句柄中,无法重复添加.">
    常量 递归的回调 <公开 类型 = 整数 值 = 8 注释 = "回调函数出现递归.">
    常量 唤醒失败 <公开 类型 = 整数 值 = 9 注释 = "唤醒不可用或失败.">
    常量 参数错误 <公开 类型 = 整数 值 = 10 注释 = "函数调用了一个错误的参数.">
    常量 回调方法中止 <公开 类型 = 整数 值 = 11 注释 = "多句柄的回调方法返回了错误.">
}

类 网络下载响应类 <公开 基础类 = 扩展对象类 注释 = "下载所返回的响应内容." 折叠 @文档 = "category = \"高并发网络访问.辅助类\"">
{
    变量 下载地址 <公开 类型 = 文本型 注释 = "本次请求的网址." @属性变量 = 真>
    变量 文件名 <公开 类型 = 文本型 注释 = "本次请求解析到的原始文件名(不含路径),不一定是最终保存的文件名." @属性变量 = 真>
    变量 文件路径 <公开 类型 = 文本型 注释 = "本次请求实际保存的全路径文件名.为空表示还没开始下载就失败了." @属性变量 = 真>
    变量 文件大小 <公开 类型 = 长整数 注释 = "本次请求所下载的文件大小." @属性变量 = 真>
    变量 Cookies <公开 类型 = 文本型 注释 = "本次请求所返回的Cookie内容." @属性变量 = 真>
    变量 响应头 <公开 类型 = 文本数组类 注释 = "本次请求所接收到服务器的响应头内容." @属性变量 = 真>
    变量 重定向地址 <公开 类型 = 文本型 注释 = "本次请求最终的重定向地址." @属性变量 = 真>
    变量 重定向次数 <公开 类型 = 整数 注释 = "本次请求所遵循重定向的次数." @属性变量 = 真>
    变量 响应码 <公开 类型 = 整数 注释 = "本次请求的HTTP状态码." @属性变量 = 真>
    变量 下载耗时 <公开 类型 = 长整数 注释 = "本次请求所耗下载时长(毫秒)." @属性变量 = 真>
    变量 平均下载速度 <公开 类型 = 长整数 注释 = "本次请求的平均下载速度(字节/秒)." @属性变量 = 真>

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖 @输出名 = "GetDumpString"
            @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<网络下载响应类> 总共 11 个成员:\r\n"
        加入文本 (展示内容, "1. 下载地址: " + 取调试文本2 (最大展示数据尺寸, 下载地址) + "\r\n")
        加入文本 (展示内容, "2. 文件名: " + 取调试文本2 (最大展示数据尺寸, 文件名) + "\r\n")
        加入文本 (展示内容, "3. 文件路径: " + 取调试文本2 (最大展示数据尺寸, 文件路径) + "\r\n")
        加入文本 (展示内容, "4. 文件大小: " + 取调试文本2 (最大展示数据尺寸, 文件大小) + "\r\n")
        加入文本 (展示内容, "5. Cookies: " + 取调试文本2 (最大展示数据尺寸, Cookies) + "\r\n")
        加入文本 (展示内容, "6. 响应头: " + 取调试文本2 (最大展示数据尺寸, 响应头) + "\r\n")
        加入文本 (展示内容, "7. 重定向地址: " + 取调试文本2 (最大展示数据尺寸, 重定向地址) + "\r\n")
        加入文本 (展示内容, "8. 重定向次数: " + 取调试文本2 (最大展示数据尺寸, 重定向次数) + "\r\n")
        加入文本 (展示内容, "9. 响应码: " + 取调试文本2 (最大展示数据尺寸, 响应码) + "\r\n")
        加入文本 (展示内容, "10. 下载耗时: " + 取调试文本2 (最大展示数据尺寸, 下载耗时) + "\r\n")
        加入文本 (展示内容, "11. 平均下载速度: " + 取调试文本2 (最大展示数据尺寸, 平均下载速度) + "\r\n")
    }
}

类 CURL信息指针 <公开 基础类 = PIV指针模板 注释 = "\"取多会话信息\"所返回的结果." 折叠 @文档 = "category = \"高并发网络访问.辅助类\""
        @模板实现类 = "CURL信息指针" @别名 = "CURLMsg*" @别名类型 = 本地参考类型>
{
    变量 信息 <公开 类型 = 整数 注释 = "1 CURLMSG_DONE 表示传输完成,其他值未定义" @输出名 = "msg">
    变量 whatever <公开 类型 = 通用指针 注释 = "message-specific data" @输出名 = "data.whatever">

    方法 会话句柄 <公开 静态 属性读 类型 = 变整数 注释 = "\"信息\"为1时返回会话句柄" 折叠 @嵌入式方法 = "">
    参数 本结构指针 <类型 = CURL信息指针>
    {
        @ (INT_P)@<本结构指针>->easy_handle
    }

    方法 返回码 <公开 静态 属性读 类型 = 变整数 注释 = "网络传输的返回码,请参考\"执行状态码\"中所提供的常量定义." @嵌入式方法 = "">
    参数 本结构指针 <类型 = CURL信息指针>
    {
        @ (INT_P)@<本结构指针>->data.result
    }
}

# 内部对象 ===

类 网络访问参数类 <注释 = "内部使用" 折叠 @文档 = "category = \"高并发网络访问.辅助类\"">
{
    变量 访问类型 <公开 类型 = 整数 注释 = "0=网页访问, 1=下载, 2=上传(未写)..." "">
    变量 网址 <公开 类型 = 文本型 注释 = "提供所欲访问的网址内容.">
    变量 访问方式 <公开 类型 = 网页访问方式 值 = 网页访问方式.GET 注释 = "提供所欲使用的请求方式.">
    变量 提交信息 <公开 类型 = 字节集类 注释 = "设置本次请求所提交的数据,非POST请求也支持提交请求体,如需携带请求体务必保证该参数不为空对象,如果需要提交空请求体提供空字节集即可.">
    变量 提交协议头 <公开 类型 = 文本数组类 注释 = "提供本次请求所欲使用的附加协议头,每个成员表示一个协议.">
    变量 提交Cookie <公开 类型 = 文本型 值 = "" 注释 = "提供本次请求所欲使用的Cookie内容,注意该参数提交的内容不会同步到\"Cookie管理文件\"(不会写出至管理文件).">
    变量 内容编码 <公开 类型 = 文本型 值 = ""
            注释 = "指定所欲请求服务器使用的内容编码(压缩)方式,即\"Accept-Encoding\"协议内容,例如\"gzip, deflate, br\",提供空文本则自动选择,提供空对象则禁用.">
    变量 代理地址 <公开 类型 = 文本型 值 = ""
            注释 = "提供所欲使用的代理地址,支持多种协议(http,https,socks4,socks4a,socks5,socks5h),例如(http协议):http://127.0.0.1:8080">
    变量 代理账号 <公开 类型 = 文本型 值 = "" 注释 = "提供代理地址所需的用户名.">
    变量 代理密码 <公开 类型 = 文本型 值 = "" 注释 = "提供代理地址所需的用户密码.">
    变量 超时时间 <公开 类型 = 整数 值 = -1 注释 = "指定本次完成整个请求所限定的超时时间,为-1时不限制,单位:毫秒.">
    变量 重定向次数 <公开 类型 = 整数 值 = -1 注释 = "欲遵循网站重定向的最大次数,为-1时无限制,为0时禁止重定向.">
    变量 忽略SSL错误 <公开 类型 = 逻辑型 值 = 真 注释 = "是否忽略任何SSL验证相关错误,即不验证证书也不验证服务器(如使用了代理将会被一同忽略).">
    变量 "//文件名" <公开 类型 = 文本型 注释 = "提供自定义的文件名(不含路径),留空则使用响应头的文件名.">
    变量 保存位置 <公开 类型 = 文本型 注释 = "下载的文本保存在此位置中,请以\"\\\\\"结尾.">
    变量 最大上传速度 <公开 类型 = 变整数 值 = 0 注释 = "单位:字节/秒,为0表示不限制.">
    变量 最大下载速度 <公开 类型 = 变整数 值 = 0 注释 = "单位:字节/秒,为0表示不限制.">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖 @输出名 = "GetDumpString"
            @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<网络访问参数类> 总共 15 个成员:\r\n"
        加入文本 (展示内容, "1. 访问类型: " + 取调试文本2 (最大展示数据尺寸, 访问类型) + "\r\n")
        加入文本 (展示内容, "2. 网址: " + 取调试文本2 (最大展示数据尺寸, 网址) + "\r\n")
        加入文本 (展示内容, "3. 访问方式: " + 取调试文本2 (最大展示数据尺寸, 访问方式) + "\r\n")
        加入文本 (展示内容, "4. 提交信息: " + 取调试文本2 (最大展示数据尺寸, 提交信息) + "\r\n")
        加入文本 (展示内容, "5. 提交协议头: " + 取调试文本2 (最大展示数据尺寸, 提交协议头) + "\r\n")
        加入文本 (展示内容, "6. 内容编码: " + 取调试文本2 (最大展示数据尺寸, 内容编码) + "\r\n")
        加入文本 (展示内容, "7. 代理地址: " + 取调试文本2 (最大展示数据尺寸, 代理地址) + "\r\n")
        加入文本 (展示内容, "8. 代理账号: " + 取调试文本2 (最大展示数据尺寸, 代理账号) + "\r\n")
        加入文本 (展示内容, "9. 代理密码: " + 取调试文本2 (最大展示数据尺寸, 代理密码) + "\r\n")
        加入文本 (展示内容, "10. 超时时间: " + 取调试文本2 (最大展示数据尺寸, 超时时间) + "\r\n")
        加入文本 (展示内容, "11. 重定向次数: " + 取调试文本2 (最大展示数据尺寸, 重定向次数) + "\r\n")
        加入文本 (展示内容, "12. 忽略SSL错误: " + 取调试文本2 (最大展示数据尺寸, 忽略SSL错误) + "\r\n")
        加入文本 (展示内容, "13. 保存位置: " + 取调试文本2 (最大展示数据尺寸, 保存位置) + "\r\n")
        加入文本 (展示内容, "14. 最大上传速度: " + 取调试文本2 (最大展示数据尺寸, 最大上传速度) + "\r\n")
        加入文本 (展示内容, "15. 最大下载速度: " + 取调试文本2 (最大展示数据尺寸, 最大下载速度) + "\r\n")
    }
}

类 网络访问参数指针 <基础类 = 共享智能指针模板 注释 = "内部使用" @文档 = "category = \"高并发网络访问.辅助类\"" @模板实现类 = "网络访问参数类">

类 网络访问参数队列类 <基础类 = 标准双端队列模板 注释 = "内部使用" @文档 = "category = \"高并发网络访问.辅助类\"" @模板实现类 = "网络访问参数指针">

类 Curl传输指针 <基础类 = 共享智能指针模板 注释 = "内部使用" @文档 = "category = \"高并发网络访问.辅助类\"" @模板实现类 = "Curl传输类">

类 会话句柄到传输指针表 <基础类 = 通用排序表模板 注释 = "内部使用" @文档 = "category = \"高并发网络访问.辅助类\"" @模板实现类 = "变整数, Curl传输指针">

类 Curl下载信息类 <注释 = "内部使用" 折叠 @文档 = "category = \"高并发网络访问.辅助类\"">
{
    变量 标志头 <公开 类型 = 长整数 值 = 0x4C444C525543 注释 = ".curldownload文件的标识头,ANSI文本:CURLDL">
    变量 下载地址 <公开 类型 = 文本型>
    变量 文件路径 <公开 类型 = 文本型>
    变量 创建日期 <公开 类型 = 小数>
    变量 文件大小 <公开 类型 = 长整数 值 = 0 注释 = "0为未知大小">
    变量 已下载 <公开 类型 = 长整数 值 = 0>
    变量 断点续传 <公开 类型 = 逻辑型 值 = 假>
    变量 分块传输 <公开 类型 = 逻辑型 值 = 假 注释 = "功能未写">
    变量 分块数量 <公开 类型 = 整数 值 = 0 注释 = "功能未写">
    变量 未完成分块 <公开 类型 = 文本数组类 注释 = "功能未写">
    变量 响应头 <公开 类型 = 文本数组类>
    变量 保留文本 <公开 类型 = 文本型 注释 = "保留参数">
    变量 保留字节集 <公开 类型 = 字节集类 注释 = "保留参数">
    变量 保留整数 <公开 类型 = 整数 注释 = "保留参数">
    变量 保留长整数 <公开 类型 = 长整数 注释 = "保留参数">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖 @输出名 = "GetDumpString"
            @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<Curl下载信息类> 总共 15 个成员:\r\n"
        加入文本 (展示内容, "1. 标志头: " + 取调试文本2 (最大展示数据尺寸, 标志头) + "\r\n")
        加入文本 (展示内容, "2. 下载地址: " + 取调试文本2 (最大展示数据尺寸, 下载地址) + "\r\n")
        加入文本 (展示内容, "3. 文件路径: " + 取调试文本2 (最大展示数据尺寸, 文件路径) + "\r\n")
        加入文本 (展示内容, "4. 创建日期: " + 取调试文本2 (最大展示数据尺寸, 创建日期) + "\r\n")
        加入文本 (展示内容, "5. 文件大小: " + 取调试文本2 (最大展示数据尺寸, 文件大小) + "\r\n")
        加入文本 (展示内容, "6. 已下载: " + 取调试文本2 (最大展示数据尺寸, 已下载) + "\r\n")
        加入文本 (展示内容, "7. 断点续传: " + 取调试文本2 (最大展示数据尺寸, 断点续传) + "\r\n")
        加入文本 (展示内容, "8. 分块传输: " + 取调试文本2 (最大展示数据尺寸, 分块传输) + "\r\n")
        加入文本 (展示内容, "9. 分块数量: " + 取调试文本2 (最大展示数据尺寸, 分块数量) + "\r\n")
        加入文本 (展示内容, "10. 未完成分块: " + 取调试文本2 (最大展示数据尺寸, 未完成分块) + "\r\n")
        加入文本 (展示内容, "11. 响应头: " + 取调试文本2 (最大展示数据尺寸, 响应头) + "\r\n")
        加入文本 (展示内容, "12. 保留文本: " + 取调试文本2 (最大展示数据尺寸, 保留文本) + "\r\n")
        加入文本 (展示内容, "13. 保留字节集: " + 取调试文本2 (最大展示数据尺寸, 保留字节集) + "\r\n")
        加入文本 (展示内容, "14. 保留整数: " + 取调试文本2 (最大展示数据尺寸, 保留整数) + "\r\n")
        加入文本 (展示内容, "15. 保留长整数: " + 取调试文本2 (最大展示数据尺寸, 保留长整数) + "\r\n")
    }
}

类 Curl下载信息指针 <基础类 = 共享智能指针模板 注释 = "内部使用" @文档 = "category = \"高并发网络访问.辅助类\"" @模板实现类 = "Curl下载信息类">

# =====

类 网络辅助类 <公开 注释 = "网络相关的辅助方法(弃用)" 折叠 @文档 = "category = \"网络辅助\"" @禁止创建对象 = 真>
{
    方法 检查删除网址路径 <公开 静态 注释 = "删除网址末尾的斜杠" 折叠>
    参数 网址路径 <类型 = 文本型>
    参数 转换到小写 <类型 = 逻辑型 注释 = "是否将\"网址路径\"转换到小写" @默认值 = 假>
    {
        如果 (取尾字符 (网址路径) == '/' && 取文本长度 (网址路径) > 1)
        {
            删除字符 (网址路径, 取文本长度 (网址路径) - 1, 1)
        }
        如果 (转换到小写 == 真)
        {
            自身到小写 (网址路径)
        }
    }

    方法 解析URL参数 <公开 静态 类型 = 文本型 注释 = "分析URL的参数,注意本方法会修改参数里的请求URL" 返回值注释 = "返回参数" 折叠>
    参数 请求URL <类型 = 文本型 注释 = "如果有参数，会返回无参数的请求URL">
    参数 删除URL尾部路径字符 <类型 = 逻辑型 注释 = "删除网址末尾的斜杠,并将URL转换到小写" @默认值 = 真>
    {
        变量 参数 <类型 = 文本型>
        变量 位置 <类型 = 整数>
        位置 = 寻找字符 (请求URL, '?')
        如果 (位置 != -1)
        {
            <> 参数 = 取文本右边 (请求URL, 取文本长度 (请求URL) - 位置 - 1)  // 参数去掉了 ? 号
            请求URL = 取文本左边 (请求URL, 位置)
            如果 (删除URL尾部路径字符 == 真)
            {
                检查删除网址路径 (请求URL, 真)
            }
            返回 (参数)
        }
        否则
        {
            返回 ("")
        }
    }

    方法 取参数 <公开 静态 类型 = 文本型 注释 = "取GET或POST请求中的参数" 折叠>
    参数 参数名称 <类型 = 文本型>
    参数 参数文本 <类型 = 文本型 "">
    参数 URL取参数 <类型 = 逻辑型 注释 = "  为真时在URL中取参数" 注释 = "  post设为假,get的设为真" @默认值 = 假>
    参数 是否URL解码 <类型 = 逻辑型 @默认值 = 假>
    {
        变量 临时参数文本 <类型 = 文本型>
        临时参数文本 = 参数文本
        如果 (URL取参数 == 真)
        {
            变量 找到位置 <类型 = 整数>
            找到位置 = 寻找字符 (临时参数文本, '?')
            如果 (找到位置 != -1)
            {
                删除字符 (临时参数文本, 0, 找到位置 + 1)
            }
        }
        否则
        {
            如果 (是否以字符开头 (临时参数文本, '?') == 真)
            {
                删除字符 (临时参数文本, 0, 1)
            }

        }
        变量 结果数组 <类型 = 文本数组类>
        变量 成员数 <类型 = 整数>
        变量 索引 <类型 = 整数>
        成员数 = 分割文本 (临时参数文本, "&", 结果数组)
        循环 (0, 成员数, 索引, 1)
        {
            变量 临时结果 <类型 = 文本型>
            变量 位置 <类型 = 整数>
            临时结果 = 结果数组.取成员 (索引)
            位置 = 寻找字符 (临时结果, '=')
            如果 (位置 != -1)
            {
                如果 (取文本左边 (临时结果, 位置) == 参数名称)
                {
                    变量 参数值 <类型 = 文本型>
                    参数值 = 取文本右边 (临时结果, 取文本长度 (临时结果) - 位置 - 1)
                    如果 (是否URL解码 == 真)
                    {
                        返回 (UTF8到文本 (URL编解码类.解码 (文本到UTF8 (参数值, 假))))
                    }
                    否则
                    {
                        返回 (参数值)
                    }
                }
            }
        }
        返回 ("")
    }

    方法 取参数POST <公开 静态 类型 = 文本型 注释 = "POST专用的取参数,导入UTF8数据" 折叠>
    参数 参数名称 <类型 = 文本型>
    参数 提交数据 <类型 = 字节集类 "">
    参数 是否URL解码 <类型 = 逻辑型 @默认值 = 假>
    {
        变量 参数数组 <类型 = 字节集数组类>
        变量 成员数 <类型 = 整数>
        变量 索引 <类型 = 整数>
        成员数 = 提交数据.分割字节集 (创建字节集 (0x26), 参数数组)  // 用 & 分割
        循环 (0, 成员数, 索引, 1)
        {
            变量 临时结果 <类型 = 字节集类>
            变量 位置 <类型 = 整数>
            临时结果 = 参数数组.取成员 (索引)
            位置 = 临时结果.寻找字节集 (创建字节集 (0x3D))  // 寻找 = 的位置
            如果 (位置 != -1)
            {
                如果 (临时结果.取字节集左边 (位置) == 文本到UTF8 (参数名称, 假))
                {
                    临时结果.字节集删除 (0, 位置 + 1)
                    如果 (是否URL解码 == 真)
                    {
                        返回 (UTF8到文本 (URL编解码类.解码 (临时结果)))
                    }
                    否则
                    {
                        返回 (UTF8到文本 (临时结果))
                    }

                }
            }
        }
        返回 ("")
    }

    方法 取ETag <公开 静态 类型 = 文本型 注释 = "使用了七牛云公开的算法"
            注释 = "https://developer.qiniu.com/kodo/1231/appendix#qiniu-etag" 折叠>
    参数 数据 <类型 = 字节集类>
    {
        变量 校验码 <类型 = 字节集类>
        如果 (数据.取字节集长度 () > 1024 * 1024 * 4)
        {
            变量 分段校验码 <类型 = 字节集类>
            变量 次数 <类型 = 整数>
            次数 = 数据.取字节集长度 () / (1024 * 1024 * 4)
            计次循环 (次数)
            {
                分段校验码.添加字节集 (CNG加解密.取数据SHA1_字节集 (数据.取字节集中间 (取循环索引 () * 1024 * 1024 * 4, 1024 * 1024 * 4)))

            }
            如果 (数据.取字节集长度 () % (1024 * 1024 * 4) != 0)
            {
                分段校验码.添加字节集 (CNG加解密.取数据SHA1_字节集 (数据.取字节集右边 (数据.取字节集长度 () % (1024 * 1024 * 4))))

            }
            校验码.添加字节集内容 (0x96)
            校验码.添加字节集 (CNG加解密.取数据SHA1_字节集 (分段校验码))
        }
        否则
        {
            校验码.添加字节集内容 (0x16)
            校验码.添加字节集 (CNG加解密.取数据SHA1_字节集 (数据))
        }
        返回 (校验码.字节集到BASE64文本 (BASE64编码方式.URL专用))
    }

    方法 取文件ETag <公开 静态 类型 = 文本型 注释 = "使用了七牛云公开的算法"
            注释 = "https://developer.qiniu.com/kodo/1231/appendix#qiniu-etag" 返回值注释 = "失败返回空文本" 折叠>
    参数 文件名 <类型 = 文本型>
    {
        变量 校验码 <类型 = 字节集类>
        变量 文件操作 <类型 = 文件读写类>
        变量 文件长度 <类型 = 长整数>
        文件操作.打开文件 (文件名, 文件打开方式.读入)
        文件长度 = 文件操作.取文件长度 ()
        如果 (文件长度 == -1)
        {
            返回 ("")
        }
        否则 (文件长度 > 1024 * 1024 * 4)
        {
            变量 分段校验码 <类型 = 字节集类>
            文件操作.移到文件首 ()
            循环判断首 ()
            {
                分段校验码.添加字节集 (CNG加解密.取数据SHA1_字节集 (文件操作.读入字节集 (1024 * 1024 * 4)))

            }
            循环判断尾 (文件操作.是否在文件尾 () == 假)
            校验码.添加字节集内容 (0x96)
            校验码.添加字节集 (CNG加解密.取数据SHA1_字节集 (分段校验码))
            文件操作.关闭文件 ()
        }
        否则
        {
            校验码.添加字节集内容 (0x16)
            校验码.添加字节集 (CNG加解密.取数据SHA1_字节集 (文件操作.读入字节集 ((整数)文件长度)))
            文件操作.关闭文件 ()

        }
        返回 (校验码.字节集到BASE64文本 (BASE64编码方式.URL专用))
    }

    方法 密码处理 <公开 静态 类型 = 文本型 注释 = "将密码进行密钥派生处理." 注释 = "POST进来的密码都需要经过处理,再跟数据库上的密码对比." 返回值注释 = "返回加密后的密码" 折叠>
    参数 密码 <类型 = 文本型 注释 = "POST进来的明文密码">
    参数 前缀 <类型 = 文本型 注释 = "加密之前在密码前加盐" @默认值 = "">
    {
        变量 掩码密码 <类型 = 字节集类>
        掩码密码 = CNG加解密.密钥派生_PBKDF2 (文本到多字节 (密码, 假), 文本到多字节 (前缀, 假), 128, CNG_算法类型.哈希_SHA1, 10)
        返回 (掩码密码.字节集到BASE64文本 (BASE64编码方式.URL专用, -1))
    }

    方法 生成SessionID <公开 静态 类型 = 文本型 注释 = "生成唯一的session ID" 返回值注释 = "返回Session ID" 折叠>
    {
        变量 GUID <类型 = GUID类>
        变量 SessionID <类型 = 字节集类>
        SessionID.分配字节集 (32)
        GUID.创建 ()
        SessionID = GUID.取字节集 ()
        GUID.创建 ()
        SessionID.添加字节集 (GUID.取字节集 ())
        返回 (取文本左边 (SessionID.字节集到BASE64文本 (BASE64编码方式.URL专用, -1), 32))
    }

    方法 文件路径到URL <公开 静态 类型 = 文本型 注释 = "将完整的文件路径转换成子URL路径" 返回值注释 = "返回的子URL路径" 折叠>
    参数 文件路径 <类型 = 文本型 注释 = "文件路径">
    参数 根目录 <类型 = 文本型 注释 = "返回的URL会减去根目录,如果提供的文件路径是相对路径,可以留空." @默认值 = 空对象>
    {
        变量 路径 <类型 = 文本型>
        路径 = 文件路径
        如果 (文本是否为空 (根目录) == 假)
        {
            变量 位置 <类型 = 整数>
            位置 = 寻找文本 (路径, 根目录, 0, 假)
            如果 (位置 != -1)
            {
                删除字符 (路径, 0, 位置)
            }

        }
        子文本替换 (路径, "\\", "/")
        如果 (是否以字符开头 (路径, '/') == 假)
        {
            插入字符 (路径, 0, '/')

        }
        返回 (路径)
    }

    方法 检查补全网址 <公开 静态 类型 = 文本型 注释 = "检查并补全网址前面的 http:// 或 https://" 折叠>
    参数 网址 <类型 = 文本型 "">
    参数 https <类型 = 逻辑型 注释 = "在网址不完整时才有效" @默认值 = 假>
    {
        变量 URL <类型 = 文本型>
        变量 位置 <类型 = 整数>
        URL = 网址
        位置 = 寻找文本 (URL, "://")
        分支判断 (位置)
        {
            分支 (-1)
            {
                如果 (https == 真)
                {
                    返回 ("https://" + URL)
                }
                否则
                {
                    返回 ("http://" + URL)
                }
            }
            分支 (3)
            {
                如果 (到小写 (取文本左边 (URL, 3)) == "ftp")
                {
                    返回 (URL)

                }
            }
            分支 (4)
            {
                如果 (到小写 (取文本左边 (URL, 4)) == "http")
                {
                    返回 (URL)
                }
                如果 (到小写 (取文本左边 (URL, 4)) == "file")
                {
                    返回 (URL)
                }

            }
            分支 (5)
            {
                如果 (到小写 (取文本左边 (URL, 5)) == "https")
                {
                    返回 (URL)
                }

            }
            默认分支 ()
            {
                删除字符 (URL, 0, 位置)
                如果 (https == 真)
                {
                    返回 ("https" + URL)
                }
                否则
                {
                    返回 ("http" + URL)
                }

            }

        }
        返回 (网址)
    }

    方法 是否合法网址 <公开 静态 类型 = 逻辑型 注释 = "使用正则表达式匹配网址是否合法" 折叠>
    参数 网址 <类型 = 文本型>
    {
        返回 (正则匹配类.完全匹配 (网址, "(https?|ftp|file)://[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|]"))
    }

    方法 是否IP地址 <公开 静态 类型 = 逻辑型 注释 = "使用正则表达式匹配IP地址是否合法" 折叠>
    参数 IP地址 <类型 = 文本型>
    {
        返回 (正则匹配类.完全匹配 (IP地址, "\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}"))
    }

    方法 网页访问 <公开 静态 类型 = 文本型 注释 = "使用curl库访问网页,返回文本" 折叠>
    参数 请求网址 <类型 = 文本型 "">
    参数 编码 <类型 = 文本编码类型 @默认值 = 文本编码类型.UTF8>
    {
        变量 网络访问 <类型 = 网络访问类>
        变量 网页响应 <类型 = 网页访问响应类>
        网页响应 = 网络访问.网页访问 (检查补全网址 (请求网址))
        分支判断 ((整数)编码)
        {
            分支 ((整数)文本编码类型.UTF8)
            {
                返回 (UTF8到文本 (网页响应.请求结果))
            }
            分支 ((整数)文本编码类型.UTF16)
            {
                返回 (字节集到文本 (网页响应.请求结果))
            }
            分支 ((整数)文本编码类型.多字节)
            {
                返回 (多字节到文本 (网页响应.请求结果))
            }

        }
        返回 (多字节到文本 (网页响应.请求结果))
    }

    方法 网页访问2 <公开 静态 类型 = 字节集类 注释 = "使用curl库访问网页,返回字节集" 折叠>
    参数 请求网址 <类型 = 文本型 "">
    {
        变量 网络访问 <类型 = 网络访问类>
        变量 网页响应 <类型 = 网页访问响应类>
        网页响应 = 网络访问.网页访问 (检查补全网址 (请求网址))
        返回 (网页响应.请求结果)
    }
}
